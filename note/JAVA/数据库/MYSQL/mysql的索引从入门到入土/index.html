<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>mysql的索引从入门到入土 | CCWorld</title><meta name="author" content="张三"><meta name="copyright" content="张三"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="索引的XMIND图文件位置：点我打开   索引的常见数据结构哈希表  哈希表这种结构适用于只有等值查询的场景，比如 Memcached 及其他一些 NoSQL 引擎。  有序数组  有序数组在等值查询和范围查询场景中的性能就都非常优秀。  有序数组索引只适用于静态存储引擎   搜索树  二叉搜索树：父节点左子树所有结点的值小于父节点的值，右子树所有结点的值大于父节点的值。  平衡二叉树  N叉树">
<meta property="og:type" content="article">
<meta property="og:title" content="mysql的索引从入门到入土">
<meta property="og:url" content="https://zhuansun.github.io/note/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL/mysql%E7%9A%84%E7%B4%A2%E5%BC%95%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/index.html">
<meta property="og:site_name" content="CCWorld">
<meta property="og:description" content="索引的XMIND图文件位置：点我打开   索引的常见数据结构哈希表  哈希表这种结构适用于只有等值查询的场景，比如 Memcached 及其他一些 NoSQL 引擎。  有序数组  有序数组在等值查询和范围查询场景中的性能就都非常优秀。  有序数组索引只适用于静态存储引擎   搜索树  二叉搜索树：父节点左子树所有结点的值小于父节点的值，右子树所有结点的值大于父节点的值。  平衡二叉树  N叉树">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/10/31/C8gKdeILb2EhnT1.jpg">
<meta property="article:published_time" content="2022-10-31T12:03:02.000Z">
<meta property="article:modified_time" content="2023-06-01T10:14:17.764Z">
<meta property="article:author" content="张三">
<meta property="article:tag" content="mysql">
<meta property="article:tag" content="索引">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/10/31/C8gKdeILb2EhnT1.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhuansun.github.io/note/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL/mysql%E7%9A%84%E7%B4%A2%E5%BC%95%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'mysql的索引从入门到入土',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-01 10:14:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="CCWorld" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">101</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">139</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2022/10/31/C8gKdeILb2EhnT1.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">CCWorld</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">mysql的索引从入门到入土</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2022-10-31T12:03:02.000Z" title="发表于 2022-10-31 12:03:02">2022-10-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JAVA/">JAVA</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL/">MYSQL</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="索引的XMIND图"><a href="#索引的XMIND图" class="headerlink" title="索引的XMIND图"></a>索引的XMIND图</h2><p>文件位置：<a href="./mysql%E7%9A%84%E7%B4%A2%E5%BC%95%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F.assets/Mysql%E7%B4%A2%E5%BC%95.xmind">点我打开</a></p>
<img src="mysql的索引从入门到入土.assets/image-20230506173943461.png" alt="image-20230506173943461" style="zoom:80%;" />

<h2 id="索引的常见数据结构"><a href="#索引的常见数据结构" class="headerlink" title="索引的常见数据结构"></a>索引的常见数据结构</h2><p>哈希表</p>
<ul>
<li>哈希表这种结构适用于只有等值查询的场景，比如 Memcached 及其他一些 NoSQL 引擎。</li>
</ul>
<p>有序数组</p>
<ul>
<li><p>有序数组在等值查询和范围查询场景中的性能就都非常优秀。</p>
</li>
<li><p>有序数组索引只适用于静态存储引擎</p>
</li>
</ul>
<p>搜索树</p>
<ul>
<li><p>二叉搜索树：父节点左子树所有结点的值小于父节点的值，右子树所有结点的值大于父节点的值。</p>
</li>
<li><p>平衡二叉树</p>
</li>
<li><p>N叉树</p>
</li>
</ul>
<h2 id="InnoDB为什么选择B-树（对比其他树）"><a href="#InnoDB为什么选择B-树（对比其他树）" class="headerlink" title="InnoDB为什么选择B+树（对比其他树）"></a>InnoDB为什么选择B+树（对比其他树）</h2><h3 id="为什么选择树"><a href="#为什么选择树" class="headerlink" title="为什么选择树"></a>为什么选择树</h3><p>树的查询效率高，还可以保持有序。</p>
<h3 id="为什么不用二叉搜索树"><a href="#为什么不用二叉搜索树" class="headerlink" title="为什么不用二叉搜索树"></a>为什么不用二叉搜索树</h3><h4 id="什么是二叉搜索树（也叫二叉排序树或者二叉查找树）"><a href="#什么是二叉搜索树（也叫二叉排序树或者二叉查找树）" class="headerlink" title="什么是二叉搜索树（也叫二叉排序树或者二叉查找树）"></a>什么是二叉搜索树（也叫二叉排序树或者二叉查找树）</h4><p>以下是二叉查找树的结构：</p>
<img src="mysql的索引从入门到入土.assets/image-20221219173305682.png" alt="image-20221219173305682" style="zoom:50%;" />

<p>它的<strong>特点</strong>是：</p>
<ul>
<li>父节点左子树所有结点的值小于父节点的值，右子树所有结点的值大于父节点的值。</li>
<li>只有两个叉</li>
<li>查询的时间复杂度是：O(log(N))</li>
<li>从算法逻辑来讲，二叉搜索树的查找速度和比较次数都是最小的。</li>
</ul>
<h4 id="为什么不用二叉搜索树（查找耗磁盘IO）"><a href="#为什么不用二叉搜索树（查找耗磁盘IO）" class="headerlink" title="为什么不用二叉搜索树（查找耗磁盘IO）"></a>为什么不用二叉搜索树（查找耗磁盘IO）</h4><p>因为考虑到磁盘IO的性能。</p>
<p>为什么这么说：InnoDB在查找的时候，是不能将所有的索引全部加载到内存中的，所以必然涉及到磁盘IO。</p>
<p>比如下面这个，二叉搜索树，我们想获取到10，需要经历几次磁盘IO：</p>
<img src="mysql的索引从入门到入土.assets/image-20221219173305682.png" alt="image-20221219173305682" style="zoom:50%;" />

<p>答案是：4次</p>
<ul>
<li>第一次磁盘IO，读取9</li>
<li>第二次磁盘IO，读取13</li>
<li>第三次磁盘IO，读取11</li>
<li>第四次磁盘IO，读取10</li>
</ul>
<p>这样性能是很低的。</p>
<p>所以InnoDB并没有采用二叉搜索树来作为索引的数据结构。</p>
<p>但是InnoDB的设计者，又不能抛弃树这个数据结构带来的遍历，所以只能将 “瘦高” 的二叉搜索树，让它变得 “矮胖”。以便于节省磁盘IO。这就是<code>B树</code>的特征之一</p>
<h3 id="什么是B树"><a href="#什么是B树" class="headerlink" title="什么是B树"></a>什么是B树</h3><h4 id="什么是B树-1"><a href="#什么是B树-1" class="headerlink" title="什么是B树"></a>什么是B树</h4><p>B树 是一种<code>多路平衡查找树</code>，它的每一个节点最多包含<code>m</code>个孩子，<code>m</code>被称为<code>B树</code>的阶。</p>
<p>上面说了，InnoDB的设计者为了想保留树带来的便利，只能将： “瘦高” 的二叉搜索树，让它变得 “矮胖”。以便于节省磁盘IO。</p>
<p>下图就是一个 <code>3阶的B树</code> 示意图</p>
<img src="mysql的索引从入门到入土.assets/image-20221219180143637.png" alt="image-20221219180143637" style="zoom:50%;" />



<p>一颗<code>m阶的B树</code>，它的特点是：</p>
<ul>
<li><code>m阶</code>表示每一个节点最多拥有<code>m</code>个孩子</li>
<li>根节点至少有 <code>2</code> 个子女</li>
<li>有<code>k</code>个孩子的节点包含有k-1个元素，其中： <code>ceil(m/2) &lt;= k &lt;= m</code>，（ceil表示向上取整）</li>
<li>每一个叶子节点都包含<code>k-1</code>个元素，其中：<code>ceil(m/2) &lt;= k &lt;= m</code>，（ceil表示向上取整）</li>
<li>所有的叶子节点都位于同一层</li>
<li>每个节点的元素从小到大排列，并且当该结点的孩子是非叶子结点时，节点中第<code>k-1</code>个元素正好是<code>k</code>个孩子包含的元素的值域分划。</li>
</ul>
<p>我们一一来看这些特点，其中</p>
<ul>
<li>一颗<code>3阶</code>的树，每个节点最多包含<code>3</code>个孩子，m &#x3D; 3</li>
<li><code>9</code>是根节点，有<code>2</code>个孩子<code>（2,6）</code>和 <code>12</code>。(根节点至少<code>2</code>个)</li>
<li><code>（2,6）</code>这个中间节点包含<code>2</code>个元素：<code>2</code>和<code>6</code>，有<code>3</code>个孩子。 <code>2 &lt;= k &lt;= 3</code></li>
<li><code>12 </code>这个中间节点包含<code>1</code>一个元素：<code>12</code>，有<code>2</code>个孩子。满足规则</li>
<li>叶子节点<code>1</code>,<code>(3,5)</code>,<code>8</code>,<code>11</code>,<code>(13,15)</code>位于同一层</li>
<li>每个节点的元素从小到大排列，<code>(3,5)</code>在<code>(2,6)</code>的值域之间。</li>
</ul>
<h4 id="B树的等值查找"><a href="#B树的等值查找" class="headerlink" title="B树的等值查找"></a>B树的等值查找</h4><p>在下面的一个3阶B树中，查找5，需要经历几次磁盘IO：</p>
<img src="mysql的索引从入门到入土.assets/image-20221219180143637.png" alt="image-20221219180143637" style="zoom:50%;" />

<p>答案是：三次</p>
<ul>
<li>第一次磁盘IO：<code>9</code></li>
<li>第二次磁盘IO：<code>（2,6）</code></li>
<li>第三次磁盘IO：<code>（3,5）</code></li>
</ul>
<h4 id="B树的范围查找"><a href="#B树的范围查找" class="headerlink" title="B树的范围查找"></a>B树的范围查找</h4><p>在下面的一个3阶B树中，查找范围是 3-11 的元素，需要经历几次磁盘IO：</p>
<img src="mysql的索引从入门到入土.assets/image-20221219180143637.png" alt="image-20221219180143637" style="zoom:50%;" />

<p>答案是：好多好多次</p>
<ul>
<li>3次磁盘IO后，找到范围下限：3 所在的（3,5）这个节点</li>
<li>中序遍历到 元素6</li>
<li>中序遍历到 元素8</li>
<li>中序遍历到 元素9</li>
<li>中序遍历到 元素11，遍历结束</li>
</ul>
<p>由此可见，B树的范围查找，很繁琐。</p>
<h4 id="B树的插入（自平衡）"><a href="#B树的插入（自平衡）" class="headerlink" title="B树的插入（自平衡）"></a>B树的插入（自平衡）</h4><p>插入比较复杂</p>
<p>以下面的为例子：在一个3阶的B树中，插入 4</p>
<img src="mysql的索引从入门到入土.assets/image-20221219180143637.png" alt="image-20221219180143637" style="zoom:50%;" />

<p>由于 4 在 （3,5）之间。</p>
<img src="mysql的索引从入门到入土.assets/image-20221219185214252.png" alt="image-20221219185214252" style="zoom:50%;" />

<ul>
<li>这是一颗<code>3阶</code>的B树，由于每个节点最多包含 <code>k-1</code> 个元素，其中  <code>2 &lt;= k &lt;= 3</code>，所以每个节点可以包含<code>1个</code>，<code>2个</code>元素；</li>
<li>要在<code>（3,5）</code>之间插入 <code>4</code>，<code>（3,5）</code>已经是<code>2</code>个元素了，不能在插入了。</li>
<li><code>（3,5）</code>的父节点<code>（2,6）</code>也是<code>2</code>个元素，也不能在插入了</li>
<li>根节点 <code>9</code> 是<code>1</code>个元素，可以在升级为2个元素。</li>
<li>于是：</li>
</ul>
<img src="mysql的索引从入门到入土.assets/image-20221219190355215.png" alt="image-20221219190355215" style="zoom:50%;" />

<p>总结：</p>
<ul>
<li>仅仅是插入一个元素，就让整个B树发生了连锁反应</li>
<li>虽然麻烦，但是也正因为如此，可以让B树始终保持多路平衡。（<strong>自平衡</strong>）</li>
</ul>
<h4 id="B树的删除（左旋）"><a href="#B树的删除（左旋）" class="headerlink" title="B树的删除（左旋）"></a>B树的删除（左旋）</h4><p>在如下的一个3阶B树中，删除元素11</p>
<img src="mysql的索引从入门到入土.assets/image-20221219190937755.png" alt="image-20221219190937755" style="zoom:50%;" />



<ul>
<li>首先这是一颗3阶B树，由于B树的规则，每个中间节点都包含<code>k-1</code>个元素和<code>k</code>个孩子，其中 <code> 2&lt;= k &lt;= 3</code></li>
<li>所以：11删除之后，父节点12就只剩下1个孩子了，不符合规则，3阶的B树每个中间节点至少有2个孩子。</li>
<li>因为，需要找出删除11后，剩余的三个元素12,13,15的中位数，取代节点12；然后节点12下移成为孩子（<strong>左旋</strong>）</li>
</ul>
<img src="mysql的索引从入门到入土.assets/image-20221219191850585.png" alt="image-20221219191850585" style="zoom:50%;" />



<h4 id="B树的卫星数据"><a href="#B树的卫星数据" class="headerlink" title="B树的卫星数据"></a>B树的卫星数据</h4><p>所谓的卫星数据（Satellite Information），指的是索引元素所指向的数据记录；</p>
<p>在B树中，每一个节点都带有卫星数据。</p>
<img src="mysql的索引从入门到入土.assets/image-20221219221417559.png" alt="image-20221219221417559" style="zoom:50%;" />



<h3 id="为什么选择B-树"><a href="#为什么选择B-树" class="headerlink" title="为什么选择B+树"></a>为什么选择B+树</h3><h4 id="什么是B-树"><a href="#什么是B-树" class="headerlink" title="什么是B+树"></a>什么是B+树</h4><p>B+树是基于B树的一种变体。有着比B树更高的查询性能</p>
<p>下面是一个3阶的B+树的示意图：节点之间含有重复元素，叶子节点还用指针连在一起</p>
<img src="mysql的索引从入门到入土.assets/image-20221219215758443.png" alt="image-20221219215758443" style="zoom:50%;" />





<p>一颗m阶的B+树有以下特点：</p>
<ul>
<li>有k个子树的中间节点包含有k个元素（B树中是k-1个元素）</li>
<li>每个元素不保存数据，只用来索引，所有的数据保存在叶子节点</li>
<li>所有的叶子节点包含了全部元素的信息，而且每个叶子节点都带有指向下一个节点的指针，形成了一个有序链表</li>
<li>叶子节点本身依关键字大小自小而大顺序链接</li>
<li>每一个父节点的元素都出现在子节点中，而且是子节点中最大（或最小）的元素</li>
<li>无论插入多少元素，都要保持最大元素在根节点中</li>
</ul>
<h4 id="B-树的卫星数据"><a href="#B-树的卫星数据" class="headerlink" title="B+树的卫星数据"></a>B+树的卫星数据</h4><p>所谓的卫星数据（Satellite Information），指的是索引元素所指向的数据记录；</p>
<p>在B+树中，只有叶子节点带有卫星数据。</p>
<p>在mysql中，表中的一行记录就是一个卫星数据。</p>
<p>不过需要注意的是：</p>
<ul>
<li>在mysql中，主键索引的叶子结点存的是<code>卫星数据</code>（就是行记录）</li>
<li>在mysql中，非主键索引的叶子节点存的是<code>指向卫星数据的指针</code>（就是行记录的主键id）</li>
</ul>
<img src="mysql的索引从入门到入土.assets/image-20221219221505548.png" alt="image-20221219221505548" style="zoom:50%;" />



<h4 id="B-树的等值查找"><a href="#B-树的等值查找" class="headerlink" title="B+树的等值查找"></a>B+树的等值查找</h4><p>在下面这颗3阶的B+树上查找元素 3，会经历几次磁盘IO：</p>
<img src="mysql的索引从入门到入土.assets/image-20221219215758443.png" alt="image-20221219215758443" style="zoom:50%;" />



<p>结果：</p>
<ul>
<li>第一次磁盘IO：（8,15）</li>
<li>第二次磁盘IO：（2,5,8）</li>
<li>第三次磁盘IO：（3,5）</li>
</ul>
<p>由于B+树的中间节点并没有存放卫星数据，所以比B树更加“矮胖”，也即是说：在相同数据量的情况下，B+树会比B树访问到更少的磁盘IO。</p>
<p>由于 B+树 的中间节点没有存放卫星数据，所以要想拿到记录，必须访问到叶子节点。</p>
<p>而 B树 由于每个节点都存放了卫星数据，所以只要匹配到，就可以获取到记录。</p>
<p>对B树来说：最好的情况是只访问根节点就能拿到记录，最坏的情况就是访问到叶子结点。换言之：B树的查找性能不稳定</p>
<p>对B+树来说：由于每一次都要访问到叶子节点，所以B+树的查找性能是稳定的。</p>
<h4 id="B-树的范围查找"><a href="#B-树的范围查找" class="headerlink" title="B+树的范围查找"></a>B+树的范围查找</h4><p>在下面这颗3阶的B+树上，查找范围是 3-11 的元素，需要经历几次磁盘IO：</p>
<img src="mysql的索引从入门到入土.assets/image-20221219215758443.png" alt="image-20221219215758443" style="zoom:50%;" />

<p>答案是：5次</p>
<ul>
<li>第一次磁盘IO：找到：（8,15）</li>
<li>第二次磁盘IO：找到：（2,5,8）</li>
<li>第三次磁盘IO：找到：（3,5），此时找到范围下限：3 所在的（3,5）这个节点</li>
<li>然后通过叶子结点上的指针，直接遍历叶子节点。（3,5），（6,8），（9,11）</li>
<li>直接确定到范围</li>
</ul>
<p>相比于B树范围查找的繁琐，B+树就简单的多了。</p>
<h3 id="B-树的B树的比较"><a href="#B-树的B树的比较" class="headerlink" title="B+树的B树的比较"></a>B+树的B树的比较</h3><p>B+树相比B树的优势有三个</p>
<ul>
<li>IO次数更少</li>
<li>查询性能稳定</li>
<li>范围查询简便</li>
</ul>
<p>至于插入和删除，两者大同小异。</p>
<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><p>了解下面列出来的索引概念：</p>
<ul>
<li>主键索引</li>
<li>普通索引</li>
<li>聚簇索引</li>
<li>非聚簇索引</li>
<li>二级索引</li>
<li>唯一索引</li>
<li>全文索引</li>
<li>联合索引</li>
<li>覆盖索引</li>
<li>前缀索引</li>
</ul>
<h3 id="主键索引和普通索引"><a href="#主键索引和普通索引" class="headerlink" title="主键索引和普通索引"></a>主键索引和普通索引</h3><p>主键索引：也叫聚簇索引，它 是一种特殊的唯一索引，<strong>不允许有空值</strong>。</p>
<p>普通索引：也叫二级索引，最基本的索引，没有任何限制</p>
<p>主键索引在InnoDB中是聚簇索引；普通索引在InnoDB中是非聚簇索引</p>
<h3 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h3><p>聚簇索引并不是单独的索引类型，而是一种数据存储方式，指的是：数据和对应的索引紧凑的存储在一起。</p>
<p>非聚簇索引指的就是：数据和索引分开存储。</p>
<p>举例来说：</p>
<p>对于InnoDB：主键索引的叶子节点存的是主键id和数据，它们是保存在一起的；非主键索引的叶子节点存的是主键id，和真实的数据是分开的。所以主键索引是聚簇索引，非主键索引是非聚簇索引。（InnoDB的索引和数据是放在同一个文件中的：数据即索引，索引即数据）</p>
<p>对于MyISAM：索引和记录本身就是分开存储的，是不同的文件。所以MyISAM中所有的索引都是非聚簇索引。</p>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>唯一索引：与”普通索引”类似，不同的就是：索引列的值必须唯一，但<strong>允许有空值</strong>。</p>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>全文索引：仅可用于 MyISAM 表，针对较大的数据，生成全文索引很耗时耗空间。</p>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>也叫组合索引，为了更多的提高mysql效率可建立组合索引，遵循”最左前缀“原则。</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>当一个SQL查询语句所需要查询的字段，被所使用的的索引可以直接满足需求，不需要回表了，称之为覆盖索引</p>
<h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>当需要索引的字段很长，而且该字段后半部分的选择性很低，比如邮箱地址；后面都是一样的。</p>
<p>对于这种我们就可以建立前缀索引：使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">alter</span> <span class="token keyword">table</span> SUser <span class="token keyword">add</span> <span class="token keyword">index</span> index2<span class="token punctuation">(</span>email<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>前缀索引会导致覆盖索引失效，因为前缀索引是截取后的部分做的索引，不得不在回表查一次完整的信息。</p>
<h2 id="索引特点"><a href="#索引特点" class="headerlink" title="索引特点"></a>索引特点</h2><h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><p>假设有一个用户表，我们给 （name, age）加上联合索引。</p>
<p>如果我们要查询所有名字第一个字是“张”的人，SQL语句可能会这么写：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">'张%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在这种情况下，也是可以使用到这个索引的。这就是索引的最左匹配原则。</p>
<ul>
<li>最左匹配原则可以是联合索引的最左N的字段，也可以是一个字符串的最左M个字符；</li>
<li>在建立联合索引的时候，如何安排索引内的字段顺序，需要仔细考量了。</li>
</ul>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>mysql 5.6 引入了 索引下推优化。可以在索引遍历的过程中，对索引中包含的字段先做判断，直接过滤掉不满足的记录，减少回表次数。</p>
<p>假如有一个用户表，我们给（name，age）加上联合索引。</p>
<p>如果我们要查询所有名字第一个字是“张”的人，并且年龄大于10岁的男人。SQL语句可能会这么写</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">'张%'</span> <span class="token operator">and</span> age <span class="token operator">></span> <span class="token number">10</span> <span class="token operator">and</span> male<span class="token operator">=</span><span class="token string">'男'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<p>对于这个语句，我们知道由于最左匹配原则，使用到了（name，age）这个索引。</p>
<p>然后，接下来呢？</p>
<p>在mysql 5.6之前，接下来就需要回表了。对扫描的每一条记录，都回表判断 age 和 male 是否满足；</p>
<p>在mysql 5.6之后，由于有索引下推优化，对于age的判断可以直接完成，过滤掉age不符合的记录，然后对剩下的记录在此回表判断male是否满足。（减少了回表次数）</p>
<h3 id="索引潜水"><a href="#索引潜水" class="headerlink" title="索引潜水"></a>索引潜水</h3><p>英文单词：index dive</p>
<p>主要是用于 IN 查询语句的优化，</p>
<p>跟这个词语相关的，还有一个配置参数 <code>eq_range_index_dive_limit</code>。</p>
<p>MySQL5.7.3之前的版本，这个值默认是10，之后的版本，这个值默认是200。</p>
<p>简单的理解就是：IN 语句的数量如果少于200个，就使用<strong>索引潜水（Index dive）</strong>预估扫描行数，很精确，所以选择索引的时候就不容易出错；</p>
<p>如果 IN 语句的数量大于200个，就使用 <strong>索引统计（Index statistics）</strong>预估扫描行数，误差很大，所以会导致选择索引容易选错，导致性能下降</p>
<p>关于索引潜水，具体见：Mysql性能调优从入门到入土</p>
<h3 id="普通索引默认联合主键索引"><a href="#普通索引默认联合主键索引" class="headerlink" title="普通索引默认联合主键索引"></a>普通索引默认联合主键索引</h3><p>二级索引会默认与主键索引做联合索引。</p>
<p>为什么？</p>
<p>因为二级索引的叶子节点存放的就是主键。</p>
<h2 id="索引比较"><a href="#索引比较" class="headerlink" title="索引比较"></a>索引比较</h2><p>任何索引之间的比较，都从 增删改查 四个角度来具体分析，就不迷惑了。</p>
<h3 id="普通索引和主键索引有什么区别？"><a href="#普通索引和主键索引有什么区别？" class="headerlink" title="普通索引和主键索引有什么区别？"></a>普通索引和主键索引有什么区别？</h3><p>主键索引的查询，不需要回表了。</p>
<p>普通索引的查询，如果要查询的字段没有被当前索引覆盖，是需要回表的。</p>
<p>针对回表的优化：</p>
<ul>
<li>覆盖索引可以减少回表</li>
<li>索引下推可以减少回表</li>
</ul>
<h3 id="普通索引和唯一索引有什么区别？"><a href="#普通索引和唯一索引有什么区别？" class="headerlink" title="普通索引和唯一索引有什么区别？"></a>普通索引和唯一索引有什么区别？</h3><h4 id="对查询的影响"><a href="#对查询的影响" class="headerlink" title="对查询的影响"></a>对查询的影响</h4><ul>
<li>微乎其微。</li>
<li>普通索引的查询：定位到当前记录之后，还要继续判断下一条记录是否满足条件。</li>
<li>唯一索引的查询：定位到当前记录之后，由于是唯一的，不再需要判断下一条记录了。</li>
</ul>
<p>不过，后面看到加锁规则这部分的时候，有一个加锁规则是：唯一索引上的范围查询，会访问到不满足查询条件的第一个值为止。 </p>
<p>也就是说：</p>
<ul>
<li>对于范围查询，普通索引和唯一索引是一样的，都需要访问下一条记录。</li>
<li>对于等值查询，唯一索引比普通索引少了一次查找下一条记录的性能消耗。</li>
</ul>
<h4 id="对更新的影响"><a href="#对更新的影响" class="headerlink" title="对更新的影响"></a>对更新的影响</h4><ul>
<li><p>参考：《mysql的日志从入门到入土》这篇文章中讲到了changebuffer：</p>
<ul>
<li>changebuffer（对更新的优化，对比redolog）</li>
<li>changebuffer在 5.5 版本之前叫做：insert buffer，只支持插入操作；在5.5之后，支持了更新操作</li>
<li>changebuffer的作用：</li>
<li>更新的时候不需要从内存中加载数据页，而是直接将更新后的记录写到changebuffer中（内存中）就可以返回了</li>
<li>那么changebuffer中的数据什么时候刷盘呢？</li>
<li>因为写入changebuffer了，一定会写入redolog，后台会定时将redolog中的数据应用到数据页中，同时也会将changebuffer的数据应用到数据页，这是两个后台线程，他俩没有任何关系。操作的都是内存中的数据页，然后刷脏页</li>
<li>具体的可以参考：《mysql的日志从入门到入土》</li>
</ul>
</li>
<li><p>为什么唯一索引的更新就不能使用 change buffer，只有普通索引可以使用。</p>
<ul>
<li><p>因为唯一索引的更新，需要判断当前的这个更新会不会影响到唯一索引的唯一性。</p>
</li>
<li><p>所以必须判断要将数据页加载到内存中，进行判断才可以。</p>
</li>
</ul>
</li>
<li><p>change buffer适应于：写多读少的场景和写多读多的场景；</p>
</li>
<li><p>change buffer 和 redo log的联系和区别。</p>
<ul>
<li>change buffer减少了磁盘的随机读（减少了加载数据页的操作）</li>
<li>redo log减少的磁盘的随机写（WAL机制）</li>
</ul>
</li>
</ul>
<h3 id="前缀索引对覆盖索引的影响"><a href="#前缀索引对覆盖索引的影响" class="headerlink" title="前缀索引对覆盖索引的影响"></a>前缀索引对覆盖索引的影响</h3><p>我们知道覆盖索引可以减少回表，提升查询性能；</p>
<p>但是当我们的覆盖索引是前缀索引的时候，此时覆盖索引是不生效的。</p>
<p>因为前缀索引是截取后的信息作为索引，要想获取完整的字段，就不得不回表在查询一次。</p>
<h2 id="合理创建索引"><a href="#合理创建索引" class="headerlink" title="合理创建索引"></a>合理创建索引</h2><p>为什么要合理的创建索引。</p>
<p>因为索引很显然并不是越多越好，因为占空间，而且数据变更的时候还要多维护索引的变更，消耗性能。</p>
<p>那么怎么合理的创建索引呢</p>
<p>首先要知道，索引只能用来加快查询的速度，所以</p>
<ul>
<li>索引应该建立在频繁查询的字段上，比如 where 语句后的字段，order by 的字段， join 的字段等。</li>
</ul>
<p>那么是对所有的where，order by，join等的字段都建立索引吗？很显然不能</p>
<ul>
<li>过多的索引会占用空间，而且更新的时候，还需要维护索引，消耗性能。</li>
</ul>
<p>那什么样的字段不用建立索引呢？</p>
<ul>
<li>区分度低的字段不用建立索引。</li>
<li>频繁更新的字段一般不建议当做索引，因为要维护索引，页分裂，页合并等，消耗性能。</li>
</ul>
<p>那剩下的别的字段，就都可以建立索引了吗？也不是</p>
<ul>
<li>为了节省空间，推荐建立 组合索引。</li>
<li>组合索引还有一个好处，就是可以满足最左匹配原则。</li>
</ul>
<p>另外补充一个</p>
<ul>
<li>字段长的可以前缀索引，倒序索引等。</li>
</ul>
<h2 id="选错索引（索引统计，强制索引）"><a href="#选错索引（索引统计，强制索引）" class="headerlink" title="选错索引（索引统计，强制索引）"></a>选错索引（索引统计，强制索引）</h2><ul>
<li><p>由于索引统计的更新机制，索引统计信息不准确导致的。</p>
</li>
<li><p>解决：重新采集统计信息：analyze table</p>
</li>
<li><p>解决：手动指定索引；force index</p>
</li>
</ul>
<h3 id="优化器是怎么选择索引的"><a href="#优化器是怎么选择索引的" class="headerlink" title="优化器是怎么选择索引的"></a>优化器是怎么选择索引的</h3><p>选择索引是优化器的工作。</p>
<p>而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。</p>
<p>在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的 CPU 资源越少。</p>
<p>但是扫描行数并不是唯一确定索引的因素。优化器还会结合是否使用临时表、是否排序等因素进行综合判断。</p>
<h3 id="怎么确定扫描行数呢？"><a href="#怎么确定扫描行数呢？" class="headerlink" title="怎么确定扫描行数呢？"></a><strong>怎么确定扫描行数呢？</strong></h3><p>在确定扫描行数之前，mysql 会先看看 索引基数。索引基数决定了要不要使用索引</p>
<ul>
<li>如果索引基数太小，就会弃用索引。</li>
<li>当索引基数比较大的时候，要不要走这个索引，还得看扫描行数，回表，子查询等等，最后优化器根据预估的成本决定是否走这个索引。</li>
</ul>
<h4 id="什么是索引基数呢"><a href="#什么是索引基数呢" class="headerlink" title="什么是索引基数呢"></a>什么是索引基数呢</h4><p>MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据<strong>统计信息</strong>来估算记录数。</p>
<p>这个<strong>统计信息</strong>就是索引的“<strong>区分度</strong>”。</p>
<p>显然，一个索引上不同的值越多，这个索引的区分度就越好。</p>
<p>而一个索引上不同的值的个数，我们称之为<strong>“基数”（cardinality）</strong>。</p>
<p>也就是说，这个基数越大，索引的区分度越好。</p>
<p>我们可以使用 show index 方法，看到一个索引的基数。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> <span class="token keyword">index</span> <span class="token keyword">from</span> t<span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+</span>
<span class="token operator">|</span> <span class="token keyword">Table</span> <span class="token operator">|</span> Non_unique <span class="token operator">|</span> Key_name <span class="token operator">|</span> Seq_in_index <span class="token operator">|</span> Column_name <span class="token operator">|</span> Collation <span class="token operator">|</span> Cardinality <span class="token operator">|</span> Sub_part <span class="token operator">|</span> Packed <span class="token operator">|</span> <span class="token boolean">Null</span> <span class="token operator">|</span> Index_type <span class="token operator">|</span> <span class="token keyword">Comment</span> <span class="token operator">|</span> Index_comment <span class="token operator">|</span> Visible <span class="token operator">|</span> Expression <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+</span>
<span class="token operator">|</span> t     <span class="token operator">|</span>          <span class="token number">0</span> <span class="token operator">|</span> <span class="token keyword">PRIMARY</span>  <span class="token operator">|</span>            <span class="token number">1</span> <span class="token operator">|</span> id          <span class="token operator">|</span> A         <span class="token operator">|</span>           <span class="token number">6</span> <span class="token operator">|</span>     <span class="token boolean">NULL</span> <span class="token operator">|</span>   <span class="token boolean">NULL</span> <span class="token operator">|</span>      <span class="token operator">|</span> <span class="token keyword">BTREE</span>      <span class="token operator">|</span>         <span class="token operator">|</span>               <span class="token operator">|</span> YES     <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span>
<span class="token operator">|</span> t     <span class="token operator">|</span>          <span class="token number">1</span> <span class="token operator">|</span> c        <span class="token operator">|</span>            <span class="token number">1</span> <span class="token operator">|</span> c           <span class="token operator">|</span> A         <span class="token operator">|</span>           <span class="token number">6</span> <span class="token operator">|</span>     <span class="token boolean">NULL</span> <span class="token operator">|</span>   <span class="token boolean">NULL</span> <span class="token operator">|</span> YES  <span class="token operator">|</span> <span class="token keyword">BTREE</span>      <span class="token operator">|</span>         <span class="token operator">|</span>               <span class="token operator">|</span> YES     <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+</span>
<span class="token number">2</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.03</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>MySQL 是怎样得到索引的基数的呢？</strong></p>
<p>MySQL 使用采样统计的方法进行统计索引的基数。</p>
<p>为什么要采样统计呢？因为把整张表取出来一行行统计，虽然可以得到精确的结果，但是代价太高了，所以只能选择“采样统计”。</p>
<p>采样统计的时候，InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。</p>
<p>而数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过 1&#x2F;M 的时候，会自动触发重新做一次索引统计。</p>
<p>举个例子：</p>
<p>取n&#x3D;3个数据页统计，假设共有10个索引数据页； page1：10个不同值； page2：20个不同值； page3：15 个不同值； 索引基数&#x3D;(10+20+15)&#x2F;3*10&#x3D;150；</p>
<p><strong>上文所说的 N  和 M 具体是多少呢？</strong></p>
<p>在 MySQL 中，有两种存储索引统计的方式，可以通过设置参数 innodb_stats_persistent 的值来选择：</p>
<ul>
<li>设置为 on 的时候，表示统计信息会持久化存储。这时，默认的 N 是 20，M 是 10。</li>
<li>设置为 off 的时候，表示统计信息只存储在内存中。这时，默认的 N 是 8，M 是 16。</li>
</ul>
<p>由于是采样统计，所以不管 N 是 20 还是 8，这个基数都是很容易不准的。</p>
<h4 id="怎么确定扫描行数呢？-1"><a href="#怎么确定扫描行数呢？-1" class="headerlink" title="怎么确定扫描行数呢？"></a>怎么确定扫描行数呢？</h4><p>知道了索引基数，优化器还要继续预估执行这个语句，具体需要扫描多少行</p>
<p>通过 explain 命令可以看到优化器预估的扫描行数，至于mysql是怎么预估扫描行数的，这里就不在展开了。</p>
<h3 id="怎么解决选错索引的问题"><a href="#怎么解决选错索引的问题" class="headerlink" title="怎么解决选错索引的问题"></a>怎么解决选错索引的问题</h3><p>如果你通过 explain 命令，看到是由于 预估行数 错误，导致了mysql选错了索引。</p>
<p>可以使用：analyze table t 命令，可以用来重新统计索引信息。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">analyze</span> <span class="token keyword">table</span> t<span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">-------+---------+----------+----------+</span>
<span class="token operator">|</span> <span class="token keyword">Table</span> <span class="token operator">|</span> Op      <span class="token operator">|</span> Msg_type <span class="token operator">|</span> Msg_text <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">-------+---------+----------+----------+</span>
<span class="token operator">|</span> zs<span class="token punctuation">.</span>t  <span class="token operator">|</span> <span class="token keyword">analyze</span> <span class="token operator">|</span> <span class="token keyword">status</span>   <span class="token operator">|</span> OK       <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">-------+---------+----------+----------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.04</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>另外，我们知道索引的选择，并不是仅仅靠 扫描行数 这一个影响因素来决定的</p>
<p>如果在实际的生产环境中，我们发现使用 索引a 就是比 索引b 有更好的性能</p>
<p>我们可以使用 force index 强制这个sql语句使用索引a，而不是索引b</p>
<h2 id="索引排序（order-by）"><a href="#索引排序（order-by）" class="headerlink" title="索引排序（order by）"></a>索引排序（order by）</h2><p>在日常的开发过程中，经常会使用<code>order by</code>语句，那么排序的原理是什么呢？</p>
<p>排序分为两种情况</p>
<ul>
<li>排序的字段有索引</li>
<li>排序的字段没有索引</li>
</ul>
<h3 id="有索引的排序"><a href="#有索引的排序" class="headerlink" title="有索引的排序"></a>有索引的排序</h3><p>我们知道索引是有序的，所以有索引的排序会直接使用索引；</p>
<p>直接使用索引排序的话，<code>explain</code>结果中是不会有 Using filesort 的</p>
<p>结果中有 Using filesort ，表示的就是需要排序，而且没有用到索引</p>
<h3 id="没有索引的排序"><a href="#没有索引的排序" class="headerlink" title="没有索引的排序"></a>没有索引的排序</h3><p>没有索引的排序，相对来说复杂一下。</p>
<p>一个语句是否使用了排序，可以通过：<code>explain</code>命令查看，结果中有 Using filesort ，表示的就是需要排序。</p>
<p>MySQL 会给每个线程分配一块<code>内存</code>用于排序，称为<code> sort_buffer</code>。</p>
<h4 id="sort-buffer是什么"><a href="#sort-buffer是什么" class="headerlink" title="sort_buffer是什么"></a>sort_buffer是什么</h4><p>MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer；</p>
<p>sort_buffer既然是内存区域，就不可能无限的扩大，是可以通过参数<code>sort_buffer_size</code>控制的</p>
<h4 id="sort-buffer有多大（内部排序和外部排序）"><a href="#sort-buffer有多大（内部排序和外部排序）" class="headerlink" title="sort buffer有多大（内部排序和外部排序）"></a>sort buffer有多大（内部排序和外部排序）</h4><p>通过参数<code>sort_buffer_size</code>控制的，默认是：262144（公司是：8388608）</p>
<p>sort_buffer_size，就是 MySQL 为排序开辟的内存（sort_buffer）的大小。</p>
<p>如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。 这叫做：<code>内部排序</code></p>
<p>但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。这叫做：<code>外部排序</code></p>
<p>内存放不下时，就需要使用外部排序，外部排序一般使用归并排序算法。</p>
<p>可以这么简单理解，MySQL 将需要排序的数据分成 N 份，每一份单独排序后存在这些临时文件中。然后把这 N 个有序文件再合并成一个有序的大文件。</p>
<p>内部排序：使用快速排序</p>
<p>外部排序：使用归并排序</p>
<h4 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h4><p>示例数据</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>t<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>
  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>city<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>addr<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>city<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>city<span class="token punctuation">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span>

<span class="token comment">-- 初始化10条数据</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当我们执行下面的查询语句的时候</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> city<span class="token punctuation">,</span>name<span class="token punctuation">,</span>age <span class="token keyword">from</span> t <span class="token keyword">where</span> city<span class="token operator">=</span><span class="token string">'杭州'</span> <span class="token keyword">order</span> <span class="token keyword">by</span> name <span class="token keyword">limit</span> <span class="token number">1000</span>  <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>它的排序执行流程如下：</p>
<ul>
<li>初始化 sort_buffer，确定放入 name、city、age 这三个字段；</li>
<li>从索引 city 找到第一个满足 city&#x3D;’杭州’条件的主键 id；</li>
<li>到主键 id 索引取出整行，取 name、city、age 三个字段的值，存入 sort_buffer 中</li>
<li>从索引 city 取下一个记录的主键 id；</li>
<li>重复步骤 3、4 直到 city 的值不满足查询条件为止；</li>
<li>对 sort_buffer 中的数据按照字段 name 做快速排序；</li>
<li>按照排序结果取前 1000 行返回给客户端。</li>
</ul>
<p>在上面这个过程里面，只对原表的数据读了一遍，剩下的操作都是在 sort_buffer 和临时文件中执行的。</p>
<p>但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么 sort_buffer 里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。</p>
<p>那么，如果 MySQL 认为排序的单行长度太大会怎么做呢？</p>
<h4 id="rowId排序"><a href="#rowId排序" class="headerlink" title="rowId排序"></a>rowId排序</h4><p>如果 MySQL 认为排序的单行长度太大会怎么做呢？</p>
<p><code>max_length_for_sort_data</code>：是 MySQL 中专门控制用于排序的行数据的长度的一个参数。</p>
<p>它的意思是，如果单行的长度超过这个值，MySQL 就认为单行太大，要换一个算法。</p>
<p>示例数据</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>t<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>
  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>city<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>addr<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>city<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>city<span class="token punctuation">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span>

<span class="token comment">-- 初始化10条数据</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当我们执行下面的查询语句的时候</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> city<span class="token punctuation">,</span>name<span class="token punctuation">,</span>age <span class="token keyword">from</span> t <span class="token keyword">where</span> city<span class="token operator">=</span><span class="token string">'杭州'</span> <span class="token keyword">order</span> <span class="token keyword">by</span> name <span class="token keyword">limit</span> <span class="token number">1000</span>  <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>city、name、age 这三个字段的定义总长度是 36，我把 max_length_for_sort_data 设置为 16，我们再来看看计算过程有什么改变。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> max_length_for_sort_data <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>新的算法放入 sort_buffer 的字段，只有要排序的列（即 name 字段）和主键 id。</p>
<p>但这时，排序的结果就因为少了 city 和 age 字段的值，不能直接返回了，整个执行流程就变成如下所示的样子：</p>
<ul>
<li>初始化 sort_buffer，确定放入两个字段，即 name 和 id；</li>
<li>从索引 city 找到第一个满足 city&#x3D;’杭州’条件的主键 id；</li>
<li>到主键 id 索引取出整行，取 name、id 这两个字段，存入 sort_buffer 中；</li>
<li>从索引 city 取下一个记录的主键 id；</li>
<li>重复步骤 3、4 直到不满足 city&#x3D;’杭州’条件为止；</li>
<li>对 sort_buffer 中的数据按照字段 name 进行排序；</li>
<li>遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端。</li>
</ul>
<h4 id="全字段排序-VS-rowid-排序"><a href="#全字段排序-VS-rowid-排序" class="headerlink" title="全字段排序 VS rowid 排序"></a>全字段排序 VS rowid 排序</h4><ul>
<li>MySQL 如果觉得排序内存太小，会影响排序效率，会采用 rowid 排序算法，这样排序过程中一次可以排序更多行，但是需要回表</li>
<li>MySQL 认为内存足够大，会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，可以减少回表</li>
</ul>
<h2 id="索引为什么不生效"><a href="#索引为什么不生效" class="headerlink" title="索引为什么不生效"></a>索引为什么不生效</h2><p>以下三种情况，都会影响索引的使用</p>
<ul>
<li>条件字段使用函数</li>
<li>隐式类型转换</li>
<li>隐式字符编码转换</li>
</ul>
<h3 id="条件字段函数操作会影响索引"><a href="#条件字段函数操作会影响索引" class="headerlink" title="条件字段函数操作会影响索引"></a>条件字段函数操作会影响索引</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 查询创建时间是7月份的记录，created_time有索引</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> <span class="token keyword">month</span><span class="token punctuation">(</span>created_time<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>由于加了 month() 函数操作，created_time索引树里面，并不认识7，所以MySQL 无法再使用索引快速定位功能，而<strong>只能使用全索引扫描</strong>。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> id <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>虽然这个加 1 操作并不会改变主键索引的有序性，但是 MySQL 优化器还是不能用 id 索引快速定位到 id&#x3D;4 这一行。</p>
<p>所以，需要你在写 SQL 语句的时候，手动改写成 where id &#x3D; 5 -1 才可以。</p>
<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>这个坑，今天刚踩过，表里对于单号 order_no 有索引，order_no 字段是varchar类型，但是我的语句是这么写的</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> order_no<span class="token operator">=</span><span class="token number">110717</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>explain 的结果显示：这条语句需要走全表扫描</p>
<p>因为：order_no 字段是varchar类型，而我的查询条件里用到的是整型。所以mysql会默认用到类型转换，<strong>导致索引失效</strong></p>
<p><strong>字符串和数字做比较的话，是将字符串转换成数字</strong>；所以，上面那个语句等同于</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> CAST<span class="token punctuation">(</span>order_no signed <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">110717</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这也就明白了，为什么不会走索引了。</p>
<p>然后考虑下面这个语句，会走主键索引吗</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token string">'11'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>答案是：会走索引，因为：字符串和数字做比较的话，是将字符串转换成数字，所以没有对条件字段使用函数。索引不会失效</p>
<h3 id="隐式字符编码转换"><a href="#隐式字符编码转换" class="headerlink" title="隐式字符编码转换"></a>隐式字符编码转换</h3><p>如果关联的两张表，使用的字符集不同的话，比如一个使用utf8，一个使用utf8mb4； 所以做表连接查询的时候用不上关联字段的索引。</p>
<p>为什么字符集不一样，不能用索引呢？</p>
<p>因为字符集 utf8mb4 是 utf8 的超集，所以当这两个类型的字符串在做比较的时候，MySQL 内部的操作是，先把 utf8 字符串转成 utf8mb4 字符集，再做比较。</p>
<p>（自动类型转换的时候，为了避免数据在转换过程中由于截断导致数据错误，也都是“<strong>按数据长度增加的方向</strong>”进行转换的。）</p>
<h2 id="InnoB的索引模型（B-树）"><a href="#InnoB的索引模型（B-树）" class="headerlink" title="InnoB的索引模型（B+树）"></a>InnoB的索引模型（B+树）</h2><h3 id="复习B-树"><a href="#复习B-树" class="headerlink" title="复习B+树"></a>复习B+树</h3><p>每一个索引在 InnoDB 里面对应一棵 B+ 树。在复习一下B+树</p>
<p>下面是一个3阶的B+树的示意图：</p>
<ul>
<li>节点之间含有重复元素</li>
<li>叶子节点还用指针连在一起</li>
</ul>
<img src="mysql的索引从入门到入土.assets/image-20221219215758443.png" alt="image-20221219215758443" style="zoom:50%;" />

<p>接下来：</p>
<ul>
<li>我们考虑各个索引在InnoDB中具体的B+树结构是什么样子的</li>
<li>这些索引是怎么维护的（插入数据，删除数据，更新数据对索引的影响，页分裂，页合并）</li>
<li>这些索引是怎么使用的（等值查询，范围查询）</li>
</ul>
<h3 id="案例数据"><a href="#案例数据" class="headerlink" title="案例数据"></a>案例数据</h3><p>准备一张表：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>
  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>city<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>address<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>city<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>city<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>name_age<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">,</span><span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>表里有一个主键 id</li>
<li>表里有一个普通索引 city</li>
<li>表里有一个联合索引 name_age</li>
<li>接下来，我们看看，不停的向表里写入数据，会发生什么</li>
</ul>
<p><strong>重要声明</strong>：</p>
<ul>
<li>我们知道mysql的数据是按照 数据页 来进行存储的，对于索引来说，同样也是 数据页 存储的。</li>
<li>一个数据页是 16KB，所以一个数据库能存放的元素是有限的。</li>
<li>在测试的时候：我们假设<ul>
<li><code>id</code>是 int 类型，占<code>4</code>个字节</li>
<li><code>name</code>是 varchar 类型，因为是不定长的，假设 name 不论写入什么，都占<code>8</code>个字节</li>
<li><code>age</code>是 int 类型，占<code>4</code>个字节</li>
<li><code>city</code>是 varchar 类型，因为是不定长的，假设 city 不论写入什么，都占<code>8</code>个字节</li>
<li><code>address</code>是 varchar 类型，因为是不定长的，假设 address 不论写入什么，都占<code>8</code>个字节</li>
</ul>
</li>
<li>正常情况下，一个数据页是16KB，我们这里假设，一个数据页只有：<code>36字节</code><ul>
<li>意味着：一个数据页最多能存9个id索引元素(4x9&#x3D;36)；最多能存4个city索引元素(8x4&#x3D;32)，最多能存3个 name_age 联合索引元素(12x3&#x3D;36);</li>
</ul>
</li>
</ul>
<h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>我们上边介绍的<code>B+</code>树本身就是一个目录，或者说本身就是一个索引。它有两个特点：</p>
<ol>
<li><p>使用记录主键值的大小进行记录和数据页的排序，这包括三个方面的含义：</p>
<ul>
<li>数据页中的记录是按照主键的大小顺序排成一个单向链表。</li>
<li>各个 存放用户记录的数据页 也是 根据 数据页中用户记录的主键大小 顺序排成一个双向链表。</li>
<li>存放 目录项记录的数据页 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。</li>
</ul>
</li>
<li><p><code>B+</code>树的叶子节点存储的是完整的用户记录。</p>
<p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p>
</li>
</ol>
<p>我们把具有这两种特性的<code>B+</code>树称为<code>聚簇索引</code>，所有完整的用户记录都存放在这个<code>聚簇索引</code>的叶子节点处。这种<code>聚簇索引</code>并不需要我们在<code>MySQL</code>语句中显式的使用<code>INDEX</code>语句去创建（后边会介绍索引相关的语句），<code>InnoDB</code>存储引擎会自动的为我们创建聚簇索引。另外有趣的一点是，在<code>InnoDB</code>存储引擎中，<code>聚簇索引</code>就是数据的存储方式（所有的用户记录都存储在了<code>叶子节点</code>），也就是所谓的索引即数据，数据即索引。</p>
<h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><h3 id="联合索引-1"><a href="#联合索引-1" class="headerlink" title="联合索引"></a>联合索引</h3><p><code>B+</code>树按照<code>name</code>和<code>age</code>列的大小进行排序，这个包含两层含义：</p>
<ul>
<li>先把各个记录和页按照<code>name</code>列进行排序。</li>
<li>在记录的<code>name</code>列相同的情况下，采用<code>age</code>列进行排序</li>
</ul>
<h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><p>索引维护（更新，页分裂，页合并）</p>
<p>为什么我们一般在建表的时候都会创建一个自增主键，及时表中有业务唯一的id，也会创建一个自增主键？</p>
<p>1、因为主键只会自增，在B+树中一直都是往后写的，不会触发页分裂；但是如果删除过多的话，会触发页合并；</p>
<p>2、要考虑业务唯一的id的长度，比如身份证号，如果用身份证号作为主键，比直接使用整型自增的主键占用的字节数要多，这样每一个页存放的数据就会少，每个页存的数据少了，这样查询的时候，效率就会低。 同时主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</p>
<p>3、所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。</p>
<p>索引的页分裂和页合并是怎么导致的，会有什么影响？具体的分裂和合并的过程是什么样子的？</p>
<p>为什么mysql的b+树，在非叶子节点中，也保留了双向列表</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/478187330/answer/2050494617">https://www.zhihu.com/question/478187330/answer/2050494617</a></p>
</article><div class="tag_share"><div class="post_share"></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84XMIND%E5%9B%BE"><span class="toc-number">1.</span> <span class="toc-text">索引的XMIND图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">索引的常见数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9B-%E6%A0%91%EF%BC%88%E5%AF%B9%E6%AF%94%E5%85%B6%E4%BB%96%E6%A0%91%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">InnoDB为什么选择B+树（对比其他树）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E6%A0%91"><span class="toc-number">3.1.</span> <span class="toc-text">为什么选择树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">3.2.</span> <span class="toc-text">为什么不用二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88%E4%B9%9F%E5%8F%AB%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E6%88%96%E8%80%85%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%89"><span class="toc-number">3.2.1.</span> <span class="toc-text">什么是二叉搜索树（也叫二叉排序树或者二叉查找树）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88%E6%9F%A5%E6%89%BE%E8%80%97%E7%A3%81%E7%9B%98IO%EF%BC%89"><span class="toc-number">3.2.2.</span> <span class="toc-text">为什么不用二叉搜索树（查找耗磁盘IO）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFB%E6%A0%91"><span class="toc-number">3.3.</span> <span class="toc-text">什么是B树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFB%E6%A0%91-1"><span class="toc-number">3.3.1.</span> <span class="toc-text">什么是B树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B%E6%A0%91%E7%9A%84%E7%AD%89%E5%80%BC%E6%9F%A5%E6%89%BE"><span class="toc-number">3.3.2.</span> <span class="toc-text">B树的等值查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E6%9F%A5%E6%89%BE"><span class="toc-number">3.3.3.</span> <span class="toc-text">B树的范围查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%EF%BC%88%E8%87%AA%E5%B9%B3%E8%A1%A1%EF%BC%89"><span class="toc-number">3.3.4.</span> <span class="toc-text">B树的插入（自平衡）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%EF%BC%88%E5%B7%A6%E6%97%8B%EF%BC%89"><span class="toc-number">3.3.5.</span> <span class="toc-text">B树的删除（左旋）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B%E6%A0%91%E7%9A%84%E5%8D%AB%E6%98%9F%E6%95%B0%E6%8D%AE"><span class="toc-number">3.3.6.</span> <span class="toc-text">B树的卫星数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9B-%E6%A0%91"><span class="toc-number">3.4.</span> <span class="toc-text">为什么选择B+树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFB-%E6%A0%91"><span class="toc-number">3.4.1.</span> <span class="toc-text">什么是B+树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E6%A0%91%E7%9A%84%E5%8D%AB%E6%98%9F%E6%95%B0%E6%8D%AE"><span class="toc-number">3.4.2.</span> <span class="toc-text">B+树的卫星数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E6%A0%91%E7%9A%84%E7%AD%89%E5%80%BC%E6%9F%A5%E6%89%BE"><span class="toc-number">3.4.3.</span> <span class="toc-text">B+树的等值查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E6%9F%A5%E6%89%BE"><span class="toc-number">3.4.4.</span> <span class="toc-text">B+树的范围查找</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91%E7%9A%84B%E6%A0%91%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">3.5.</span> <span class="toc-text">B+树的B树的比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text">索引分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E5%92%8C%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95"><span class="toc-number">4.1.</span> <span class="toc-text">主键索引和普通索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">4.2.</span> <span class="toc-text">聚簇索引和非聚簇索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95"><span class="toc-number">4.3.</span> <span class="toc-text">唯一索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95"><span class="toc-number">4.4.</span> <span class="toc-text">全文索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.</span> <span class="toc-text">联合索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">4.6.</span> <span class="toc-text">覆盖索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="toc-number">4.7.</span> <span class="toc-text">前缀索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%89%B9%E7%82%B9"><span class="toc-number">5.</span> <span class="toc-text">索引特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="toc-number">5.1.</span> <span class="toc-text">最左匹配原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="toc-number">5.2.</span> <span class="toc-text">索引下推</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%BD%9C%E6%B0%B4"><span class="toc-number">5.3.</span> <span class="toc-text">索引潜水</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E9%BB%98%E8%AE%A4%E8%81%94%E5%90%88%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95"><span class="toc-number">5.4.</span> <span class="toc-text">普通索引默认联合主键索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%AF%94%E8%BE%83"><span class="toc-number">6.</span> <span class="toc-text">索引比较</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">普通索引和主键索引有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">6.2.</span> <span class="toc-text">普通索引和唯一索引有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">6.2.1.</span> <span class="toc-text">对查询的影响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%9B%B4%E6%96%B0%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">6.2.2.</span> <span class="toc-text">对更新的影响</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E5%AF%B9%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">6.3.</span> <span class="toc-text">前缀索引对覆盖索引的影响</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E7%90%86%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">7.</span> <span class="toc-text">合理创建索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E9%94%99%E7%B4%A2%E5%BC%95%EF%BC%88%E7%B4%A2%E5%BC%95%E7%BB%9F%E8%AE%A1%EF%BC%8C%E5%BC%BA%E5%88%B6%E7%B4%A2%E5%BC%95%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">选错索引（索引统计，强制索引）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9%E7%B4%A2%E5%BC%95%E7%9A%84"><span class="toc-number">8.1.</span> <span class="toc-text">优化器是怎么选择索引的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%A1%AE%E5%AE%9A%E6%89%AB%E6%8F%8F%E8%A1%8C%E6%95%B0%E5%91%A2%EF%BC%9F"><span class="toc-number">8.2.</span> <span class="toc-text">怎么确定扫描行数呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%E5%9F%BA%E6%95%B0%E5%91%A2"><span class="toc-number">8.2.1.</span> <span class="toc-text">什么是索引基数呢</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%A1%AE%E5%AE%9A%E6%89%AB%E6%8F%8F%E8%A1%8C%E6%95%B0%E5%91%A2%EF%BC%9F-1"><span class="toc-number">8.2.2.</span> <span class="toc-text">怎么确定扫描行数呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E9%80%89%E9%94%99%E7%B4%A2%E5%BC%95%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">8.3.</span> <span class="toc-text">怎么解决选错索引的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%8E%92%E5%BA%8F%EF%BC%88order-by%EF%BC%89"><span class="toc-number">9.</span> <span class="toc-text">索引排序（order by）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E7%B4%A2%E5%BC%95%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="toc-number">9.1.</span> <span class="toc-text">有索引的排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E7%B4%A2%E5%BC%95%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="toc-number">9.2.</span> <span class="toc-text">没有索引的排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sort-buffer%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">9.2.1.</span> <span class="toc-text">sort_buffer是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sort-buffer%E6%9C%89%E5%A4%9A%E5%A4%A7%EF%BC%88%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E5%92%8C%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="toc-number">9.2.2.</span> <span class="toc-text">sort buffer有多大（内部排序和外部排序）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%AD%97%E6%AE%B5%E6%8E%92%E5%BA%8F"><span class="toc-number">9.2.3.</span> <span class="toc-text">全字段排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rowId%E6%8E%92%E5%BA%8F"><span class="toc-number">9.2.4.</span> <span class="toc-text">rowId排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%AD%97%E6%AE%B5%E6%8E%92%E5%BA%8F-VS-rowid-%E6%8E%92%E5%BA%8F"><span class="toc-number">9.2.5.</span> <span class="toc-text">全字段排序 VS rowid 排序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%9F%E6%95%88"><span class="toc-number">10.</span> <span class="toc-text">索引为什么不生效</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%AD%97%E6%AE%B5%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C%E4%BC%9A%E5%BD%B1%E5%93%8D%E7%B4%A2%E5%BC%95"><span class="toc-number">10.1.</span> <span class="toc-text">条件字段函数操作会影响索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">10.2.</span> <span class="toc-text">隐式类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">10.3.</span> <span class="toc-text">隐式字符编码转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoB%E7%9A%84%E7%B4%A2%E5%BC%95%E6%A8%A1%E5%9E%8B%EF%BC%88B-%E6%A0%91%EF%BC%89"><span class="toc-number">11.</span> <span class="toc-text">InnoB的索引模型（B+树）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E4%B9%A0B-%E6%A0%91"><span class="toc-number">11.1.</span> <span class="toc-text">复习B+树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%95%B0%E6%8D%AE"><span class="toc-number">11.2.</span> <span class="toc-text">案例数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95"><span class="toc-number">11.3.</span> <span class="toc-text">主键索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95"><span class="toc-number">11.4.</span> <span class="toc-text">普通索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95-1"><span class="toc-number">11.5.</span> <span class="toc-text">联合索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%BB%B4%E6%8A%A4"><span class="toc-number">11.6.</span> <span class="toc-text">索引维护</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2022/10/31/C8gKdeILb2EhnT1.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 张三</div><div class="footer_custom_text"><a href="https://beian.miit.gov.cn/" target="_blank">浙ICP备2023014267号</a></div></div><script src="https://cdn.bootcdn.net/ajax/libs/mermaid/9.4.0/mermaid.min.js"></script></footer></div><div id="rightside"><div id="rightside-config-hide"></div><div id="rightside-config-show"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div></div></body></html>