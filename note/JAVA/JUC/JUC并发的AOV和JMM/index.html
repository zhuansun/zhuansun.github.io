<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JUC并发的AOV和JMM | CCWorld</title><meta name="author" content="张三"><meta name="copyright" content="张三"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文还有xmind图解，点击下载：并发编程的AOV.xmind     CPU缓存带来的可见性问题  一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为可见性。  在以前单核CPU的情况下，CPU只有一个缓存，所以多个线程同时修改一个变量是不会有可见性问题的 在目前多核CPU的情况下，每一个核心都会有一个缓存， 对变量的修改保存在当前核心的缓存中，另一个核心就无法可见，所以就会存在可见">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC并发的AOV和JMM">
<meta property="og:url" content="https://zhuansun.github.io/note/JAVA/JUC/JUC%E5%B9%B6%E5%8F%91%E7%9A%84AOV%E5%92%8CJMM/index.html">
<meta property="og:site_name" content="CCWorld">
<meta property="og:description" content="本文还有xmind图解，点击下载：并发编程的AOV.xmind     CPU缓存带来的可见性问题  一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为可见性。  在以前单核CPU的情况下，CPU只有一个缓存，所以多个线程同时修改一个变量是不会有可见性问题的 在目前多核CPU的情况下，每一个核心都会有一个缓存， 对变量的修改保存在当前核心的缓存中，另一个核心就无法可见，所以就会存在可见">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhuansun.github.io/JUC%E5%B9%B6%E5%8F%91%E7%9A%84AOV%E5%92%8CJMM.assets/image-20230529221626357.png">
<meta property="article:published_time" content="2023-05-05T16:49:48.000Z">
<meta property="article:modified_time" content="2023-06-01T10:14:17.528Z">
<meta property="article:author" content="张三">
<meta property="article:tag" content="JUC">
<meta property="article:tag" content="原子性">
<meta property="article:tag" content="volalite">
<meta property="article:tag" content="内存屏障">
<meta property="article:tag" content="有序性">
<meta property="article:tag" content="可见性">
<meta property="article:tag" content="Java内存模型">
<meta property="article:tag" content="JMM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhuansun.github.io/JUC%E5%B9%B6%E5%8F%91%E7%9A%84AOV%E5%92%8CJMM.assets/image-20230529221626357.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhuansun.github.io/note/JAVA/JUC/JUC%E5%B9%B6%E5%8F%91%E7%9A%84AOV%E5%92%8CJMM/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JUC并发的AOV和JMM',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-01 10:14:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="CCWorld" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">101</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">139</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./JUC%E5%B9%B6%E5%8F%91%E7%9A%84AOV%E5%92%8CJMM.assets/image-20230529221626357.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">CCWorld</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JUC并发的AOV和JMM</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-05-05T16:49:48.000Z" title="发表于 2023-05-05 16:49:48">2023-05-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JAVA/">JAVA</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JAVA/JUC/">JUC</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><img src="/JUC%E5%B9%B6%E5%8F%91%E7%9A%84AOV%E5%92%8CJMM.assets/image-20230529221626357.png" alt="image-20230529221626357"></p>
<p>本文还有xmind图解，点击下载：<a href="./JUC%E5%B9%B6%E5%8F%91%E7%9A%84AOV%E5%92%8C%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.assets/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84AOV.xmind">并发编程的AOV.xmind</a></p>
<img src="JUC并发的AOV和JMM.assets/image-20230507191602711.png" alt="image-20230507191602711" style="zoom: 67%;" />



<h2 id="CPU缓存带来的可见性问题"><a href="#CPU缓存带来的可见性问题" class="headerlink" title="CPU缓存带来的可见性问题"></a>CPU缓存带来的可见性问题</h2><img src="JUC并发的AOV和JMM.assets/image-20230505220957901.png" alt="image-20230505220957901" style="zoom:80%;" />

<p>一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为可见性。</p>
<ul>
<li>在以前单核CPU的情况下，CPU只有一个缓存，所以多个线程同时修改一个变量是不会有可见性问题的</li>
<li>在目前多核CPU的情况下，每一个核心都会有一个缓存， 对变量的修改保存在当前核心的缓存中，另一个核心就无法可见，所以就会存在可见性的问题。</li>
<li>用一段代码来验证一下多核场景下的可见性问题。下面的代码，每执行一次 add10K() 方法，都会循环 10000 次 count+&#x3D;1 操作。在 calc() 方法中我们创建了两个线程，每个线程调用一次 add10K() 方法，我们来想一想执行 calc() 方法得到的结果应该是多少呢？</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">private</span> <span class="token keyword">long</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">add10K</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>idx<span class="token operator">++</span> <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      count <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">final</span> <span class="token class-name">Test</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 创建两个线程，执行add()操作</span>
    <span class="token class-name">Thread</span> th1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span>
      test<span class="token punctuation">.</span><span class="token function">add10K</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span> th2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span>
      test<span class="token punctuation">.</span><span class="token function">add10K</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 启动两个线程</span>
    th1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    th2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 等待两个线程执行结束</span>
    th1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    th2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> count<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>在多核CPU的环境下，返回的结果是：10000 到 20000 之间的随机数。</li>
</ul>
<h2 id="线程切换带来的原子性问题"><a href="#线程切换带来的原子性问题" class="headerlink" title="线程切换带来的原子性问题"></a>线程切换带来的原子性问题</h2><p>我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性。也就是要么全部成功，要么全部失败。</p>
<p>Java 并发程序都是基于多线程的，自然也会涉及到线程切换，但是不可控的在于：我们无法控制CPU切换的时间点。就会导致一些很诡异的问题；</p>
<p>举个例子：count&#x3D;0；启动两个线程都执行count+&#x3D;1；你以为的结果是2，实际上结果可能是1，还可能是2；</p>
<p>这是因为，count+&#x3D;1 这行代码对操作系统来说，对应三个汇编指令：</p>
<ul>
<li><p>指令 1：首先，需要把变量 count 从内存加载到 CPU 的寄存器；</p>
</li>
<li><p>指令 2：之后，在寄存器中执行 +1 操作；</p>
</li>
<li><p>指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。</p>
</li>
</ul>
<p>而在多线程环境下，CPU切换的时间点是不可控的，所以就会出现下面的情况</p>
<img src="JUC并发的AOV和JMM.assets/image-20230505222540170.png" alt="image-20230505222540170" style="zoom:80%;" />



<h2 id="编译优化带来的有序性问题"><a href="#编译优化带来的有序性问题" class="headerlink" title="编译优化带来的有序性问题"></a>编译优化带来的有序性问题</h2><p>编译器为了优化性能，有时候会改变程序中语句的先后顺序，例如程序中：“a&#x3D;6；b&#x3D;7；”编译器优化后可能变成“b&#x3D;7；a&#x3D;6；”，在这个例子中，编译器调整了语句的顺序，但是不影响程序的最终结果。不过有时候编译器及解释器的优化可能导致意想不到的 Bug。</p>
<p>下面看一个经典案例：双重检查创建单例对象</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>
  <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
          instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>以上代码在多线程情况下，会出现什么问题呢？</p>
<p>出在 new 操作上，我们以为的 new 操作应该是：</p>
<ul>
<li>分配一块内存 M；</li>
<li>在内存 M 上初始化 Singleton 对象；</li>
<li>然后 M 的地址赋值给 instance 变量。</li>
</ul>
<p>但是实际上优化后的执行路径却是这样的：</p>
<ul>
<li>分配一块内存 M；</li>
<li>将 M 的地址赋值给 instance 变量；</li>
<li>最后在内存 M 上初始化 Singleton 对象。</li>
</ul>
<p>所以就有可能导致在将地址赋值给instance之后，没有创建对象，此时线程切换了。就会导致返回的instance实例是null，进而引发NPE；</p>
<p>问：什么时候会重排序？</p>
<p>答：在编译器与CPU处理器中都能执行指令重排优化操作。</p>
<img src="JUC并发的AOV和JMM.assets/image-20230507181344121.png" alt="image-20230507181344121" style="zoom:50%;" />



<p>问：A如果没有完成实例的初始化，锁应该不会释放的，B是拿不到锁的，怎么还会出问题呢？</p>
<p>答：CPU时间片切换后，线程B刚好执行到第一次判断instance&#x3D;&#x3D;null，此时不为空（分配了地址，只是没有初始化），不用进入synchronized里，就将还未初始化的instance返回了</p>
<img src="JUC并发的AOV和JMM.assets/image-20230505224316948.png" alt="image-20230505224316948" style="zoom: 40%;" />



<p>特意提到缓存导致的可见性问题，线程切换带来的原子性问题，编译优化带来的有序性问题，其实缓存、线程、编译优化的目的和我们写并发程序的目的是相同的，都是提高程序性能。但是技术在解决一个问题的同时，必然会带来另外一个问题，所以在<strong>采用一项技术的同时，一定要清楚它带来的问题是什么，以及如何规避。</strong></p>
<h2 id="怎么解决可见性和有序性问题"><a href="#怎么解决可见性和有序性问题" class="headerlink" title="怎么解决可见性和有序性问题"></a>怎么解决可见性和有序性问题</h2><p>我们知道可见性是由于CPU缓存的存在导致的，有序性是由于编译优化导致的，要想解决这两个问题，最简单的思路就是</p>
<ul>
<li>禁用CPU缓存和编译优化</li>
</ul>
<p>是的，只需要禁用，我们就可以解决可见性和有序性，但是随之而来的问题就是：</p>
<ul>
<li>系统的性能直线下降</li>
</ul>
<p>很显然这不是我们想要的，那怎么办呢？</p>
<ul>
<li>合理的禁用CPU缓存和编译优化（意思就是：只在需要禁用的时候禁用）</li>
</ul>
<p>那么，什么时候是需要禁用的时候呢？</p>
<ul>
<li>其实就是指按照程序员的要求来禁用</li>
</ul>
<p>既然要禁用CPU缓存和编译优化，而且还是需要程序员主观的判断控制，那就需要为程序员提供</p>
<ul>
<li>提供给程序员按需禁用缓存和编译优化的方法</li>
</ul>
<p>这个方法就是：</p>
<ul>
<li>Java内存模型（JMM）</li>
</ul>
<h3 id="Java内存模型（JMM）"><a href="#Java内存模型（JMM）" class="headerlink" title="Java内存模型（JMM）"></a>Java内存模型（JMM）</h3><p>这一小部分有一个思维导图，点击下载思维导图文件：<a href="./JUC%E5%B9%B6%E5%8F%91%E7%9A%84AOV%E5%92%8C%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.assets/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.xmind">Java内存模型.xmind</a></p>
<img src="JUC并发的AOV和JMM.assets/image-20230506141920930.png" alt="image-20230506141920930" style="zoom:80%;" />

<h3 id="什么是Java内存模型"><a href="#什么是Java内存模型" class="headerlink" title="什么是Java内存模型"></a>什么是Java内存模型</h3><p>Java内存模型（JMM）是Java定义的一种抽象的计算机内存模型，并不真实存在。它描述的一组规则或者规范。通过这些规则、规范定义了程序中各个变量的访问方式。从而解决在多线程环境下可能出现的问题。</p>
<h3 id="多线程环境下都有哪些问题"><a href="#多线程环境下都有哪些问题" class="headerlink" title="多线程环境下都有哪些问题"></a><strong>多线程环境下都有哪些问题</strong></h3><p>这个标题也可以理解为：为什么要引入JMM？</p>
<p>现代计算机体系大部是采用的对称多处理器的体系架构。每个处理器均有独立的寄存器组和缓存，寄存器组和缓存中保存的同一个变量的值可能是不同的，这就会导致<strong>缓存一致性问题（可见性）</strong>。另外多个处理器可同时执行同一进程中的不同线程，这里称为<strong>处理器的乱序执行（原子性）</strong>。此外，编译器为了提高性能，会对指令进行优化，导致顺序发生变化，如果任由编译器或处理器对这些访问进行优化的话，很有可能出现无法想象的问题，这里称为<strong>编译器的重排序（有序性）</strong>。除了缓存一致性问题、处理器的乱序执行、编译器的重排序，还有内存系统的重排序。</p>
<p>因此Java语言规范引入了JMM，通过定义多项规则对编译器和处理器进行限制，解决这三个问题。</p>
<h3 id="怎么解决这些问题的"><a href="#怎么解决这些问题的" class="headerlink" title="怎么解决这些问题的"></a>怎么解决这些问题的</h3><p>但是 JMM 只解决了缓存一致性问题（可见性），和编译器的重排序（有序性），另外解决了<strong>部分的</strong>原子性问题</p>
<p>在描述 JMM 是怎么解决这些问题之前，我们先看一下原理，也就是在操作系统上，是怎么解决这些问题的。</p>
<h4 id="操作系统层面上是怎么解决的"><a href="#操作系统层面上是怎么解决的" class="headerlink" title="操作系统层面上是怎么解决的"></a>操作系统层面上是怎么解决的</h4><p>在操作系统层面上，缓存一致性问题的解决办法：</p>
<ul>
<li>总线锁 Bus Lock，性能极低，是CPU和硬件层面的</li>
<li>直接内存访问 Direct Memory Access ，简称DMA，是一种硬件设备，绕过处理器直接访问内存</li>
<li>缓存一致性协议 Cache Coherence Protocol，比如Intel公司提出的 MESI 协议，是CPU层面的</li>
</ul>
<p>在操作系统层面上，并没有解决原子性。</p>
<ul>
<li>因为操作系统执行的是指令，对于任意一个指令来说肯定是原子性的。但是很多情况下我们的一行代码可能对应多行指令：如 <code>i+=1</code></li>
</ul>
<p>在操作系统层面上，编译器的重排序的解决办法：</p>
<ul>
<li>内存屏障 Memory Barrier，是操作系统和硬件层面的，通过在CPU指令前后加上屏障，避免重排序</li>
</ul>
<p>上面说了在操作系统层面，那么回到Java语言上来，JMM是怎么解决的呢？</p>
<h4 id="JMM是怎么解决这些问题的"><a href="#JMM是怎么解决这些问题的" class="headerlink" title="JMM是怎么解决这些问题的"></a>JMM是怎么解决这些问题的</h4><p>JMM 对内存区域重新划分，分为：主内存和工作内存。每个线程运行时，都会创建一个工作内存（也叫栈空间），来保存线程所有的私有变量。而JMM规范中规定所有的变量都存储在主内存中，而主内存中的变量是所有的线程都可以共享的，而对主内存中的变量进行操作时，必须在线程的工作内存进行操作，首先将主内存的变量copy到工作内存，进行操作后，再将变量刷回到主内存中。所有线程只有通过主内存来进行通信。</p>
<img src="JUC并发的AOV和JMM.assets/image-20230506121343472.png" alt="image-20230506121343472" style="zoom:50%;" />

<p>为什么要对内存区域重新划分呢？</p>
<p>最主要的原因还是为了实现JVM的跨平台，举个例子，内存屏障的实现在不同的CPU架构上是不同的，甚至指令都不一样，而Java是跨平台的，必然不能直接使用，所以中间加了一层自己的内存结构并制定了自己的内存屏障规范。另外，有了自己的内存结构之后，就可以完美的配合JMM提出的 volatile 关键字，synchronized关键字，final关键字，happens-before关系这些规范了。</p>
<p>JMM对内存区域进行了重新划分，和硬件层面上的内存架构有什么关系呢？</p>
<p>多线程的执行最终是映射到硬件层面，通过硬件上的处理器进行执行，但java内存模型跟硬件内存架构并不完全一致。对于硬件内存架构来说，只有寄存器、缓存行、主内存的概念，并没有工作内存（私有内存区域）、主内存（堆内存）之分。也就是说JMM的内存划分对硬件内存架构并没有什么影响，因为JMM是一种抽象的概念，是一种规范，并不实际存在。对于硬件内存来说，不管是工作内存，还是主内存，都是储存在寄存器、缓存行、主内存中，JMM与硬件内存架构是一种相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉。（注意对于JVM内存区域划分一样）。</p>
<img src="JUC并发的AOV和JMM.assets/image-20230506121452727.png" alt="image-20230506121452727" style="zoom:50%;" />

<p>JMM是通过 volatile 关键字来解决可见性和有序性的。</p>
<ul>
<li>是的，你没有看错，volatile 一个关键字就可以解决两个问题。</li>
<li>原理就是：volatile 关键字用来实现内存屏障(memory barrier)，从而禁止重排序的，即时编译器根据具体的底层体系架构，将这些内存屏障替换成具体的 CPU 指令<ul>
<li>1、对于编译器而言，内存屏障将限制它所能做的重排序优化。从而解决了有序性问题</li>
<li>2、而对于处理器而言，内存屏障将会导致缓存的刷新操作。从而解决了可见性问题。</li>
</ul>
</li>
</ul>
<p>对于原子性，JMM并没有保证原子性，在Java中是用锁来实现的原子性，后面会详细展开说。</p>
<p>JMM不仅仅提供了上面这些，还有：volatile 关键字，synchronized关键字，final关键字，happens-before关系来解决在多线程环境下出现的问题。</p>
<h3 id="Java内存模型的官方文档"><a href="#Java内存模型的官方文档" class="headerlink" title="Java内存模型的官方文档"></a>Java内存模型的官方文档</h3><p>官方文档：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jls/se16/html/jls-17.html">Chapter 17. Threads and Locks (oracle.com)</a>，这篇文章是Java语言规范（Java Language Specification）的第17章，主要讲解Java内存模型（Java Memory Model，JMM）的相关内容。</p>
<p>具体来说，该章节介绍了</p>
<ul>
<li>Java内存模型的定义和作用；</li>
<li>Java内存模型中的原子性、可见性、有序性等概念；</li>
<li>如何使用synchronized、volatile、final等关键字来实现线程安全的编程；</li>
<li>Java内存模型中的happens-before关系、同步块和同步方法的语义、volatile变量的语义等概念；</li>
<li>如何避免Java内存模型中的常见问题，如死锁、饥饿等。</li>
</ul>
<p>文章中详细介绍了Java内存模型的各种概念和规则，并提供了相关的例子和解析，让读者能够更加深入地理解Java内存模型的实现原理和使用方法，从而编写出高效、正确且线程安全的Java程序。</p>
<h3 id="Java内存模型的总结"><a href="#Java内存模型的总结" class="headerlink" title="Java内存模型的总结"></a>Java内存模型的总结</h3><p>Java 内存模型是个很复杂的规范，可以从不同的视角来解读，站在我们这些程序员的视角，本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。<strong>具体来说，这些方法包括 volatile、synchronized 和 final 三个关键字，以及六项 Happens-Before 规则</strong></p>
<h3 id="Happens-Before-规则"><a href="#Happens-Before-规则" class="headerlink" title="Happens-Before 规则"></a>Happens-Before 规则</h3><p><strong>不用去背，没啥意思，如果有面试官问这个，就是LOW</strong></p>
<p>只靠sychronized和volatile关键字来保证原子性、可见性以及有序性，那么编写并发程序可能会显得十分麻烦，幸运的是，从JDK 5开始，Java使用新的JSR-133内存模型，提供了happens-before 原则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据，happens-before 原则内容如下：</p>
<table>
<thead>
<tr>
<th>原则</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>程序顺序原则</td>
<td>在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。</td>
</tr>
<tr>
<td>锁规则</td>
<td>解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)。</td>
</tr>
<tr>
<td>volatile规则</td>
<td>volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。</td>
</tr>
<tr>
<td>传递性</td>
<td>A先于B ，B先于C 那么A必然先于C</td>
</tr>
<tr>
<td>线程启动规则</td>
<td>线程的start()方法先于它的每一个动作，即如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B可见</td>
</tr>
<tr>
<td>线程终止规则</td>
<td>线程的所有操作先于线程的终结，Thread.join()方法的作用是等待当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。</td>
</tr>
<tr>
<td>线程中断规则</td>
<td>对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。</td>
</tr>
<tr>
<td>对象终结规则</td>
<td>对象的构造函数执行，结束先于finalize()方法</td>
</tr>
</tbody></table>
<p>两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。happens-before的定义很微妙，后文会具体说明happens-before为什么要这么定义。——来自《Java并发编程的艺术》</p>
<p><strong>Happens-Before与JMM的关系</strong></p>
<p>一个happens-before规则对应于一个或多个编译器和处理器重排序规则。对于Java程序员来说，happens-before规则简单易懂，它避免Java程序员为了理解JMM提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现方法。</p>
<p>简单理解就是：JMM帮我们封装好了。</p>
<img src="JUC并发的AOV和JMM.assets/image-20230506152551844.png" alt="image-20230506152551844" style="zoom:80%;" />



<h3 id="volatile关键字的实现原理"><a href="#volatile关键字的实现原理" class="headerlink" title="volatile关键字的实现原理"></a>volatile关键字的实现原理</h3><p>通过本文前面，我们知道 volatile 关键字有两个作用</p>
<p>1、在编译器层面，内存屏障禁用了编译器的重排序，保证了有序性；</p>
<p>2、在处理器层面，内存屏障将会导致缓存的刷新操作，保证了可见性。</p>
<p>那么，volatile 关键字到底是怎么实现这些功能的呢？</p>
<ul>
<li>那就涉及到内存屏障了。</li>
</ul>
<h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p>内存屏障在处理器层面，是一种特殊指令。处理器执行的时候看到这种指令，必须保证这个指令前的操作执行完，只能执行后面的；</p>
<p><strong>在处理器层面</strong>：这些指令包括：ifence，sfence，mfence（Intel的CPU的特有指令，不同的CPU指令可能不一样）</p>
<p><strong>在JVM层面</strong>：由于JVM是跨平台的，所以JVM规定了自己的内存屏障：LoadLoadBarrier，LoadStoreBarrier，StoreStoreBarrier，StoreLoadBarrier。那么所有实现JVM规范的虚拟机，比如hotspot，都必须实现这四个屏障。</p>
<h4 id="volatile关键字和内存屏障有啥关系呢"><a href="#volatile关键字和内存屏障有啥关系呢" class="headerlink" title="volatile关键字和内存屏障有啥关系呢"></a>volatile关键字和内存屏障有啥关系呢</h4><p>volatile 只是一个关键字，它只能简单的用来修饰一个变量，或者说，标记一块内存区域地址；</p>
<p>那么，它和顺序有啥关系呢？为啥说使用 volatile 修饰的变量就可以禁止重排序呢？</p>
<p>举个例子来说</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VolatileExample</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> count<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>set 方法是写，而且要写的变量是 count，而 count 使用了 volatile 进行修饰。说明 set 方法是一个 volatile写 操作；</p>
<p>get 方法是读，而且要读的变量是 count，而 count 使用了 volatile 进行修饰，说明 get 方法是一个 volatile读 操作；</p>
<p>对于 volatile写 操作，在JVM层面上，会添加如下内存屏障</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token class-name">StoreStoreBarrier</span><span class="token operator">--</span><span class="token operator">--</span>
【<span class="token keyword">volatile</span>写 操作】
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token class-name">StoreLoadBarrier</span><span class="token operator">--</span><span class="token operator">--</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>对于 volatile读 操作，在JVM层面上，会添加如下内存屏障</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">【<span class="token keyword">volatile</span>读 操作】
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token class-name">LoadLoadBarrier</span><span class="token operator">--</span><span class="token operator">--</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token class-name">LoadStoreBarrier</span><span class="token operator">--</span><span class="token operator">--</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<p>那么是什么意思呢：</p>
<ul>
<li>对于 volatile写 操作<ul>
<li>StoreStoreBarrier表示：在当前线程写这块内存区域之前，所有别的线程对这块内存要做的<strong>写操作</strong>都必须先完成。</li>
<li>StoreLoadBarrier表示：在当前线程写完这块区域之后，所有别的线程对这块内存的<strong>读操作</strong>才可以开始。</li>
</ul>
</li>
<li>对于 volatile读 操作<ul>
<li>LoadLoadBarrier表示：在当前线程读完这块内存区域之后，所有别的线程对这块内存区域的<strong>读操作</strong>才可以开始。</li>
<li>LoadStoreBarrier表示：在当前线程读完这块内存区域之后，所有别的线程对这块内存区域的<strong>写操作</strong>才可以开始。</li>
</ul>
</li>
</ul>
<h4 id="内存屏障和重排序有啥关系呢？"><a href="#内存屏障和重排序有啥关系呢？" class="headerlink" title="内存屏障和重排序有啥关系呢？"></a>内存屏障和重排序有啥关系呢？</h4><p>关系很简单。</p>
<p>我们知道，在编译器和CPU处理器中都有可能导致指令的重排序。</p>
<p>那么在编译器和CPU处理器中，当遇到内存屏障的相关指令，就不在排序，这就避免了重排序；</p>
<p>既然不再排序了。那么最终生成的机器码就是正确的。</p>
<h4 id="内存屏障和可见性有啥关系呢？"><a href="#内存屏障和可见性有啥关系呢？" class="headerlink" title="内存屏障和可见性有啥关系呢？"></a>内存屏障和可见性有啥关系呢？</h4><p>关系也很简单，这是在JMM层面和CPU层面都做的优化。</p>
<p>我们知道JMM对计算机系统的内存区域重新划分了区域。分为了工作内存和主存。</p>
<p>一个变量被volatile修饰的时候，在系统运行期间，会遇到这个变量的内存屏障，然后：</p>
<ul>
<li>如果要对这个变量进行<strong>写操作</strong>，会先在工作内存中写，由于内存屏障的存在，还会在继续做两个操作<ul>
<li>1、实时的同步到主存中；</li>
<li>2、通知其他CPU核心，你们缓存中的数据已经失效了。</li>
</ul>
</li>
<li>如果要对这个变量进行<strong>读操作</strong>，由于内存屏障的存在<ul>
<li>不会从缓存中拿，而是实时的去主存中拿</li>
</ul>
</li>
</ul>
<p>这样，就解决了可见性。</p>
<h4 id="volatile的原理总结"><a href="#volatile的原理总结" class="headerlink" title="volatile的原理总结"></a>volatile的原理总结</h4><ul>
<li>代码层面：程序员用 volatile 修饰一个变量</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">volatile</span> i<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>编译器层面：编译成字节码的时候，对使用 volatile 关键字的变量，会使用 ACC_VOLATILE 修饰</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token constant">ACC_VOLATILE</span> i<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>JVM层面：JVM执行字节码的时候，遇到 ACC_VOLATILE 就会添加内存屏障</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token class-name">StoreStoreBarrier</span><span class="token operator">--</span><span class="token operator">--</span>
【<span class="token keyword">volatile</span>写 操作】
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token class-name">StoreLoadBarrier</span><span class="token operator">--</span><span class="token operator">--</span>

    
【<span class="token keyword">volatile</span>读 操作】
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token class-name">LoadLoadBarrier</span><span class="token operator">--</span><span class="token operator">--</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token class-name">LoadStoreBarrier</span><span class="token operator">--</span><span class="token operator">--</span>    

    
屏障两边的指令不可以重排！保障有序！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>hotspot层面</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// bytecodeinterpreter.cpp</span>
<span class="token keyword">int</span> field_offset <span class="token operator">=</span> cache<span class="token operator">-></span><span class="token function">f2_as_index</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>cache<span class="token operator">-></span><span class="token function">is_volatile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>support_IRIW_for_not_multiple_copy_atomic_cpu<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
              <span class="token class-name">OrderAccess</span><span class="token operator">::</span><span class="token function">fence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
<span class="token comment">//orderaccess_linux_x86.inline.hpp</span>
inline <span class="token keyword">void</span> <span class="token class-name">OrderAccess</span><span class="token operator">::</span><span class="token function">fence</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>os<span class="token operator">::</span><span class="token function">is_MP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// always use locked addl since mfence is sometimes expensive</span>
#ifdef <span class="token constant">AMD64</span>
    __asm__ <span class="token keyword">volatile</span> <span class="token punctuation">(</span><span class="token string">"lock; addl $0,0(%%rsp)"</span> <span class="token operator">:</span> <span class="token operator">:</span> <span class="token operator">:</span> <span class="token string">"cc"</span><span class="token punctuation">,</span> <span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
#<span class="token keyword">else</span>
    __asm__ <span class="token keyword">volatile</span> <span class="token punctuation">(</span><span class="token string">"lock; addl $0,0(%%esp)"</span> <span class="token operator">:</span> <span class="token operator">:</span> <span class="token operator">:</span> <span class="token string">"cc"</span><span class="token punctuation">,</span> <span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
#endif
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
<span class="token comment">//主要是调用CPU指令：ifence，sfence，mfence实现内存屏障</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="怎么解决原子性问题"><a href="#怎么解决原子性问题" class="headerlink" title="怎么解决原子性问题"></a>怎么解决原子性问题</h2><p>原子性问题的一个经典面试题就是：为什么在 32 位的机器上对 long 型变量进行加减操作存在并发隐患</p>
<p>要解决这个问题，就要知道为什么会发生原子性问题。</p>
<p>原子性问题的产生原因就是因为：高级编程语言的一行代码可能对应多个CPU指令，以在 32 位的机器上对 long 型变量进行加减操作为例，分为两步：第一步：写高32位；第二步：写低32位；而CPU在执行的时候是可能发生线程切换的，导致出现了原子性出现问题。</p>
<p>那么知道了原因，那就好解决了。</p>
<ul>
<li>禁止线程切换，保证当前线程一直继续执行下去不就好了。</li>
</ul>
<p>在早期CPU只是单核的情况下，禁止线程切换，可以保证我们的代码只被一个核心的一个线程执行持续执行。问题可以得到解决。</p>
<img src="JUC并发的AOV和JMM.assets/image-20230507210300090.png" alt="image-20230507210300090" style="zoom:80%;" />

<p>但是目前CPU都是多核的。也就是意味着我们的一行代码对应的多个CPU指令，可能是不同的核心的不同线程执行的。</p>
<p>在多核CPU情况下，我们禁止线程切换，只能保证当前核心的当前线程持续执行，但是我们的代码被分散到了多个核心上。所以是没有用的。</p>
<img src="JUC并发的AOV和JMM.assets/image-20230507210513200.png" alt="image-20230507210513200" style="zoom:80%;" />

<p>那怎么办呢？</p>
<ul>
<li>我们只需要保证同一时刻只有一个线程在执行，就可以解决问题。</li>
</ul>
<p>“同一时刻只有一个线程执行”这个条件非常重要，我们称之为<strong>互斥</strong>。如果我们能够保证对共享变量的修改是互斥的，那么，无论是单核 CPU 还是多核 CPU，就都能保证原子性了。</p>
<img src="JUC并发的AOV和JMM.assets/image-20230507210846979.png" alt="image-20230507210846979" style="zoom:80%;" />

<p>具体是怎么保证“同一时刻只有一个线程在执行的”</p>
<ul>
<li>就是怎么保证互斥，当然是：<strong>锁</strong>了。</li>
</ul>
<p>那么java给我们程序员提供的工具就是：</p>
<ul>
<li>锁</li>
</ul>
<p>锁这部分的内容很多，包括 synchronized，Lock，无锁CAS等，这部分单独抽一篇说。</p>
<p>参考《JUC并发的锁》</p>
<h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h2></article><div class="tag_share"><div class="post_share"></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU%E7%BC%93%E5%AD%98%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">CPU缓存带来的可见性问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">线程切换带来的原子性问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">编译优化带来的有序性问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">怎么解决可见性和有序性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88JMM%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">Java内存模型（JMM）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">什么是Java内存模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">4.3.</span> <span class="toc-text">多线程环境下都有哪些问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98%E7%9A%84"><span class="toc-number">4.4.</span> <span class="toc-text">怎么解决这些问题的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B1%82%E9%9D%A2%E4%B8%8A%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%9A%84"><span class="toc-number">4.4.1.</span> <span class="toc-text">操作系统层面上是怎么解决的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JMM%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98%E7%9A%84"><span class="toc-number">4.4.2.</span> <span class="toc-text">JMM是怎么解决这些问题的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3"><span class="toc-number">4.5.</span> <span class="toc-text">Java内存模型的官方文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-number">4.6.</span> <span class="toc-text">Java内存模型的总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Happens-Before-%E8%A7%84%E5%88%99"><span class="toc-number">4.7.</span> <span class="toc-text">Happens-Before 规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">4.8.</span> <span class="toc-text">volatile关键字的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="toc-number">4.8.1.</span> <span class="toc-text">内存屏障</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E6%9C%89%E5%95%A5%E5%85%B3%E7%B3%BB%E5%91%A2"><span class="toc-number">4.8.2.</span> <span class="toc-text">volatile关键字和内存屏障有啥关系呢</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E5%92%8C%E9%87%8D%E6%8E%92%E5%BA%8F%E6%9C%89%E5%95%A5%E5%85%B3%E7%B3%BB%E5%91%A2%EF%BC%9F"><span class="toc-number">4.8.3.</span> <span class="toc-text">内存屏障和重排序有啥关系呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E5%92%8C%E5%8F%AF%E8%A7%81%E6%80%A7%E6%9C%89%E5%95%A5%E5%85%B3%E7%B3%BB%E5%91%A2%EF%BC%9F"><span class="toc-number">4.8.4.</span> <span class="toc-text">内存屏障和可见性有啥关系呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile%E7%9A%84%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93"><span class="toc-number">4.8.5.</span> <span class="toc-text">volatile的原理总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">5.</span> <span class="toc-text">怎么解决原子性问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.</span> <span class="toc-text">final 关键字</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('/./JUC%E5%B9%B6%E5%8F%91%E7%9A%84AOV%E5%92%8CJMM.assets/image-20230529221626357.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 张三</div><div class="footer_custom_text"><a href="https://beian.miit.gov.cn/" target="_blank">浙ICP备2023014267号</a></div></div><script src="https://cdn.bootcdn.net/ajax/libs/mermaid/9.4.0/mermaid.min.js"></script></footer></div><div id="rightside"><div id="rightside-config-hide"></div><div id="rightside-config-show"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div></div></body></html>