<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JUC并发之synchronized | CCWorld</title><meta name="author" content="张三"><meta name="copyright" content="张三"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="锁的出现主要是解决原子性。 但是：锁不仅解决了原子性。同样的，它还解决了可见性。 但是：锁不仅解决了原子性和可见性，还解决了有序性。 哈哈哈哈，牛不牛 锁把可见性，有序性，原子性全都解决了。 但是 锁对有序性的解决，只是保证了as-if-serial语义，并不是严格意义上的有序性。 Java提供的锁技术：synchronized关键字synchronized关键字的简单使用class X &amp;#1">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC并发之synchronized">
<meta property="og:url" content="https://zhuansun.github.io/note/JAVA/JUC/JUC%E5%B9%B6%E5%8F%91%E4%B9%8Bsynchronized/index.html">
<meta property="og:site_name" content="CCWorld">
<meta property="og:description" content="锁的出现主要是解决原子性。 但是：锁不仅解决了原子性。同样的，它还解决了可见性。 但是：锁不仅解决了原子性和可见性，还解决了有序性。 哈哈哈哈，牛不牛 锁把可见性，有序性，原子性全都解决了。 但是 锁对有序性的解决，只是保证了as-if-serial语义，并不是严格意义上的有序性。 Java提供的锁技术：synchronized关键字synchronized关键字的简单使用class X &amp;#1">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhuansun.github.io/JUC%E5%B9%B6%E5%8F%91%E4%B9%8Bsynchronized.assets/image-20230529221408433.png">
<meta property="article:published_time" content="2023-05-07T21:50:02.000Z">
<meta property="article:modified_time" content="2023-05-29T14:32:36.741Z">
<meta property="article:author" content="张三">
<meta property="article:tag" content="JUC">
<meta property="article:tag" content="锁">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhuansun.github.io/JUC%E5%B9%B6%E5%8F%91%E4%B9%8Bsynchronized.assets/image-20230529221408433.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhuansun.github.io/note/JAVA/JUC/JUC%E5%B9%B6%E5%8F%91%E4%B9%8Bsynchronized/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JUC并发之synchronized',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-29 14:32:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="CCWorld" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">101</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">139</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./JUC%E5%B9%B6%E5%8F%91%E4%B9%8Bsynchronized.assets/image-20230529221408433.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">CCWorld</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JUC并发之synchronized</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-05-07T21:50:02.000Z" title="发表于 2023-05-07 21:50:02">2023-05-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JAVA/">JAVA</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JAVA/JUC/">JUC</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><img src="/JUC%E5%B9%B6%E5%8F%91%E4%B9%8Bsynchronized.assets/image-20230529221408433.png" alt="image-20230529221408433"></p>
<p>锁的出现主要是解决原子性。</p>
<p>但是：锁不仅解决了原子性。同样的，它还解决了可见性。</p>
<p>但是：锁不仅解决了原子性和可见性，还解决了有序性。</p>
<p>哈哈哈哈，牛不牛</p>
<p>锁把可见性，有序性，原子性全都解决了。</p>
<p>但是</p>
<p>锁对有序性的解决，只是保证了as-if-serial语义，并不是严格意义上的有序性。</p>
<h2 id="Java提供的锁技术：synchronized关键字"><a href="#Java提供的锁技术：synchronized关键字" class="headerlink" title="Java提供的锁技术：synchronized关键字"></a>Java提供的锁技术：synchronized关键字</h2><h3 id="synchronized关键字的简单使用"><a href="#synchronized关键字的简单使用" class="headerlink" title="synchronized关键字的简单使用"></a>synchronized关键字的简单使用</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 修饰非静态方法</span>
  <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 临界区</span>
  <span class="token punctuation">&#125;</span>
  <span class="token comment">// 修饰静态方法</span>
  <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 临界区</span>
  <span class="token punctuation">&#125;</span>
  <span class="token comment">// 修饰代码块</span>
  <span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；
  <span class="token keyword">void</span> <span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token comment">// 临界区</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当修饰静态方法的时候，锁定的是当前类的 Class 对象，在上面的例子中就是 Class X；</p>
<p>当修饰非静态方法的时候，锁定的是当前实例对象 this。</p>
<h3 id="synchronized关键字的实现原理"><a href="#synchronized关键字的实现原理" class="headerlink" title="synchronized关键字的实现原理"></a>synchronized关键字的实现原理</h3><h4 id="代码层面"><a href="#代码层面" class="headerlink" title="代码层面"></a>代码层面</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token comment">//...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h4 id="字节码层面"><a href="#字节码层面" class="headerlink" title="字节码层面"></a>字节码层面</h4><p>分为两种情况：</p>
<ul>
<li><p>synchronized修饰代码块</p>
</li>
<li><p>synchronized修饰方法</p>
</li>
</ul>
<p>synchronized修饰代码块</p>
<ul>
<li><p>monitorenter</p>
</li>
<li><p>moniterexit</p>
</li>
<li><p>反编译一段synchronized修饰代码块代码，<code>javap -c -s -v -l XXX.class</code>，可以看到相应的字节码指令。</p>
<img src="JUC并发之synchronized.assets/image-20230508144543939.png" alt="image-20230508144543939" style="zoom:80%;" /></li>
</ul>
<p>synchronized修饰方法</p>
<ul>
<li>ACC_SYNCHRONIZED 标记</li>
<li>反编译一段synchronized修饰方法，<code>javap -c -s -v -l XXX.class</code>，可以看到相应的字节码指令。</li>
</ul>
<img src="JUC并发之synchronized.assets/image-20230508144850196.png" alt="image-20230508144850196" style="zoom:80%;" />



<h4 id="JVM层级（Hotspot）"><a href="#JVM层级（Hotspot）" class="headerlink" title="JVM层级（Hotspot）"></a>JVM层级（Hotspot）</h4><img src="JUC并发之synchronized.assets/image-20230508150728674.png" alt="image-20230508150728674" style="zoom:80%;" />

<p>InterpreterRuntime.cpp:: monitorenter方法是开始获取锁</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">IRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))
#ifdef ASSERT
  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);
#endif
  if (PrintBiasedLockingStatistics) &#123;
    Atomic::inc(BiasedLocking::slow_path_entry_count_addr());
  &#125;
  Handle h_obj(thread, elem-&gt;obj());
  assert(Universe::heap()-&gt;is_in_reserved_or_null(h_obj()),&quot;must be NULL or an object&quot;);
  &#x2F;&#x2F;UseBiasedLocking 轻量级锁的开关是否打开
  if (UseBiasedLocking) &#123;
    &#x2F;&#x2F; Retry fast entry if bias is revoked to avoid unnecessary inflation
    ObjectSynchronizer::fast_enter(h_obj, elem-&gt;lock(), true, CHECK);
  &#125; else &#123;
    ObjectSynchronizer::slow_enter(h_obj, elem-&gt;lock(), CHECK);
  &#125;
  assert(Universe::heap()-&gt;is_in_reserved_or_null(elem-&gt;obj()),&quot;must be NULL or an object&quot;);
#ifdef ASSERT
  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);
#endif
IRT_END<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>fast_enter方法：获取偏向锁</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void ObjectSynchronizer::fast_enter(Handle obj, BasicLock* lock, bool attempt_rebias, TRAPS) &#123;
 if (UseBiasedLocking) &#123;
    if (!SafepointSynchronize::is_at_safepoint()) &#123;
      &#x2F;&#x2F;在安全点的时候，尝试获取偏向锁：revoke_and_rebias
      BiasedLocking::Condition cond &#x3D; BiasedLocking::revoke_and_rebias(obj, attempt_rebias, THREAD);
      if (cond &#x3D;&#x3D; BiasedLocking::BIAS_REVOKED_AND_REBIASED) &#123;
        return;
      &#125;
    &#125; else &#123;
      assert(!attempt_rebias, &quot;can not rebias toward VM thread&quot;);
      BiasedLocking::revoke_at_safepoint(obj);
    &#125;
    assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 &#125;
 &#x2F;&#x2F;偏向锁没有获取到，升级为：获取轻量级锁
 slow_enter (obj, lock, THREAD) ;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>slow_enter方法：获取轻量级锁</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void ObjectSynchronizer::slow_enter(Handle obj, BasicLock* lock, TRAPS) &#123;
  markOop mark &#x3D; obj-&gt;mark();
  assert(!mark-&gt;has_bias_pattern(), &quot;should not see bias pattern here&quot;);

  if (mark-&gt;is_neutral()) &#123;
    &#x2F;&#x2F; Anticipate successful CAS -- the ST of the displaced mark must
    &#x2F;&#x2F; be visible &lt;&#x3D; the ST performed by the CAS.
    &#x2F;&#x2F; 获取轻量级锁的时候，会先进行自旋：cmpxchg_ptr，尝试获取轻量级锁
    lock-&gt;set_displaced_header(mark);
    if (mark &#x3D;&#x3D; (markOop) Atomic::cmpxchg_ptr(lock, obj()-&gt;mark_addr(), mark)) &#123;
      TEVENT (slow_enter: release stacklock) ;
      return ;
    &#125;
    &#x2F;&#x2F; Fall through to inflate() ...
  &#125; else
  if (mark-&gt;has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark-&gt;locker())) &#123;
    assert(lock !&#x3D; mark-&gt;locker(), &quot;must not re-lock the same lock&quot;);
    assert(lock !&#x3D; (BasicLock*)obj-&gt;mark(), &quot;don&#39;t relock with same BasicLock&quot;);
    lock-&gt;set_displaced_header(NULL);
    return;
  &#125;

#if 0
  &#x2F;&#x2F; The following optimization isn&#39;t particularly useful.
  if (mark-&gt;has_monitor() &amp;&amp; mark-&gt;monitor()-&gt;is_entered(THREAD)) &#123;
    lock-&gt;set_displaced_header (NULL) ;
    return ;
  &#125;
#endif

  &#x2F;&#x2F; The object header will never be displaced to this lock,
  &#x2F;&#x2F; so it does not matter what the value is, except that it
  &#x2F;&#x2F; must be non-zero to avoid looking like a re-entrant lock,
  &#x2F;&#x2F; and must not look locked either.
  lock-&gt;set_displaced_header(markOopDesc::unused_mark());
  &#x2F;&#x2F; 如果轻量级锁也没有获取到，就升级为：重量级锁 inflate
  ObjectSynchronizer::inflate(THREAD, obj())-&gt;enter(THREAD);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>inflate方法：获取重量级锁</p>
<h2 id="Java实例对象内存布局"><a href="#Java实例对象内存布局" class="headerlink" title="Java实例对象内存布局"></a>Java实例对象内存布局</h2><p>对象实例内存布局</p>
<img src="JUC并发之synchronized.assets/image-20230508152706963.png" alt="image-20230508152706963" style="zoom:80%;" />



<ul>
<li>Mark Word：记录锁信息，GC信息等等</li>
<li>class pointer：指向当前对象的class字节码文件</li>
</ul>
<p>引用Maven依赖</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>
    <span class="token comment">&lt;!-- https://mvnrepository.com/artifact/org.openjdk.jol/jol-core --></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.openjdk.jol<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jol-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.9<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>编写测试代码</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>mashibing<span class="token punctuation">.</span>insidesync</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jol<span class="token punctuation">.</span>info<span class="token punctuation">.</span></span><span class="token class-name">ClassLayout</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">T04_HelloJol</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        
        <span class="token class-name">Object</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ClassLayout</span><span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ClassLayout</span><span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试结果</p>
<img src="JUC并发之synchronized.assets/image-20230507222134977.png" alt="image-20230507222134977"  />







<h2 id="用户态与内核态"><a href="#用户态与内核态" class="headerlink" title="用户态与内核态"></a>用户态与内核态</h2><p>JDK早期，synchronized 叫做重量级锁， 因为申请锁资源必须通过 kernel 系统调用进行锁的分配，所以叫：重量级锁。</p>
<p>后来JDK对synchronized进行了优化，细分为了：偏向锁，轻量级锁，重量级锁。其中偏向锁其实就是无锁，轻量级锁不需要 kernel 内核调用。</p>
<p>所以：在用户态生成的锁都属于轻量级，因为不需要 kernel 内核调用。 kernel 内核调用就是内核态，比较耗资源。</p>
<p>重量级锁的申请，需要应用程序通过用户态，通过指令 0x80 调用内核态，去申请锁。</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">;hello.asm
;write(int fd, const void *buffer, size_t nbytes)

section data
    msg db &quot;Hello&quot;, 0xA
    len equ $ - msg

section .text
global _start
_start:

    mov edx, len
    mov ecx, msg
    mov ebx, 1 ;文件描述符1 std_out
    mov eax, 4 ;write函数系统调用号 4
    int 0x80

    mov ebx, 0
    mov eax, 1 ;exit函数系统调用号
    int 0x80
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>Compare And Swap (Compare And Exchange) &#x2F; 自旋 &#x2F; 自旋锁 &#x2F; 无锁 （无重量锁）</p>
<p>因为经常配合循环操作，直到完成为止，所以泛指一类操作</p>
<p>cas(v, a, b) ，变量v，期待值a, 修改值b</p>
<img src="JUC并发之synchronized.assets/image-20230507215542996.png" alt="image-20230507215542996" style="zoom:80%;" />



<h3 id="CAS的ABA问题"><a href="#CAS的ABA问题" class="headerlink" title="CAS的ABA问题"></a>CAS的ABA问题</h3><p>ABA问题，你的女朋友在离开你的这段儿时间经历了别的人，自旋就是你空转等待，一直等到她接纳你为止</p>
<p>解决办法（加版本号），基础类型简单值不需要版本号</p>
<p>每次修改变量，都在这个变量的版本号上加1，这样，刚刚A-&gt;B-&gt;A，虽然A的值没变，但是它的版本号已经变了，再判断版本号就会发现此时的A已经被改过了。参考乐观锁的版本号，这种做法可以给数据带上了一种实效性的检验。</p>
<p>Java提供了AtomicStampReference类，它的compareAndSet方法首先检查当前的对象引用值是否等于预期引用，并且当前印戳（Stamp）标志是否等于预期标志，如果全部相等，则以原子方式将引用值和印戳标志的值更新为给定的更新值。</p>
<h3 id="CAS的循环性能开销问题"><a href="#CAS的循环性能开销问题" class="headerlink" title="CAS的循环性能开销问题"></a>CAS的循环性能开销问题</h3><p>自旋CAS，如果一直循环执行，一直不成功，会给CPU带来非常大的执行开销。</p>
<p>怎么解决循环性能开销问题？</p>
<p>在Java中，很多使用自旋CAS的地方，会有一个自旋次数的限制，超过一定次数，就停止自旋。</p>
<h3 id="CAS的只能保证一个变量的原子操作问题"><a href="#CAS的只能保证一个变量的原子操作问题" class="headerlink" title="CAS的只能保证一个变量的原子操作问题"></a>CAS的只能保证一个变量的原子操作问题</h3><p>CAS 保证的是对一个变量执行操作的原子性，如果对多个变量操作时，CAS 目前无法直接保证操作的原子性的。</p>
<p>怎么解决只能保证一个变量的原子操作问题？</p>
<p>可以考虑改用锁来保证操作的原子性</p>
<p>可以考虑合并多个变量，将多个变量封装成一个对象，通过AtomicReference来保证原子性。</p>
<h3 id="CAS在JUC包的应用"><a href="#CAS在JUC包的应用" class="headerlink" title="CAS在JUC包的应用"></a>CAS在JUC包的应用</h3><ul>
<li>AtomicInteger</li>
<li>AtomicXXX</li>
</ul>
<h3 id="CAS的底层实现"><a href="#CAS的底层实现" class="headerlink" title="CAS的底层实现"></a>CAS的底层实现</h3><p>以 AtomicInteger 这个类的 compareAndSet 方法为例</p>
<img src="JUC并发之synchronized.assets/image-20230508160116738.png" alt="image-20230508160116738" style="zoom:80%;" />

<p>AtomicInteger:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> current <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> next <span class="token operator">=</span> current <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Unsafe:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token class-name">Object</span> var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var2<span class="token punctuation">,</span> <span class="token keyword">int</span> var4<span class="token punctuation">,</span> <span class="token keyword">int</span> var5<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>Unsafe的底层实现是C++</p>
<p>jdk8u: unsafe.cpp</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))
  UnsafeWrapper(&quot;Unsafe_CompareAndSwapInt&quot;);
  oop p &#x3D; JNIHandles::resolve(obj);
  jint* addr &#x3D; (jint *) index_oop_from_field_offset_long(p, offset);
  &#x2F;&#x2F; c++ 文件最终调用的是 Atomic::cmpxchg
  return (jint)(Atomic::cmpxchg(x, addr, e)) &#x3D;&#x3D; e;
UNSAFE_END<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Atomic::cmpxchg 在不同的架构上有不同的实现。</p>
<p>以 linux_86为例：在这个文件上： jdk8u: atomic_linux_x86.inline.hpp  93行</p>
<ul>
<li><code>__asm__</code>：表示是一个汇编指令</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">inline jint     Atomic::cmpxchg    (jint     exchange_value, volatile jint*     dest, jint     compare_value) &#123;
  int mp &#x3D; os::is_MP();
  __asm__ volatile (LOCK_IF_MP(%4) &quot;cmpxchgl %1,(%3)&quot;
                    : &quot;&#x3D;a&quot; (exchange_value)
                    : &quot;r&quot; (exchange_value), &quot;a&quot; (compare_value), &quot;r&quot; (dest), &quot;r&quot; (mp)
                    : &quot;cc&quot;, &quot;memory&quot;);
  return exchange_value;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>jdk8u: atomic_linux_x86.inline.hpp</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define LOCK_IF_MP(mp) &quot;cmp $0, &quot; #mp &quot;; je 1f; lock; 1: &quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>最终实现：</p>
<ul>
<li>lock指令，在多处理器情况下，会加上lock指令，如果是单处理器，就不需要lock指令了。</li>
<li>cmpxchg：是一个汇编指令，在cpu层面实现了cas操作</li>
</ul>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lock cmpxchg <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>硬件：</p>
<p>lock指令在执行后面指令的时候锁定一个北桥信号不采用锁总线的方式</p>
<h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><p>开发Java的这群大佬，总是想方设法的优化Java，其中锁肯定是重中之重。</p>
<p>我们都知道，向内核态申请锁是一个很重量级的操作，必然会影响性能；</p>
<p>所以后来有了CAS；</p>
<p>但是CAS的自旋锁仍然会消耗性能；</p>
<p>所以这群大佬们，又想了一些别的办法：引入了</p>
<ul>
<li>偏向锁</li>
</ul>
<p>至此，Java中的锁就有：偏向锁，轻量级锁（CAS），重量级锁。</p>
<p>那么这些锁之间的关系是什么呢？</p>
<h3 id="锁升级-1"><a href="#锁升级-1" class="headerlink" title="锁升级"></a>锁升级</h3><p>所谓的锁升级，就是从：无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁的变化过程；</p>
<p>我们现在要探究的就是，这个过程是怎么变化的。</p>
<p>在探究变化之前，我们要先知道锁是什么？</p>
<h3 id="锁的本质"><a href="#锁的本质" class="headerlink" title="锁的本质"></a>锁的本质</h3><p>锁的本质：就是实例对象内存布局中 markword 的锁标识位。</p>
<p>synchronized优化的过程和markword息息相关</p>
<p>用markword中最低的三位代表锁状态 其中1位是偏向锁位 2位是普通锁位</p>
<p><strong>markword的实现表</strong></p>
<img src="JUC并发之synchronized.assets/image-20230508150425391.png" alt="image-20230508150425391" style="zoom: 67%;" />

<p>以上实验环境是JDK11，打开就是偏向锁，而JDK8默认对象头是无锁</p>
<h3 id="锁升级过程"><a href="#锁升级过程" class="headerlink" title="锁升级过程"></a>锁升级过程</h3><img src="JUC并发之synchronized.assets/image-20230508223009839.png" alt="image-20230508223009839" style="zoom:80%;" />

<p>以上实验环境是JDK11，打开就是偏向锁，而JDK8默认对象头是无锁</p>
<h4 id="什么是偏向锁"><a href="#什么是偏向锁" class="headerlink" title="什么是偏向锁"></a>什么是偏向锁</h4><p>在无竞争的情况下，只是在 markword 里存储当前线程指针，CAS操作都不做。</p>
<p>为什么要引入偏向锁</p>
<p>这是因为，Java的开发者发现，对于一个同步块来说，在大部分情况下，都是只有一个线程在执行，根本不存在竞争，所以就直接给一个标识位就可以了。</p>
<p>上偏向锁，指的就是，把markword的线程ID改为自己线程ID的过程。</p>
<p>什么时候释放偏向锁</p>
<ul>
<li>偏向锁不会主动释放</li>
<li>当获取偏向锁的线程死亡，偏向锁会释放，此时对象是无锁状态</li>
<li>当有别的线程来竞争偏向锁，此时会升级位轻量级锁，偏向锁也就不存在了。</li>
</ul>
<h4 id="什么是偏向锁未启动-x2F-已启动"><a href="#什么是偏向锁未启动-x2F-已启动" class="headerlink" title="什么是偏向锁未启动&#x2F;已启动"></a>什么是偏向锁未启动&#x2F;已启动</h4><p>是否要开启偏向锁，在JVM中是有一个变量标识的。这个变量的默认是：<strong>开启</strong>。但是是<strong>延迟开启</strong></p>
<p>延迟开启是什么意思？</p>
<p>就是说：在JVM启动的时候，偏向锁默认是没有启动的，经过一定的时间之后，偏向锁才启动。这个时候线程才可以获取偏向锁。那么在偏向锁没有启动的时候，此时线程获取的锁直接就是轻量级锁。</p>
<p>那么一定的时间是指多少时间</p>
<p>默认是4秒，可以通过 <code>-XX:BiasedLockingStartupDelay=0</code> 来进行设置。</p>
<p>为什么要把偏向锁设置为延迟启动</p>
<p>因为在JVM启动的时候有很多内部线程，这些内部线程必然会抢占资源，也就是说这些内部线程必然会将锁升级到轻量级锁甚至重量级锁。既然是必然的，那就没必要在经历一次偏向锁，因为经历一次偏向锁，就会造成偏向锁不断的进行锁撤销和锁升级的操作，效率较低。</p>
<h4 id="什么是匿名偏向"><a href="#什么是匿名偏向" class="headerlink" title="什么是匿名偏向"></a>什么是匿名偏向</h4><p>匿名偏向就是在偏向锁开关开启的情况下，但是此时没有任何线程进入。</p>
<p>表示当前对象没有偏向任何线程。此时匿名偏向的markword标识位是<code>101</code>，和偏向锁的markword标识位是一样的。</p>
<p>换言之：打开偏向锁标识开关，new出来的对象，默认就是一个可偏向匿名对象101；不打开偏向锁标识开关，new出来的对象就是普通对象。</p>
<p>但是它和偏向锁的位移区别就是：偏向锁此时是有线程进入的。匿名偏向此时没有任何线程进入。</p>
<p>匿名偏向只有JDK1.6才有，1.7之后就被移除了。</p>
<p>1.7之后只有偏向锁了。</p>
<h4 id="什么是轻度竞争"><a href="#什么是轻度竞争" class="headerlink" title="什么是轻度竞争"></a>什么是轻度竞争</h4><p>轻度竞争，就是当前有别的线程来抢占锁资源。</p>
<p>比如：目前线程-A拿到了对象O的偏向锁；此时线程B也需要拿对象O的锁，此时就产生了竞争；</p>
<p>既然有竞争，偏向锁就要升级，升级为：轻量级锁。</p>
<p>轻度竞争：表示自旋次数小于10次（1.6之后加入了自适应自旋，这个10次就没用了），或者自旋的线程数小于CPU核数的一半。</p>
<h4 id="什么是轻量级锁"><a href="#什么是轻量级锁" class="headerlink" title="什么是轻量级锁"></a>什么是轻量级锁</h4><p>本质就是CAS；</p>
<p>自旋锁又是什么？</p>
<p>自旋锁就是当前线程在不停的做CAS操作，抢占锁。就相当于在自旋。</p>
<h4 id="什么是重度竞争"><a href="#什么是重度竞争" class="headerlink" title="什么是重度竞争"></a>什么是重度竞争</h4><p>重度竞争是和轻度竞争比较的，只要超过了轻度，就是重度竞争。</p>
<ul>
<li>自旋次数大于10次（1.6之后加入了自适应自旋，这个10次就没用了）</li>
<li>自旋的线程数大于CPU核数的一半</li>
</ul>
<h4 id="什么是重量级锁"><a href="#什么是重量级锁" class="headerlink" title="什么是重量级锁"></a>什么是重量级锁</h4><p>就是想内核态通过0x80申请的锁，向操作系统申请资源，linux mutex , CPU从3级-0级系统调用，线程挂起，进入等待队列，等待操作系统的调度，然后再映射回用户空间</p>
<p>为什么有了轻量级锁（CAS自旋锁）还需要重量级锁</p>
<ul>
<li>CAS自旋锁浪费性能</li>
<li>而重量级锁有一个waitSet，不占用CPU性能</li>
</ul>
<h2 id="锁重入"><a href="#锁重入" class="headerlink" title="锁重入"></a>锁重入</h2><p>synchronized 是一个可重入锁。</p>
<h3 id="什么是可重入"><a href="#什么是可重入" class="headerlink" title="什么是可重入"></a>什么是可重入</h3><p>就是一个线程可以多次获取当前锁；</p>
<p>举个例子</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  <span class="token class-name">Object</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
      <span class="token comment">//do something...</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>synchronized代码快中的代码是可以被多次执行的。也就验证了synchronized的可重入性。</p>
<p>如果不可重入的话，在第二次循环，就阻塞了。</p>
<h3 id="可重入的实现原理"><a href="#可重入的实现原理" class="headerlink" title="可重入的实现原理"></a>可重入的实现原理</h3><p>通过markword的实现表：我这里在拿图拿过来，方便阅读：<a href="#%E9%94%81%E7%9A%84%E6%9C%AC%E8%B4%A8">锁的本质</a></p>
<img src="JUC并发之synchronized.assets/image-20230508150425391.png" alt="image-20230508150425391" style="zoom: 67%;" />

<p>我们可以看到在无锁态下，markword中有31位是表示hashcode的。这里的hashcode是当前对象的identity hashcode；也就是唯一标识当前对象的。</p>
<p>但是当对象变成了偏向锁的时候，hashcode的31位就没有了，取而代之的是54位的线程指针。</p>
<p>这个线程指针是什么？它又指向了什么？</p>
<p>首先我们要知道，一个对象从无锁态变成偏向锁，必然是因为有线程进入，线程进入了，拿到了这个对象的偏向锁。</p>
<p>此时线程就会创建一个LR（Lock Record）放进自己的线程栈中（线程栈是线程私有的）</p>
<p>而markword中这个54位的线程指针，其实是线程的ID，而它指向了当前的线程，就是拿到了这个对象的偏向锁的这个线程；</p>
<p>什么是LR（Lock Record）</p>
<img src="JUC并发之synchronized.assets/image-20230508225623031.png" alt="image-20230508225623031" style="zoom:80%;" />

<ul>
<li>线程在获取偏向锁的时候，会创建一个LockRecord放在自己的栈中；而对象的hashcode就是存在LockRecord中（我们知道hashcode是对象的identity hashcode，唯一标识），这样当前线程就知道锁的是哪个对象了。</li>
<li>当这个线程再次获取该对象锁的时候（此时就是重入），会再次创建一个LockRecord，只不过此时的LockRecord指向的是null；</li>
<li>同样的，在释放锁的时候，就是一个一个出栈。</li>
</ul>
<p>扩展：偏向锁和轻量级锁的hashcode是放在lockRecord中的；重量级锁是放在ObjectMonitor的成员中</p>
<p>扩展：关于epoch: (不重要)</p>
<blockquote>
<p><strong>批量重偏向与批量撤销</strong>渊源：从偏向锁的加锁解锁过程中可看出，当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到safe point时，再将偏向锁撤销为无锁状态或升级为轻量级，会消耗一定的性能，所以在多线程竞争频繁的情况下，偏向锁不仅不能提高性能，还会导致性能下降。于是，就有了批量重偏向与批量撤销的机制。</p>
<p><strong>原理</strong>以class为单位，为每个class维护<strong>解决场景</strong>批量重偏向（bulk rebias）机制是为了解决：一个线程创建了大量对象并执行了初始的同步操作，后来另一个线程也来将这些对象作为锁对象进行操作，这样会导致大量的偏向锁撤销操作。批量撤销（bulk revoke）机制是为了解决：在明显多线程竞争剧烈的场景下使用偏向锁是不合适的。</p>
<p>一个偏向锁撤销计数器，每一次该class的对象发生偏向撤销操作时，该计数器+1，当这个值达到重偏向阈值（默认20）时，JVM就认为该class的偏向锁有问题，因此会进行批量重偏向。每个class对象会有一个对应的epoch字段，每个处于偏向锁状态对象的Mark Word中也有该字段，其初始值为创建该对象时class中的epoch的值。每次发生批量重偏向时，就将该值+1，同时遍历JVM中所有线程的栈，找到该class所有正处于加锁状态的偏向锁，将其epoch字段改为新值。下次获得锁时，发现当前对象的epoch值和class的epoch不相等，那就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过CAS操作将其Mark Word的Thread Id 改成当前线程Id。当达到重偏向阈值后，假设该class计数器继续增长，当其达到批量撤销的阈值后（默认40），JVM就认为该class的使用场景存在多线程竞争，会标记该class为不可偏向，之后，对于该class的锁，直接走轻量级锁的逻辑。</p>
</blockquote>
<h2 id="锁升级和锁重入的小结"><a href="#锁升级和锁重入的小结" class="headerlink" title="锁升级和锁重入的小结"></a>锁升级和锁重入的小结</h2><p>加锁，指的是锁定对象</p>
<p>锁升级的过程</p>
<p>JDK较早的版本 OS的资源 互斥量 用户态 -&gt; 内核态的转换 重量级 效率比较低</p>
<p>现代版本进行了优化</p>
<p>无锁 - 偏向锁 -轻量级锁（自旋锁）-重量级锁</p>
<p>偏向锁 - markword 上记录当前线程指针，下次同一个线程加锁的时候，不需要争用，只需要判断线程指针是否同一个，所以，偏向锁，偏向加锁的第一个线程 。hashCode备份在线程栈上 线程销毁，锁降级为无锁</p>
<p>有争用 - 锁升级为轻量级锁 - 每个线程有自己的LockRecord在自己的线程栈上，用CAS去争用markword的LR的指针，指针指向哪个线程的LR，哪个线程就拥有锁</p>
<p>自旋超过10次，升级为重量级锁 - 如果太多线程自旋 CPU消耗过大，不如升级为重量级锁，进入等待队列（不消耗CPU）-XX:PreBlockSpin</p>
<p>自旋锁在 JDK1.4.2 中引入，使用 -XX:+UseSpinning 来开启。JDK 6 中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p>
<p>自适应自旋锁意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
<p>偏向锁由于有锁撤销的过程revoke，会消耗系统资源，所以，在锁争用特别激烈的时候，用偏向锁未必效率高。还不如直接使用轻量级锁。</p>
<h2 id="synchronized的优化"><a href="#synchronized的优化" class="headerlink" title="synchronized的优化"></a>synchronized的优化</h2><p>在JDK1.6之前，synchronized的实现直接调用ObjectMonitor的enter和exit，这种锁被称之为<strong>重量级锁</strong>。从JDK6开始，HotSpot虚拟机开发团队对Java中的锁进行优化，提升了synchronized的性能。</p>
<p>优化分为两部分：</p>
<p>C1 Compile Level 1 (一级优化)：增加了适应性自旋、轻量级锁和偏向锁等优化策略，</p>
<p>C2 Compile Level 2 (二级优化)：增加了锁消除、锁粗化等优化策略</p>
<h3 id="锁消除-lock-eliminate"><a href="#锁消除-lock-eliminate" class="headerlink" title="锁消除 lock eliminate"></a>锁消除 lock eliminate</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">String</span> str1<span class="token punctuation">,</span><span class="token class-name">String</span> str2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
     <span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们都知道 StringBuffer 是线程安全的，因为它的关键方法都是被 synchronized 修饰过的，但我们看上面这段代码，我们会发现，sb 这个引用只会在 add 方法中使用，不可能被其它线程引用（因为是局部变量，栈私有），因此 sb 是不可能共享的资源，JVM 会自动消除 StringBuffer 对象内部的锁。</p>
<h3 id="锁粗化-lock-coarsening"><a href="#锁粗化-lock-coarsening" class="headerlink" title="锁粗化 lock coarsening"></a>锁粗化 lock coarsening</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
       
       <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
       <span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>
       <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
           sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
           i<span class="token operator">++</span><span class="token punctuation">;</span>
       <span class="token punctuation">&#125;</span>
       <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>JVM 会检测到这样一连串的操作都对同一个对象加锁（while 循环内 100 次执行 append，没有锁粗化的就要进行 100  次加锁&#x2F;解锁），此时 JVM 就会将加锁的范围粗化到这一连串的操作的外部（比如 while 虚幻体外），使得这一连串操作只需要加一次锁即可。</p>
<h3 id="锁降级（不重要）"><a href="#锁降级（不重要）" class="headerlink" title="锁降级（不重要）"></a>锁降级（不重要）</h3><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/63859501">https://www.zhihu.com/question/63859501</a></p>
<p>其实，只被VMThread访问，降级也就没啥意义了。所以可以简单认为锁降级不存在！</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html">http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html</a></p>
</article><div class="tag_share"><div class="post_share"></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%8F%90%E4%BE%9B%E7%9A%84%E9%94%81%E6%8A%80%E6%9C%AF%EF%BC%9Asynchronized%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.</span> <span class="toc-text">Java提供的锁技术：synchronized关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text">synchronized关键字的简单使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">synchronized关键字的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%B1%82%E9%9D%A2"><span class="toc-number">1.2.1.</span> <span class="toc-text">代码层面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E5%B1%82%E9%9D%A2"><span class="toc-number">1.2.2.</span> <span class="toc-text">字节码层面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM%E5%B1%82%E7%BA%A7%EF%BC%88Hotspot%EF%BC%89"><span class="toc-number">1.2.3.</span> <span class="toc-text">JVM层级（Hotspot）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">2.</span> <span class="toc-text">Java实例对象内存布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E4%B8%8E%E5%86%85%E6%A0%B8%E6%80%81"><span class="toc-number">3.</span> <span class="toc-text">用户态与内核态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS"><span class="toc-number">4.</span> <span class="toc-text">CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E7%9A%84ABA%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.</span> <span class="toc-text">CAS的ABA问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E7%9A%84%E5%BE%AA%E7%8E%AF%E6%80%A7%E8%83%BD%E5%BC%80%E9%94%80%E9%97%AE%E9%A2%98"><span class="toc-number">4.2.</span> <span class="toc-text">CAS的循环性能开销问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E7%9A%84%E5%8F%AA%E8%83%BD%E4%BF%9D%E8%AF%81%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98"><span class="toc-number">4.3.</span> <span class="toc-text">CAS的只能保证一个变量的原子操作问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E5%9C%A8JUC%E5%8C%85%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.4.</span> <span class="toc-text">CAS在JUC包的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.5.</span> <span class="toc-text">CAS的底层实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7"><span class="toc-number">5.</span> <span class="toc-text">锁升级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7-1"><span class="toc-number">5.1.</span> <span class="toc-text">锁升级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">5.2.</span> <span class="toc-text">锁的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B"><span class="toc-number">5.3.</span> <span class="toc-text">锁升级过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">5.3.1.</span> <span class="toc-text">什么是偏向锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%81%8F%E5%90%91%E9%94%81%E6%9C%AA%E5%90%AF%E5%8A%A8-x2F-%E5%B7%B2%E5%90%AF%E5%8A%A8"><span class="toc-number">5.3.2.</span> <span class="toc-text">什么是偏向锁未启动&#x2F;已启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8C%BF%E5%90%8D%E5%81%8F%E5%90%91"><span class="toc-number">5.3.3.</span> <span class="toc-text">什么是匿名偏向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%BB%E5%BA%A6%E7%AB%9E%E4%BA%89"><span class="toc-number">5.3.4.</span> <span class="toc-text">什么是轻度竞争</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">5.3.5.</span> <span class="toc-text">什么是轻量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E5%BA%A6%E7%AB%9E%E4%BA%89"><span class="toc-number">5.3.6.</span> <span class="toc-text">什么是重度竞争</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">5.3.7.</span> <span class="toc-text">什么是重量级锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E9%87%8D%E5%85%A5"><span class="toc-number">6.</span> <span class="toc-text">锁重入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E9%87%8D%E5%85%A5"><span class="toc-number">6.1.</span> <span class="toc-text">什么是可重入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">6.2.</span> <span class="toc-text">可重入的实现原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7%E5%92%8C%E9%94%81%E9%87%8D%E5%85%A5%E7%9A%84%E5%B0%8F%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">锁升级和锁重入的小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">8.</span> <span class="toc-text">synchronized的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4-lock-eliminate"><span class="toc-number">8.1.</span> <span class="toc-text">锁消除 lock eliminate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%B2%97%E5%8C%96-lock-coarsening"><span class="toc-number">8.2.</span> <span class="toc-text">锁粗化 lock coarsening</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E9%99%8D%E7%BA%A7%EF%BC%88%E4%B8%8D%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">8.3.</span> <span class="toc-text">锁降级（不重要）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">9.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('/./JUC%E5%B9%B6%E5%8F%91%E4%B9%8Bsynchronized.assets/image-20230529221408433.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 张三</div></div><script src="https://cdn.bootcdn.net/ajax/libs/mermaid/9.4.0/mermaid.min.js"></script></footer></div><div id="rightside"><div id="rightside-config-hide"></div><div id="rightside-config-show"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div></div></body></html>