<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张三平常人</title>
  
  
  <link href="https://zspcer.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://zspcer.gitee.io/"/>
  <updated>2023-05-05T07:52:55.248Z</updated>
  <id>https://zspcer.gitee.io/</id>
  
  <author>
    <name>zspcr</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>时效项目</title>
    <link href="https://zspcer.gitee.io/note/PROJECT/%E6%97%B6%E6%95%88%E9%A1%B9%E7%9B%AE/"/>
    <id>https://zspcer.gitee.io/note/PROJECT/%E6%97%B6%E6%95%88%E9%A1%B9%E7%9B%AE/</id>
    <published>2023-05-05T07:52:55.248Z</published>
    <updated>2023-05-05T07:52:55.248Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="fb410205c8d8bc36c4c738dcd43ee01512f18abbc5c9902405a28a3b4210723e">4481e58e69bf28fe8fa7a8d820fb67f5e9f850618a8149328e1352eb2761e00864c9ec1666d69215c4e379c6b7e75ca12bd43a2b53d49dbb37042b934c1d1ee303226426f53c115ee4a222adbc7481574dbe47d19d8278eb9a761d9389389ddf105ecebdfe154cbe8d5c2cdb6ecdc5d456370f695aec2931ae6f6ca12222a6c9f56f871d46eaf109a6700b1741f1efd9070e77399cda21f77a2380b2670c1c956a4d306fddbe45063ed2d7256580f0bf16f3b6d781612a9e19abf39fc1eb0dc6d0f647ad600908758d8c45320aaf289371a83c17e97200dfb12e80fc58404f22c016cc8acbb665c34c21ed1d10e54134bddb4921e99e05bbdba2bdeb85f6f7b3f80eaa5dbfbf1e7ee89167690b5f3317963e6c61c87e18f9b488eedcf86ed275f8d30a449e33ab175508513208327352db7b95a521f6a82de3720e2ec81959f45fc2007bf5a7315e419b94172530580ff673e1f516e59ca98a42437c5f9faad132f60e663de194876db38bb7286b1c00c875867a1cbe4bb6743e9b1d11830802307e4faf2cd2a5727c28ec0f84e461d86258a74182fe4fe6dbd7d74d3de7d9e43bfc7538965310a7b05676cef9e3ded8e75128f19266cd1092ba8a0020068b13927ff81dc6a0d2bf4a256e8ffc2f496c3b8a7319e0c70933d40ea444bb9e23bb004664e2d8c7a88e4c5fd842dc7a6a356e8f0a319d4bbed7c8510488b65071a6f9466f50d801e01831c92f5619df4b981dc9c79d9aefe77fb48828532b2c8a57e30b65625d12008e927bca5b6bcbd498552e39e31ca53a764ff6d44ed6e543dbcf66441adbe23826b5eceeb7df498d7b9f4dd9352ea693f79b441437b613baddc5a314aca7462fab70510485a17335af466203d0121fb5f6e22ecf4d706c671bae3d56a290a8413aa3d1981c1c9aa6713122580696686e1f74e6fa5c451e19c3d1668118d0596d9b631c1bd95ecdc431fc780d01598a6a314f288cd0f8253f1dc32d8bde5c7862a4aab0b787bf8a0221be4cd1c84057f6c13ebe083894d500b5dd2373344dafd8aef15a56894b7200c86140d4dd4c691efc6cac7111e55b3ae0fd07e7f3bf421d43371d5e758f9346096da77e36651325df9a1d733d16f282fac882a55efe932470e533730e515d21fb87c4c9b5fd3b75feda72e9060437cb77b9d0a6f94d9b41695b7991756353ba00c8c3a3edfa8bd83049d5b03d967c6dfecf24f38bc57c673840cb035fe457744791c7b993a913b3bf3df707ae81848018c3df38797b7f02b9af9df9c4bda46d8ddc37baf2221439d66395bdc0a84ef2dd24de6dcb2057a24d349c8c15151f1c9dba1cc4f0f0f0ebc401c5357986d024e808923c00e77aafa5f0df63f07390acf4dbb5d19d433266b0292f4eaa21d023ea83c7e05b06dce383078b2f622f9553248c5a5eb32d06ff672659b0360277f3e8b877bf9502e66c6988b1603f31b3cd225209762d24ccf906caea6326f89fae4dc46ee0350b4fa9f5028eefb6bf0fd3e2d7449ca38f3075a2fa3ec63604eb5939f5d1f04571eb625776a572e58ee919e567adc0942c2742e0f58f5f885cc4025d61c8afde53f06f432318c186ddca36b969b5365501cb72420c2b5690213aa78255f0001178354ddccfb26138f8c27919accd1fba6963b795cd4fd73f3b3136707c3f299c6d3f25631d614f218b1f0a75646735379c10170347ceadd7c827bd6f37c42f399c1b3d0eb56ac77e1f383b9895c2bfca1634baf7089d34ff816788d601245976030869ee274b7640523cc20d8c25d8ca6a3221987f92d4f28cce7c25f5606439fc891ef4925c2f20a5cf7578820edec7f28937857bc55f25095fdd10915c76c4b60391c2983271d70e981895e536fe72ad972c63151dfb9a5ba0fa88a3434b96af9de165060aa6a51778aa31366d15485c8b3dbe59540ddbc8de17dae233585b003a383e4ae9e0649baa658d7790dd519be71925587b4920e62babbb6fb34bb545cf7463b8d219a20b24a2b079b4725717ace8af4a1a25764a0bf0f6f509be0e2753ed323abe787e6d485df972a4a118f908752c9997506c8574561b985d682fa687862ef3308860603929ec8c70788232b2c3e4e2358161de638e8db6a8232269551ae5dba2563950c798d755c08ef96fd9efc3be2e9f71d8f250aa8fd9129b2841de075ea1706b6de6124a5587fa1443649cb4051d76703e98dccde518a898e0c3e180cb472aea261b49306ac6e539a33b32a51f9f19a9a1fc65121b012decaad54fafba981970947e78746c1024aeeaf4f44abae37eef3c51426c0c146049e29b2d41f82b8351eb6a85ceb690df17c29622f258f00f61c814b85c9ad7304c88649568ae3dccf764fbd60f30e21682924e6b5114aa937b82b834e87ab5a8f427e1c056f528fb5a0f9e11d576d965a263a22cab17924c0ce7ade48e4c4d4affec59c3eaf71f7962f09ad528f79c87a040e5d0b0cc2520157be9554e3e36d0f40092cfce7d56f09c383f80b32a48c744b770f8f5bd0936be45c2fe64d0e78e6c68b2e6d5cd7a4fa2aa9745ebb6136e00f3e5afba61bbca32fe666c703a208432eb17e58718dc01afaaecb5c9bdd5bebd450742af3f81a56f752ba54ece458f2c5c03a1fd13f536a6b8e5bb6f10545ceb4ded56675dd2419af3a2326b9acf8ef913a5a9681a4b80a68e51ee3392b4c42fb7e3fb2cb6d2cd3f56bbe1ba7f9f5477e7e5f9023bfcd7cd6bc5fb573f7baf7bafbbc84015b369e669fd66edf7399a4eab5926f2508367fafe3254d2634c09189cd5d755c798d8fb63e74a74d7364c22b4b3a790f356532b42a297672a5c59586050cfa23f5e89d28724a78148409c52cf345a746ecee33446e717599058a33629ec91f2a799615f0f68cb1e782818b349b92725d53e32e3e2a6e77db90ceada9ed525dcaa67c0fedcc210764a3b757cb4892e6b9a49654f840ba6fe68c988b7baba5de4fc087b6c962803ded6498ff86485d8dc7f364e4738e7b93800f37ecd1c1b194b1fa7a150dab12fc7c574aeb1b3c0c2b3cdd4609883279c6878ca2f6c850396783de9961c5d4e0084768a9dddd68203f8a3e7f46056e8bfd55c0a4da9da67f01de88fa614ed3331ad75379190562bdda30a977a139f72e41b7d532c05a4c137cb9883439650429ce041cb3682c5dd70732023421572c0ad07a9ed0ceca04ef9d2106a1b5995b7dea97f7512e6e31043800fe1bfb02b8b6eac69b65707b4314feb92e861b6d49c29fd8c9bee9091ea1f5d6ea3080d91902805f76ad68b7c86d2bfa5cddb4a9228981aba68a3e3a47084bf2de43bde1b23c7496ee12bf7cd6da789d1a99e527e4fcae6d8d7655bd3289b0dc93d53e07c9d596d92f1eed86a2335cc773bd99a328d9192b189de02338a3a1c4aa49cea5c51486aa9695b6efd5bb82f80061cc2450634311078ef1c9966b54c7f4810221c04aa25f99f8625f5320662c31511808d0dcba9853837fa512c3d5104d3b764785b123941199f496aaf39b4dfaceb5e071f6ec7d4f6c3e9300653298e7bd8c899ea7beb7560626aabf5e8e012c35d71ba0ffb1333c4d7b0d0c39999eec8f59fa0d888220380c66238ab8e39d678bbb889c86c2b930511cd3bf8d69a83726f7b482643ef090168a8a95ae90b39788d823d76811a3275bf16178d1ccae7ee060f88c7772ee2bff9274a6fda0989db4c9377af342b3aaba16d34f66f8582cbedc64dca08e87fddfcb490086a850abd93e53b2f021530b3b7dd44efab8fbc3fecd74ef5ae65505ac963cb508f74166f9f9469ff63b96d57a405d05b6ff709adfb20ef1e6e09d1c0a1c7bfcf83a6a28f28a84bda01723dd1c848527fcb2a6c7ae0a68b266cb5bb2dcdb28b6676fb9cf4b16215c91f9f3966fb0737d0a7b2128c9c6c658cecf5359dde2d8662e3c284a8839ff356ff2b3afd1107bbcffa95f81366a33bcf28af7bbd84b345ccb1dce47a40047568439d77ebb2647788b8ca04f79641c66cab1a5f81e6ac4d827e063a2c3a1cad6bf29191e789858c6202d4bea813ed2e719c1843200e318cb501fda607b3aac1b63c5791da715a882f541200044247bacd2dddcf45fe86054abcea3dac8ca3635d9be60debff73baf9eb97eadca6d0a28adcf7edcc05652b6ffa19ccc0a8441b4b8ba3ec3007b78b5d881a9bdf12547470cb139550881d223df1f9b739b79fba0d0ee028f52e504032cab99ee87fc877bc42dbbaaf9a1c31360671d15e4cc9313ae61112669732087359ae0385e2f35eb0d28345828513be001fb95ab38055c6f544488c45ba318f96de8dd4b7d258220faeb2a2672b911b5d8bf3ff018afb460f594c5f6080c9839f4c71229593917d1fcd8715e2bce98402343f5c35958bb4d8a9a76db8b24dda9aef3c3d749c4eb2698ba66d335be38fa71d72817891664be45d5726ee614df754be26674c3e5680c9eb211f14dd6bc9cb8e0f275f733c4a296bf34a913594d38161bf1ec127ce02c7968c27b9eb037c68f8783c9e9bc9b0604cc749a57c4c0f613537e77603500e40b2cbf89424e4847a1b870e68748324a8c7a7f8de52c56344246abad6ae61548c3c1e2f1b45b85ff9a56ea2908d28abaf733a087bd1943c407ff35bd980b31881bfc7f6e9347f13a8a4752fe65d4d7bb40e9a4a326e894a5397542115a911b6e739ba88ca98e047384fa6ca124aeadb2314dc8e59e873a61312bfdc7eda1b89d74cbcd4e471a430f29b5fc8483c90c20dfc7991d23541b6cf805dd82e09c512d499425301f6ba5292877bb97cf2af7365672f69e50a97a4125e5f4753d61dfe9ede2cdb90273bee863b3a27d76121f51dbdab35e61a6d770a6a08f52f837aae3654d19ad506fc3b181891f707bbde3f05375a28a5a695095e1059e72ccc7a11305272a258131a587141095785b91d241953dac378902da225cd21657775a80614f0ba57e5897deac7e34141225a5734fda98449ee6738004aa054b505cd6a8afe215fe0f4280e9eae13a6e25708a640d77e503901f156f5c294efa03c0a958f9c08537af23407d72315648cc7971fe1185d13534e738dd3902167f15fb62dcab40bc3642e76f67e1ebd15a4be528591663ba4d2a9f01afddce06310f38ade09adad0815c04db14f8dc54465c991119fd897e8b686b3b841e8b20309ee5e84db0ef0c136336025f8a4e9a2bc17f54195dc584af376953bc7ee35d15b4c86235dcee7a09de7c0ea47b980a264c1bfc26ad9dce838d972c84dfca3540107ae7ac2aeab639b2638298558d33af3d0aba16bc1fa6ae05f046141e2c0959fc034acf2e7e18729351b8f0b2884e7b420c2c39fd0008c97975b27ac7e0472b5d8fa7a9e0e3f69b21983e9032721f860baad04e717f8f308a4427bb344534a0f6242c0b447f511c2645864b8a9a659b6a09192293b10b02f9dce674bf425d01e6852793c63c769b224049b2a45b1b6bf53a57900fc5ade87b452affe85a47a1690b9829b98525bfbe232990121b7fb360e94f176dfe142a89dd3a8dbabaee68fdf084ee2895fc88f1fcfa451d8affc3f3b564995964c7a418a0ae9379b38bef8d84f3fa5905af2906aa34434fa12027e685bdd94d0de431a91ded490a868bb2227cad9f4e2ed683b26f6893546ec757a333a602bd5a3370c0c6240d0868dbdc3c952444ae8076fb08a67246c59f862e7c02808d9253f6ea24edc5a91f8a8c8b984d7ad1e3aec4367476abd50f040d887b159d6dec43e14c83a6f9d96f97640f6da06cfeb4f81e11f6623afe11700d8d03bc80730aaa869c3ec81d231e3ff83354baf0d181605e03e5cb2acf85f38961a53c724a5ac968c39c8ae1e11cc95e0ddfc02562e7a80679b9e48bde6a8ef3bd07a9a01d5cc6515a1e9a20336e1406a2223264e1bd71dd2d1d5f23af6a77b19166989c5dc6c7c1919df4729cff03ecaa87631b5c9704aa48d34bd3ab3ee9f6808cefb62150d059cae357e87baa432d32adc00b962edb4d8a3dcbe46cffccf2d23a73f1930eb7c0dc7ea8cc77ff403c7badd411bec0f7da37436ee54d3d3b56044f75f8239a2290426dbf19906c5149b3543c9cb0f5b4ef98a14c92271f0dfd45830a16966c8095947564efb7a9314ec9d04f37beaa66cd15eec4c92ce875d281b03de1dad05dbcba32b24657cb67bd0c6a0102f40473754f4e312cf0f9da09d97c8f2baee1a8b35146bc3203990ec20588b162c8dbb8ca7eee55316ecf3bbafb91b9d016735cc95b7988897c257555af6d1ab64a7a55d2cebabad82b171ced32a2f8397ade3f498dddb43a41cf9954165c74c5ac6751922eaa78218df7f4e328a4055411e0c226041e9503a351cf9026dd097ce30d0862e5c420d40008c0ec0b97ad1353ee18ae5972a946993b7bc94af395d4c91139a7e71809207f9f2cd6f4515b50ff30480eadd465b2969c2c7ab0f23ee7090087cd400b9598152b9930150856731620e56578fa13d3488ee7b137ec0a9b8286d18dfbb9a9d52640d6148761a27899868d043589aab40409248fb7dd76f9c7bf1e306990ffe5541efb1fbd67a17474b91ac1f7bf7ad5075b4e08863aa6ce4ec9afdb8d54114cabe22079a2ac5eb50d441b57ff593105a82938afdcd30da5af851b52e4200017542c1cb49f0e9652cbc416795ae7140963e9b6509f7dc2d55c7ab7610d2dc3b2008ef9585a0e95999361c2e991b5a744450f0f11d012c188e0b596e5ac49f0e8d75a2be9d1f17baf2a4c7eaceabd9d12d1d0be659097adb368cbe24e69e561802ae8eae195c59e875964c0c60d0c0e3d9c3176649059fa5ca2358c11368fae181b065b2a5d7a56a6891ba6c8ebb3c657947406191199b27e52eb15011f45398cb73f1f7d976e736c7a7c0cd3253da7eac2420fd9467f2220d3b2c17e4a6b9f0f66ca8cb8ff1f820cf0fc631cacda42ddd4a3834b919cb14d3789a527f38f02f5425f3b94d4a5120bc8be2db58775a070515fb98e87ad1560aef486dd6865fb5604ce4e0655782c8754d9bb94b5c7bfc1568fd8a69e0332b9ee140b33b3d01b1c233bf22cc534fcea02518d7c508b58a69f5caa939fbd14c34ae6e451040b09c23468fa36267d6cbad7a177a64fb5c97bf12c0869f32fe387cf25ff561cbd2f3ef72395740536c54401721e373e19e918704078a33e89f6d6e180c1fd54d0c6817d1692b4106ad656ccf5b783229f2ea0e73638fb074112f0d4883811d5887d410488e9319e514f9e25f1d1297fb539afaf52fc10d69128d7a65c34f7b18063255a5758bfc8b58d6e2cadac95055f4dc206099e6423f7ff109429a977832b8b07d8cc59402980bb125f1a0ec9716d565466ded221ff95a70d63b5dca1380b65d5b898e888577210fbb21d1bb18515c9d165c5b4e67eba4499be561bdf32f737b4f12d5defb2572694a90b74695e04986be6dcbaa2e53c569cd73b8b3b29ff9f2260f77e71d016dab028eb7597ff16edd21ff7cd291b6d965161a8135c2027bfd1b0b7f9ce8423bd0e6e92ec8321abc66b27d7f02163e7bd4c7daeed4a3f7bc74255a07380312fe7b44fb782078fd5fe8d643282ea19448a015b85f86b99cae75401fb14d5df78a1c315970d93d8a5cd41e4a1f599ac163f4ac71b2553c245e1384cd70b77150d5d443a1b5074707de4113e3cff2854559448af646d0d4f3d70afa50eed6fdb01ec593e15d0a4481937302e7df5442a2042c65c382f5ef1ceda720d86a7b786d72b2634cb48788354d1474ad6b706304086d2d1359dea0e310604d1a626db2bc2598440ed15515d0f1f249a8b20bdf99eb12d8faac25a3f889f31cc899b74f4cb5215275a76f34ae7ec54705786d4b77c9f738632fd71e5a2b52e4e25f55a634dc5fc7e17047bae16b3a9afe27946a9ca584428922dfe47f7d608f4b84f332f1f2219f67e8f246ede24596e19c1066b26aae39754c98b59ca10015e2a881b818f1b73334b7cf0dc885b64855c1d2a8fce2af78dca64fea0b9c7b8e85e9727719866bb3f3690bba75a274f4d5b6e37638de6a49a50dbb8d78e757ed34a66c0f95852ef788f113b42a6dfa28eb8f953d0434344e8ed54d7748e257f2b2f791b802097b1df9614dff6d391ade322704c6c7b21c2a621215449217c452a88cf82de314edbe6ebe8e73a24e1c9600219b7a14553433bfc8c4476eaae76aab3fa62d0fe8209fcf9e0e32b2cdcffe6c37cfe421afd5502ab211d967d6b24df57dea7bb20dbd5fe441971dcc6bbbd9a84a47622db81c2638ed2ff1f5458cd1fb048d9c4eef7d6dd2366c78cec507f9e245a8ae0a2adea69b32f6bda280c8e65a1ab7bef4b0e4fdf3b86bf403b840b06b81a88b9c5e19374c5d75874e00e1d0e5949d0209be375ae0e55a64e6fcda6ef7f29e1841953c1dec57e6ec06ff1980757438f99f6d17e3e8f879ae32810ce05fdf0b4cb59faaf8e85dd4b7c038428cd3c52aeafe58f6290845b44f213831b9fee3f0da1e15e2c58c2eaa6699e570f860aa10387821736737f46c338b7c429b96e690ca55672b9919387b89be62173376ec1cc116b55e2c99080f1c0082624611a49ead43306b2c890038379ad6debac28149f22feb6a07839f74df237344059571abc09f2036cc247c8bfc195da00e6e22066ecf1c0c08b47488298737329c57381328a8cf2e5f9a9ad04e2dd7a412759e342af6eb8b5c89f9433735937113499775d952c0b8b6c03bcd18fdd77b864ab28714f76240e9ee4c37cb241b289bdd0e7597e67f16144c66ea093cc21ae7c94a2b8d7002b63833ce0e266c0e1891027dfd9be40cbf587ed39d5073b1d4719a8009c8a7db83363844d48345c5d48b0f249c41c3c693c32c7bc23deb86f524284c1b2757557aef3741d8afddbebee179a94eef2caa42409a611bb0977331aec02a3dfa60fc2b5483948f15dfeb9634436f16f2b3cd948cb6f4810001e28b9816546f26a710f4dde8f031c518aefe3b2c44a64fadd71402abf200fab99dfe19e1e9627be451a9eaab7ed8f5e4dbb4b03bf7ee721369a4906ee75f8de45419fa45fc8c7ab1e5a97bd0103ce9f94e88576988f6cd2072f61a6b446cd40993d307c26d9af1288fdb542fb8980fa980092c816cc972739de1dff424aaa31f94a484f6895c64b0b2ab241600588ab2ab6932503abcbacce8769901d6167d865a523fef9fb5a4f5ccf24b7b1b27f33048e17e74ca65a2c6eb8cc8eafdaf38d9dbb7c673a69e8d8408612d1ceb58589ae941d005f451ba7f3bd4c66b5b72964cd965ef16b1de971f5e1c1196f519caffb47a9939316a9433f90a0bec24ea875db9033eeea259a3e9e8b0c114c198b9b2593271c6e49a71707569c5dad471f179817fb1fe225f1173ade22eaae6a9700c920a1b315f7e70457fe90090a904ef93a10298a95a1390baf09929882f6f58f64957ef8c14f2e57ab24d1054f1c6f8b9b3a1fded837616ce86aaf41444ba14c7a954c0a874bf02c97106721338ea61369d3859dc0018c03570235f176a5871c273f11b0ad5cd2c8319e8c3106b3364edfc9d9584b3eb7e360f3adc5bbf43c7941bfbf4a3ba8674d3a255e548a11a1a17f11fb0b3b4fc80cffbbfa5bb7163284a05e8b90d1bf8874b9df0188c34590bb313af53515583f225df7747a9ff939189e6073400f7137e9d885b595cbecf1c57e19035aa3be1943890e8d1bdf3ec0ed3668e8184f4fb5e0e2013cddcad9805753262a125b7dc934d0bee2c6de298150259213b12be6bf5aab48bfa0fc2dd9c218abc3c87f88b7b21b3707991bc9f9185414061024c21943bff7faf2a2b8330980955b02dd828eee74a1d79a8d627729a4651880497f1a4f38b711d89a30f3f0b7ea5c58221020f47d94779089f3c5bfd750f6a3d3ab27bda5e58cb1cc7e3d0172c1c7f83bcbe634f0106593c412211ec1ac30b261c0bc3573c3c191a5dd597477a5bc17e6e62c5edd660d01fb6018e976d5e936238e2453e37d5a2369ea33a307df861707d90772a2dfd683eb920ebf6afbe36a55e934fdaa52c77492973346d21b77954aa792cd397b37b54040bb7b682eac92d3b2e46ea95fa26462b6a411bac8914b6304b41620abf97ad2878716149aec90e970d8a1f65fbabc1ce80be66089ee49a9ddda8c23b17ad155fe23355c7a8757a8dcc1051bfca4dcc522a18e727524a8aa82de717b2c8c518293ab8471adb4233f3054c6d9613315530c42231aa951c7302c2185eec9df6737e15047c487669b6d0de920db3de408bdd27029ba26ef965ad478349c30923484db3d7e598d7061a21fc9a0227af4cc04443c7bc5c52c9d058617e9c629234257e3f730a183aa41af3c906521151e1a413836d0d35b8d956ae783cf86194ceed8f8b5bbf14291397ec6956a147013b0d4c3cff9b1fe347e51a30e2d9446c9f95cb89d6ffa04f941c12ab73dd99df352edd093826fefced6b279ce226ace8eab0654c194bcfbf48631314cd3f3145cc2f1fab99704ff82a28e03803d98dcd557456ec4703989a5c7bae47656c2a01600d995168ba4b57391b9dc26f4d3112ba0ed80c5134958a734fda0421e78286315637106ced68ea6109064e94a6e28d5fe8981973a84e9e6d467b93929da288500fee0c0bb19c8f13ae4a6e45c07d89d3e491ed43ddb478b116146319c71a6f89ab12dbb8d402b4bf11df6f01b31530adc514468c08640ff03a7f95c6c00291dd18cd148d5b49e23234cd24495fc0d8cd90c801b67efb875d9618a622b8f4e2053d51a09d2e27716ca0066da0a72e5a64c8375aaef3b0bafab7e01845adf05b1adab22172210eff833bb758fba54ce3d16f36b9dd82c2db32074a48824848ba0a19160570497ef0b7f31c5a335c396b6697d44ae4c870e17679201c9af1a5181c34d05f705e6aff2bd82752fab70561a2020a92fc8c28964e3bde75fb5b3052e2fce4f2d6f40adc7ac558560a979a4429a0cd5f2aa25145852c7475a701b4f799ed9117592f93cd7d50f12f5ef8b4b1b37c857c84fe176580f90683936f375ff88464424ab63dc9215ab6f5de52d1cb0fb90beb8fd5441c1527644e2a45d567bde2b5830a2c236b88c501e1f9b65f1ad1e41d6c8050da3a7cdce54cab9fb4553cf1986c9df3375923732a8977e4be7a532a79b90ef99e84a4f77a8dc231a1b35d2dd84c9c2d45c2a80e67de0af6707cead7e577678021d07e038edfe44b6be3c406a56c4f1c903dabc9855cdc4136f900da2686432e85e7ec2a395d87e1ad8de94d8025716d72cb9a024355d4f58fed32fc591b5b3fa537cc2aac736b8d5d489606f74664f6a0df2aa0501a517dfb97ef02aab51487321e840cd9b95ca7e0adbc331eec09025895e163798309e53862e9b741987e3bbbf7dfa1ec0ff4720da6e0c2f96ace827a07974dae2b838510a8a35d2e28d741d8d6a04e07210873d3707c77f0cab52a2c4f0b58c47a4a3f34a146558d781360eab9f023bb13d4a10624d4649c01f7de840f6339a79c0e12b95cf730f7225ac1ca7f551dc632af81afe1e4c700b7e8534f2c9394fc5a65ecf9d2796e1c54a6321edafc3a0c374e50d64af5532afe06d1cc52638d0c85d4ecaafc29f63e8ab7466e9cea6ea9f01e47a6a7c4214446245233703c4455d158577c7fe73373263ced5102f75dc66d71514148b05274607a544a205dff1308bf5db24e3127b20ec1f6fa2f0f1cce6d444338c2abffb4eb4d4d67e1b6908c608e20957e532e2951366ca0bf3ef020b07999da515509fd45f4cd310c1e488161cd8fcbc9d0c49bb11c1bf3df7ee43d40db446d0c8832d4fa3c300104e6320af1e793a8664c9bfd67364d7842e4d14f5138ed613e58dc1bbec10c7331166307074bc79219feb9b8f274bc328f6349d29ff7bcd1119197af17ede3d2f0d51f50ce58b80cad0b40ae9d1cbf8c18a2eb6bd50a0da1893a319ce3b26db347a8a440aa5e6a114b0379ad0e897627e554aca108f077ddd88c17b2760ea2a39ff1dd134c87247568657eed4ddee7c103242ba6befdaecb3e6073bce88b30de40873c9108cac78432540615ba79b1baf23a39e3aa1a24d78f486cf6e07ceb48b6fdbba55480c3402cdf8fc5de4cd1c08f4cc4172fca7955cb7000edb25af5238c199fd027ad103dc5b2d91eedc6b6968482bdad4fcfde729781d0cb0cbc04892f8f2af44fc51772c3e1ea99ac69d06525196e0c3631bd704fa854996898711ae168a3450ac28d7959be0ce9d610dc87733100868fc4b19f0449f67c304651ec26e3c24792ddb39777023d39d914190c11879c53c5828d3ffa64672b56cdc6efb3a447afd67fca2f8c620220a7288ae389ab320173f4547a9be1a8f6fd5384606fdf75b21aa2a3ebdabb51dcdfcd18ab646cc8a38584bab7582c094398e096e789998d96783f3aaf59946010f6b3986859571ddf6a31ebe3d079a8382c88a03ce5f572d459fbc54ff18c67b0e6c25c32e9003649709f5b7b024daca6f8a482b294c69c69542b54a4385f689384578ef97592609de55acc9c1c0d854fcdff871079a7f1f8a691be9595f5c9f642771b31cd72916132fb256a2348efa1d25ae90416820a5b0145b6203a0c3ca94369e539eed044325cd1a09b77de4cf03f9e74858c2c5a9b9bad9d9200c71072a5709018fb38f510705c070544449f10f6210e23c3bb0fe5a86f855abb7ffb2de3d8c7b7b38962600b3d7b68b8068a2699a8c035bdb11fd06f4086ae284070df361fea816d5fa3121e6b7b813b0720dee6147dbc5f749928f9d6045cc246e1990a23e90c912c5490912134fbb437c72afcd403eba9175236d2a52fcc104dc5dd7f4d3aba36f6c4acc85b8ed703241438c974733b91e19a83e3e54d09017f67bcd9714ef0846253d3baeb98c62e72b1846e0122816f42f56599491c1d4ce6e81f0a5cf8f7fdd1dec066212baa0dc190f2da01a4b4a595ca70f258802a1af97ab760931f130c607fa0928fc9aa419563cfa760b051e828a2bc9e094cd9a4c53c73132b84751ba4fae52cdc87b22014cd894d2898f224a1bb8d9de887a294e802b4c5162ba79eee14e27280fa59db43ebada6013d6c53add2dd4984a2100204ec03dd4987e96c6043e4aa3f77b68be5705ba0b280d689c2a441f1770593e1bdf4759fcd30658e4d2e06c74b04872f414888a67cb33df331134a0699365639fb3aec0c84195d63161ebc2183fd77603a7b1e890557fadc1183d947fa6141e07c64526b4ba2a41b1e20b8e1a28915d7d6c4dec73012b3c77a7274a61a42d897a116a04bc5fe44f61aaba758ff6df59707fff5d75ea96b17b66827aff5c7c6931532d13b581f75f14e8864e11dc0874df3ff01a3b97875b96a791682e5c17f123b371678d759e4ac37324511bde39fd768227dbf69516cac37a02a4896226d3946e9c7c0bc1e1d4988ea9ed6f17cd95758b54948a47383ac82fe6034943736636e36d30ce66210ce71067cd7a18b4768be7a13bf9d2490f7b0bc00bd5a43b06c0b5f1068c4acc99a3e3d4fc7f9a93939e960ebcb689dc7043c1ac2d21928a0cca5340869bd24b1808a99ecb1a3b7eac9bb57b667b30e20bdcb4f70dc9f80870d862ed810dc7d24652d21812574ccbe593640403eccd0f792dbf95093781fd2825cf6e2ee64268fb37fc032a9decb1cb45054f705222c40db447389dfe26423c717f6b3b13b65a235da0cc51abb01d5b31113482c5ade155d65436c0e3436c9866c2410cd7d2b04c6d3e4b32e05571d4d429890d8744319464024c6faeb188c4186f618762d15a1a7727827d694c048f34090903244e226b491c87931af13948fbf99fac3088bb12ab3db8f4d0df9c6d08f587abd82bbb97882ffa810b37d0260a4b17273df5ee484a407b499d987728c496371947f3d75127545ebbee72ddac81c87f553bda240131b8163d3c752bd8188a2fe7257c939ecb9f580b16c5c29132133e8e9eec9accc7e2cb269a004fae0a8020844f6e3d96207b9e92e425822db3f3a760af5ff6c3958965da0be71817d4d5d7a038484928b863f6693f567344bfee5003b59ebb4077c6d72514ad660a4e7479f4c927c6fac54671286838579bbc4c6dcdf2720f1802f68c3ff7c4bf9de0c798959d328eac9b20c9b5e2c277d00367baea7fae20d3934ff18b86a9962ec1f5f709e3ecf0c478c2d530184557672d53afe814c38bb8ac4c32a05c3d557f156b203851627742b970a881d80a0451b3be53c23179eab2c86b43b9ed8da3d224cc241107c92dbce622f4fabdd10a65fa7f75e8410eefe99cbb49cbac2a79586df414983a6caa069fc4a2b681d531ba2504a7c4499e2d830ee980f7b087f63101fb862e945730581505349d0c1d7c1ba16490ec607b85e09624fcb6481eacd05c3d49642f5af013c83342a7686745057c77ecc25083bcc93fbdad592a86934d01777ae9a9a22e29743c9fcdc6d2db47473201110218e842383c97d22e4cbc49236166a25c306feb7443181d66d30494a19eae2e505cb0e2f71b6c74ac30b7c4aab4f33b840c6c0b763e90db2e40e9766fb87688cd134cf7ba8717e0aab22325d452a204b57f298ee95bef4a2e8886edfb4d29e81749b7b7843765492ab274a0c0cbbda9add6b3003d4a47b3ae15b084d4b497a1cad8ae69fed4087e3717cdae98334a8ffd4049031779b35dc5dd5b631394da28414b45dcb359175212cb47fcbd300fb9874338109e5cbfd323ba504343a5071d38af04daf352f30d78574626273d65f6a181141408370add62482000383b1d58d5a76d5f6eb2018caeee9ac8c44d1bb416f2343b3b3aa22d5e9a74c2e7fc83cecae08c5af457cd6cedf233764bf0b2133a71f619d7574a9156f7e4184cd4caf53446bb81734f901a75e3afcb31fa4f45612d044c4c236393e04c16943ad6142b3bd4b6be16cac30862510132c828b33a19d90d0fd0e9da16d388e2df0a60eacb7b7d07c3f8ae52090ef0c4212286f871b2e769d1dde3afeac1c5ec0ea275e5939c2edb533c802c809d572bbbc5b30c79886c6a1d45fcf4a84f5112f012dec342aaa7a856a00949a73aa05fb23ca049d583ac9d72a662a0540feb15a8b76a5e28ffda929e8ee4f85d222c28cdc76945ae9386a20c3431a8d27be70c57b6a7f4cac469327a9f0c89e8bdd73544e6045a363b5450bc0376d282fc525b9a97eb745421fbdd41d7d52e84b6064d6d1f11c2f6380afdba3bb827527954e7f860570f58087f09771b21ae5962d9293862265d2b8b74a42afbd0c11d480f8dd04bc90a12ab4936cb98b9f6bf02076837a23fbddd0531f44ecf1438b3998cdfd99ea5eeb4a40164f2b3235bcdfc3dd6a1b33dfbcf4745db2e9a741338e776638d19dc8f41a1d0f79e909408ccb14af9ae2258fb1e262c5bc580bc62537e0bf64c1d107c7e1426a0fda69d2dbdd3ccca0dcee43c51ba3d3d00047d8089623ff8252b7c5be66a28cc73249096689168a9492852f3dd887bb6b3b3df8db596b6c4ad9ae41af69a617bd345a7b28a4ce9b5c3c1d036534c9d061cfe4516b6c6f4dfce94240d424ab8f941782c3a4bda7d738bdff2eda9e3641735ff9179c21ba862f5d8d273af1c2439b4b4fdbd7ce509c856e6ea3593968205f0e20bba843810a63031af6e352061cf98dcec0fbac328d385fb74b4ac79e9d6e0de74f8a551677c017a1acc00051f50ae61f21950778839fe831d94d47fb6f2bf2b7f077e49cb9db32fc719e68e42f2e4bb4d10caab4190b0e98dadfe5f25896b88c5bfd60c1b2f71b5735a22a8d3d9be2caa3ce54b60be066ab6c836c22db7c1895a7cc8ae80081a86821ecf1346b50f2a2e504fdcb7a06a7ab2a6a5b7eb8c5cce02bee8219c5b0e95832d86f25d2794e00d2368a160c9510c32b6b27dd6251ab1b18df503ff0d330e8013c68df1d03393cd9c1e0c501c1aeb402ebfc1b7f953abe893e0871a0eb2e5532466d4b73a3bec2ca9040c2007b9e405b8bf7b759f27aab3247183acd76a702ab5c43ab3b693fe54076c282867eab5d8e00f4e9e00e2e6ba43d95730d966e794782dff11b719dce54bcd0b078b53bc542ee0edc1899d9d48109c2495518690d382b263a864fe369b9ba6bb36af7d5186616c52d50ed87fdc4b7f3c9db65a9d1d1f15b7fae6033b4cf2016e4fb344202b7cb5715354b1f4604173eeb2c9a1212bd43130b4c77e668fad076bd3a3983cfa97a867991e7878144b3be8e1118ccba3e6c70ae71b72a2f3e38db1dfd5e9b670b816a59e94517268895dabc8071c8e589ecae28191adff0cdd6a01be6ed13a9f32e93214fa580c0c1688d5cb33a414c1630f8cf28c12d4605fed1e584e7f971c7141c114466af14bfbdff174024a7296fc43b4bc14369b07e2eaca5cf4f7a3c9539240b875d458ca2f2d0c5d958d25c32855da58f8bc75f6819760a471f093a2a66ff2e1efdecb1eb2f60fcad460c96ec44f522080df5bd437ec754ad24f6c37cc0f4e593928d6b3c3a6ec679fd17d33eacbab4dcf45033fa14f92ef52f0f89aace41a12a30d3c00ece3cbcb8dc72a39c6d7c778c847db84d33c6d735a714b3e170fb9f4bc87a3fa0ada4889ae17aea0f5d1d201f5c5727f6726e855c465558fd4ab1ca158099453a2f72f3fc07e80080b1847e996f36583b8790f3293f41548d39a6aa6f969780e3e523855e62057d13986f906b4f8cf639dd83deb7917bba05521e9e13180635bf95e4fe7e63a9985a126cd9045662d273416906ed9bf65d404a730c6f9a304846dc68e742a34cd64ff9e399c3a345050c2462d85648c1b6e5f7b78aeb1f2130218ff3b5c5ca5a66e3f9f65375196b9a441153f96aa04aa284030573575a4d8b8912d1a37aa0d50fdde7df5572d75e0cebe6fc98ae5ce6e75e01136d72db2963c7a6c3ae82feada210ddc1f5d7d122fe81d4e9a498d5758ea61d5afd60ebd26e71c99950cef254eaac57443c82ca265d6afcdf05099561373d277c25623b99ca4ae4a126da4474eb0af858d99fdecac517580f0e96da71a13655d6861aa96bedfc0ec3c10793e4636f78a52a429c2e505aabfb8ff61dda7b7f878b84252b8e9e98915e9d6fc74e233c8db332266522df34103aadd69e1e3c1a48f8a778be29218582e6fc31c297c9af80bfe4875319ed8b7207157a829b0f23847fd7d305578f54c1b063ccc25b7b2f5f96f82b969bf89c5c11ce3ccd1e7508f5d21441036e7225c9f7799f13651d49bce51eb38e567fd4c278f9355bd2bd8db9933183ef78b536b20443576adb8b3b337e83f0c95ac710bd6161a923ac72a1b06ed53462e3807b3778af0001a2ccd5a9a7b1c01f1bbd09e64a037058e7c737045479b0ec9df5e34789a4422125de203659cf501b4444f7a38055660ccde5a623e4633735d6c1d206af11a973fd285012f95c0955fa5d357c410672d7c8bd20aaa1c09b750717127d0b4e685b34f6170cac693241372411d588db4c71c7285c24281128476a9bd884543772781fd3ef571991b34e417409edbe42cd1c423a89240c644005f1287fa085ed5d9df350bc4ee4c50e75afd78f5f4aae61db19e9045dc8d57f34cb5b9d8467e4dc55debbbfa691be2812962632696725a8c49eb28c32c702e4901f4a4b56519275d55aa4f2446a3df29554a12d66e224150a9c0ede80a3a10dd9b49856d423030b7059e547d25d26ee5ffd789e31a1008fc3458fb16234188859cebdc5387078b963139937eb9998e8e0dfac968f46ff03b5b0d5b912537429c827fb0bcbcba178e4e1971b6a2924ea9de75ff2dea1cf4cae2d70e53800b29dc4362933912950c3927d9e78a21b586b98133e7ebe99893fdcf8ebd89329973ed5da603cc8ed03a78d291ac689df054f70073006d4382b731bc54826d5490897dac18b09b658ac6e076f6d639125a49be8e932862e04a86c3c62267f10515772685299e07c364273c26b5211650bcc65c97a89dd757a2c043cb8f5d9d3b09b1798ddbe4d8b70247e856f2324cf33968059ee5738d240e6ead9643a3facdb2ee7317c8bf2bc369cdda5f86cd26f39fed5bc8edae172fd2fd6b09e13fc0db9c84fa6c8fdadab079c442562cdc9399412d2cf0dcdcb6c997597ce09f46135a7d8baf79e1d83a759573fa67d52dbbd80968052f6e4b8c8a5a042486d2c9d0063e90d58ad25d3bd11d2a1eb3372d7ea85b2cf4e307e3dd057a6869a78fb641c5244e272eb9a711b060dc94cffe24702c9a5544bf48653441bd91a3af239143f927861a305672e4530333e4815f73848ee2bc07eab8f9521828127772ff233045219a4f482f64a01f4e7494e011b3e152a4cbc568d79841f8096298a8145ded99e875a90ef97738a52598b9a673306ea757d420fa2c7cad404af85ff497276a7cce47dfd948df6498f1b25d725dd192bb30bd382bda0be3020c4e2e9011e8dd508cb24db959b07434904a0eefdf56d5207e481e364ca07c8aced35a1734ae87202358b181d09d5f556128ec7d4e8bfe4ca0b88d26964c10c44347bbb8eb447d2719a4bb4eb8c45b1b531ef9bfdebf32a1ca393e5a5ee25dec4fff22c89e27af4a87d52c62cb4570c6a2a4d41470261610f55c27673c12fc624df96533623e15b7eb155e243e95450a605e3dd2a2cbce0ed49f3fa390a98cc9d7f8bafc65f5b34cb8f2758b6e7e0efe932ba66ea15f8b0049702ce173a8cb408b14ecbd8d9e4f986c746cc6d0b1f181b23decc68e89d84433d9a59a8f0d32a51881766f0d98f698b9b410cccf995146bf99b743c85e2937f18dceb6cc787eff8a4cd54a3bc716d5d33</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">有东西被加密了, 请输入密码查看.</summary>
    
    
    
    <category term="PROJECT" scheme="https://zspcer.gitee.io/categories/PROJECT/"/>
    
    
    <category term="项目" scheme="https://zspcer.gitee.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="时效" scheme="https://zspcer.gitee.io/tags/%E6%97%B6%E6%95%88/"/>
    
  </entry>
  
  <entry>
    <title>考研单词</title>
    <link href="https://zspcer.gitee.io/note/MYSELF/%E8%80%83%E7%A0%94%E5%8D%95%E8%AF%8D/"/>
    <id>https://zspcer.gitee.io/note/MYSELF/%E8%80%83%E7%A0%94%E5%8D%95%E8%AF%8D/</id>
    <published>2023-05-05T07:52:54.949Z</published>
    <updated>2023-05-05T07:52:54.949Z</updated>
    
    <content type="html"><![CDATA[<h2 id="后缀"><a href="#后缀" class="headerlink" title="后缀"></a>后缀</h2><ul><li>后缀一般只表：词性</li></ul><table><thead><tr><th>后缀</th><th>含义</th><th>例子</th></tr></thead><tbody><tr><td>ion，tion，sion，ation，ition</td><td>n</td><td>action（活动）</td></tr><tr><td>ive，tive，sive，ative，stive</td><td>adj，n</td><td>active（积极的）</td></tr><tr><td>ate</td><td>v，n，adj</td><td>create（创造）；private（私人的）</td></tr><tr><td>ury，ure</td><td>n</td><td>century（世纪）;creature（创造物）</td></tr><tr><td>ence，ance</td><td>n</td><td>confidence（自信）</td></tr><tr><td>al</td><td>adj,n</td><td>animal（动物）personal（个人的）</td></tr><tr><td>ify，ize</td><td>v</td><td>表使动； identify（识别，认出）</td></tr><tr><td>able，ible</td><td>adj</td><td>durable（持久的）</td></tr><tr><td>ty，ity，ety</td><td>n</td><td>responsibility (责任)</td></tr><tr><td>ic</td><td>adj</td><td>basic（基础的）</td></tr><tr><td>ous</td><td>adj</td><td>famous（著名的）</td></tr><tr><td>ish</td><td>adj，v</td><td>foolish（愚蠢的），abolish (废除)</td></tr><tr><td>ia</td><td>n</td><td>media（媒体）</td></tr><tr><td>ent</td><td>adj，n，v</td><td>different（不同的），environment（环境），prevent（防止）</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>前缀</p><ul><li>表方向</li><li>表词性</li></ul><table><thead><tr><th>前缀</th><th>含义</th><th>例子</th></tr></thead><tbody><tr><td>a+辅音（除了ab外）</td><td>表加强to</td><td></td></tr><tr><td>ab</td><td>表否定</td><td></td></tr><tr><td>e+辅音（除了em，en）</td><td>表方向：外</td><td></td></tr><tr><td>em，en</td><td>使动用法</td><td></td></tr><tr><td>co，com，con，col，cor</td><td>表：全部，都</td><td></td></tr><tr><td>de</td><td>表方向：下</td><td></td></tr><tr><td>sub，sup，suf</td><td>表方向：下</td><td></td></tr><tr><td>under</td><td>表方向：下</td><td></td></tr><tr><td>re</td><td>表方向：后<br />表性质：again and again</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="DAY01"><a href="#DAY01" class="headerlink" title="DAY01"></a>DAY01</h2><table><thead><tr><th>单词</th><th>翻译</th></tr></thead><tbody><tr><td>enable</td><td></td></tr><tr><td>disable</td><td></td></tr><tr><td></td><td></td></tr><tr><td>abolish</td><td></td></tr><tr><td>abuse</td><td></td></tr><tr><td>absurd</td><td></td></tr><tr><td></td><td></td></tr><tr><td>academy</td><td></td></tr><tr><td>academic</td><td></td></tr><tr><td></td><td></td></tr><tr><td>action</td><td></td></tr><tr><td>activity</td><td></td></tr><tr><td>active</td><td></td></tr><tr><td>activate</td><td></td></tr><tr><td>actual</td><td></td></tr><tr><td>react</td><td></td></tr><tr><td>exact</td><td></td></tr><tr><td>interact</td><td></td></tr><tr><td>transaction</td><td></td></tr><tr><td>enact</td><td></td></tr><tr><td>agent</td><td></td></tr><tr><td>agency</td><td></td></tr><tr><td>agenda</td><td></td></tr><tr><td>agitate</td><td></td></tr><tr><td>agony</td><td></td></tr><tr><td></td><td></td></tr><tr><td>acute</td><td></td></tr><tr><td>massacre</td><td></td></tr><tr><td></td><td></td></tr><tr><td>add</td><td></td></tr><tr><td>addition</td><td></td></tr><tr><td></td><td></td></tr><tr><td>aerial</td><td></td></tr><tr><td>aerospace</td><td></td></tr><tr><td>airline</td><td></td></tr><tr><td>airport</td><td></td></tr><tr><td></td><td></td></tr><tr><td>alarm</td><td></td></tr><tr><td>alert</td><td></td></tr><tr><td>ally</td><td></td></tr><tr><td>coalition</td><td></td></tr><tr><td></td><td></td></tr><tr><td>alter</td><td></td></tr><tr><td>alternate</td><td></td></tr><tr><td>alternative</td><td></td></tr><tr><td></td><td></td></tr><tr><td>ancient</td><td></td></tr><tr><td>ancestor</td><td></td></tr><tr><td></td><td></td></tr><tr><td>annual</td><td></td></tr><tr><td>millennial</td><td></td></tr><tr><td></td><td></td></tr><tr><td>augment</td><td></td></tr><tr><td>auction</td><td></td></tr><tr><td></td><td></td></tr><tr><td>audio</td><td></td></tr><tr><td>audience</td><td></td></tr><tr><td>audit</td><td></td></tr><tr><td>aural</td><td></td></tr></tbody></table><h2 id="DAY02"><a href="#DAY02" class="headerlink" title="DAY02"></a>DAY02</h2><table><thead><tr><th>单词</th><th>翻译</th></tr></thead><tbody><tr><td>author</td><td></td></tr><tr><td>authority</td><td></td></tr><tr><td>authorize</td><td></td></tr><tr><td>authentic</td><td></td></tr><tr><td></td><td></td></tr><tr><td>abandon</td><td></td></tr><tr><td>abide</td><td></td></tr><tr><td>accompany</td><td></td></tr><tr><td>accuse</td><td></td></tr><tr><td>accustomed</td><td></td></tr><tr><td>acknowledged</td><td></td></tr><tr><td>acquaintance</td><td></td></tr><tr><td>address</td><td></td></tr><tr><td>admire</td><td></td></tr><tr><td>afford</td><td></td></tr><tr><td>amuse</td><td></td></tr><tr><td>annoy</td><td></td></tr><tr><td>appoint</td><td></td></tr><tr><td>approach</td><td></td></tr><tr><td>appropriate</td><td></td></tr><tr><td>arrest</td><td></td></tr><tr><td>assault</td><td></td></tr><tr><td>asset</td><td></td></tr><tr><td>assess</td><td></td></tr><tr><td>astonishing</td><td></td></tr><tr><td>awaken</td><td></td></tr><tr><td></td><td></td></tr><tr><td>abdomen</td><td></td></tr><tr><td>arbitrary</td><td></td></tr><tr><td>advisable</td><td></td></tr><tr><td>algorithm</td><td></td></tr><tr><td>alien</td><td></td></tr><tr><td>ambition</td><td></td></tr><tr><td>ample</td><td></td></tr><tr><td>anxious</td><td></td></tr><tr><td>apparent</td><td></td></tr><tr><td>awkward</td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="DAY03"><a href="#DAY03" class="headerlink" title="DAY03"></a>DAY03</h2><table><thead><tr><th>单词</th><th>翻译</th></tr></thead><tbody><tr><td>backdrop</td><td></td></tr><tr><td>backfire</td><td></td></tr><tr><td>background</td><td></td></tr><tr><td>setback</td><td></td></tr><tr><td>feedback</td><td></td></tr><tr><td></td><td></td></tr><tr><td>band</td><td></td></tr><tr><td>bind</td><td></td></tr><tr><td>bond</td><td></td></tr><tr><td>bonus</td><td></td></tr><tr><td>bound</td><td></td></tr><tr><td>boundary</td><td></td></tr><tr><td>abound</td><td></td></tr><tr><td>abundant</td><td></td></tr><tr><td>combine</td><td></td></tr><tr><td></td><td></td></tr><tr><td>base</td><td></td></tr><tr><td>basis</td><td></td></tr><tr><td>basic</td><td></td></tr><tr><td></td><td></td></tr><tr><td>battle</td><td></td></tr><tr><td>combat</td><td></td></tr><tr><td>battery</td><td></td></tr><tr><td>debate</td><td></td></tr><tr><td>bet</td><td></td></tr><tr><td></td><td></td></tr><tr><td>behalf</td><td></td></tr><tr><td>beneath</td><td></td></tr><tr><td>betray</td><td></td></tr><tr><td>behave</td><td></td></tr><tr><td>behaviour</td><td></td></tr><tr><td>bewilder</td><td></td></tr><tr><td></td><td></td></tr><tr><td>bilingual</td><td></td></tr><tr><td>ambiguous</td><td></td></tr><tr><td></td><td></td></tr><tr><td>blunt</td><td></td></tr><tr><td>blunder</td><td></td></tr><tr><td></td><td></td></tr><tr><td>board</td><td></td></tr><tr><td>aboard</td><td></td></tr><tr><td>broad</td><td></td></tr><tr><td>abroad</td><td></td></tr><tr><td></td><td></td></tr><tr><td>boast</td><td></td></tr><tr><td>boost</td><td></td></tr><tr><td></td><td></td></tr><tr><td>bureau</td><td></td></tr><tr><td>bureaucracy</td><td></td></tr><tr><td></td><td></td></tr><tr><td>bachelor</td><td></td></tr><tr><td>balance</td><td></td></tr><tr><td>bargain</td><td></td></tr><tr><td>barrier</td><td></td></tr><tr><td>benefit</td><td></td></tr><tr><td>bill</td><td></td></tr><tr><td>bizarre</td><td></td></tr><tr><td>bleak</td><td></td></tr><tr><td>boil</td><td></td></tr><tr><td>bold</td><td></td></tr><tr><td>boom</td><td></td></tr><tr><td>doom</td><td></td></tr><tr><td>boycott</td><td></td></tr><tr><td>brevity</td><td></td></tr><tr><td>Brexit</td><td></td></tr><tr><td>bribe</td><td></td></tr><tr><td>bulk</td><td></td></tr><tr><td>burden</td><td></td></tr></tbody></table><h2 id="DAY04"><a href="#DAY04" class="headerlink" title="DAY04"></a>DAY04</h2><table><thead><tr><th>单词</th><th>翻译</th></tr></thead><tbody><tr><td>scale</td><td></td></tr><tr><td>sculpture</td><td></td></tr><tr><td></td><td></td></tr><tr><td>camp</td><td></td></tr><tr><td>campaign</td><td></td></tr><tr><td>campus</td><td></td></tr><tr><td>chamber</td><td></td></tr><tr><td></td><td></td></tr><tr><td>capable</td><td></td></tr><tr><td>capital</td><td></td></tr><tr><td>capture</td><td></td></tr><tr><td>captive</td><td></td></tr><tr><td>captivate</td><td></td></tr><tr><td>capacity</td><td></td></tr><tr><td>escape</td><td></td></tr><tr><td>participate</td><td></td></tr><tr><td>anticipate</td><td></td></tr><tr><td>discipline</td><td></td></tr><tr><td>occupy</td><td></td></tr><tr><td></td><td></td></tr><tr><td>career</td><td></td></tr><tr><td>carpet</td><td></td></tr><tr><td>care</td><td></td></tr><tr><td>scare</td><td></td></tr><tr><td>caress</td><td></td></tr><tr><td>charity</td><td></td></tr><tr><td>cherish</td><td></td></tr><tr><td>concern</td><td></td></tr><tr><td>discern</td><td></td></tr><tr><td>curious</td><td></td></tr><tr><td></td><td></td></tr><tr><td>caution</td><td></td></tr><tr><td>precaution</td><td></td></tr><tr><td></td><td></td></tr><tr><td>proceed</td><td></td></tr><tr><td>process</td><td></td></tr><tr><td>procedure</td><td></td></tr><tr><td>precede</td><td></td></tr><tr><td>precedent</td><td></td></tr><tr><td>predecessor</td><td></td></tr><tr><td>recession</td><td></td></tr><tr><td>succeed</td><td></td></tr><tr><td>success</td><td></td></tr><tr><td>succession</td><td></td></tr><tr><td>succcessor</td><td></td></tr><tr><td>exceed</td><td></td></tr><tr><td>excess</td><td></td></tr><tr><td>exceedingly</td><td></td></tr><tr><td>excel</td><td></td></tr><tr><td>excellent</td><td></td></tr><tr><td>concede</td><td></td></tr><tr><td>access</td><td></td></tr><tr><td>cease</td><td></td></tr></tbody></table><h2 id="DAY05"><a href="#DAY05" class="headerlink" title="DAY05"></a>DAY05</h2><table><thead><tr><th>单词</th><th>翻译</th></tr></thead><tbody><tr><td>receive</td><td></td></tr><tr><td>accept</td><td></td></tr><tr><td>concept</td><td></td></tr><tr><td>conceive</td><td></td></tr><tr><td>perceive</td><td></td></tr><tr><td>deceive</td><td></td></tr><tr><td>except</td><td></td></tr><tr><td>susceptible</td><td></td></tr><tr><td></td><td></td></tr><tr><td>century</td><td></td></tr><tr><td>innocent</td><td></td></tr><tr><td>incentive</td><td></td></tr><tr><td></td><td></td></tr><tr><td>accelerate</td><td></td></tr><tr><td>decelerate</td><td></td></tr><tr><td></td><td></td></tr><tr><td>center</td><td></td></tr><tr><td>central</td><td></td></tr><tr><td>concentrate</td><td></td></tr><tr><td></td><td></td></tr><tr><td>ceremony</td><td></td></tr><tr><td>celebrate</td><td></td></tr><tr><td>celebrity</td><td></td></tr><tr><td></td><td></td></tr><tr><td>certain</td><td></td></tr><tr><td>certify</td><td></td></tr><tr><td></td><td></td></tr><tr><td>decide</td><td></td></tr><tr><td>suicide</td><td></td></tr><tr><td>homicide</td><td></td></tr><tr><td>precise</td><td></td></tr><tr><td>genocide</td><td></td></tr><tr><td>casual</td><td></td></tr><tr><td>casualty</td><td></td></tr><tr><td>accident</td><td></td></tr><tr><td>occasion</td><td></td></tr><tr><td>incident</td><td></td></tr><tr><td>incidence</td><td></td></tr><tr><td>coincidence</td><td></td></tr><tr><td>cascade</td><td></td></tr><tr><td>decay</td><td></td></tr><tr><td></td><td></td></tr><tr><td>chronic</td><td></td></tr><tr><td>synchronous</td><td></td></tr><tr><td>chronicle</td><td></td></tr><tr><td></td><td></td></tr><tr><td>circle</td><td></td></tr><tr><td>circuit</td><td></td></tr><tr><td>circulation</td><td></td></tr><tr><td>cycle</td><td></td></tr><tr><td>recycle</td><td></td></tr><tr><td></td><td></td></tr><tr><td>civil</td><td></td></tr><tr><td>civilization</td><td></td></tr><tr><td></td><td></td></tr><tr><td>claim</td><td></td></tr><tr><td>acclaim</td><td></td></tr><tr><td>exclaim</td><td></td></tr><tr><td>proclaim</td><td></td></tr></tbody></table><h2 id="DAY06"><a href="#DAY06" class="headerlink" title="DAY06"></a>DAY06</h2><table><thead><tr><th>单词</th><th>翻译</th></tr></thead><tbody><tr><td>clarify</td><td></td></tr><tr><td>clarity</td><td></td></tr><tr><td>declare</td><td></td></tr><tr><td></td><td></td></tr><tr><td>class</td><td></td></tr><tr><td>classify</td><td></td></tr><tr><td>classical</td><td></td></tr><tr><td></td><td></td></tr><tr><td>decline</td><td></td></tr><tr><td>incline</td><td></td></tr><tr><td></td><td></td></tr><tr><td>conclude</td><td></td></tr><tr><td>include</td><td></td></tr><tr><td>exclude</td><td></td></tr><tr><td>exclusive</td><td></td></tr><tr><td>disclose</td><td></td></tr><tr><td></td><td></td></tr><tr><td>accumulate</td><td></td></tr><tr><td>complain</td><td></td></tr><tr><td>comprehensive</td><td></td></tr><tr><td>condition</td><td></td></tr><tr><td>confront</td><td></td></tr><tr><td>conjunction</td><td></td></tr><tr><td>conscious</td><td></td></tr><tr><td>contemplate</td><td></td></tr><tr><td>collapse</td><td></td></tr><tr><td>colleague</td><td></td></tr><tr><td>context</td><td></td></tr><tr><td>continent</td><td></td></tr><tr><td>conceal</td><td></td></tr><tr><td>condemn</td><td></td></tr><tr><td>connect</td><td></td></tr><tr><td>convince</td><td></td></tr><tr><td></td><td></td></tr><tr><td>common</td><td></td></tr><tr><td>community</td><td></td></tr><tr><td>communicate</td><td></td></tr><tr><td>immune</td><td></td></tr><tr><td></td><td></td></tr><tr><td>contrast</td><td></td></tr><tr><td>contrary</td><td></td></tr><tr><td>counterpart</td><td></td></tr><tr><td>counteract</td><td></td></tr><tr><td>encounter</td><td></td></tr><tr><td></td><td></td></tr><tr><td>core</td><td></td></tr><tr><td>according</td><td></td></tr><tr><td>record</td><td></td></tr><tr><td></td><td></td></tr><tr><td>count</td><td></td></tr><tr><td>compute</td><td></td></tr><tr><td>calculate</td><td></td></tr><tr><td>counter</td><td></td></tr><tr><td>account</td><td></td></tr><tr><td>accounting</td><td></td></tr><tr><td>discount</td><td></td></tr><tr><td></td><td></td></tr><tr><td>cover</td><td></td></tr><tr><td>discover</td><td></td></tr><tr><td>recover</td><td></td></tr><tr><td>uncover</td><td></td></tr></tbody></table><h2 id="DAY07"><a href="#DAY07" class="headerlink" title="DAY07"></a>DAY07</h2><table><thead><tr><th>单词</th><th>翻译</th></tr></thead><tbody><tr><td>create</td><td></td></tr><tr><td>creative</td><td></td></tr><tr><td>creation</td><td></td></tr><tr><td>creature</td><td></td></tr><tr><td>concrete</td><td></td></tr><tr><td>discrete</td><td></td></tr><tr><td>increase</td><td></td></tr><tr><td>decrease</td><td></td></tr><tr><td></td><td></td></tr><tr><td>credit</td><td></td></tr><tr><td>credible</td><td></td></tr><tr><td>grant</td><td></td></tr><tr><td></td><td></td></tr><tr><td>crime</td><td></td></tr><tr><td>criminal</td><td></td></tr><tr><td>discriminate</td><td></td></tr><tr><td></td><td></td></tr><tr><td>criticize</td><td></td></tr><tr><td>critic</td><td></td></tr><tr><td>criteria</td><td></td></tr><tr><td>critical</td><td></td></tr><tr><td>crucial</td><td></td></tr><tr><td></td><td></td></tr><tr><td>culture</td><td></td></tr><tr><td>cultivate</td><td></td></tr><tr><td>colony</td><td></td></tr><tr><td></td><td></td></tr><tr><td>accurate</td><td></td></tr><tr><td>occur</td><td></td></tr><tr><td>recur</td><td></td></tr><tr><td>concur</td><td></td></tr><tr><td>incur</td><td></td></tr><tr><td>current</td><td></td></tr><tr><td>currency</td><td></td></tr><tr><td>curriculum</td><td></td></tr><tr><td></td><td></td></tr><tr><td>cure</td><td></td></tr><tr><td>secure</td><td></td></tr><tr><td>rescue</td><td></td></tr><tr><td></td><td></td></tr><tr><td>calorie</td><td></td></tr><tr><td>cancer</td><td></td></tr><tr><td>census</td><td></td></tr><tr><td>canteen</td><td></td></tr><tr><td>category</td><td></td></tr><tr><td>cater</td><td></td></tr><tr><td>chain</td><td></td></tr><tr><td>challenge</td><td></td></tr><tr><td>chaos</td><td></td></tr><tr><td>charge</td><td></td></tr><tr><td>cite</td><td></td></tr><tr><td>citizen</td><td></td></tr><tr><td>clash</td><td></td></tr><tr><td>crash</td><td></td></tr><tr><td>client</td><td></td></tr><tr><td>cling</td><td></td></tr><tr><td>clue</td><td></td></tr><tr><td>corporation</td><td></td></tr><tr><td>crisis</td><td></td></tr><tr><td>crisp</td><td></td></tr><tr><td>cruel</td><td></td></tr><tr><td>curb</td><td></td></tr><tr><td>cyber</td><td></td></tr></tbody></table><h2 id="DAY08"><a href="#DAY08" class="headerlink" title="DAY08"></a>DAY08</h2><table><thead><tr><th>单词</th><th>翻译</th></tr></thead><tbody><tr><td>deforestation</td><td></td></tr><tr><td>delay</td><td></td></tr><tr><td>deliver</td><td></td></tr><tr><td>default</td><td></td></tr><tr><td>deny</td><td></td></tr><tr><td>deploy</td><td></td></tr><tr><td>destiny</td><td></td></tr><tr><td>detail</td><td></td></tr><tr><td>retail</td><td></td></tr><tr><td>wholesale</td><td></td></tr><tr><td>deteriorate</td><td></td></tr><tr><td>determine</td><td></td></tr><tr><td></td><td></td></tr><tr><td>decorate</td><td></td></tr><tr><td>decent</td><td></td></tr><tr><td></td><td></td></tr><tr><td>democracy</td><td></td></tr><tr><td>epidemic</td><td></td></tr><tr><td>pandemic</td><td></td></tr><tr><td>demonstrate</td><td></td></tr><tr><td></td><td></td></tr><tr><td>dental</td><td></td></tr><tr><td>identity</td><td></td></tr><tr><td>identify</td><td></td></tr><tr><td>identical</td><td></td></tr><tr><td></td><td></td></tr><tr><td>dictate</td><td></td></tr><tr><td>predict</td><td></td></tr><tr><td>indicate</td><td></td></tr><tr><td>index</td><td></td></tr><tr><td>contradict</td><td></td></tr><tr><td>addict</td><td></td></tr><tr><td>dedicate</td><td></td></tr><tr><td>verdict</td><td></td></tr><tr><td>abdicate</td><td></td></tr><tr><td></td><td></td></tr><tr><td>dilemma</td><td></td></tr><tr><td>display</td><td></td></tr><tr><td>divorce</td><td></td></tr><tr><td>disappoint</td><td></td></tr><tr><td>discourage</td><td></td></tr><tr><td>discard</td><td></td></tr><tr><td>discourse</td><td></td></tr><tr><td>disgrace</td><td></td></tr><tr><td>disguise</td><td></td></tr><tr><td>distaste</td><td></td></tr><tr><td></td><td></td></tr><tr><td>divide</td><td></td></tr><tr><td>division</td><td></td></tr><tr><td>individual</td><td></td></tr><tr><td></td><td></td></tr><tr><td>dome</td><td></td></tr><tr><td>domestic</td><td></td></tr><tr><td>domain</td><td></td></tr><tr><td>dominate</td><td></td></tr><tr><td>predominance</td><td></td></tr><tr><td>random</td><td></td></tr></tbody></table><h2 id="DAY09"><a href="#DAY09" class="headerlink" title="DAY09"></a>DAY09</h2><table><thead><tr><th>单词</th><th>翻译</th></tr></thead><tbody><tr><td>introduce</td><td></td></tr><tr><td>conduct</td><td></td></tr><tr><td>conductor</td><td></td></tr><tr><td>produce</td><td></td></tr><tr><td>productive</td><td></td></tr><tr><td>reproduce</td><td></td></tr><tr><td>reduce</td><td></td></tr><tr><td>deduce</td><td></td></tr><tr><td>induce</td><td></td></tr><tr><td>seduce</td><td></td></tr><tr><td></td><td></td></tr><tr><td>durable</td><td></td></tr><tr><td>duration</td><td></td></tr><tr><td>endure</td><td></td></tr><tr><td></td><td></td></tr><tr><td>daily</td><td></td></tr><tr><td>weekly</td><td></td></tr><tr><td>monthly</td><td></td></tr><tr><td>dazzle</td><td></td></tr><tr><td>deadline</td><td></td></tr><tr><td>deal</td><td></td></tr><tr><td>debt</td><td></td></tr><tr><td>deem</td><td></td></tr><tr><td>density</td><td></td></tr><tr><td>desire</td><td></td></tr><tr><td>digital</td><td></td></tr><tr><td>diplomat</td><td></td></tr><tr><td>doctrine</td><td></td></tr><tr><td>donate</td><td></td></tr><tr><td>dramatic</td><td></td></tr><tr><td>drive</td><td></td></tr><tr><td>drop</td><td></td></tr><tr><td>drought</td><td></td></tr><tr><td>drug</td><td></td></tr><tr><td>dual</td><td></td></tr><tr><td>dwelling</td><td></td></tr><tr><td>dynamic</td><td></td></tr><tr><td></td><td></td></tr><tr><td>electricity</td><td></td></tr><tr><td>electric</td><td></td></tr><tr><td>electrical</td><td></td></tr><tr><td>electronic</td><td></td></tr><tr><td></td><td></td></tr><tr><td>empire</td><td></td></tr><tr><td>imperative</td><td></td></tr><tr><td></td><td></td></tr><tr><td>tempt</td><td></td></tr><tr><td>contempt</td><td></td></tr><tr><td>attempt</td><td></td></tr><tr><td>exempt</td><td></td></tr><tr><td></td><td></td></tr><tr><td>embarrass</td><td></td></tr><tr><td>embody</td><td></td></tr><tr><td>embrace</td><td></td></tr><tr><td>empathy</td><td></td></tr><tr><td>employ</td><td></td></tr><tr><td>empower</td><td></td></tr></tbody></table><h2 id="DAY10"><a href="#DAY10" class="headerlink" title="DAY10"></a>DAY10</h2><table><thead><tr><th>单词</th><th>翻译</th></tr></thead><tbody><tr><td>encourage</td><td></td></tr><tr><td>entitle</td><td></td></tr><tr><td>encode</td><td></td></tr><tr><td>engage</td><td></td></tr><tr><td>enhance</td><td></td></tr><tr><td>enlarge</td><td></td></tr><tr><td>enlist</td><td></td></tr><tr><td>enrich</td><td></td></tr><tr><td>enroll</td><td></td></tr><tr><td>entail</td><td></td></tr><tr><td>deepen</td><td></td></tr><tr><td>hasten</td><td></td></tr><tr><td>heighten</td><td></td></tr><tr><td>lessen</td><td></td></tr><tr><td>loosen</td><td></td></tr><tr><td>sharpen</td><td></td></tr><tr><td>shorten</td><td></td></tr><tr><td>tighten</td><td></td></tr><tr><td>weaken</td><td></td></tr><tr><td>widen</td><td></td></tr><tr><td>soften</td><td></td></tr><tr><td></td><td></td></tr><tr><td>equal</td><td></td></tr><tr><td>equity</td><td></td></tr><tr><td>equation</td><td></td></tr><tr><td>equip</td><td></td></tr><tr><td>equipment</td><td></td></tr><tr><td>adequate</td><td></td></tr><tr><td></td><td></td></tr><tr><td>evaporate</td><td></td></tr><tr><td>exaggerate</td><td></td></tr><tr><td>exchange</td><td></td></tr><tr><td>expand</td><td></td></tr><tr><td>exploit</td><td></td></tr><tr><td>explode</td><td></td></tr><tr><td></td><td></td></tr><tr><td>eager</td><td></td></tr><tr><td>earn</td><td></td></tr><tr><td>earnest</td><td></td></tr><tr><td>empirical</td><td></td></tr><tr><td>energy</td><td></td></tr><tr><td>enterprise</td><td></td></tr><tr><td>envy</td><td></td></tr><tr><td>essence</td><td></td></tr><tr><td>esteem</td><td></td></tr><tr><td>ethical</td><td></td></tr><tr><td>evil</td><td></td></tr><tr><td>executive</td><td></td></tr><tr><td>exemplify</td><td></td></tr><tr><td>exhaust</td><td></td></tr><tr><td>explain</td><td></td></tr></tbody></table><h2 id="DAY11"><a href="#DAY11" class="headerlink" title="DAY11"></a>DAY11</h2><table><thead><tr><th>单词</th><th>翻译</th></tr></thead><tbody><tr><td>fact</td><td>事实</td></tr><tr><td>affect</td><td>影响，感动 v</td></tr><tr><td>effect</td><td>影响，效果 n</td></tr><tr><td>effective</td><td>有效果的</td></tr><tr><td>efficient</td><td>有效率的</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;后缀&quot;&gt;&lt;a href=&quot;#后缀&quot; class=&quot;headerlink&quot; title=&quot;后缀&quot;&gt;&lt;/a&gt;后缀&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;后缀一般只表：词性&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;后缀&lt;/th&gt;
&lt;th&gt;含义&lt;/th</summary>
      
    
    
    
    <category term="MYSELF" scheme="https://zspcer.gitee.io/categories/MYSELF/"/>
    
    
    <category term="考研" scheme="https://zspcer.gitee.io/tags/%E8%80%83%E7%A0%94/"/>
    
    <category term="单词" scheme="https://zspcer.gitee.io/tags/%E5%8D%95%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://zspcer.gitee.io/note/PROJECT/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90/"/>
    <id>https://zspcer.gitee.io/note/PROJECT/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90/</id>
    <published>2023-05-05T07:52:54.949Z</published>
    <updated>2023-05-05T07:52:54.949Z</updated>
    
    <content type="html"><![CDATA[<p>地址解析</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">第一步：要是将签收数据以城市的维度汇总到hive的表中<span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>sf<span class="token punctuation">.</span>sort<span class="token punctuation">.</span>keyword<span class="token punctuation">.</span>datasource<span class="token punctuation">.</span></span>SignDataProcess</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>1、获取城市的签收数据，数据来自于原始数据，签收表中的，字段包括：签收时间，签收人，省，市，区，完整地址等等一系列的签收信息；</p><p>2、根据城市的签收数据，进行解析，重新构建数据，保存在城市历史签收表中（表名：<code>history_sign_data_&#123;city_code&#125;</code>），实例如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">record_id@<span class="token operator">&amp;</span>@江苏省@<span class="token operator">&amp;</span>@无锡市@<span class="token operator">&amp;</span>@宜兴市@<span class="token operator">&amp;</span>@宜城街道今日星辰西南门<span class="token number">85</span><span class="token operator">-</span><span class="token number">5</span>（重要文件，送货上门，务必本人签收）@<span class="token operator">&amp;</span><span class="token variable">@a320200000</span>@<span class="token operator">&amp;</span><span class="token variable">@99610</span>@<span class="token operator">&amp;</span><span class="token variable">@99610</span>@<span class="token operator">&amp;</span>@丰网速运无锡宜兴一分部@<span class="token operator">&amp;</span><span class="token variable">@2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">06</span>:<span class="token number">03</span>:<span class="token number">25</span>@<span class="token operator">&amp;</span><span class="token variable">@null</span>@<span class="token operator">&amp;</span><span class="token variable">@null</span>@<span class="token operator">&amp;</span><span class="token variable">@091194350887</span>@<span class="token operator">&amp;</span><span class="token variable">@201</span>@<span class="token operator">&amp;</span>@江苏省无锡市宜兴市宜城街道今日星辰西南门<span class="token number">85</span><span class="token operator">-</span><span class="token number">5</span>（重要文件，送货上门，务必本人签收）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">第二步骤，将获取到的城市历史签收数据，按照一定的格式处理<span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>sf<span class="token punctuation">.</span>sort<span class="token punctuation">.</span>keyword<span class="token punctuation">.</span>datasource<span class="token punctuation">.</span></span>CityDataProcess</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>1、获取城市的历史签收数据，数据源来自第一步骤中的：城市历史签收表中（表名：<code>history_sign_data_&#123;city_code&#125;</code>)</p><p>2、根据历史签收数据，进行解析，重新构建数据，保存在城市数据表中（表名：<code>city_data_&#123;city_code&#125;</code>），示例如下（和第一步骤的数据结构不一样哦）：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">record_id@<span class="token operator">&amp;</span>@江苏省@<span class="token operator">&amp;</span>@无锡市@<span class="token operator">&amp;</span>@宜兴市@<span class="token operator">&amp;</span>@宜城街道今日星辰西南门<span class="token number">85</span><span class="token operator">-</span><span class="token number">5</span>（重要文件，送货上门，务必本人签收）@<span class="token operator">&amp;</span><span class="token variable">@a320200000</span>@<span class="token operator">&amp;</span><span class="token variable">@201</span>@<span class="token operator">&amp;</span><span class="token variable">@null</span>@<span class="token operator">&amp;</span><span class="token variable">@99610</span>@<span class="token operator">&amp;</span><span class="token variable">@99610</span>@<span class="token operator">&amp;</span>@丰网速运无锡宜兴一分部@<span class="token operator">&amp;</span><span class="token variable">@2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">06</span>:<span class="token number">03</span>:<span class="token number">25</span>@<span class="token operator">&amp;</span><span class="token variable">@null</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">第三步骤，将城市数据表中的数据拆分成关键字保存<span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>sf<span class="token punctuation">.</span>sort<span class="token punctuation">.</span>keyword<span class="token punctuation">.</span>datasource<span class="token punctuation">.</span></span>KeyWordBuildProcess</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>1、获取城市数据表</p><p>2、根据传参类型，判断是构建：站点关键字，还是派件区域关键字，还是都构建；</p><p>3、以构建站点关键字为例</p><p>3.1、遍历取addr中的每一个字符；</p><p>3.2、判断字符是否是有效字符，不是有效字符的，过滤掉</p><p>3.3、针对有效字符，进行拆分关键字，得到关键字List</p><p>3.4、针对每一个关键字，和派件站点id进行组合，得到最终数据map</p><p>4、根据关键字统计对应站点分布(关键字-&gt;[site1,site2,site3])</p><p>5、按分数过滤：对站点累加，得出一个站点出现多少次（site1：x1；site2：x2）</p><p>6、针对每一个站点，通过：出现次数 * 100 &#x2F; 总站点数 计算出站点得分</p><p>7、通过站点得分和默认分90分比较；大于90的保留，小于90的不要；</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">----------------------------------------------test_site_site.txt</span>临平南苑街道理想世纪<span class="token variable">@79145</span><span class="token variable">@100</span><span class="token variable">@1</span><span class="token variable">@1</span>杭区临平南苑街<span class="token variable">@79145</span><span class="token variable">@100</span><span class="token variable">@8</span><span class="token variable">@8</span>想康城一品<span class="token number">6</span>幢<span class="token number">1</span><span class="token variable">@79145</span><span class="token variable">@100</span><span class="token variable">@1</span><span class="token variable">@1</span>区省临<span class="token variable">@79145</span><span class="token variable">@100</span><span class="token variable">@1</span><span class="token variable">@1</span>泰城小区<span class="token number">4</span>幢<span class="token number">1</span>单元<span class="token number">2902</span><span class="token variable">@79145</span><span class="token variable">@100</span><span class="token variable">@1</span><span class="token variable">@1</span>苑街道理想银泰城<span class="token number">4</span>栋<span class="token number">1</span>单<span class="token variable">@79145</span><span class="token variable">@100</span><span class="token variable">@1</span><span class="token variable">@1</span>道理想世纪金座奥兰城季<span class="token variable">@79145</span><span class="token variable">@100</span><span class="token variable">@1</span><span class="token variable">@1</span>想康城国际约克郡<span class="token number">19</span>号<span class="token variable">@79145</span><span class="token variable">@100</span><span class="token variable">@1</span><span class="token variable">@1</span>临平区南<span class="token variable">@79145</span><span class="token variable">@100</span><span class="token variable">@24</span><span class="token variable">@24</span>约克郡<span class="token number">24</span><span class="token variable">@79145</span><span class="token variable">@100</span><span class="token variable">@1</span><span class="token variable">@1</span>想银泰城<span class="token number">1</span>幢<span class="token number">2</span>单<span class="token variable">@79145</span><span class="token variable">@100</span><span class="token variable">@4</span><span class="token variable">@4</span><span class="token comment">----------------------------------------------test_site_disp.txt</span><span class="token number">79145</span>_州威帕无纺布有<span class="token variable">@d_003</span><span class="token variable">@100</span><span class="token variable">@1</span><span class="token variable">@1</span><span class="token number">79145</span>_康城国际康城国际<span class="token number">14</span><span class="token variable">@d_014</span><span class="token variable">@100</span><span class="token variable">@1</span><span class="token variable">@1</span><span class="token number">79145</span>_想银泰城<span class="token number">1</span>号楼<span class="token variable">@d_003</span><span class="token variable">@100</span><span class="token variable">@1</span><span class="token variable">@1</span><span class="token number">79145</span>_城国际约克郡<span class="token number">17</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span><span class="token number">1301</span><span class="token variable">@d_014</span><span class="token variable">@100</span><span class="token variable">@1</span><span class="token variable">@1</span><span class="token number">79145</span>_苑街道理想世<span class="token variable">@d_009</span><span class="token variable">@100</span><span class="token variable">@3</span><span class="token variable">@3</span><span class="token number">79145</span>_街道理想康城一品<span class="token number">7</span>幢<span class="token number">2</span>单<span class="token variable">@d_009</span><span class="token variable">@100</span><span class="token variable">@1</span><span class="token variable">@1</span><span class="token number">79145</span>_二单元<span class="token number">1301</span>室<span class="token variable">@d_003</span><span class="token variable">@100</span><span class="token variable">@1</span><span class="token variable">@1</span><span class="token number">79145</span>_街道理想国际大<span class="token variable">@d_015</span><span class="token variable">@100</span><span class="token variable">@1</span><span class="token variable">@1</span><span class="token number">79145</span>_道理想国际大厦<span class="token number">16</span><span class="token variable">@d_015</span><span class="token variable">@100</span><span class="token variable">@1</span><span class="token variable">@1</span><span class="token number">79145</span>_区南苑街道理想银泰城负一<span class="token variable">@d_003</span><span class="token variable">@100</span><span class="token variable">@1</span><span class="token variable">@1</span><span class="token number">79145</span>_中心下午<span class="token number">2</span>点<span class="token variable">@d_009</span><span class="token variable">@100</span><span class="token variable">@1</span><span class="token variable">@1</span><span class="token number">79145</span>_杭区南苑街道理想康城国<span class="token variable">@d_014</span><span class="token variable">@100</span><span class="token variable">@15</span><span class="token variable">@15</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>8、将数据写入到hive的表中，表名（<code>city_keyword_pair_&#123;city_code&#125;_&#123;disp/site&#125;</code>）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">第四步骤，将关键字数据load到redis中<span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>sf<span class="token punctuation">.</span>sort<span class="token punctuation">.</span>keyword<span class="token punctuation">.</span>datasource<span class="token punctuation">.</span></span>LoadKeywordProcess</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>1、读取hive表中的数据，将数据存储到redis中</p><p>2、redis的存储结构是 hmset 数据结构</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;地址解析&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-java&quot; data-language=&quot;java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;第一步：要是将签收数据以城市的维度汇总到hive的表中
&lt;span class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>大厂面试之JVM篇</title>
    <link href="https://zspcer.gitee.io/note/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BJVM%E7%AF%87/"/>
    <id>https://zspcer.gitee.io/note/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BJVM%E7%AF%87/</id>
    <published>2023-05-04T16:09:14.000Z</published>
    <updated>2023-05-05T07:52:55.068Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大厂面试之JVM篇"><a href="#大厂面试之JVM篇" class="headerlink" title="大厂面试之JVM篇"></a>大厂面试之JVM篇</h1><h1 id="1-什么是JVM"><a href="#1-什么是JVM" class="headerlink" title="1.什么是JVM?"></a>1.什么是JVM?</h1><p>JVM——Java虚拟机，它是Java实现平台无关性的基石。</p><p>Java程序运行的时候，编译器将Java文件编译成平台无关的Java字节码文件（.class）,接下来对应平台JVM对字节码文件进行解释，翻译成对应平台匹配的机器指令并运行。</p><img src="大厂面试之JVM篇.assets/image-20230504161048844.png" alt="image-20230504161048844" style="zoom:80%;" /><p>同时JVM也是一个跨语言的平台，和语言无关，只和class的文件格式关联，任何语言，只要能翻译成符合规范的字节码文件，都能被JVM运行。</p><img src="大厂面试之JVM篇.assets/1677503624714-e8744f9f-6603-4f57-9211-4dbe9761e5d3.png" alt="img" style="zoom:80%;" /><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="2-能说一下JVM的内存区域吗？"><a href="#2-能说一下JVM的内存区域吗？" class="headerlink" title="2.能说一下JVM的内存区域吗？"></a>2.能说一下JVM的内存区域吗？</h2><p>JVM内存区域最粗略的划分可以分为<code>堆</code>和<code>栈</code>，当然，按照虚拟机规范，可以划分为以下几个区域：</p><img src="大厂面试之JVM篇.assets/1677503626945-c92c5d35-ea8a-4892-a166-626e95ec3cb9.png" alt="img" style="zoom:80%;" /><p>JVM内存分为线程私有区和线程共享区，其中<code>方法区</code>和<code>堆</code>是线程共享区，<code>虚拟机栈</code>、<code>本地方法栈</code>和<code>程序计数器</code>是线程隔离的数据区。</p><p><strong>1、程序计数器</strong></p><p>程序计数器（Program Counter Register）也被称为PC寄存器，是一块较小的内存空间。</p><p>它可以看作是当前线程所执行的字节码的行号指示器。</p><p><strong>2、Java虚拟机栈</strong></p><p>Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。</p><p>Java虚拟机栈描述的是Java方法执行的线程内存模型：方法执行时，JVM会同步创建一个栈帧，用来存储局部变量表、操作数栈、动态连接等。</p><img src="大厂面试之JVM篇.assets/1677503629496-4a73c555-054d-4133-b933-029e1cfeb116.png" alt="img" style="zoom:80%;" /><p><strong>3、本地方法栈</strong></p><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p><p>Java 虚拟机规范允许本地方法栈被实现成固定大小的或者是根据计算动态扩展和收缩的。</p><p><strong>4、Java堆</strong></p><p>对于Java应用程序来说，Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java里“<strong>几乎</strong>”所有的对象实例都在这里分配内存。</p><p>Java堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”（Garbage Collected Heap，）。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆中经常会出现<code>新生代</code>、<code>老年代</code>、<code>Eden空间</code>、<code>From Survivor空间</code>、<code>To Survivor空间</code>等名词，需要注意的是这种划分只是根据垃圾回收机制来进行的划分，不是Java虚拟机规范本身制定的。</p><img src="大厂面试之JVM篇.assets/1677503632116-8428fa47-5118-4781-b41b-235289c4892b.png" alt="img" style="zoom:80%;" /><p><strong>5.方法区</strong></p><p>方法区是比较特别的一块区域，和堆类似，它也是各个线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><p>它特别在Java虚拟机规范对它的约束非常宽松，所以方法区的具体实现历经了许多变迁，例如jdk1.7之前使用永久代作为方法区的实现。</p><h2 id="3-说一下JDK1-6、1-7、1-8内存区域的变化？"><a href="#3-说一下JDK1-6、1-7、1-8内存区域的变化？" class="headerlink" title="3.说一下JDK1.6、1.7、1.8内存区域的变化？"></a>3.说一下JDK1.6、1.7、1.8内存区域的变化？</h2><p>JDK1.6、1.7&#x2F;1.8内存区域发生了变化，主要体现在方法区的实现：</p><ul><li>JDK1.6使用永久代实现方法区：</li></ul><img src="大厂面试之JVM篇.assets/1677503634698-d37c0cfa-f9c4-4c60-b615-53909203c7ed.png" alt="img" style="zoom:80%;" /><ul><li>JDK1.7时发生了一些变化，将字符串常量池、静态变量，存放在堆上</li></ul><img src="大厂面试之JVM篇.assets/1677503636535-3f628479-9a93-445d-8f79-b6e6af487e49.png" alt="img" style="zoom:80%;" /><ul><li>在JDK1.8时彻底干掉了永久代，而在直接内存中划出一块区域作为<strong>元空间</strong>，运行时常量池、类常量池都移动到元空间。</li></ul><img src="大厂面试之JVM篇.assets/1677503638514-7d445502-cdfb-43ec-aca1-2989d077a79e.png" alt="img" /> <h2 id="4-为什么使用元空间替代永久代作为方法区的实现？"><a href="#4-为什么使用元空间替代永久代作为方法区的实现？" class="headerlink" title="4.为什么使用元空间替代永久代作为方法区的实现？"></a>4.为什么使用元空间替代永久代作为方法区的实现？</h2><p>Java虚拟机规范规定的方法区只是换种方式实现。有客观和主观两个原因。</p><ul><li>客观上使用永久代来实现方法区的决定的设计导致了Java应用更容易遇到内存溢出的问题（永久代有-XX：MaxPermSize的上限，即使不设置也有默认大小，而J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB限制，就不会出问题），而且有极少数方法 （例如String::intern()）会因永久代的原因而导致不同虚拟机下有不同的表现。</li><li>主观上当Oracle收购BEA获得了JRockit的所有权后，准备把JRockit中的优秀功能，譬如Java Mission Control管理工具，移植到HotSpot 虚拟机时，但因为两者对方法区实现的差异而面临诸多困难。考虑到HotSpot未来的发展，在JDK 6的 时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计划了，到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了 JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Meta-space）来代替，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。</li></ul><h2 id="5-对象创建的过程了解吗？"><a href="#5-对象创建的过程了解吗？" class="headerlink" title="5.对象创建的过程了解吗？"></a>5.对象创建的过程了解吗？</h2><p>在JVM中对象的创建，我们从一个new指令开始：</p><ul><li>首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用</li><li>检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，就先执行相应的类加载过程</li><li>类加载检查通过后，接下来虚拟机将为新生对象分配内存。</li><li>内存分配完成之后，虚拟机将分配到的内存空间（但不包括对象头）都初始化为零值。</li><li>接下来设置对象头，请求头里包含了对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。</li></ul><p>这个过程大概图示如下：</p><img src="大厂面试之JVM篇.assets/1677503641547-1cdb8ac9-1a4b-4b16-8171-95a5eb356d0d.png" alt="img" style="zoom:80%;" /><h2 id="6-什么是指针碰撞？什么是空闲列表？"><a href="#6-什么是指针碰撞？什么是空闲列表？" class="headerlink" title="6.什么是指针碰撞？什么是空闲列表？"></a>6.什么是指针碰撞？什么是空闲列表？</h2><p>内存分配有两种方式，<strong>指针碰撞</strong>（Bump The Pointer）、<strong>空闲列表</strong>（Free List）。</p><img src="大厂面试之JVM篇.assets/1677503643493-25e288b8-d94f-4ad8-81bb-454f7df4db70.png" alt="img" style="zoom:80%;" /><ul><li>指针碰撞：假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。</li><li>空闲列表：如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。</li><li>两种方式的选择由Java堆是否规整决定，Java堆是否规整是由选择的垃圾收集器是否具有压缩整理能力决定的。</li></ul><h2 id="7-JVM-里-new-对象时，堆会发生抢占吗？JVM是怎么设计来保证线程安全的？"><a href="#7-JVM-里-new-对象时，堆会发生抢占吗？JVM是怎么设计来保证线程安全的？" class="headerlink" title="7.JVM 里 new 对象时，堆会发生抢占吗？JVM是怎么设计来保证线程安全的？"></a>7.JVM 里 new 对象时，堆会发生抢占吗？JVM是怎么设计来保证线程安全的？</h2><p>会，假设JVM虚拟机上，每一次new 对象时，指针就会向右移动一个对象size的距离，一个线程正在给A对象分配内存，指针还没有来的及修改，另一个为B对象分配内存的线程，又引用了这个指针来分配内存，这就发生了抢占。</p><p>有两种可选方案来解决这个问题：</p><img src="大厂面试之JVM篇.assets/1677503645536-bbe8ec34-a3b3-4539-9919-f2dbf0e0550b.png" alt="img" style="zoom:80%;" /><ul><li>采用CAS分配重试的方式来保证更新操作的原子性 </li><li>每个线程在Java堆中预先分配一小块内存，也就是本地线程分配缓冲（Thread Local Allocation<br>  Buffer，TLAB），要分配内存的线程，先在本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。</li></ul><h2 id="8-能说一下对象的内存布局吗？"><a href="#8-能说一下对象的内存布局吗？" class="headerlink" title="8.能说一下对象的内存布局吗？"></a>8.能说一下对象的内存布局吗？</h2><p>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p><img src="大厂面试之JVM篇.assets/1677503647463-47c45c0e-c535-47eb-929b-24f01f56abc9.png" alt="img" style="zoom:80%;" /><p><strong>对象头</strong>主要由两部分组成：</p><ul><li>第一部分存储对象自身的运行时数据：哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，官方称它为Mark Word，它是个动态的结构，随着对象状态变化。</li><li>第二部分是类型指针，指向对象的类元数据类型（即对象代表哪个类）。</li><li>此外，如果对象是一个Java数组，那还应该有一块用于记录数组长度的数据</li></ul><p><strong>实例数据</strong>用来存储对象真正的有效信息，也就是我们在程序代码里所定义的各种类型的字段内容，无论是从父类继承的，还是自己定义的。</p><p><strong>对齐填充</strong>不是必须的，没有特别含义，仅仅起着占位符的作用。</p><h2 id="9-对象怎么访问定位？"><a href="#9-对象怎么访问定位？" class="headerlink" title="9.对象怎么访问定位？"></a>9.对象怎么访问定位？</h2><p>Java程序会通过栈上的reference数据来操作堆上的具体对象。由于reference类型在《Java虚拟机规范》里面只规定了它是一个指向对象的引用，并没有定义这个引用应该通过什么方式去定位、访问到堆中对象的具体位置，所以对象访问方式也是由虚拟机实现而定的，主流的访问方式主要有使用句柄和直接指针两种：</p><ul><li>如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息，其结构如图所示：</li></ul><img src="大厂面试之JVM篇.assets/1677503650073-29165857-8ebf-4561-a169-5bbb94b9f307.png" alt="img" style="zoom:80%;" /><ul><li>如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销，如图所示：</li></ul><img src="大厂面试之JVM篇.assets/1677503651863-c56883a1-c3ab-4aaf-9f13-d84e797b860b.png" alt="img" style="zoom:80%;" /><p>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</p><p>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。</p><p>HotSpot虚拟机主要使用直接指针来进行对象访问。</p><h2 id="10-内存溢出和内存泄漏是什么意思？"><a href="#10-内存溢出和内存泄漏是什么意思？" class="headerlink" title="10.内存溢出和内存泄漏是什么意思？"></a>10.内存溢出和内存泄漏是什么意思？</h2><p>内存泄露就是申请的内存空间没有被正确释放，导致内存被白白占用。</p><p>内存溢出就是申请的内存超过了可用内存，内存不够了。</p><p>两者关系：内存泄露可能会导致内存溢出。</p><p>用一个有味道的比喻，内存溢出就是排队去蹲坑，发现没坑位了，内存泄漏，就是有人占着茅坑不拉屎，占着茅坑不拉屎的多了可能会导致坑位不够用。</p><img src="大厂面试之JVM篇.assets/1677503654450-accfc02d-8a4e-45da-8352-c9dfa8bf92a3.png" alt="img" style="zoom:80%;" /><h2 id="11-能手写内存溢出的例子吗？"><a href="#11-能手写内存溢出的例子吗？" class="headerlink" title="11.能手写内存溢出的例子吗？"></a>11.能手写内存溢出的例子吗？</h2><p>在JVM的几个内存区域中，除了程序计数器外，其他几个运行时区域都有发生内存溢出（OOM）异常的可能，重点关注堆和栈。</p><ul><li>Java堆溢出</li></ul><p>Java堆用于储存对象实例，只要不断创建不可被回收的对象，比如静态对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常（OutOfMemoryError）。</p><p>这就相当于一个房子里，不断堆积不能被收走的杂物，那么房子很快就会被堆满了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * VM参数： -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapOOM</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">OOMObject</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">OOMObject</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">OOMObject</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OOMObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>虚拟机栈.OutOfMemoryError</li></ul><p>JDK使用的HotSpot虚拟机的栈内存大小是固定的，我们可以把栈的内存设大一点，然后不断地去创建线程，因为操作系统给每个进程分配的内存是有限的，所以到最后，也会发生OutOfMemoryError异常。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * vm参数：-Xss2M */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JavaVMStackOOM</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dontStop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stackLeakByThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token function">dontStop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">JavaVMStackOOM</span> oom <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JavaVMStackOOM</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        oom<span class="token punctuation">.</span><span class="token function">stackLeakByThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="12-内存泄漏可能由哪些原因导致呢？"><a href="#12-内存泄漏可能由哪些原因导致呢？" class="headerlink" title="12.内存泄漏可能由哪些原因导致呢？"></a>12.内存泄漏可能由哪些原因导致呢？</h2><p>内存泄漏可能的原因有很多种：</p><img src="大厂面试之JVM篇.assets/1677503657117-b78c2a04-899c-4496-8506-856dd47b759c.png" alt="img" style="zoom:80%;" /><p><strong>静态集合类引起内存泄漏</strong></p><p>静态集合的生命周期和 JVM 一致，所以静态集合引用的对象不能被释放。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OOM</span> <span class="token punctuation">&#123;</span> <span class="token keyword">static</span> <span class="token class-name">List</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">oomTests</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>单例模式</strong></p><p>和上面的例子原理类似，单例对象在初始化后会以静态变量的方式在 JVM 的整个生命周期中存在。如果单例对象持有外部的引用，那么这个外部对象将不能被 GC 回收，导致内存泄漏。</p><p><strong>数据连接、IO、Socket等连接</strong></p><p>创建的连接不再使用时，需要调用 <strong>close</strong> 方法关闭连接，只有连接被关闭后，GC 才会回收对应的对象（Connection，Statement，ResultSet，Session）。忘记关闭这些资源会导致持续占有内存，无法被 GC 回收。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    conn <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token string">"url"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Statement</span> stmt <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ResultSet</span> rs <span class="token operator">=</span> stmt<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token string">"...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token punctuation">&#125;</span><span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//不关闭连接</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>变量不合理的作用域</strong></p><p>一个变量的定义作用域大于其使用范围，很可能存在内存泄漏；或不再使用对象没有及时将对象设置为 null，很可能导致内存泄漏的发生。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Simple</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Object</span> object<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        object <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//...其他代码</span>        <span class="token comment">//由于作用域原因，method1执行完成之后，object 对象所分配的内存不会马上释放</span>        object <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>hash值发生变化</strong></p><p>对象Hash值改变，使用HashMap、HashSet等容器中时候，由于对象修改之后的Hah值和存储进容器时的Hash值不同，所以无法找到存入的对象，自然也无法单独删除了，这也会造成内存泄漏。说句题外话，这也是为什么String类型被设置成了不可变类型。</p><p><strong>ThreadLocal使用不当</strong></p><p>ThreadLocal的弱引用导致内存泄漏也是个老生常谈的话题了，使用完ThreadLocal一定要记得使用remove方法来进行清除。</p><h2 id="13-如何判断对象仍然存活？"><a href="#13-如何判断对象仍然存活？" class="headerlink" title="13.如何判断对象仍然存活？"></a>13.如何判断对象仍然存活？</h2><p>有两种方式，<strong>引用计数算法（reference counting）</strong>和可达性分析算法。</p><ul><li><strong>引用计数算法</strong></li></ul><p>引用计数器的算法是这样的：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p><img src="大厂面试之JVM篇.assets/1677503660586-9abee06a-23c5-4c96-b10d-4f05b4d93b8c.png" alt="img" style="zoom:80%;" /><ul><li><strong>可达性分析算法</strong></li></ul><p>目前 Java 虚拟机的主流垃圾回收器采取的是可达性分析算法。这个算法的实质在于将一系列 GC Roots 作为初始的存活对象合集（Gc Root Set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。</p><img src="大厂面试之JVM篇.assets/1677503662225-de1158d7-43a5-4527-ab90-a7fbfaa3bffa.png" alt="img" style="zoom:80%;" /><h2 id="14-Java中可作为GC-Roots的对象有哪几种？"><a href="#14-Java中可作为GC-Roots的对象有哪几种？" class="headerlink" title="14.Java中可作为GC Roots的对象有哪几种？"></a>14.Java中可作为GC Roots的对象有哪几种？</h2><p>可以作为GC Roots的主要有四种对象：</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI引用的对象</li></ul><h2 id="15-说一下对象有哪几种引用？"><a href="#15-说一下对象有哪几种引用？" class="headerlink" title="15.说一下对象有哪几种引用？"></a>15.说一下对象有哪几种引用？</h2><p>Java中的引用有四种，分为强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。</p><ul><li>强引用是最传统的<code>引用</code>的定义，是指在程序代码之中普遍存在的引用赋值，无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Object</span> obj <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ReferenceQueue</span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">SoftReference</span> reference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//强引用对象滞空，保留软引用</span>obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ReferenceQueue</span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">WeakReference</span> reference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//强引用对象滞空，保留软引用</span>obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ReferenceQueue</span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">PhantomReference</span> reference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//强引用对象滞空，保留软引用</span>obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="大厂面试之JVM篇.assets/1677503665254-cc3e1891-edbe-46f9-ab0f-3a99dbfeb408.png" alt="img" style="zoom:80%;" /><h2 id="16-finalize-方法了解吗？有什么作用？"><a href="#16-finalize-方法了解吗？有什么作用？" class="headerlink" title="16.finalize()方法了解吗？有什么作用？"></a>16.finalize()方法了解吗？有什么作用？</h2><p>用一个不太贴切的比喻，垃圾回收就是古代的秋后问斩，finalize()就是刀下留人，在人犯被处决之前，还要做最后一次审计，青天大老爷看看有没有什么冤情，需不需要刀下留人。</p><img src="大厂面试之JVM篇.assets/1677503667730-c6e9ac08-fe2b-4f62-861d-ecd6aded9cb7.png" alt="img" style="zoom:80%;" /><p>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。如果对象在在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 （this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它就”逃过一劫“；但是如果没有抓住这个机会，那么对象就真的要被回收了。</p><h2 id="17-Java堆的内存分区了解吗？"><a href="#17-Java堆的内存分区了解吗？" class="headerlink" title="17.Java堆的内存分区了解吗？"></a>17.Java堆的内存分区了解吗？</h2><p>按照垃圾收集，将Java堆划分为<strong>新生代 （Young Generation）</strong>和<strong>老年代（Old Generation）</strong>两个区域，新生代存放存活时间短的对象，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。</p><p>而新生代又可以分为三个区域，eden、from、to，比例是8：1：1，而新生代的内存分区同样是从垃圾收集的角度来分配的。</p><img src="大厂面试之JVM篇.assets/1677503669890-4c2f0952-6db9-4d3a-aacb-9cc066a223ef.png" alt="img" style="zoom:80%;" /><h2 id="18-垃圾收集算法了解吗？"><a href="#18-垃圾收集算法了解吗？" class="headerlink" title="18.垃圾收集算法了解吗？"></a>18.垃圾收集算法了解吗？</h2><p>垃圾收集算法主要有三种：</p><ol><li><strong>标记-清除算法</strong></li></ol><p>见名知义，<code>标记-清除</code>（Mark-Sweep）算法分为两个阶段：</p><ul><li><strong>标记</strong> : 标记出所有需要回收的对象</li><li><strong>清除</strong>：回收所有被标记的对象</li></ul><img src="大厂面试之JVM篇.assets/1677503671884-ce56eed4-13ef-492b-b969-654071a2f96b.png" alt="img" style="zoom:80%;" /><p>标记-清除算法比较基础，但是主要存在两个缺点：</p><ul><li>执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低。</li><li>内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ul><ol><li><strong>标记-复制算法</strong></li></ol><p>标记-复制算法解决了标记-清除算法面对大量可回收对象时执行效率低的问题。</p><p>过程也比较简单：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p><img src="大厂面试之JVM篇.assets/1677503674474-ea71cac0-7e6d-4a59-9d77-29bbf81babb7.png" alt="img" style="zoom:80%;" /><p>这种算法存在一个明显的缺点：一部分空间没有使用，存在空间的浪费。</p><p>新生代垃圾收集主要采用这种算法，因为新生代的存活对象比较少，每次复制的只是少量的存活对象。当然，实际新生代的收集不是按照这个比例。</p><ol><li><strong>标记-整理算法</strong></li></ol><p>为了降低内存的消耗，引入一种针对性的算法：<code>标记-整理</code>（Mark-Compact）算法。</p><p>其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</p><img src="大厂面试之JVM篇.assets/1677503676387-2831fbac-b1d9-48ef-9d6a-021029b831c4.png" alt="img" style="zoom:80%;" /><p>标记-整理算法主要用于老年代，移动存活对象是个极为负重的操作，而且这种操作需要Stop The World才能进行，只是从整体的吞吐量来考量，老年代使用标记-整理算法更加合适。</p><h2 id="19-说一下新生代的区域划分？"><a href="#19-说一下新生代的区域划分？" class="headerlink" title="19.说一下新生代的区域划分？"></a>19.说一下新生代的区域划分？</h2><p>新生代的垃圾收集主要采用标记-复制算法，因为新生代的存活对象比较少，每次复制少量的存活对象效率比较高。</p><p>基于这种算法，虚拟机将内存分为一块较大的Eden空间和两块较小的 Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾收集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。默认Eden和Survivor的大小比例是8∶1。</p><img src="大厂面试之JVM篇.assets/1677503678911-d4943fee-ac4d-4e6d-95a5-f550b7fcdc25.png" alt="img" style="zoom:80%;" /><h2 id="20-Minor-GC-x2F-Young-GC、Major-GC-x2F-Old-GC、Mixed-GC、Full-GC都是什么意思？"><a href="#20-Minor-GC-x2F-Young-GC、Major-GC-x2F-Old-GC、Mixed-GC、Full-GC都是什么意思？" class="headerlink" title="20.Minor GC&#x2F;Young GC、Major GC&#x2F;Old GC、Mixed GC、Full GC都是什么意思？"></a>20.Minor GC&#x2F;Young GC、Major GC&#x2F;Old GC、Mixed GC、Full GC都是什么意思？</h2><p><strong>部分收集</strong>（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：</p><ul><li>新生代收集（Minor GC&#x2F;Young GC）：指目标只是新生代的垃圾收集。</li><li>老年代收集（Major GC&#x2F;Old GC）：指目标只是老年代的垃圾收集。目前<strong>只有</strong>CMS收集器会有单独收集老年代的行为。</li><li>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</li></ul><p><strong>整堆收集</strong>（Full GC）：收集整个Java堆和方法区的垃圾收集。</p><h2 id="21-Minor-GC-x2F-Young-GC什么时候触发？"><a href="#21-Minor-GC-x2F-Young-GC什么时候触发？" class="headerlink" title="21.Minor GC&#x2F;Young GC什么时候触发？"></a>21.Minor GC&#x2F;Young GC什么时候触发？</h2><p>新创建的对象优先在新生代Eden区进行分配，如果Eden区没有足够的空间时，就会触发Young GC来清理新生代。</p><h2 id="22-什么时候会触发Full-GC？"><a href="#22-什么时候会触发Full-GC？" class="headerlink" title="22.什么时候会触发Full GC？"></a>22.什么时候会触发Full GC？</h2><p>这个触发条件稍微有点多，往下看：</p><img src="大厂面试之JVM篇.assets/1677503681486-8b771a67-c436-419b-b8e5-1dbc16855878.png" alt="img" style="zoom:80%;" /><ul><li><strong>Young GC之前检查老年代</strong>：在要进行 Young GC 的时候，发现<code>老年代可用的连续内存空间</code> &lt; <code>新生代历次Young GC后升入老年代的对象总和的平均大小</code>，说明本次Young GC后可能升入老年代的对象大小，可能超过了老年代当前可用内存空间,那就会触发 Full GC。</li><li><strong>Young GC之后老年代空间不足</strong>：执行Young GC之后有一批对象需要放入老年代，此时老年代就是没有足够的内存空间存放这些对象了，此时必须立即触发一次Full GC</li><li><strong>老年代空间不足</strong>，老年代内存使用率过高，达到一定比例，也会触发Full GC。</li><li><strong>空间分配担保失败</strong>（ Promotion Failure），新生代的 To 区放不下从 Eden 和 From 拷贝过来对象，或者新生代对象 GC 年龄到达阈值需要晋升这两种情况，老年代如果放不下的话都会触发 Full GC。</li><li><strong>方法区内存空间不足</strong>：如果方法区由永久代实现，永久代空间不足 Full GC。</li><li><strong>System.gc()等命令触发</strong>：System.gc()、jmap -dump 等命令会触发 full gc。</li></ul><h2 id="23-对象什么时候会进入老年代？"><a href="#23-对象什么时候会进入老年代？" class="headerlink" title="23.对象什么时候会进入老年代？"></a>23.对象什么时候会进入老年代？</h2><img src="大厂面试之JVM篇.assets/1677503683731-45c187bd-ed4c-4259-a403-fba98657ee15.png" alt="img" style="zoom:80%;" /><p><strong>长期存活的对象将进入老年代</strong></p><p>在对象的对象头信息中存储着对象的迭代年龄,迭代年龄会在每次YoungGC之后对象的移区操作中增加,每一次移区年龄加一.当这个年龄达到15(默认)之后,这个对象将会被移入老年代。</p><p>可以通过这个参数设置这个年龄值。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">-</span> <span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">MaxTenuringThreshold</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>大对象直接进入老年代</strong></p><p>有一些占用大量连续内存空间的对象在被加载就会直接进入老年代.这样的大对象一般是一些数组,长字符串之类的对。</p><p>HotSpot虚拟机提供了这个参数来设置。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">-</span><span class="token constant">XX</span>：<span class="token class-name">PretenureSizeThreshold</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>动态对象年龄判定</strong></p><p>为了能更好地适应不同程序的内存状况，HotSpot虚拟机并不是永远要求对象的年龄必须达到- XX：MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p><p><strong>空间分配担保</strong></p><p>假如在Young GC之后，新生代仍然有大量对象存活，就需要老年代进行分配担保，把Survivor无法容纳的对象直接送入老年代。</p><h2 id="24-知道有哪些垃圾收集器吗？"><a href="#24-知道有哪些垃圾收集器吗？" class="headerlink" title="24.知道有哪些垃圾收集器吗？"></a>24.知道有哪些垃圾收集器吗？</h2><p>主要垃圾收集器如下，图中标出了它们的工作区域、垃圾收集算法，以及配合关系。</p><img src="大厂面试之JVM篇.assets/1677503686311-7f40160b-146a-4fd8-9af8-37bdba69b934.png" alt="img" style="zoom:80%;" /><p>这些收集器里，面试的重点是两个——<strong>CMS</strong>和<strong>G1</strong>。</p><ul><li>Serial收集器</li></ul><p>Serial收集器是最基础、历史最悠久的收集器。</p><p>如同它的名字（串行），它是一个单线程工作的收集器，使用一个处理器或一条收集线程去完成垃圾收集工作。并且进行垃圾收集时，必须暂停其他所有工作线程，直到垃圾收集结束——这就是所谓的“Stop The World”。</p><p>Serial&#x2F;Serial Old收集器的运行过程如图：</p><img src="大厂面试之JVM篇.assets/1677503688565-0392f21d-0059-4cac-b80f-c2fb2b11c9ff.png" alt="img" style="zoom:80%;" /><ul><li>ParNew</li></ul><p>ParNew收集器实质上是Serial收集器的多线程并行版本，使用多条线程进行垃圾收集。</p><p><strong>我们可以通过选项 “-XX:+UseParNewGC” 手动指定使用 ParNew 收集器执行垃圾收集任务</strong></p><p>ParNew&#x2F;Serial Old收集器运行示意图如下：</p><img src="大厂面试之JVM篇.assets/1677503690187-f9be250e-9177-495f-957a-362cfc02ead8.png" alt="img" style="zoom:80%;" /><ul><li>Parallel Scavenge</li></ul><p>Parallel Scavenge收集器是一款新生代收集器，基于标记-复制算法实现，也能够并行收集。和ParNew有些类似，但Parallel Scavenge主要关注的是垃圾收集的吞吐量——所谓吞吐量，就是CPU用于运行用户代码的时间和总消耗时间的比值，比值越大，说明垃圾收集的占比越小。</p><p><strong>JDK1.8默认的新生代收集器，采用标记-复制算法</strong></p><img src="大厂面试之JVM篇.assets/1677503692027-f1d68e0d-40a4-454e-95de-5c98c0d5fde7.png" alt="img" style="zoom:80%;" /><ul><li>Serial Old</li></ul><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。</p><ul><li>Parallel Old</li></ul><p>Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。</p><p>JDK1.8 默认的老年代垃圾收集器</p><p>我们可以通过参数 -XX: +UseParalleloldGC 手动指定老年代使用 Parallel Old 并行收集器</p><img src="大厂面试之JVM篇.assets/1677503693580-279416e3-d99c-4fac-be22-2e6fec9d2a1a.png" alt="img" style="zoom:80%;" /><ul><li>CMS收集器</li></ul><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，同样是老年代的收集器，采用<strong>标记-清除算法</strong>。</p><ul><li>Garbage First收集器</li></ul><p>Garbage First（简称G1）收集器是垃圾收集器的一个颠覆性的产物，它开创了局部收集的设计思路和基于Region的内存布局形式。</p><p>可以使用参数：-XX:+UseG1GC 指定G1垃圾收集器</p><h2 id="25-什么是Stop-The-World-什么是-OopMap-？什么是安全点？"><a href="#25-什么是Stop-The-World-什么是-OopMap-？什么是安全点？" class="headerlink" title="25.什么是Stop The World ? 什么是 OopMap ？什么是安全点？"></a>25.什么是Stop The World ? 什么是 OopMap ？什么是安全点？</h2><p>进行垃圾回收的过程中，会涉及对象的移动。为了保证对象引用更新的正确性，必须暂停所有的用户线程，像这样的停顿，虚拟机设计者形象描述为<code>Stop The World</code>。也简称为STW。</p><p>在HotSpot中，有个数据结构（映射表）称为<code>OopMap</code>。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，记录到OopMap。在即时编译过程中，也会在<code>特定的位置</code>生成 OopMap，记录下栈上和寄存器里哪些位置是引用。</p><p>这些特定的位置主要在：</p><ul><li>1.循环的末尾（非 counted 循环）</li><li>2.方法临返回前 &#x2F; 调用方法的call指令后</li><li>3.可能抛异常的位置</li></ul><p>这些位置就叫作<strong>安全点(safepoint)。</strong> 用户程序执行时并非在代码指令流的任意位置都能够在停顿下来开始垃圾收集，而是必须是执行到安全点才能够暂停。</p><p>用通俗的比喻，假如老王去拉车，车上东西很重，老王累的汗流浃背，但是老王不能在上坡或者下坡休息，只能在平地上停下来擦擦汗，喝口水。</p><img src="大厂面试之JVM篇.assets/1677503695720-a69f01ea-a476-42fb-9207-8042a4ea3add.png" alt="img" style="zoom:80%;" /><h2 id="26-能详细说一下CMS收集器的垃圾收集过程吗？"><a href="#26-能详细说一下CMS收集器的垃圾收集过程吗？" class="headerlink" title="26.能详细说一下CMS收集器的垃圾收集过程吗？"></a>26.能详细说一下CMS收集器的垃圾收集过程吗？</h2><p>CMS收集齐的垃圾收集分为四步：</p><ul><li><strong>初始标记</strong>（CMS initial mark）：单线程运行，需要Stop The World，标记GC Roots能直达的对象。</li><li><strong>并发标记</strong>（（CMS concurrent mark）：无停顿，和用户线程同时运行，从GC Roots直达对象开始遍历整个对象图。</li><li><strong>重新标记</strong>（CMS remark）：多线程运行，需要Stop The World，标记并发标记阶段产生对象。</li><li><strong>并发清除</strong>（CMS concurrent sweep）：无停顿，和用户线程同时运行，清理掉标记阶段标记的死亡的对象。</li></ul><p>Concurrent Mark Sweep收集器运行示意图如下：</p><img src="大厂面试之JVM篇.assets/1677503697771-787559ff-0506-4ae2-93cb-64ba6e76c9c8.png" alt="img" style="zoom:80%;" /><h2 id="27-G1垃圾收集器了解吗？"><a href="#27-G1垃圾收集器了解吗？" class="headerlink" title="27.G1垃圾收集器了解吗？"></a>27.G1垃圾收集器了解吗？</h2><p>Garbage First（简称G1）收集器是垃圾收集器的一个颠覆性的产物，它开创了局部收集的设计思路和基于Region的内存布局形式。</p><p>虽然G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异。以前的收集器分代是划分新生代、老年代、持久代等。</p><p>G1把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理。</p><img src="大厂面试之JVM篇.assets/1677503699536-80d2237a-f211-4729-915e-8a7a0466bc3f.png" alt="img" style="zoom:80%;" /><p>这样就避免了收集整个堆，而是按照若干个Region集进行收集，同时维护一个优先级列表，跟踪各个Region回收的“价值，优先收集价值高的Region。</p><p>G1收集器的运行过程大致可划分为以下四个步骤：</p><ul><li><strong>初始标记</strong>（initial mark），标记了从GC Root开始直接关联可达的对象。STW（Stop the World）执行。</li><li><strong>并发标记</strong>（concurrent marking），和用户线程并发执行，从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象、</li><li><strong>最终标记</strong>（Remark），STW，标记再并发标记过程中产生的垃圾。</li><li><strong>筛选回收</strong>（Live Data Counting And Evacuation），制定回收计划，选择多个Region 构成回收集，把回收集中Region的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间。需要STW。</li></ul><img src="大厂面试之JVM篇.assets/1677503701396-8ea8e792-40f7-4d04-a223-0e3a38d2460b.png" alt="img" style="zoom:80%;" /><h2 id="28-有了CMS，为什么还要引入G1？"><a href="#28-有了CMS，为什么还要引入G1？" class="headerlink" title="28.有了CMS，为什么还要引入G1？"></a>28.有了CMS，为什么还要引入G1？</h2><p>优点：CMS最主要的优点在名字上已经体现出来——并发收集、低停顿。</p><p>缺点：CMS同样有三个明显的缺点。</p><ul><li>Mark Sweep算法会导致内存碎片比较多</li><li>CMS的并发能力比较依赖于CPU资源，并发回收时垃圾收集线程可能会抢占用户线程的资源，导致用户程序性能下降。</li><li>并发清除阶段，用户线程依然在运行，会产生所谓的理“浮动垃圾”（Floating Garbage），本次垃圾收集无法处理浮动垃圾，必须到下一次垃圾收集才能处理。如果浮动垃圾太多，会触发新的垃圾回收，导致性能降低。</li></ul><p>G1主要解决了内存碎片过多的问题。</p><h2 id="29-你们线上用的什么垃圾收集器？为什么要用它？"><a href="#29-你们线上用的什么垃圾收集器？为什么要用它？" class="headerlink" title="29.你们线上用的什么垃圾收集器？为什么要用它？"></a>29.你们线上用的什么垃圾收集器？为什么要用它？</h2><p>怎么说呢，虽然调优说的震天响，但是我们一般都是用默认。管你Java怎么升，我用8，那么JDK1.8默认用的是什么呢？</p><p>可以使用命令：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">java <span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">PrintCommandLineFlags</span> <span class="token operator">-</span>version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到有这么一行：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">UseParallelGC</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>UseParallelGC</code> &#x3D; <code>Parallel Scavenge + Parallel Old</code>，表示的是新生代用的<code>Parallel Scavenge</code>收集器，老年代用的是<code>Parallel Old</code> 收集器。</p><p>那为什么要用这个呢？默认的呗。</p><p>当然面试肯定不能这么答。</p><p>Parallel Scavenge的特点是什么？</p><p>高吞吐，我们可以回答：因为我们系统是业务相对复杂，但并发并不是非常高，所以希望尽可能的利用处理器资源，出于提高吞吐量的考虑采用<code>Parallel Scavenge + Parallel Old</code>的组合。</p><p>当然，这个默认虽然也有说法，但不太讨喜。</p><p>还可以说：</p><p>采用<code>Parallel New</code>+<code>CMS</code>的组合，我们比较关注服务的响应速度，所以采用了CMS来降低停顿时间。</p><p>或者一步到位：</p><p>我们线上采用了设计比较优秀的G1垃圾收集器，因为它不仅满足我们低停顿的要求，而且解决了CMS的浮动垃圾问题、内存碎片问题。</p><h2 id="30-垃圾收集器应该如何选择？"><a href="#30-垃圾收集器应该如何选择？" class="headerlink" title="30.垃圾收集器应该如何选择？"></a>30.垃圾收集器应该如何选择？</h2><p>垃圾收集器的选择需要权衡的点还是比较多的——例如运行应用的基础设施如何？使用JDK的发行商是什么？等等……</p><p>这里简单地列一下上面提到的一些收集器的适用场景：</p><ul><li>Serial ：如果应用程序有一个很小的内存空间（大约100 MB）亦或它在没有停顿时间要求的单线程处理器上运行。</li><li>Parallel：如果优先考虑应用程序的峰值性能，并且没有时间要求要求，或者可以接受1秒或更长的停顿时间。</li><li>CMS&#x2F;G1：如果响应时间比吞吐量优先级高，或者垃圾收集暂停必须保持在大约1秒以内。</li><li>ZGC：如果响应时间是高优先级的，或者堆空间比较大。</li></ul><h2 id="31-对象一定分配在堆中吗？有没有了解逃逸分析技术？"><a href="#31-对象一定分配在堆中吗？有没有了解逃逸分析技术？" class="headerlink" title="31.对象一定分配在堆中吗？有没有了解逃逸分析技术？"></a>31.对象一定分配在堆中吗？有没有了解逃逸分析技术？</h2><p><strong>对象一定分配在堆中吗？</strong> 不一定的。</p><p>随着JIT编译期的发展与逃逸分析技术逐渐成熟，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。其实，在编译期间，JIT会对代码做很多优化。其中有一部分优化的目的就是减少内存堆分配压力，其中一种重要的技术叫做逃逸分析。</p><p><strong>什么是逃逸分析？</strong></p><p><strong>逃逸分析</strong>是指分析指针动态范围的方法，它同编译器优化原理的指针分析和外形分析相关联。当变量（或者对象）在方法中分配后，其指针有可能被返回或者被全局引用，这样就会被其他方法或者线程所引用，这种现象称作指针（或者引用）的逃逸(Escape)。</p><p>通俗点讲，当一个对象被new出来之后，它可能被外部所调用，如果是作为参数传递到外部了，就称之为方法逃逸。</p><img src="大厂面试之JVM篇.assets/1677503705162-76c1e695-027a-49b8-bc59-6ad2cd472f51.png" alt="img" style="zoom:80%;" /><p>除此之外，如果对象还有可能被外部线程访问到，例如赋值给可以在其它线程中访问的实例变量，这种就被称为线程逃逸。</p><img src="大厂面试之JVM篇.assets/1677503707324-75bf1124-c77f-4e62-be38-b4526a928082.png" alt="img" style="zoom:80%;" /><p><strong>逃逸分析的好处</strong></p><ul><li>栈上分配</li></ul><p>如果确定一个对象不会逃逸到线程之外，那么久可以考虑将这个对象在栈上分配，对象占用的内存随着栈帧出栈而销毁，这样一来，垃圾收集的压力就降低很多。</p><ul><li><strong>同步消除</strong></li></ul><p>线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争， 对这个变量实施的同步措施也就可以安全地消除掉。</p><ul><li><strong>标量替换</strong></li></ul><p>如果一个数据是基本数据类型，不可拆分，它就被称之为标量。把一个Java对象拆散，将其用到的成员变量恢复为原始类型来访问，这个过程就称为标量替换。假如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么可以不创建对象，直接用创建若干个成员变量代替，可以让对象的成员变量在栈上分配和读写。</p><h1 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h1><h2 id="32-有哪些常用的命令行性能监控和故障处理工具？"><a href="#32-有哪些常用的命令行性能监控和故障处理工具？" class="headerlink" title="32.有哪些常用的命令行性能监控和故障处理工具？"></a>32.有哪些常用的命令行性能监控和故障处理工具？</h2><ul><li><p>操作系统工具 </p></li><li></li><li><ul><li>top：显示系统整体资源使用情况</li><li>vmstat：监控内存和CPU</li><li>iostat：监控IO使用</li><li>netstat：监控网络使用</li></ul></li><li><p>JDK性能监控工具 </p></li><li></li><li><ul><li>jps：虚拟机进程查看</li><li>jstat：虚拟机运行时信息查看</li><li>jinfo：虚拟机配置查看</li><li>jmap：内存映像（导出）</li><li>jhat：堆转储快照分析</li><li>jstack：Java堆栈跟踪</li><li>jcmd：实现上面除了jstat外所有命令的功能</li></ul></li></ul><h2 id="33-了解哪些可视化的性能监控和故障处理工具？"><a href="#33-了解哪些可视化的性能监控和故障处理工具？" class="headerlink" title="33.了解哪些可视化的性能监控和故障处理工具？"></a>33.了解哪些可视化的性能监控和故障处理工具？</h2><p>以下是一些JDK自带的可视化性能监控和故障处理工具：</p><ul><li>JConsole</li></ul><img src="大厂面试之JVM篇.assets/1677503709595-5cb0ff29-7111-4784-b364-fd8fc9b0f527.png" alt="img" style="zoom:80%;" /><ul><li>VisualVM</li></ul><img src="大厂面试之JVM篇.assets/1677503711625-bea5de06-ce27-459a-a0d8-eedf487b697f.png" alt="img" style="zoom:80%;" /><ul><li>Java Mission Control</li></ul><img src="大厂面试之JVM篇.assets/1677503713831-5db9ba8c-71c3-4954-a084-e6acd2b520d1.png" alt="img" style="zoom:80%;" /><p>除此之外，还有一些第三方的工具：</p><ul><li><strong>MAT</strong></li></ul><p>Java 堆内存分析工具。</p><ul><li><strong>GChisto</strong></li></ul><p>GC 日志分析工具。</p><ul><li><strong>GCViewer</strong></li></ul><p><code>GC</code> 日志分析工具。</p><ul><li><strong>JProfiler</strong></li></ul><p>商用的性能分析利器。</p><ul><li><strong>arthas</strong></li></ul><p>阿里开源诊断工具。</p><ul><li><strong>async-profiler</strong></li></ul><p>Java 应用性能分析工具，开源、火焰图、跨平台。</p><h2 id="34-JVM的常见参数配置知道哪些？"><a href="#34-JVM的常见参数配置知道哪些？" class="headerlink" title="34.JVM的常见参数配置知道哪些？"></a>34.JVM的常见参数配置知道哪些？</h2><p>一些常见的参数配置：</p><p><strong>堆配置：</strong></p><ul><li>-Xms:初始堆大小</li><li>-Xmx：最大堆大小</li><li>-XX:NewSize&#x3D;n:设置年轻代大小</li><li>-XX:NewRatio&#x3D;n:设置年轻代和年老代的比值。如：为3表示年轻代和年老代比值为1：3，年轻代占整个年轻代年老代和的1&#x2F;4</li><li>-XX:SurvivorRatio&#x3D;n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如3表示Eden：3 Survivor：2，一个Survivor区占整个年轻代的1&#x2F;5</li><li>-XX:MaxPermSize&#x3D;n:设置持久代大小</li></ul><p><strong>收集器设置：</strong></p><ul><li>-XX:+UseSerialGC:设置串行收集器</li><li>-XX:+UseParallelGC:设置并行收集器</li><li>-XX:+UseParalledlOldGC:设置并行年老代收集器</li><li>-XX:+UseConcMarkSweepGC:设置并发收集器</li></ul><p><strong>并行收集器设置</strong></p><ul><li>-XX:ParallelGCThreads&#x3D;n:设置并行收集器收集时使用的CPU数。并行收集线程数</li><li>-XX:MaxGCPauseMillis&#x3D;n:设置并行收集最大的暂停时间（如果到这个时间了，垃圾回收器依然没有回收完，也会停止回收）</li><li>-XX:GCTimeRatio&#x3D;n:设置垃圾回收时间占程序运行时间的百分比。公式为：1&#x2F;(1+n)</li><li>-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况</li><li>-XX:ParallelGCThreads&#x3D;n:设置并发收集器年轻代手机方式为并行收集时，使用的CPU数。并行收集线程数</li></ul><p><strong>打印GC回收的过程日志信息</strong></p><ul><li>-XX:+PrintGC</li><li>-XX:+PrintGCDetails</li><li>-XX:+PrintGCTimeStamps</li><li>-Xloggc:filename</li></ul><h2 id="35-有做过JVM调优吗？"><a href="#35-有做过JVM调优吗？" class="headerlink" title="35.有做过JVM调优吗？"></a>35.有做过JVM调优吗？</h2><p>JVM调优是一件很严肃的事情，不是拍脑门就开始调优的，需要有严密的分析和监控机制，大概的一个JVM调优流程图：</p><img src="大厂面试之JVM篇.assets/1677503717013-a9f55da8-e038-4e83-af88-3759cdd3f3eb.png" alt="img" style="zoom:80%;" /><p>实际上，JVM调优是不得已而为之，有那功夫，好好把烂代码重构一下不比瞎调JVM强。</p><p>但是，面试官非要问怎么办？可以从处理问题的角度来回答（对应图中事后），这是一个中规中矩的案例：电商公司的运营后台系统，偶发性的引发OOM异常，堆内存溢出。</p><p>1、因为是偶发性的，所以第一次简单的认为就是堆内存不足导致，单方面的加大了堆内存从4G调整到8G  -Xms8g。</p><p>2、但是问题依然没有解决，只能从堆内存信息下手，通过开启了-XX:+HeapDumpOnOutOfMemoryError参数 获得堆内存的dump文件。</p><p>3、用JProfiler 对  堆dump文件进行分析，通过JProfiler查看到占用内存最大的对象是String对象，本来想跟踪着String对象找到其引用的地方，但dump文件太大，跟踪进去的时候总是卡死，而String对象占用比较多也比较正常，最开始也没有认定就是这里的问题，于是就从线程信息里面找突破点。</p><p>4、通过线程进行分析，先找到了几个正在运行的业务线程，然后逐一跟进业务线程看了下代码，有个方法引起了我的注意，<code>导出订单信息</code>。</p><p>5、因为订单信息导出这个方法可能会有几万的数据量，首先要从数据库里面查询出来订单信息，然后把订单信息生成excel，这个过程会产生大量的String对象。</p><p>6、为了验证自己的猜想，于是准备登录后台去测试下，结果在测试的过程中发现导出订单的按钮前端居然没有做点击后按钮置灰交互事件，后端也没有做防止重复提交，因为导出订单数据本来就非常慢，使用的人员可能发现点击后很久后页面都没反应，然后就一直点，结果就大量的请求进入到后台，堆内存产生了大量的订单对象和EXCEL对象，而且方法执行非常慢，导致这一段时间内这些对象都无法被回收，所以最终导致内存溢出。</p><p>7、知道了问题就容易解决了，最终没有调整任何JVM参数，只是做了两个处理：</p><ul><li>在前端的导出订单按钮上加上了置灰状态，等后端响应之后按钮才可以进行点击</li><li>后端代码加分布式锁，做防重处理</li></ul><p>这样双管齐下，保证导出的请求不会一直打到服务端，问题解决！</p><h2 id="36-线上服务CPU占用过高怎么排查？"><a href="#36-线上服务CPU占用过高怎么排查？" class="headerlink" title="36.线上服务CPU占用过高怎么排查？"></a>36.线上服务CPU占用过高怎么排查？</h2><p>问题分析：CPU高一定是某个程序长期占用了CPU资源。</p><img src="大厂面试之JVM篇.assets/1677503719891-a7619b05-6f64-47ef-8feb-48dbbc1400b0.png" alt="img" style="zoom:80%;" /><p>1、所以先需要找出那个进程占用CPU高。</p><ul><li>top  列出系统各个进程的资源占用情况。</li></ul><p>2、然后根据找到对应进行里哪个线程占用CPU高。</p><ul><li>top -Hp 进程ID  列出对应进程里面的线程占用资源情况</li></ul><p>3、找到对应线程ID后，再打印出对应线程的堆栈信息</p><ul><li>printf “%x\n”  PID  把线程ID转换为16进制。</li><li>jstack PID 打印出进程的所有线程信息，从打印出来的线程信息中找到上一步转换为16进制的线程ID对应的线程信息。</li></ul><p>4、最后根据线程的堆栈信息定位到具体业务方法,从代码逻辑中找到问题所在。</p><p>查看是否有线程长时间的watting 或blocked，如果线程长期处于watting状态下， 关注watting on xxxxxx，说明线程在等待这把锁，然后根据锁的地址找到持有锁的线程。</p><h2 id="37-内存飙高问题怎么排查？"><a href="#37-内存飙高问题怎么排查？" class="headerlink" title="37.内存飙高问题怎么排查？"></a>37.内存飙高问题怎么排查？</h2><p>分析：内存飚高如果是发生在java进程上，一般是因为创建了大量对象所导致，持续飚高说明垃圾回收跟不上对象创建的速度，或者内存泄露导致对象无法回收。</p><p>1、先观察垃圾回收的情况</p><ul><li>jstat -gc PID 1000 查看GC次数，时间等信息，每隔一秒打印一次。</li><li>jmap -histo PID | head -20  查看堆内存占用空间最大的前20个对象类型,可初步查看是哪个对象占用了内存。</li></ul><p>如果每次GC次数频繁，而且每次回收的内存空间也正常，那说明是因为对象创建速度快导致内存一直占用很高；如果每次回收的内存非常少，那么很可能是因为内存泄露导致内存一直无法被回收。</p><p>2、导出堆内存文件快照</p><ul><li>jmap -dump:live,format&#x3D;b,file&#x3D;&#x2F;home&#x2F;myheapdump.hprof PID  dump堆内存信息到文件。</li></ul><p>3、使用visualVM对dump文件进行离线分析，找到占用内存高的对象，再找到创建该对象的业务代码位置，从代码和业务场景中定位具体问题。</p><h2 id="38-频繁-minor-gc-怎么办？"><a href="#38-频繁-minor-gc-怎么办？" class="headerlink" title="38.频繁 minor gc 怎么办？"></a>38.频繁 minor gc 怎么办？</h2><p>优化Minor GC频繁问题：通常情况下，由于新生代空间较小，Eden区很快被填满，就会导致频繁Minor  GC，因此可以通过增大新生代空间<code>-Xmn</code>来降低Minor GC的频率。</p><h2 id="39-频繁Full-GC怎么办？"><a href="#39-频繁Full-GC怎么办？" class="headerlink" title="39.频繁Full GC怎么办？"></a>39.频繁Full GC怎么办？</h2><p>Full GC的排查思路大概如下：</p><ol><li>清楚从程序角度，有哪些原因导致FGC？</li></ol><ul><li><strong>大对象</strong>：系统一次性加载了过多数据到内存中（比如SQL查询未做分页），导致大对象进入了老年代。</li><li><strong>内存泄漏</strong>：频繁创建了大量对象，但是无法被回收（比如IO对象使用完后未调用close方法释放资源），先引发FGC，最后导致OOM.</li><li>程序频繁生成一些<strong>长生命周期的对象</strong>，当这些对象的存活年龄超过分代年龄时便会进入老年代，最后引发FGC. （即本文中的案例）</li><li><strong>程序BUG</strong></li><li>代码中<strong>显式调用了gc</strong>方法，包括自己的代码甚至框架中的代码。</li><li>JVM参数设置问题：包括总内存大小、新生代和老年代的大小、Eden区和S区的大小、元空间大小、垃圾回收算法等等。</li></ul><ol><li>清楚排查问题时能使用哪些工具</li></ol><ul><li>公司的监控系统：大部分公司都会有，可全方位监控JVM的各项指标。</li><li>JDK的自带工具，包括jmap、jstat等常用命令：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看堆内存各区域的使用率以及GC情况</span>jstat <span class="token parameter variable">-gcutil</span> <span class="token parameter variable">-h20</span> pid <span class="token number">1000</span><span class="token comment"># 查看堆内存中的存活对象，并按空间排序</span>jmap <span class="token parameter variable">-histo</span> pid <span class="token operator">|</span> <span class="token function">head</span> <span class="token parameter variable">-n20</span><span class="token comment"># dump堆内存文件</span>jmap <span class="token parameter variable">-dump:format</span><span class="token operator">=</span>b,file<span class="token operator">=</span>heap pid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>可视化的堆内存分析工具：JVisualVM、MAT等</li></ul><ol><li>排查指南</li></ol><ul><li>查看监控，以了解出现问题的时间点以及当前FGC的频率（可对比正常情况看频率是否正常）</li><li>了解该时间点之前有没有程序上线、基础组件升级等情况。</li><li>了解JVM的参数设置，包括：堆空间各个区域的大小设置，新生代和老年代分别采用了哪些垃圾收集器，然后分析JVM参数设置是否合理。</li><li>再对步骤1中列出的可能原因做排除法，其中元空间被打满、内存泄漏、代码显式调用gc方法比较容易排查。</li><li>针对大对象或者长生命周期对象导致的FGC，可通过 jmap -histo 命令并结合dump堆内存文件作进一步分析，需要先定位到可疑对象。</li><li>通过可疑对象定位到具体代码再次分析，这时候要结合GC原理和JVM参数设置，弄清楚可疑对象是否满足了进入到老年代的条件才能下结论。</li></ul><h2 id="40-有没有处理过内存泄漏问题？是如何定位的？"><a href="#40-有没有处理过内存泄漏问题？是如何定位的？" class="headerlink" title="40.有没有处理过内存泄漏问题？是如何定位的？"></a>40.有没有处理过内存泄漏问题？是如何定位的？</h2><p>内存泄漏是内在病源，外在病症表现可能有：</p><ul><li>应用程序长时间连续运行时性能严重下降</li><li>CPU 使用率飙升，甚至到 100%</li><li>频繁 Full GC，各种报警，例如接口超时报警等</li><li>应用程序抛出 <code>OutOfMemoryError</code> 错误</li><li>应用程序偶尔会耗尽连接对象</li></ul><p>严重<strong>内存泄漏</strong>往往伴随频繁的 <strong>Full GC</strong>，所以分析排查内存泄漏问题首先还得从查看 Full GC 入手。主要有以下操作步骤：</p><ol><li>使用 <code>jps</code> 查看运行的 Java 进程 ID </li><li>使用<code>top -p [pid]</code> 查看进程使用 CPU 和 MEM 的情况 </li><li>使用 <code>top -Hp [pid]</code> 查看进程下的所有线程占 CPU 和 MEM 的情况 </li><li>将线程 ID 转换为 16 进制：<code>printf &quot;%x\n&quot; [pid]</code>，输出的值就是线程栈信息中的 <strong>nid</strong>。<br>   例如：<code>printf &quot;%x\n&quot; 29471</code>，换行输出 <strong>731f</strong>。 </li><li>抓取线程栈：<code>jstack 29452 &gt; 29452.txt</code>，可以多抓几次做个对比。<br>   在线程栈信息中找到对应线程号的 16 进制值，如下是 <strong>731f</strong> 线程的信息。线程栈分析可使用 Visualvm 插件 <strong>TDA</strong>。</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token string">"Service Thread"</span> <span class="token comment">#7 daemon prio=9 os_prio=0 tid=0x00007fbe2c164000 nid=0x731f runnable [0x0000000000000000]</span>   java.lang.Thread.State: RUNNABLE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>使用<code>jstat -gcutil [pid] 5000 10</code> 每隔 5 秒输出 GC 信息，输出 10 次，查看 <strong>YGC</strong> 和 <strong>Full GC</strong> 次数。通常会出现 YGC 不增加或增加缓慢，而 Full GC 增加很快。<br>   或使用 <code>jstat -gccause [pid] 5000</code> ，同样是输出 GC 摘要信息。<br>   或使用 <code>jmap -heap [pid]</code> 查看堆的摘要信息，关注老年代内存使用是否达到阀值，若达到阀值就会执行 Full GC。 </li><li>如果发现 <code>Full GC</code> 次数太多，就很大概率存在内存泄漏了 </li><li>使用 <code>jmap -histo:live [pid]</code> 输出每个类的对象数量，内存大小(字节单位)及全限定类名。 </li><li>生成 <code>dump</code> 文件，借助工具分析哪 个对象非常多，基本就能定位到问题在那了<br>   使用 jmap 生成 dump 文件：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># jmap -dump:live,format=b,file=29471.dump 29471</span>Dumping heap to /root/dump <span class="token punctuation">..</span>.Heap dump <span class="token function">file</span> created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以使用 <strong>jhat</strong> 命令分析：<code>jhat -port 8000 29471.dump</code>，浏览器访问 jhat 服务，端口是 8000。<br>通常使用图形化工具分析，如 JDK 自带的 <strong>jvisualvm</strong>，从菜单 &gt; 文件 &gt; 装入 dump 文件。<br>或使用第三方式具分析的，如 <strong>JProfiler</strong> 也是个图形化工具，<strong>GCViewer</strong> 工具。Eclipse 或以使用 MAT 工具查看。或使用在线分析平台 <strong>GCEasy</strong>。<br>注意：如果 dump 文件较大的话，分析会占比较大的内存。<br>基本上就可以定位到代码层的逻辑了。 </p><ol><li></li><li><ol><li>在 dump 文析结果中查找存在大量的对象，再查对其的引用。</li><li>dump 文件分析</li></ol></li></ol><h2 id="41-有没有处理过内存溢出问题？"><a href="#41-有没有处理过内存溢出问题？" class="headerlink" title="41.有没有处理过内存溢出问题？"></a>41.有没有处理过内存溢出问题？</h2><p>内存泄漏和内存溢出二者关系非常密切，内存溢出可能会有很多原因导致，内存泄漏最可能的罪魁祸首之一。</p><p>排查过程和排查内存泄漏过程类似。</p><h1 id="虚拟机执行"><a href="#虚拟机执行" class="headerlink" title="虚拟机执行"></a>虚拟机执行</h1><h2 id="42-能说一下类的生命周期吗？"><a href="#42-能说一下类的生命周期吗？" class="headerlink" title="42.能说一下类的生命周期吗？"></a>42.能说一下类的生命周期吗？</h2><p>一个类从被加载到虚拟机内存中开始，到从内存中卸载，整个生命周期需要经过七个阶段：加载 （Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化 （Initialization）、使用（Using）和卸载（Unloading），其中验证、准备、解析三个部分统称为连接（Linking）。</p><img src="大厂面试之JVM篇.assets/1677503725054-aae0538c-dadd-4f1d-bd5b-bae244a071db.png" alt="img" style="zoom:80%;" /><h2 id="43-类加载的过程知道吗？"><a href="#43-类加载的过程知道吗？" class="headerlink" title="43.类加载的过程知道吗？"></a>43.类加载的过程知道吗？</h2><p>加载是JVM加载的起点，具体什么时候开始加载，《Java虚拟机规范》中并没有进行强制约束，可以交给虚拟机的具体实现来自由把握。</p><p>在加载过程，JVM要做三件事情：</p><img src="大厂面试之JVM篇.assets/1677503726689-58741f6c-bad1-4a6d-9513-2e3135990d20.png" alt="img" style="zoom:80%;" /><ul><li>1）通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ul><p>加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，方法区中的数据存储格式完全由虚拟机实现自行定义，《Java虚拟机规范》未规定此区域的具体数据结构。</p><p>类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象， 这个对象将作为程序访问方法区中的类型数据的外部接口。</p><h2 id="44-类加载器有哪些？"><a href="#44-类加载器有哪些？" class="headerlink" title="44.类加载器有哪些？"></a>44.类加载器有哪些？</h2><p>主要有四种类加载器:</p><ul><li><strong>启动类加载器</strong>(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。</li><li><strong>扩展类加载器</strong>(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li><li><strong>系统类加载器</strong>（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过ClassLoader.getSystemClassLoader()来获取它。</li><li><strong>用户自定义类加载器</strong> (user class loader)，用户通过继承 java.lang.ClassLoader类的方式自行实现的类加载器。</li></ul><h2 id="45-什么是双亲委派机制？"><a href="#45-什么是双亲委派机制？" class="headerlink" title="45.什么是双亲委派机制？"></a>45.什么是双亲委派机制？</h2><img src="大厂面试之JVM篇.assets/1677503728577-ddb773c5-bd83-4f31-80a3-75dcadcf890e.png" alt="img" style="zoom:80%;" /><p>双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。</p><h2 id="46-为什么要用双亲委派机制？"><a href="#46-为什么要用双亲委派机制？" class="headerlink" title="46.为什么要用双亲委派机制？"></a>46.为什么要用双亲委派机制？</h2><p>答案是为了保证应用程序的稳定有序。</p><p>例如类java.lang.Object，它存放在rt.jar之中，通过双亲委派机制，保证最终都是委派给处于模型最顶端的启动类加载器进行加载，保证Object的一致。反之，都由各个类加载器自行去加载的话，如果用户自己也编写了一个名为java.lang.Object的类，并放在程序的 ClassPath中，那系统中就会出现多个不同的Object类。</p><h2 id="47-如何破坏双亲委派机制？"><a href="#47-如何破坏双亲委派机制？" class="headerlink" title="47.如何破坏双亲委派机制？"></a>47.如何破坏双亲委派机制？</h2><p>如果不想打破双亲委派模型，就重写ClassLoader类中的fifindClass()方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。而如果想打破双亲委派模型则需要重写loadClass()方法。</p><h2 id="48-历史上有哪几次双亲委派机制的破坏？"><a href="#48-历史上有哪几次双亲委派机制的破坏？" class="headerlink" title="48.历史上有哪几次双亲委派机制的破坏？"></a>48.历史上有哪几次双亲委派机制的破坏？</h2><p>双亲委派机制在历史上主要有三次破坏：</p><img src="大厂面试之JVM篇.assets/1677503730859-62e0862f-baf6-4264-b5ac-dfa5404b9591.png" alt="img" style="zoom:80%;" /><p><strong>第一次破坏</strong></p><p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK 1.2面世以前的“远古”时代。</p><p>由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类  java.lang.ClassLoader则在Java的第一个版本中就已经存在，为了向下兼容旧代码，所以无法以技术手段避免loadClass()被子类覆盖的可能性，只能在JDK 1.2之后的java.lang.ClassLoader中添加一个新的  protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在 loadClass()中编写代码。</p><p><strong>第二次破坏</strong></p><p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，如果有基础类型又要调用回用户的代码，那该怎么办呢？</p><p>例如我们比较熟悉的JDBC:</p><p>各个厂商各有不同的JDBC的实现，Java在核心包<code>\lib</code>里定义了对应的SPI，那么这个就毫无疑问由<code>启动类加载器</code>加载器加载。</p><p>但是各个厂商的实现，是没办法放在核心包里的，只能放在<code>classpath</code>里，只能被<code>应用类加载器</code>加载。那么，问题来了，启动类加载器它就加载不到厂商提供的SPI服务代码。</p><p>为了解决这个问题，引入了一个不太优雅的设计：线程上下文类加载器 （Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContext-ClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p><p>JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为。</p><p><strong>第三次破坏</strong></p><p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的，例如代码热替换（Hot Swap）、模块热部署（Hot Deployment）等。</p><p>OSGi实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi中称为 Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。</p><h2 id="49-你觉得应该怎么实现一个热部署功能？"><a href="#49-你觉得应该怎么实现一个热部署功能？" class="headerlink" title="49.你觉得应该怎么实现一个热部署功能？"></a>49.你觉得应该怎么实现一个热部署功能？</h2><p>我们已经知道了Java类的加载过程。一个Java类文件到虚拟机里的对象，要经过如下过程:首先通过Java编译器，将Java文件编译成class字节码，类加载器读取class字节码，再将类转化为实例，对实例newInstance就可以生成对象。</p><p>类加载器ClassLoader功能，也就是将class字节码转换到类的实例。在Java应用中，所有的实例都是由类加载器，加载而来。</p><p>一般在系统中，类的加载都是由系统自带的类加载器完成，而且对于同一个全限定名的java类（如com.csiar.soc.HelloWorld），只能被加载一次，而且无法被卸载。</p><p>这个时候问题就来了，如果我们希望将java类卸载，并且替换更新版本的java类，该怎么做呢？</p><p>既然在类加载器中，Java类只能被加载一次，并且无法卸载。那么我们是不是可以直接把Java类加载器干掉呢？答案是可以的，我们可以自定义类加载器，并重写ClassLoader的findClass方法。</p><p>想要实现热部署可以分以下三个步骤：</p><ol><li>销毁原来的自定义ClassLoader</li><li>更新class类文件</li><li>创建新的ClassLoader去加载更新后的class类文件。</li></ol><p>到此，一个热部署的功能就这样实现了。</p><h2 id="50-Tomcat的类加载机制了解吗？"><a href="#50-Tomcat的类加载机制了解吗？" class="headerlink" title="50.Tomcat的类加载机制了解吗？"></a>50.Tomcat的类加载机制了解吗？</h2><p>Tomcat是主流的Java Web服务器之一，为了实现一些特殊的功能需求，自定义了一些类加载器。</p><p>Tomcat类加载器如下：</p><img src="大厂面试之JVM篇.assets/1677503734187-ee8c8874-1bd5-4411-ba8d-190d63d0edf7.png" alt="img" style="zoom:80%;" /><p>Tomcat实际上也是破坏了双亲委派模型的。</p><p>Tomact是web容器，可能需要部署多个应用程序。不同的应用程序可能会依赖同一个第三方类库的不同版本，但是不同版本的类库中某一个类的全路径名可能是一样的。如多个应用都要依赖hollis.jar，但是A应用需要依赖1.0.0版本，但是B应用需要依赖1.0.1版本。这两个版本中都有一个类是com.hollis.Test.class。如果采用默认的双亲委派类加载机制，那么无法加载多个相同的类。</p><p>所以，Tomcat破坏了<strong>双亲委派原则</strong>，提供隔离的机制，为每个web容器单独提供一个WebAppClassLoader加载器。每一个WebAppClassLoader负责加载本身的目录下的class文件，加载不到时再交CommonClassLoader加载，这和双亲委派刚好相反。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大厂面试之JVM篇&quot;&gt;&lt;a href=&quot;#大厂面试之JVM篇&quot; class=&quot;headerlink&quot; title=&quot;大厂面试之JVM篇&quot;&gt;&lt;/a&gt;大厂面试之JVM篇&lt;/h1&gt;&lt;h1 id=&quot;1-什么是JVM&quot;&gt;&lt;a href=&quot;#1-什么是JVM&quot; class=&quot;</summary>
      
    
    
    
    <category term="PROJECT" scheme="https://zspcer.gitee.io/categories/PROJECT/"/>
    
    <category term="我要进大厂" scheme="https://zspcer.gitee.io/categories/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/"/>
    
    
    <category term="面试" scheme="https://zspcer.gitee.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="我要进大厂" scheme="https://zspcer.gitee.io/tags/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/"/>
    
    <category term="JVM" scheme="https://zspcer.gitee.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>大厂面试之并发篇</title>
    <link href="https://zspcer.gitee.io/note/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87/"/>
    <id>https://zspcer.gitee.io/note/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87/</id>
    <published>2023-05-04T16:09:14.000Z</published>
    <updated>2023-05-05T07:52:55.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-并行跟并发有什么区别？"><a href="#1-并行跟并发有什么区别？" class="headerlink" title="1.并行跟并发有什么区别？"></a>1.并行跟并发有什么区别？</h2><p>从操作系统的角度来看，线程是CPU分配的最小单位。</p><p>并行就是同一时刻，两个线程都在执行。这就要求有两个CPU去分别执行两个线程。</p><p>并发就是同一时刻，只有一个执行，但是一个时间段内，两个线程都执行了。并发的实现依赖于CPU切换线程，因为切换的时间特别短，所以基本对于用户是无感知的。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356856068-60c252d0-0bee-4505-9459-a9ed484347d2.png" alt="img"></p><p>就好像我们去食堂打饭，并行就是我们在多个窗口排队，几个阿姨同时打菜；并发就是我们挤在一个窗口，阿姨给这个打一勺，又手忙脚乱地给那个打一勺。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356858559-42ae25c0-e161-4cb1-af5d-41efc1f3ffd8.png" alt="img"></p><p><strong>说说什么是进程和线程？</strong></p><p>要说线程，必须得先说说进程。</p><p>进程：进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。</p><p>线程：线程是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的资源。</p><p>操作系统在分配资源时是把资源分配给进程的， 但是 CPU 资源比较特殊，它是被分配到线程的，因为真正要占用CPU运行的是线程，所以也说线程是 CPU分配的基本单位。</p><p>比如在Java中，当我们启动 main 函数其实就启动了一个JVM进程，而 main 函数在的线程就是这个进程中的一个线程，也称主线程。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356861050-55c02990-7266-403f-b556-1b631fb554c7.png" alt="img"></p><p>一个进程中有多个线程，多个线程共用进程的堆和方法区资源，但是每个线程有自己的程序计数器和栈。</p><h2 id="2-说说线程有几种创建方式？"><a href="#2-说说线程有几种创建方式？" class="headerlink" title="2.说说线程有几种创建方式？"></a>2.说说线程有几种创建方式？</h2><p>Java中创建线程主要有三种方式，分别为继承Thread类、实现Runnable接口、实现Callable接口。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356864456-1d2c6770-9305-475b-9d77-cda9edba0a75.png" alt="img"></p><p>继承Thread类，重写run()方法，调用start()方法启动线程</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadTest</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 继承Thread类     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"This is child thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">MyThread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现 Runnable 接口，重写run()方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RunnableTask</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Runnable!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">RunnableTask</span> task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RunnableTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面两种都是没有返回值的，但是如果我们需要获取线程的执行结果，该怎么办呢？</p><p>实现Callable接口，重写call()方法，这种方式可以通过FutureTask获取任务执行的返回值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CallerTask</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">"Hello,i am running!"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//创建异步任务</span>        <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> task<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CallerTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//启动线程</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//等待执行完成，并获取返回结果</span>            <span class="token class-name">String</span> result<span class="token operator">=</span>task<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-为什么调用start-方法时会执行run-方法，那怎么不直接调用run-方法？"><a href="#3-为什么调用start-方法时会执行run-方法，那怎么不直接调用run-方法？" class="headerlink" title="3.为什么调用start()方法时会执行run()方法，那怎么不直接调用run()方法？"></a>3.为什么调用start()方法时会执行run()方法，那怎么不直接调用run()方法？</h2><p>JVM执行start方法，会先创建一条线程，由创建出来的新线程去执行thread的run方法，这才起到多线程的效果。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356869600-2116241a-4118-45e6-b2f7-6ad5e51b52ba.png" alt="img"></p><p><strong>为什么我们不能直接调用run()方法？</strong>也很清楚， 如果直接调用Thread的run()方法，那么run方法还是运行在主线程中，相当于顺序执行，就起不到多线程的效果。</p><h2 id="4-线程有哪些常用的调度方法？"><a href="#4-线程有哪些常用的调度方法？" class="headerlink" title="4.线程有哪些常用的调度方法？"></a>4.线程有哪些常用的调度方法？</h2><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356872732-0675abf4-07ef-42cb-80f4-5c0db2673266.png" alt="img"></p><p><strong>线程等待与通知</strong></p><p>在Object类中有一些函数可以用于线程的等待与通知。</p><p><code>wait()</code>：当一个线程A调用一个共享变量的 wait()方法时， 线程A会被阻塞挂起， 发生下面几种情况才会返回 ：</p><ul><li><p>线程A调用了共享对象 notify()或者 notifyAll()方法； </p></li><li><p>其他线程调用了线程A的 interrupt() 方法，线程A抛出InterruptedException异常返回。</p></li></ul><p><code>wait(long timeout)</code> ：这个方法相比 wait() 方法多了一个超时参数，它的不同之处在于，如果线程A调用共享对象的wait(long timeout)方法后，没有在指定的 timeout ms时间内被其它线程唤醒，那么这个方法还是会因为超时而返回。</p><p><code>wait(long timeout, int nanos)</code>：其内部调用的是 wait(long timout）函数。</p><p>上面是线程等待的方法，而唤醒线程主要是下面两个方法：</p><p><code>notify()</code> : 一个线程A调用共享对象的 notify() 方法后，会唤醒一个在这个共享变量上调用 wait 系列方法后被挂起的线程。一个共享变量上可能会有多个线程在等待，具体唤醒哪个等待的线程是随机的。</p><p><code>notifyAll()</code>：不同于在共享变量上调用 notify() 函数会唤醒被阻塞到该共享变量上的一个线程，notifyAll()方法则会唤醒所有在该共享变量上由于调用 wait 系列方法而被挂起的线程。</p><p>问：那如果在synchronized代码块中间部分执行了wait方法，当该线程被再次notify唤醒的时候，是从哪里开始执行的？</p><ul><li>被再次唤醒notify的时候，该线程会重新开始竞争锁；</li><li>竞争到之后，从wait()处往后执行</li></ul><p>下面是一段的验证的代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WaitNotifyDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">SimpleDateFormat</span> sf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sf<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"：Thread 1 get lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sf<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"：Thread 1 is waiting"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        lock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在synchronized代码块中间部分执行wait方法</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sf<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"：Thread 1 continue。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sf<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"：Thread 2 get lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    lock<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sf<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"：Thread 2 notify"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sf<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"：Thread 2 released lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待t1线程先执行</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Thread类也提供了一个方法用于等待的方法：</p><p><code>join()</code>：如果一个线程A执行了threadB.join()语句，其含义是：当前线程A等待threadB线程执行完成之后才可以继续执行。</p><p><strong>线程休眠</strong></p><p><code>sleep(long millis)</code>  :Thread类中的静态方法，当一个执行中的线程A调用了Thread 的sleep方法后，线程A会暂时让出指定时间的执行权，但是线程A所拥有的监视器资源，比如锁还是持有不让出的。指定的睡眠时间到了后该函数会正常返回，接着参与 CPU 的调度，获取到 CPU 资源后就可以继续运行。</p><p><strong>让出优先权</strong></p><p><code>yield()</code>：Thread类中的静态方法，当一个线程调用 yield 方法时，实际就是在暗示线程调度器当前线程请求让出自己的CPU ，但是线程调度器可以无条件忽略这个暗示。</p><p><strong>线程中断</strong></p><p>Java 中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理。</p><p><code>void interrupt()</code> ：中断线程，例如，当线程A运行时，线程B可以调用钱程interrupt() 方法来设置线程的中断标志为true 并立即返回。设置标志仅仅是设置标志, 线程A实际并没有被中断， 会继续往下执行。</p><p><code>boolean isInterrupted()</code>方法：检测当前线程是否被中断。</p><p><code>boolean interrupted()</code> 方法：检测当前线程是否被中断，与 isInterrupted 不同的是，该方法如果发现当前线程被中断，则会清除中断标志。</p><h2 id="5-线程有几种状态？"><a href="#5-线程有几种状态？" class="headerlink" title="5.线程有几种状态？"></a>5.线程有几种状态？</h2><p>在Java中，线程共有六种状态：</p><p>java.lang.Thread.State</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * A thread state.  A thread can be in one of the following states: * NEW *     A thread that has not yet started is in this state. * RUNNABLE *     A thread executing in the Java virtual machine is in this state. * BLOCKED *     A thread that is blocked waiting for a monitor lock is in this state. * WAITING *     A thread that is waiting indefinitely for another thread to *     perform a particular action is in this state. * TIMED_WAITING *     A thread that is waiting for another thread to perform an action *     for up to a specified waiting time is in this state. * TERMINATED *     A thread that has exited is in this state. *  * A thread can be in only one state at a given point in time. * These states are virtual machine states which do not reflect * any operating system thread states. * * @since   1.5 * @see #getState */</span><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">State</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * Thread state for a thread which has not yet started.     */</span>    <span class="token constant">NEW</span><span class="token punctuation">,</span>    <span class="token comment">/**     * Thread state for a runnable thread.  A thread in the runnable     * state is executing in the Java virtual machine but it may     * be waiting for other resources from the operating system     * such as processor.     */</span>    <span class="token constant">RUNNABLE</span><span class="token punctuation">,</span>    <span class="token comment">/**     * Thread state for a thread blocked waiting for a monitor lock.     * A thread in the blocked state is waiting for a monitor lock     * to enter a synchronized block/method or     * reenter a synchronized block/method after calling     * &#123;@link Object#wait() Object.wait&#125;.     */</span>    <span class="token constant">BLOCKED</span><span class="token punctuation">,</span>    <span class="token comment">/**     * Thread state for a waiting thread.     * A thread is in the waiting state due to calling one of the     * following methods:     * &lt;ul>     *   &lt;li>&#123;@link Object#wait() Object.wait&#125; with no timeout&lt;/li>     *   &lt;li>&#123;@link #join() Thread.join&#125; with no timeout&lt;/li>     *   &lt;li>&#123;@link LockSupport#park() LockSupport.park&#125;&lt;/li>     * &lt;/ul>     *     * &lt;p>A thread in the waiting state is waiting for another thread to     * perform a particular action.     *     * For example, a thread that has called &lt;tt>Object.wait()&lt;/tt>     * on an object is waiting for another thread to call     * &lt;tt>Object.notify()&lt;/tt> or &lt;tt>Object.notifyAll()&lt;/tt> on     * that object. A thread that has called &lt;tt>Thread.join()&lt;/tt>     * is waiting for a specified thread to terminate.     */</span>    <span class="token constant">WAITING</span><span class="token punctuation">,</span>    <span class="token comment">/**     * Thread state for a waiting thread with a specified waiting time.     * A thread is in the timed waiting state due to calling one of     * the following methods with a specified positive waiting time:     * &lt;ul>     *   &lt;li>&#123;@link #sleep Thread.sleep&#125;&lt;/li>     *   &lt;li>&#123;@link Object#wait(long) Object.wait&#125; with timeout&lt;/li>     *   &lt;li>&#123;@link #join(long) Thread.join&#125; with timeout&lt;/li>     *   &lt;li>&#123;@link LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li>     *   &lt;li>&#123;@link LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li>     * &lt;/ul>     */</span>    <span class="token constant">TIMED_WAITING</span><span class="token punctuation">,</span>    <span class="token comment">/**     * Thread state for a terminated thread.     * The thread has completed execution.     */</span>    <span class="token constant">TERMINATED</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>线程在自身的生命周期中， 并不是固定地处于某个状态，而是随着代码的执行在不同的状态之间进行切换，Java线程状态变化如图示：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356875839-b8ec0b34-f58e-4519-8fe6-8bbe22346917.png" alt="img"></p><h2 id="6-什么是线程上下文切换？"><a href="#6-什么是线程上下文切换？" class="headerlink" title="6.什么是线程上下文切换？"></a>6.什么是线程上下文切换？</h2><p>使用多线程的目的是为了充分利用CPU，但是我们知道，并发其实是一个CPU来应付多个线程。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356878653-9db9598b-2bfa-4450-a4d5-8229c40d2f5e.png" alt="img"></p><p>为了让用户感觉多个线程是在同时执行的， CPU 资源的分配采用了时间片轮转也就是给每个线程分配一个时间片，线程在时间片内占用 CPU 执行任务。当线程使用完时间片后，就会处于就绪状态并让出 CPU 让其他线程占用，这就是上下文切换。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356880629-de630971-80d3-4883-949f-107dd000636a.png" alt="img"></p><h2 id="7-守护线程了解吗？"><a href="#7-守护线程了解吗？" class="headerlink" title="7.守护线程了解吗？"></a>7.守护线程了解吗？</h2><p>Java中的线程分为两类，分别为 daemon 线程（守护线程）和 user 线程（用户线程）。</p><p>在JVM 启动时会调用 main 函数，main函数所在的钱程就是一个用户线程。其实在 JVM 内部同时还启动了很多守护线程， 比如垃圾回收线程。</p><p>那么守护线程和用户线程有什么区别呢？区别之一是当最后一个非守护线程束时， JVM会正常退出，而不管当前是否存在守护线程，也就是说守护线程是否结束并不影响 JVM退出。换而言之，只要有一个用户线程还没结束，正常情况下JVM就不会退出。</p><h2 id="8-线程间有哪些通信方式？"><a href="#8-线程间有哪些通信方式？" class="headerlink" title="8.线程间有哪些通信方式？"></a>8.线程间有哪些通信方式？</h2><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356883131-dc718227-8210-40cc-8646-f5e317ff62f0.png" alt="img"></p><p><strong>volatile和synchronized关键字</strong></p><p>关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。</p><p>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</p><p><strong>等待&#x2F;通知机制</strong></p><p>可以通过Java内置的等待&#x2F;通知机制（wait()&#x2F;notify()）实现一个线程修改一个对象的值，而另一个线程感知到了变化，然后进行相应的操作。</p><p><strong>管道输入&#x2F;输出流</strong></p><p>管道输入&#x2F;输出流和普通的文件输入&#x2F;输出流或者网络输入&#x2F;输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。</p><p>管道输入&#x2F;输出流主要包括了如下4种具体实现：PipedOutputStream、PipedInputStream、 PipedReader和PipedWriter，前两种面向字节，而后两种面向字符。</p><p><strong>使用Thread.join()</strong></p><p>如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。。线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法。</p><p><strong>使用ThreadLocal</strong></p><p>ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。</p><p>可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值。</p><p>关于多线程，其实很大概率还会出一些笔试题，比如交替打印、银行转账、生产消费模型等等，后面陈哥会单独出一期来盘点一下常见的多线程笔试题。</p><h2 id="9-ThreadLocal是什么？"><a href="#9-ThreadLocal是什么？" class="headerlink" title="9.ThreadLocal是什么？"></a>9.ThreadLocal是什么？</h2><p>ThreadLocal，也就是线程本地变量。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356885915-22e308f5-9086-4cf9-87b4-79c66f2a9e72.png" alt="img"></p><p><strong>创建</strong></p><p>创建了一个ThreadLoca变量localVariable，任何一个线程都能并发访问localVariable。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//创建一个ThreadLocal变量</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> localVariable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>写入</strong></p><p>线程可以在任何地方使用localVariable，写入变量。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">localVariable<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>"鄙人三某”<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>读取</strong></p><p>线程在任何地方读取的都是它写入的变量。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">localVariable<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="10-你在工作中用到过ThreadLocal吗？"><a href="#10-你在工作中用到过ThreadLocal吗？" class="headerlink" title="10.你在工作中用到过ThreadLocal吗？"></a>10.你在工作中用到过ThreadLocal吗？</h2><p>有用到过的，用来做用户信息上下文的存储。</p><p>我们的系统应用是一个典型的MVC架构，登录后的用户每次访问接口，都会在请求头中携带一个token，在控制层可以根据这个token，解析出用户的基本信息。那么问题来了，假如在服务层和持久层都要用到用户信息，比如rpc调用、更新用户获取等等，那应该怎么办呢？</p><p>一种办法是显式定义用户相关的参数，比如账号、用户名……这样一来，我们可能需要大面积地修改代码，多少有点瓜皮，那该怎么办呢？</p><p>这时候我们就可以用到ThreadLocal，在控制层拦截请求把用户信息存入ThreadLocal，这样我们在任何一个地方，都可以取出ThreadLocal中存的用户数据。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356889513-0edc8073-1121-41f7-ab40-4b1cd14b97cb.png" alt="img"></p><p>很多其它场景的cookie、session等等数据隔离也都可以通过ThreadLocal去实现。</p><p>我们常用的数据库连接池也用到了ThreadLocal：</p><ul><li>数据库连接池的连接交给ThreadLoca进行管理，保证当前线程的操作都是同一个Connnection。</li></ul><h2 id="11-ThreadLocal怎么实现的呢？"><a href="#11-ThreadLocal怎么实现的呢？" class="headerlink" title="11.ThreadLocal怎么实现的呢？"></a>11.ThreadLocal怎么实现的呢？</h2><p>我们看一下ThreadLocal的set(T)方法，发现先获取到当前线程，再获取<code>ThreadLocalMap</code>，然后把元素存到这个map中。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">T</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//获取当前线程</span>    <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//获取ThreadLocalMap</span>    <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//讲当前元素存入map</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ThreadLocal实现的秘密都在这个<code>ThreadLocalMap</code>了，可以Thread类中定义了一个类型为<code>ThreadLocal.ThreadLocalMap</code>的成员变量<code>threadLocals</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>   <span class="token comment">//ThreadLocal.ThreadLocalMap是Thread的属性</span>   <span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span> threadLocals <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>ThreadLocalMap既然被称为Map，那么毫无疑问它是&lt;key,value&gt;型的数据结构。我们都知道map的本质是一个个&lt;key,value&gt;形式的节点组成的数组，那ThreadLocalMap的节点是什么样的呢？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ThreadLocal</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">/** The value associated with this ThreadLocal. */</span>    <span class="token class-name">Object</span> value<span class="token punctuation">;</span>    <span class="token comment">//节点类</span>    <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> k<span class="token punctuation">,</span> <span class="token class-name">Object</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//key赋值</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//value赋值</span>        value <span class="token operator">=</span> v<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的节点，key可以简单低视作ThreadLocal，value为代码中放入的值，当然实际上key并不是ThreadLocal本身，而是它的一个<strong>弱引用</strong>，可以看到Entry的key继承了 WeakReference（弱引用），再来看一下key怎么赋值的：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">WeakReference</span><span class="token punctuation">(</span><span class="token class-name">T</span> referent<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>referent<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>key的赋值，使用的是WeakReference的赋值。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356894039-95594a5d-6b20-436b-9914-1b35fb231544.png" alt="img"></p><p>所以，怎么回答ThreadLocal原理？要答出这几个点：</p><p>1、Thread类有一个类型为ThreadLocal.ThreadLocalMap的实例变量threadLocals，每个线程都有一个属于自己的ThreadLocalMap。</p><p>2、ThreadLocalMap内部维护着Entry数组，每个Entry代表一个完整的对象，key是ThreadLocal的弱引用，value是ThreadLocal的泛型值。</p><p>3、每个线程在往ThreadLocal里设置值的时候，都是往自己的ThreadLocalMap里存，读也是以某个ThreadLocal作为引用，在自己的map里找对应的key，从而实现了线程隔离。</p><p>4、ThreadLocal本身不存储值，它只是作为一个key来让线程往ThreadLocalMap里存取值。</p><h2 id="12-ThreadLocal-内存泄露是怎么回事？"><a href="#12-ThreadLocal-内存泄露是怎么回事？" class="headerlink" title="12.ThreadLocal 内存泄露是怎么回事？"></a>12.ThreadLocal 内存泄露是怎么回事？</h2><p>我们先来分析一下使用ThreadLocal时的内存，我们都知道，在JVM中，栈内存线程私有，存储了对象的引用，堆内存线程共享，存储了对象实例。</p><p>所以呢，栈中存储了ThreadLocal、Thread的引用，堆中存储了它们的具体实例。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356896514-11c611d6-f041-47e5-84a7-7c1b49864c97.png" alt="img"></p><p>ThreadLocalMap中使用的 key 为 ThreadLocal 的弱引用。</p><p>“弱引用：只要垃圾回收机制一运行，不管JVM的内存空间是否充足，都会回收该对象占用的内存。”</p><p>那么现在问题就来了，弱引用很容易被回收，如果ThreadLocal（ThreadLocalMap的Key）被垃圾回收器回收了，但是ThreadLocalMap生命周期和Thread是一样的，它这时候如果不被回收，就会出现这种情况：ThreadLocalMap的key没了，value还在，这就会<strong>造成了内存泄漏问题</strong>。</p><p><strong>那怎么解决内存泄漏问题呢？</strong></p><p>很简单，使用完ThreadLocal后，及时调用remove()方法释放内存空间。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> localVariable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    localVariable<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>"鄙人三某”<span class="token punctuation">)</span><span class="token punctuation">;</span>    ……<span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>    localVariable<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>那为什么key还要设计成弱引用？</strong></p><p>key设计成弱引用同样是为了防止内存泄漏。</p><p>假如key被设计成强引用，如果ThreadLocal Reference被销毁，此时它指向ThreadLoca的强引用就没有了，但是此时key还强引用指向ThreadLoca，就会导致ThreadLocal不能被回收，这时候就发生了内存泄漏的问题。</p><h2 id="13-ThreadLocalMap的结构了解吗？"><a href="#13-ThreadLocalMap的结构了解吗？" class="headerlink" title="13.ThreadLocalMap的结构了解吗？"></a>13.ThreadLocalMap的结构了解吗？</h2><p>ThreadLocalMap虽然被叫做Map，其实它是没有实现Map接口的，但是结构还是和HashMap比较类似的，主要关注的是两个要素：<code>元素数组</code>和<code>散列方法</code>。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356898819-b1b00f43-8909-458e-996e-043d6d491d16.png" alt="img"></p><p><strong>元素数组</strong></p><p>一个table数组，存储Entry类型的元素，Entry是ThreaLocal弱引用作为key，Object作为value的结构。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>散列方法</strong></p><p>散列方法就是怎么把对应的key映射到table数组的相应下标，ThreadLocalMap用的是哈希取余法，取出key的threadLocalHashCode，然后和table数组长度减一&amp;运算（相当于取余）。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> i <span class="token operator">=</span> key<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>table<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里的threadLocalHashCode计算有点东西，每创建一个ThreadLocal对象，它就会新增<code>0x61c88647</code>，这个值很特殊，它是<strong>斐波那契数</strong> 也叫 <strong>黄金分割数</strong>。<code>hash</code>增量为 这个数字，带来的好处就是 <code>hash</code> <strong>分布非常均匀</strong>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">HASH_INCREMENT</span> <span class="token operator">=</span> <span class="token number">0x61c88647</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextHashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> nextHashCode<span class="token punctuation">.</span><span class="token function">getAndAdd</span><span class="token punctuation">(</span><span class="token constant">HASH_INCREMENT</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="14-ThreadLocalMap怎么解决Hash冲突的？"><a href="#14-ThreadLocalMap怎么解决Hash冲突的？" class="headerlink" title="14.ThreadLocalMap怎么解决Hash冲突的？"></a>14.ThreadLocalMap怎么解决Hash冲突的？</h2><p>我们可能都知道HashMap使用了链表来解决冲突，也就是所谓的链地址法。</p><p>ThreadLocalMap没有使用链表，自然也不是用链地址法来解决冲突了，它用的是另外一种方式——<strong>开放定址法</strong>。开放定址法是什么意思呢？简单来说，就是这个坑被人占了，那就接着去找空着的坑。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356901216-b4d3489b-aca9-4dd6-b94a-aafd33774136.png" alt="img"></p><p>如上图所示，如果我们插入一个value&#x3D;27的数据，通过 hash计算后应该落入第 4 个槽位中，而槽位 4 已经有了 Entry数据，而且Entry数据的key和当前不相等。此时就会线性向后查找，一直找到 Entry为 null的槽位才会停止查找，把元素放到空的槽中。</p><p>在get的时候，也会根据ThreadLocal对象的hash值，定位到table中的位置，然后判断该槽位Entry对象中的key是否和get的key一致，如果不一致，就判断下一个位置。</p><h2 id="15-ThreadLocalMap扩容机制了解吗？"><a href="#15-ThreadLocalMap扩容机制了解吗？" class="headerlink" title="15.ThreadLocalMap扩容机制了解吗？"></a>15.ThreadLocalMap扩容机制了解吗？</h2><p>在ThreadLocalMap.set()方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中<code>Entry</code>的数量已经达到了列表的扩容阈值<code>(len*2/3)</code>，就开始执行<code>rehash()</code>逻辑：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">cleanSomeSlots</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> sz<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> sz <span class="token operator">>=</span> threshold<span class="token punctuation">)</span>    <span class="token function">rehash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再着看rehash()具体实现：这里会先去清理过期的Entry，然后还要根据条件判断<code>size &gt;= threshold - threshold / 4</code> 也就是<code>size &gt;= threshold* 3/4</code>来决定是否需要扩容。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rehash</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//清理过期Entry</span>    <span class="token function">expungeStaleEntries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">>=</span> threshold <span class="token operator">-</span> threshold <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//清理过期Entry</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">expungeStaleEntries</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Entry</span> e <span class="token operator">=</span> tab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token function">expungeStaleEntry</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着看看具体的<code>resize()</code>方法，扩容后的<code>newTab</code>的大小为老数组的两倍，然后遍历老的table数组，散列方法重新计算位置，开放地址解决冲突，然后放到新的<code>newTab</code>，遍历完成之后，<code>oldTab</code>中所有的<code>entry</code>数据都已经放入到<code>newTab</code>中了，然后table引用指向<code>newTab</code></p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356904798-8cfa5960-6c5e-40c2-b28f-0fbf8c42e313.png" alt="img"></p><p>具体代码：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356906749-5c8a48d9-e202-4bf6-878e-6e2555845df4.png" alt="img"></p><h2 id="16-父子线程怎么共享数据？"><a href="#16-父子线程怎么共享数据？" class="headerlink" title="16.父子线程怎么共享数据？"></a>16.父子线程怎么共享数据？</h2><p>父线程能用ThreadLocal来给子线程传值吗？毫无疑问，不能。那该怎么办？</p><p>这时候可以用到另外一个类——<code>InheritableThreadLocal</code>。</p><p>使用起来很简单，在主线程的InheritableThreadLocal实例设置值，在子线程中就可以拿到了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InheritableThreadLocalTest</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">final</span> <span class="token class-name">ThreadLocal</span> threadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InheritableThreadLocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 主线程</span>        threadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"不擅技术"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//子线程</span>        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"鄙人三某 ，"</span> <span class="token operator">+</span> threadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>那原理是什么呢？</strong></p><p>原理很简单，在Thread类里还有另外一个变量：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span> inheritableThreadLocals <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在Thread.init的时候，如果父线程的<code>inheritableThreadLocals</code>不为空，就把它赋给当前线程（子线程）的<code>inheritableThreadLocals</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>inheritThreadLocals <span class="token operator">&amp;&amp;</span> parent<span class="token punctuation">.</span>inheritableThreadLocals <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>inheritableThreadLocals <span class="token operator">=</span>        <span class="token class-name">ThreadLocal</span><span class="token punctuation">.</span><span class="token function">createInheritedMap</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span>inheritableThreadLocals<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="17-说一下你对Java内存模型（JMM）的理解？"><a href="#17-说一下你对Java内存模型（JMM）的理解？" class="headerlink" title="17.说一下你对Java内存模型（JMM）的理解？"></a>17.说一下你对Java内存模型（JMM）的理解？</h2><p>Java内存模型（Java Memory Model，JMM），是一种抽象的模型，被定义出来屏蔽各种硬件和操作系统的内存访问差异。</p><p>JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在<code>主内存</code>（Main Memory）中，每个线程都有一个私有的<code>本地内存</code>（Local Memory），本地内存中存储了该线程以读&#x2F;写共享变量的副本。</p><p>Java内存模型的抽象图：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356911220-4d74fc7c-621a-457d-a8d9-56a782438af0.png" alt="img"></p><p>本地内存是JMM的 一个抽象概念，并不真实存在。它其实涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356916018-9d5d2470-d8d4-448f-bc98-4812f2b9eda8.png" alt="img"></p><p>图里面的是一个双核 CPU 系统架构 ，每个核有自己的控制器和运算器，其中控制器包含一组寄存器和操作控制器，运算器执行算术逻辅运算。每个核都有自己的一级缓存，在有些架构里面还有一个所有 CPU 共享的二级缓存。那么 Java 内存模型里面的工作内存，就对应这里的 Ll 缓存或者 L2 缓存或者 CPU 寄存器。</p><h2 id="18-说说你对原子性、可见性、有序性的理解？"><a href="#18-说说你对原子性、可见性、有序性的理解？" class="headerlink" title="18.说说你对原子性、可见性、有序性的理解？"></a>18.说说你对原子性、可见性、有序性的理解？</h2><p>原子性、有序性、可见性是并发编程中非常重要的基础概念，JMM的很多技术都是围绕着这三大特性展开。</p><p><strong>原子性</strong>：原子性指的是一个操作是不可分割、不可中断的，要么全部执行并且执行的过程不会被任何因素打断，要么就全不执行。</p><p><strong>可见性</strong>：可见性指的是一个线程修改了某一个共享变量的值时，其它线程能够立即知道这个修改。</p><p><strong>有序性</strong>：有序性指的是对于一个线程的执行代码，从前往后依次执行，单线程下可以认为程序是有序的，但是并发时有可能会发生指令重排。</p><p>分析下面几行代码的原子性？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">;</span>i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>第1句是基本类型赋值，是原子性操作。</p><p>第2句先读i的值，再赋值到j，两步操作，不能保证原子性。</p><p>第3和第4句其实是等效的，先读取i的值，再+1，最后赋值到i，三步操作了，不能保证原子性。</p><p><strong>原子性、可见性、有序性都应该怎么保证呢？</strong></p><p>原子性：JMM只能保证基本的原子性，如果要保证一个代码块的原子性，需要使用<code>synchronized</code>。</p><p>可见性：Java是利用<code>volatile</code>关键字来保证可见性的，除此之外，<code>final</code>和<code>synchronized</code>也能保证可见性。</p><p>有序性：<code>synchronized</code>或者<code>volatile</code>都可以保证多线程之间操作的有序性。</p><h2 id="19-那说说什么是指令重排？"><a href="#19-那说说什么是指令重排？" class="headerlink" title="19.那说说什么是指令重排？"></a>19.那说说什么是指令重排？</h2><p>在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类型。</p><p>1、编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p><p>2、指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应 机器指令的执行顺序。</p><p>3、内存系统的重排序。由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p><p>从Java源代码到最终实际执行的指令序列，会分别经历下面3种重排序，如图：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356919762-a5a52cbf-5abb-4463-a4bf-af97a5bded0b.png" alt="img"></p><p>我们比较熟悉的双重校验单例模式就是一个经典的指令重排的例子，<code>Singleton instance=new Singleton()；</code>对应的JVM指令分为三步：分配内存空间–&gt;初始化对象—&gt;对象指向分配的内存空间，但是经过了编译器的指令重排序，第二步和第三步就可能会重排序。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356921384-9342aedc-7423-49ac-83c5-ca6d940f5a28.png" alt="img"></p><p>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p><h2 id="20-指令重排有限制吗？happens-before了解吗？"><a href="#20-指令重排有限制吗？happens-before了解吗？" class="headerlink" title="20.指令重排有限制吗？happens-before了解吗？"></a>20.指令重排有限制吗？happens-before了解吗？</h2><p>指令重排也是有一些限制的，有两个规则<code>happens-before</code>和<code>as-if-serial</code>来约束。</p><p>happens-before的定义：</p><p>1、如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</p><p>2、两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照 happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法</p><p>happens-before和我们息息相关的有六大规则：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356923639-2ecb5074-b28f-4ec6-8cb6-84f9e46faf95.png" alt="img"></p><p><strong>程序顺序规则</strong>：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</p><p><strong>监视器锁规则</strong>：对一个锁的解锁，happens-before于随后对这个锁的加锁。</p><p><strong>volatile变量规则</strong>：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</p><p><strong>传递性</strong>：如果A happens-before B，且B happens-before C，那么A happens-before C。</p><p><strong>start()规则</strong>：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的 ThreadB.start()操作happens-before于线程B中的任意操作。</p><p><strong>join()规则</strong>：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作 happens-before于线程A从ThreadB.join()操作成功返回。</p><h2 id="21-as-if-serial又是什么？单线程的程序一定是顺序的吗？"><a href="#21-as-if-serial又是什么？单线程的程序一定是顺序的吗？" class="headerlink" title="21.as-if-serial又是什么？单线程的程序一定是顺序的吗？"></a>21.as-if-serial又是什么？单线程的程序一定是顺序的吗？</h2><p>as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），<strong>单线程程序的执行结果不能被改变</strong>。编译器、runtime和处理器都必须遵守as-if-serial语义。</p><p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">double</span> pi <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>   <span class="token comment">// A</span><span class="token keyword">double</span> r <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span>   <span class="token comment">// B </span><span class="token keyword">double</span> area <span class="token operator">=</span> pi <span class="token operator">*</span> r <span class="token operator">*</span> r<span class="token punctuation">;</span>   <span class="token comment">// C</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面3个操作的数据依赖关系：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356925824-5a769b53-b64a-449f-9cf6-90bb38c6fe5a.png" alt="img"></p><p>A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B的前面（C排到A和B的前面，程序的结果将会被改变）。但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。</p><p>所以最终，程序可能会有两种执行顺序：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356927677-32f90af3-e0c4-4a7b-8ae9-004c2da9673b.png" alt="img"></p><p>as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器、runtime和处理器共同编织了这么一个“楚门的世界”：单线程程序是按程序的“顺序”来执行的。as- if-serial语义使单线程情况下，我们不需要担心重排序的问题，可见性的问题。</p><h2 id="22-volatile实现原理了解吗？"><a href="#22-volatile实现原理了解吗？" class="headerlink" title="22.volatile实现原理了解吗？"></a>22.volatile实现原理了解吗？</h2><p>volatile有两个作用，保证<strong>可见性</strong>和<strong>有序性</strong>。</p><p><strong>volatile怎么保证可见性的呢？</strong></p><p>相比synchronized的加锁方式来解决共享变量的内存可见性问题，volatile就是更轻量的选择，它没有上下文切换的额外开销成本。</p><p>volatile可以确保对某个变量的更新对其他线程马上可见，一个变量被声明为volatile 时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存 当其它线程读取该共享变量 ，会从主内存重新获取最新值，而不是使用当前线程的本地内存中的值。</p><p>例如，我们声明一个 volatile 变量 volatile int x &#x3D; 0，线程A修改x&#x3D;1，修改完之后就会把新的值刷新回主内存，线程B读取x的时候，就会清空本地内存变量，然后再从主内存获取最新值。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356929670-cdd2108b-1c4a-4ad7-adf1-14a19c766f37.png" alt="img"></p><p><strong>volatile怎么保证有序性的呢？</strong></p><p>重排序可以分为编译器重排序和处理器重排序，valatile保证有序性，就是通过分别限制这两种类型的重排序。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356931393-714aec15-de45-4e38-ad9d-e62b7a44abba.png" alt="img"></p><p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p><p>1、在每个volatile写操作的前面插入一个<code>StoreStore</code>屏障</p><p>2、在每个volatile写操作的后面插入一个<code>StoreLoad</code>屏障</p><p>3、在每个volatile读操作的后面插入一个<code>LoadLoad</code>屏障</p><p>4、在每个volatile读操作的后面插入一个<code>LoadStore</code>屏障</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356933901-4dd9c6d7-10b7-4e4d-bdca-52c86351666c.png" alt="img"></p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356935999-2240fde5-b78d-450f-8f84-5827918e6278.png" alt="img"></p><h2 id="23-synchronized用过吗？怎么使用？"><a href="#23-synchronized用过吗？怎么使用？" class="headerlink" title="23.synchronized用过吗？怎么使用？"></a>23.synchronized用过吗？怎么使用？</h2><p>synchronized经常用的，用来保证代码的原子性。</p><p>synchronized主要有三种用法：</p><p><strong>修饰实例方法:</strong> 作用于当前对象实例加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//业务代码</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>修饰静态方法</strong>：也就是给当前类加锁，会作⽤于类的所有对象实例 ，进⼊同步代码前要获得当前 class 的锁。因为静态成员不属于任何⼀个实例对象，是类成员（ static 表明这是该类的⼀个静态资源，不管 new 了多少个对象，只有⼀份）。</p><p>如果⼀个线程 A 调⽤⼀个实例对象的⾮静态 synchronized ⽅法，⽽线程 B 需要调⽤这个实例对象所属类的静态 synchronized ⽅法，是允许的，不会发⽣互斥现象，因为访问静态 synchronized ⽅法占⽤的锁是当前类的锁，⽽访问⾮静态 synchronized ⽅法占⽤的锁是当前实例对象锁。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span> <span class="token keyword">void</span> staic <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//业务代码</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>修饰代码块</strong> ：指定加锁对象，对给定对象&#x2F;类加锁。synchronized(this|object) 表示进⼊同步代码库前要获得给定对象的锁。synchronized(类.class) 表示进⼊同步代码前要获得 当前 <strong>class</strong> 的锁</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//业务代码</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="24-synchronized的实现原理？"><a href="#24-synchronized的实现原理？" class="headerlink" title="24.synchronized的实现原理？"></a>24.synchronized的实现原理？</h2><p><strong>synchronized是怎么加锁的呢？</strong></p><p>我们使用synchronized的时候，发现不用自己去lock和unlock，是因为JVM帮我们把这个事情做了。</p><p>synchronized修饰代码块时，JVM采用<code>monitorenter</code>、<code>monitorexit</code>两个指令来实现同步，<code>monitorenter</code> 指令指向同步代码块的开始位置， <code>monitorexit</code> 指令则指向同步代码块的结束位置。</p><p>反编译一段synchronized修饰代码块代码，<code>javap -c -s -v -l SynchronizedDemo.class</code>，可以看到相应的字节码指令。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356939690-fa87311b-e040-4de1-a846-6ff48276881d.png" alt="img"></p><p>synchronized修饰同步方法时，JVM采用<code>ACC_SYNCHRONIZED</code>标记符来实现同步，这个标识指明了该方法是一个同步方法。</p><p>同样可以写段代码反编译看一下。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356945981-f3c7f0b0-2b7d-4fe3-9d9a-fc075c01418e.png" alt="img"></p><p><strong>synchronized锁住的是什么呢？</strong></p><p>monitorenter、monitorexit或者ACC_SYNCHRONIZED都是<strong>基于Monitor实现</strong>的。</p><p>实例对象结构里有对象头，对象头里面有一块结构叫Mark Word，Mark Word指针指向了<strong>monitor</strong>。</p><p>所谓的Monitor其实是一种<strong>同步工具</strong>，也可以说是一种<strong>同步机制</strong>。在Java虚拟机（HotSpot）中，Monitor是由<strong>ObjectMonitor实现</strong>的，可以叫做内部锁，或者Monitor锁。</p><p><strong>ObjectMonitor的工作原理</strong>：</p><p>1、ObjectMonitor有两个队列：<em>WaitSet、</em>EntryList，用来保存ObjectWaiter 对象列表。</p><p>2、<em>owner，获取 Monitor 对象的线程进入</em> owner 区时， <em>count + 1。如果线程调用了 wait() 方法，此时会释放 Monitor 对象，</em> owner 恢复为空， <em>count - 1。同时该等待线程进入</em> WaitSet 中，等待被唤醒。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ObjectMonitor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    _header       <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    _count        <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 记录线程获取锁的次数</span>    _waiters      <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>    _recursions   <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">//锁的重入次数</span>    _object       <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    _owner        <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment">// 指向持有ObjectMonitor对象的线程</span>    _WaitSet      <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment">// 处于wait状态的线程，会被加入到_WaitSet</span>    _WaitSetLock  <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>    _Responsible  <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>    _succ         <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>    _cxq          <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>    <span class="token class-name">FreeNext</span>      <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>    _EntryList    <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>  <span class="token comment">// 处于等待锁block状态的线程，会被加入到该列表</span>    _SpinFreq     <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>    _SpinClock    <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>    <span class="token class-name">OwnerIsThread</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以类比一个去医院就诊的例子[18]：</p><p>首先，患者在<strong>门诊大厅</strong>前台或自助挂号机<strong>进行挂号</strong>；</p><p>随后，挂号结束后患者找到对应的<strong>诊室就诊</strong>：</p><ul><li><p>诊室每次只能有一个患者就诊；</p></li><li><p>如果此时诊室空闲，直接进入就诊；</p></li><li><p>如果此时诊室内有其它患者就诊，那么当前患者进入<strong>候诊室</strong>，等待叫号；</p></li></ul><p>就诊结束后，<strong>走出就诊室</strong>，候诊室的<strong>下一位候诊患者</strong>进入就诊室。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356949214-16233569-1a50-4380-a4c3-e74e1ea02384.png" alt="img"></p><p>这个过程就和Monitor机制比较相似：</p><p><strong>门诊大厅</strong>：所有待进入的线程都必须先在<strong>入口Entry Set</strong>挂号才有资格；</p><p><strong>就诊室</strong>：就诊室**_Owner**里里只能有一个线程就诊，就诊完线程就自行离开</p><p><strong>候诊室</strong>：就诊室繁忙时，进入<strong>等待区（Wait Set）</strong>，就诊室空闲的时候就从<strong>等待区（Wait Set）</strong>叫新的线程</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356951068-4cf5160a-a7b7-495c-8321-3f18994bddb6.png" alt="img"></p><p>所以我们就知道了，同步是锁住的什么东西：</p><p>monitorenter，在判断拥有同步标识 ACC_SYNCHRONIZED 抢先进入此方法的线程会优先拥有 Monitor 的 owner ，此时计数器 +1。</p><p>monitorexit，当执行完退出后，计数器 -1，归 0 后被其他进入的线程获得。</p><h2 id="25-除了原子性，synchronized可见性，有序性，可重入性怎么实现？"><a href="#25-除了原子性，synchronized可见性，有序性，可重入性怎么实现？" class="headerlink" title="25.除了原子性，synchronized可见性，有序性，可重入性怎么实现？"></a>25.除了原子性，synchronized可见性，有序性，可重入性怎么实现？</h2><p><strong>synchronized怎么保证可见性？</strong></p><p>线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值。</p><p>线程加锁后，其它线程无法获取主内存中的共享变量。</p><p>线程解锁前，必须把共享变量的最新值刷新到主内存中。</p><p><strong>synchronized怎么保证有序性？</strong></p><p>synchronized同步的代码块，具有排他性，一次只能被一个线程拥有，所以synchronized保证同一时刻，代码是单线程执行的。</p><p>因为as-if-serial语义的存在，单线程的程序能保证最终结果是有序的，但是不保证不会指令重排。</p><p>所以synchronized保证的有序是执行结果的有序性，而不是防止指令重排的有序性。</p><p><strong>synchronized怎么实现可重入的呢？</strong></p><p>synchronized 是可重入锁，也就是说，允许一个线程二次请求自己持有对象锁的临界资源，这种情况称为可重入锁。</p><p>synchronized 锁对象的时候有个计数器，他会记录下线程获取锁的次数，在执行完对应的代码块之后，计数器就会-1，直到计数器清零，就释放锁了。</p><p>之所以，是可重入的。是因为 synchronized 锁对象有个计数器，会随着线程获取锁后 +1 计数，当线程执行完毕后 -1，直到清零释放锁。</p><h2 id="26-锁升级？synchronized优化了解吗？"><a href="#26-锁升级？synchronized优化了解吗？" class="headerlink" title="26.锁升级？synchronized优化了解吗？"></a>26.锁升级？synchronized优化了解吗？</h2><p>了解锁升级，得先知道，不同锁的状态是什么样的。这个状态指的是什么呢？</p><p>Java对象头里，有一块结构，叫<code>Mark Word</code>标记字段，这块结构会随着锁的状态变化而变化。</p><p>64 位虚拟机 Mark Word 是 64bit，我们来看看它的状态变化：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356953985-5effa473-5f58-4e6f-9341-9c7fd5378fab.png" alt="img"></p><p>Mark Word存储对象自身的运行数据，如<strong>哈希码、GC分代年龄、锁状态标志、偏向时间戳（Epoch）</strong> 等。</p><p><strong>synchronized做了哪些优化？</strong></p><p>在JDK1.6之前，synchronized的实现直接调用ObjectMonitor的enter和exit，这种锁被称之为<strong>重量级锁</strong>。从JDK6开始，HotSpot虚拟机开发团队对Java中的锁进行优化，如增加了适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等优化策略，提升了synchronized的性能。</p><p><strong>偏向锁</strong>：在无竞争的情况下，只是在Mark Word里存储当前线程指针，CAS操作都不做。</p><p><strong>轻量级锁</strong>：在没有多线程竞争时，相对重量级锁，减少操作系统互斥量带来的性能消耗。但是，如果存在锁竞争，除了互斥量本身开销，还额外有CAS操作的开销。</p><p><strong>自旋锁</strong>：减少不必要的CPU上下文切换。在轻量级锁升级为重量级锁时，就使用了自旋加锁的方式</p><p><strong>锁粗化</strong>：将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。</p><p><strong>锁消除</strong>：虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。</p><p><strong>锁升级的过程是什么样的？</strong></p><p>锁升级方向：无锁–&gt;偏向锁—&gt; 轻量级锁—-&gt;重量级锁，这个方向基本上是不可逆的。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356956356-1c53e4ec-a41b-4c17-8bdd-156a2f965fe4.png" alt="img"></p><p>我们看一下升级的过程：</p><h3 id="偏向锁："><a href="#偏向锁：" class="headerlink" title="偏向锁："></a>偏向锁：</h3><p><strong>偏向锁的获取：</strong></p><p>1、判断是否为可偏向状态–MarkWord中锁标志是否为‘01’，是否偏向锁是否为‘1’</p><p>2、如果是可偏向状态，则查看线程ID是否为当前线程，如果是，则进入步骤’5’，否则进入步骤‘3’</p><p>3、通过CAS操作竞争锁，如果竞争成功，则将MarkWord中线程ID设置为当前线程ID，然后执行‘5’；竞争失败，则执行‘4’</p><p>4、CAS获取偏向锁失败表示有竞争。当达到safepoint时获得偏向锁的线程被挂起，<strong>偏向锁升级为轻量级锁</strong>，然后被阻塞在安全点的线程继续往下执行同步代码块</p><p>5、执行同步代码</p><p><strong>偏向锁的撤销：</strong></p><p>1、偏向锁不会主动释放(撤销)，只有遇到其他线程竞争时才会执行撤销，由于撤销需要知道当前持有该偏向锁的线程栈状态，因此要等到safepoint时执行，此时持有该偏向锁的线程（T）有‘2’，‘3’两种情况；</p><p>2、撤销—-T线程已经退出同步代码块，或者已经不再存活，则直接撤销偏向锁，变成无锁状态—-该状态达到阈值20则执行批量重偏向</p><p>3、升级—-T线程还在同步代码块中，则将T线程的偏向锁<strong>升级为轻量级锁</strong>，当前线程执行轻量级锁状态下的锁获取步骤—-该状态达到阈值40则执行批量撤销</p><h3 id="轻量级锁："><a href="#轻量级锁：" class="headerlink" title="轻量级锁："></a>轻量级锁：</h3><p><strong>轻量级锁的获取：</strong></p><p>1、进行加锁操作时，jvm会判断是否已经时重量级锁，如果不是，则会在当前线程栈帧中划出一块空间，作为该锁的锁记录，并且将锁对象MarkWord复制到该锁记录中</p><p>2、复制成功之后，jvm使用CAS操作将对象头MarkWord更新为指向锁记录的指针，并将锁记录里的owner指针指向对象头的MarkWord。如果成功，则执行‘3’，否则执行‘4’</p><p>3、更新成功，则当前线程持有该对象锁，并且对象MarkWord锁标志设置为‘00’，即表示此对象处于轻量级锁状态</p><p>4、更新失败，jvm先检查对象MarkWord是否指向当前线程栈帧中的锁记录，如果是则执行‘5’，否则执行‘4’</p><p>5、表示锁重入；然后当前线程栈帧中增加一个锁记录第一部分（Displaced Mark Word）为null，并指向Mark Word的锁对象，起到一个重入计数器的作用。</p><p>6、表示该锁对象已经被其他线程抢占，则进行<strong>自旋等待</strong>（默认10次），等待次数达到阈值仍未获取到锁，则<strong>升级为重量级锁</strong></p><p>大体上省简的升级过程：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356958711-96efcac1-7419-430e-804b-1748cfe76aa1.png" alt="img"></p><p>完整的升级过程：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356960440-1a4fd8cf-4c5e-446d-bded-f2601199e002.png" alt="img"></p><h2 id="27-说说synchronized和ReentrantLock的区别？"><a href="#27-说说synchronized和ReentrantLock的区别？" class="headerlink" title="27.说说synchronized和ReentrantLock的区别？"></a>27.说说synchronized和ReentrantLock的区别？</h2><p>可以从锁的实现、功能特点、性能等几个维度去回答这个问题：</p><p><strong>锁的实现：</strong> synchronized是Java语言的关键字，基于JVM实现。而ReentrantLock是基于JDK的API层面实现的（一般是lock()和unlock()方法配合try&#x2F;finally 语句块来完成。）</p><p><strong>性能：</strong> 在JDK1.6锁优化以前，synchronized的性能比ReenTrantLock差很多。但是JDK6开始，增加了适应性自旋、锁消除等，两者性能就差不多了。</p><p><strong>功能特点：</strong> ReentrantLock 比 synchronized 增加了一些高级功能，如等待可中断、可实现公平锁、可实现选择性通知。</p><ul><li><p>ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制</p></li><li><p>ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</p></li><li><p>synchronized与wait()和notify()&#x2F;notifyAll()方法结合实现等待&#x2F;通知机制，ReentrantLock类借助Condition接口与newCondition()方法实现。</p></li><li><p>ReentrantLock需要手工声明来加锁和释放锁，一般跟finally配合释放锁。而synchronized不用手动释放锁。</p></li></ul><p>下面的表格列出出了两种锁之间的区别：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356963058-a24d0139-2c55-4196-bb8d-45057f6e8747.png" alt="img"></p><h2 id="28-AQS了解多少？"><a href="#28-AQS了解多少？" class="headerlink" title="28.AQS了解多少？"></a>28.AQS了解多少？</h2><p>AbstractQueuedSynchronizer 抽象同步队列，简称 AQS ，它是Java并发包的根基，并发包中的锁就是基于AQS实现的。</p><p>AQS是基于一个FIFO的双向队列，其内部定义了一个节点类Node，Node 节点内部的 SHARED 用来标记该线程是获取共享资源时被阻挂起后放入AQS 队列的， EXCLUSIVE 用来标记线程是 取独占资源时被挂起后放入AQS 队列</p><p>AQS 使用一个 volatile 修饰的 int 类型的成员变量 state 来表示同步状态，修改同步状态成功即为获得锁，volatile 保证了变量在多线程之间的可见性，修改 State 值时通过 CAS 机制来保证修改的原子性</p><p>获取state的方式分为两种，独占方式和共享方式，一个线程使用独占方式获取了资源，其它线程就会在获取失败后被阻塞。一个线程使用共享方式获取了资源，另外一个线程还可以通过CAS的方式进行获取。</p><p>如果共享资源被占用，需要一定的阻塞等待唤醒机制来保证锁的分配，AQS 中会将竞争共享资源失败的线程添加到一个变体的 CLH 队列中。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356965598-80eea7cb-66ad-457a-a137-fef40f253bcf.png" alt="img"></p><p>先简单了解一下CLH：Craig、Landin and Hagersten 队列，是 <strong>单向链表实现的队列</strong>。申请线程只在本地变量上自旋，<strong>它不断轮询前驱的状态</strong>，如果发现 <strong>前驱节点释放了锁就结束自旋</strong></p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356968275-4473424d-34c1-403e-b9e0-932f52f75041.png" alt="img"></p><p>AQS 中的队列是 CLH 变体的虚拟双向队列，通过将每条请求共享资源的线程封装成一个节点来实现锁的分配：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356970276-cedac516-6f35-44f6-b63c-2c84dda63cbd.png" alt="img"></p><p>AQS 中的 CLH 变体等待队列拥有以下特性：</p><p>AQS 中队列是个双向链表，也是 FIFO 先进先出的特性</p><p>通过 Head、Tail 头尾两个节点来组成队列结构，通过 volatile 修饰保证可见性</p><p>Head 指向节点为已获得锁的节点，是一个虚拟节点，节点本身不持有具体线程</p><p>获取不到同步状态，会将节点进行自旋获取锁，自旋一定次数失败后会将线程阻塞，相对于 CLH 队列性能较好</p><p>ps:AQS源码里面有很多细节可问，建议有时间好好看看AQS源码。</p><h2 id="29-ReentrantLock实现原理？"><a href="#29-ReentrantLock实现原理？" class="headerlink" title="29.ReentrantLock实现原理？"></a>29.<strong>ReentrantLock</strong>实现原理？</h2><p>ReentrantLock 是可重入的独占锁，只能有一个线程可以获取该锁，其它获取该锁的线程会被阻塞而被放入该锁的阻塞队列里面。</p><p>看看ReentrantLock的加锁操作：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 创建非公平锁</span><span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取锁操作</span>lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 执行代码逻辑</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span><span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 解锁操作</span>    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>new ReentrantLock()</code>构造函数默认创建的是非公平锁 NonfairSync。</p><p><strong>公平锁 FairSync</strong></p><p>1、公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁</p><p>2、公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU 唤醒阻塞线程的开销比非公平锁大</p><p><strong>非公平锁 NonfairSync</strong></p><p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁</p><p>非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU 不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁</p><p><strong>默认创建的对象lock()的时候</strong>：</p><p>如果锁当前没有被其它线程占用，并且当前线程之前没有获取过该锁，则当前线程会获取到该锁，然后设置当前锁的拥有者为当前线程，并设置 AQS 的状态值为1 ，然后直接返回。如果当前线程之前己经获取过该锁，则这次只是简单地把 AQS 的状态值加1后返回。</p><p>如果该锁己经被其他线程持有，非公平锁会尝试去获取锁，获取失败的话，则调用该方法线程会被放入 AQS 队列阻塞挂起。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356972988-ce91b9f4-c9dc-45ba-b37a-ada99f33e76b.png" alt="img"></p><h2 id="30-ReentrantLock怎么实现公平锁的？"><a href="#30-ReentrantLock怎么实现公平锁的？" class="headerlink" title="30.ReentrantLock怎么实现公平锁的？"></a>30.ReentrantLock怎么实现公平锁的？</h2><p><code>new ReentrantLock()</code>构造函数默认创建的是非公平锁 NonfairSync</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>同时也可以在创建锁构造函数中传入具体参数创建公平锁 FairSync</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">-</span> <span class="token class-name">ReentrantLock</span><span class="token comment">// true 代表公平锁，false 代表非公平锁</span><span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>FairSync、NonfairSync 代表公平锁和非公平锁，两者都是 ReentrantLock 静态内部类，只不过实现不同锁语义。</p><p><strong>非公平锁和公平锁的两处不同：</strong></p><p>1、非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</p><p>2、非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state &#x3D;&#x3D; 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356975824-b919b787-0554-44ac-9c9d-93297ccdcebc.png" alt="img"></p><p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p><h2 id="31-CAS呢？CAS了解多少？"><a href="#31-CAS呢？CAS了解多少？" class="headerlink" title="31.CAS呢？CAS了解多少？"></a>31.CAS呢？CAS了解多少？</h2><p>CAS叫做CompareAndSwap，⽐较并交换，主要是通过处理器的指令来保证操作的原⼦性的。</p><p>CAS 指令包含 3 个参数：共享变量的内存地址 A、预期的值 B 和共享变量的新值 C。</p><p>只有当内存中地址 A 处的值等于 B 时，才能将内存中地址 A 处的值更新为新值 C。作为一条 CPU 指令，CAS 指令本身是能够保证原子性的 。</p><h2 id="32-CAS-有什么问题？如何解决？"><a href="#32-CAS-有什么问题？如何解决？" class="headerlink" title="32.CAS 有什么问题？如何解决？"></a>32.CAS 有什么问题？如何解决？</h2><p>CAS的经典三大问题：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356978476-b3cdc825-8f8b-4ef5-929e-fff49fe4e4ca.png" alt="img"></p><h3 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h3><p>并发环境下，假设初始条件是A，去修改数据时，发现是A就会执行修改。但是看到的虽然是A，中间可能发生了A变B，B又变回A的情况。此时A已经非彼A，数据即使成功修改，也可能有问题。</p><p><strong>怎么解决ABA问题？</strong></p><p><strong>加版本号</strong></p><p>每次修改变量，都在这个变量的版本号上加1，这样，刚刚A-&gt;B-&gt;A，虽然A的值没变，但是它的版本号已经变了，再判断版本号就会发现此时的A已经被改过了。参考乐观锁的版本号，这种做法可以给数据带上了一种实效性的检验。</p><p>Java提供了AtomicStampReference类，它的compareAndSet方法首先检查当前的对象引用值是否等于预期引用，并且当前印戳（Stamp）标志是否等于预期标志，如果全部相等，则以原子方式将引用值和印戳标志的值更新为给定的更新值。</p><h3 id="循环性能开销"><a href="#循环性能开销" class="headerlink" title="循环性能开销"></a>循环性能开销</h3><p>自旋CAS，如果一直循环执行，一直不成功，会给CPU带来非常大的执行开销。</p><p><strong>怎么解决循环性能开销问题？</strong></p><p>在Java中，很多使用自旋CAS的地方，会有一个自旋次数的限制，超过一定次数，就停止自旋。</p><h3 id="只能保证一个变量的原子操作"><a href="#只能保证一个变量的原子操作" class="headerlink" title="只能保证一个变量的原子操作"></a>只能保证一个变量的原子操作</h3><p>CAS 保证的是对一个变量执行操作的原子性，如果对多个变量操作时，CAS 目前无法直接保证操作的原子性的。</p><p><strong>怎么解决只能保证一个变量的原子操作问题？</strong></p><p>可以考虑改用锁来保证操作的原子性</p><p>可以考虑合并多个变量，将多个变量封装成一个对象，通过AtomicReference来保证原子性。</p><h2 id="33-Java有哪些保证原子性的方法？如何保证多线程下i-结果正确？"><a href="#33-Java有哪些保证原子性的方法？如何保证多线程下i-结果正确？" class="headerlink" title="33.Java有哪些保证原子性的方法？如何保证多线程下i++ 结果正确？"></a>33.Java有哪些保证原子性的方法？如何保证多线程下i++ 结果正确？</h2><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356981199-70cb4fe5-6e28-4a5a-96a8-500db6f4e751.png" alt="img"></p><p>使用循环原子类，例如AtomicInteger，实现i++原子操作</p><p>使用juc包下的锁，如ReentrantLock ，对i++操作加锁lock.lock()来实现原子性</p><p>使用synchronized，对i++操作加锁</p><h2 id="34-原子操作类了解多少？"><a href="#34-原子操作类了解多少？" class="headerlink" title="34.原子操作类了解多少？"></a>34.原子操作类了解多少？</h2><p>当程序更新一个变量时，如果多线程同时更新这个变量，可能得到期望之外的值，比如变量i&#x3D;1，A线程更新i+1，B线程也更新i+1，经过两个线程操作之后可能i不等于3，而是等于2。因为A和B线程在更新变量i的时候拿到的i都是1，这就是线程不安全的更新操作，一般我们会使用synchronized来解决这个问题，synchronized会保证多线程不会同时更新变量i。</p><p>其实除此之外，还有更轻量级的选择，Java从JDK 1.5开始提供了java.util.concurrent.atomic包，这个包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。</p><p>因为变量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356984267-0fcd724a-3540-4b05-b90e-309aec0cd172.png" alt="img"></p><p>Atomic包里的类基本都是使用Unsafe实现的包装类。</p><p>使用原子的方式更新基本类型，Atomic包提供了以下3个类：</p><ul><li><p>AtomicBoolean：原子更新布尔类型。</p></li><li><p>AtomicInteger：原子更新整型。</p></li><li><p>AtomicLong：原子更新长整型。</p></li></ul><p>通过原子的方式更新数组里的某个元素，Atomic包提供了以下4个类：</p><ul><li><p>AtomicIntegerArray：原子更新整型数组里的元素。</p></li><li><p>AtomicLongArray：原子更新长整型数组里的元素。</p></li><li><p>AtomicReferenceArray：原子更新引用类型数组里的元素。</p></li><li><p>AtomicIntegerArray类主要是提供原子的方式更新数组里的整型</p></li></ul><p>原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了以下3个类：</p><ul><li><p>AtomicReference：原子更新引用类型。</p></li><li><p>AtomicReferenceFieldUpdater：原子更新引用类型里的字段。</p></li><li><p>AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference（V initialRef，boolean initialMark）。</p></li></ul><p>如果需原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供了以下3个类进行原子字段更新：</p><ul><li><p>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</p></li><li><p>AtomicLongFieldUpdater：原子更新长整型字段的更新器。</p></li><li><p>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的 ABA问题。</p></li></ul><h2 id="35-AtomicInteger-的原理？"><a href="#35-AtomicInteger-的原理？" class="headerlink" title="35.AtomicInteger 的原理？"></a>35.AtomicInteger 的原理？</h2><p>一句话概括：<strong>使用CAS实现</strong>。</p><p>以AtomicInteger的添加方法为例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过<code>Unsafe</code>类的实例来进行添加操作，来看看具体的CAS操作：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token class-name">Object</span> var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var2<span class="token punctuation">,</span> <span class="token keyword">int</span> var4<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> var5<span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>        var5 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getIntVolatile</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">,</span> var5<span class="token punctuation">,</span> var5 <span class="token operator">+</span> var4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> var5<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>compareAndSwapInt 是一个native方法，基于CAS来操作int类型变量。其它的原子操作类基本都是大同小异。</p><h2 id="36-线程死锁了解吗？该如何避免？"><a href="#36-线程死锁了解吗？该如何避免？" class="headerlink" title="36.线程死锁了解吗？该如何避免？"></a>36.线程死锁了解吗？该如何避免？</h2><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356989114-a883c724-4790-4aad-8d75-2da69b6a28f7.png" alt="img"></p><p>那么为什么会产生死锁呢？死锁的产生必须具备以下四个条件：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356990714-99b1b249-4fa1-4295-8ef3-a3d7714039c9.png" alt="img"></p><p>互斥条件：指线程对己经获取到的资源进行它性使用，即该资源同时只由一个线程占用。如果此时还有其它线程请求获取获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。</p><p>请求并持有条件：指一个 线程己经持有了至少一个资源，但又提出了新的资源请求，而新资源己被其它线程占有，所以当前线程会被阻塞，但阻塞 的同时并不释放自己已经获取的资源。</p><p>不可剥夺条件：指线程获取到的资源在自己使用完之前不能被其它线程抢占，只有在自己使用完毕后才由自己释放该资源。</p><p>环路等待条件：指在发生死锁时，必然存在一个线程——资源的环形链，即线程集合 {T0，T1，T2,…… ，Tn} 中 T0 正在等待一 T1 占用的资源，Tl1正在等待 T2用的资源，…… Tn 在等待己被 T0占用的资源。</p><p>该如何避免死锁呢？答案是<strong>至少破坏死锁发生的一个条件</strong>。</p><p>其中，互斥这个条件我们没有办法破坏，因为用锁为的就是互斥。不过其他三个条件都是有办法破坏掉的，到底如何做呢？</p><p>对于“请求并持有”这个条件，可以一次性请求所有的资源。</p><p>对于“不可剥夺”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。</p><p>对于“环路等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后就不存在环路了。</p><p>一个死锁的示例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Object</span> lock1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span> lock2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span>           <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock1<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>               <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread 1 get lock1。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                   <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                   e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">&#125;</span>               <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread 1 get lock2.."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">&#125;</span>           <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token string">"zs-thread-1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span>           <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>               <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread 2 get lock2.."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                   <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                   e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">&#125;</span>               <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock1<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread 1 get lock1。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">&#125;</span>           <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token string">"zs-thread-2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="37-那死锁问题怎么排查呢？"><a href="#37-那死锁问题怎么排查呢？" class="headerlink" title="37.那死锁问题怎么排查呢？"></a>37.那死锁问题怎么排查呢？</h2><p>可以使用jdk自带的命令行工具排查：</p><p>1、使用jps查找运行的Java进程：jps -l</p><p>2、使用jstack查看线程堆栈信息：jstack -l  进程id</p><p>基本就可以看到死锁的信息。</p><p>还可以利用图形化工具，比如JConsole。出现线程死锁以后，点击JConsole线程面板的<code>检测到死锁</code>按钮，将会看到线程的死锁信息。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356993682-007e0ee1-5c24-4dcd-b33c-014608d5be9c.png" alt="img"></p><p>还可以使用arthas的thread命令</p><ul><li>thread -b ：找出当前阻塞其他线程的线程</li><li>thread :  查看当前线程信息，查看线程的堆栈</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>arthas@59478<span class="token punctuation">]</span>$ thread <span class="token parameter variable">-b</span><span class="token string">"zs-thread-2"</span> <span class="token assign-left variable">Id</span><span class="token operator">=</span><span class="token number">12</span> BLOCKED on java.lang.Object@3383bc0c owned by <span class="token string">"zs-thread-1"</span> <span class="token assign-left variable">Id</span><span class="token operator">=</span><span class="token number">11</span>    at com.zs.j3y4.thread.lock.MainTest.lambda<span class="token variable">$main</span><span class="token variable">$1</span><span class="token punctuation">(</span>MainTest.java:39<span class="token punctuation">)</span>    -  blocked on java.lang.Object@3383bc0c    -  locked java.lang.Object@7aa68c87 <span class="token operator">&lt;</span>---- but blocks <span class="token number">1</span> other threads<span class="token operator">!</span>    at com.zs.j3y4.thread.lock.MainTest<span class="token variable">$$</span>Lambda<span class="token variable">$2</span>/1587487668.run<span class="token punctuation">(</span>Unknown Source<span class="token punctuation">)</span>    at java.lang.Thread.run<span class="token punctuation">(</span>Thread.java:748<span class="token punctuation">)</span><span class="token punctuation">[</span>arthas@59478<span class="token punctuation">]</span>$ threadThreads Total: <span class="token number">34</span>, NEW: <span class="token number">0</span>, RUNNABLE: <span class="token number">9</span>, BLOCKED: <span class="token number">2</span>, WAITING: <span class="token number">4</span>, TIMED_WAITING: <span class="token number">3</span>, TERMINATED: <span class="token number">0</span>, Internal threads: <span class="token number">16</span>                  ID    NAME                             GROUP            PRIORITY    STATE      %CPU       DELTA_TIME TIME        INTERRUPTE DAEMON     <span class="token number">27</span>    arthas-command-execute           system           <span class="token number">5</span>           RUNNABLE   <span class="token number">1.3</span>        <span class="token number">0.002</span>      <span class="token number">0</span>:0.018     <span class="token boolean">false</span>      <span class="token boolean">true</span>       <span class="token parameter variable">-1</span>    VM Periodic Task Thread          -                <span class="token parameter variable">-1</span>          -          <span class="token number">0.06</span>       <span class="token number">0.000</span>      <span class="token number">0</span>:0.009     <span class="token boolean">false</span>      <span class="token boolean">true</span>       <span class="token number">2</span>     Reference Handler                system           <span class="token number">10</span>          WAITING    <span class="token number">0.0</span>        <span class="token number">0.000</span>      <span class="token number">0</span>:0.000     <span class="token boolean">false</span>      <span class="token boolean">true</span>       <span class="token number">3</span>     Finalizer                        system           <span class="token number">8</span>           WAITING    <span class="token number">0.0</span>        <span class="token number">0.000</span>      <span class="token number">0</span>:0.000     <span class="token boolean">false</span>      <span class="token boolean">true</span>       <span class="token number">4</span>     Signal Dispatcher                system           <span class="token number">9</span>           RUNNABLE   <span class="token number">0.0</span>        <span class="token number">0.000</span>      <span class="token number">0</span>:0.000     <span class="token boolean">false</span>      <span class="token boolean">true</span>       <span class="token number">14</span>    Attach Listener                  system           <span class="token number">9</span>           RUNNABLE   <span class="token number">0.0</span>        <span class="token number">0.000</span>      <span class="token number">0</span>:0.020     <span class="token boolean">false</span>      <span class="token boolean">true</span>       <span class="token number">16</span>    arthas-timer                     system           <span class="token number">9</span>           WAITING    <span class="token number">0.0</span>        <span class="token number">0.000</span>      <span class="token number">0</span>:0.000     <span class="token boolean">false</span>      <span class="token boolean">true</span>       <span class="token number">18</span>    Keep-Alive-Timer                 system           <span class="token number">8</span>           TIMED_WAIT <span class="token number">0.0</span>        <span class="token number">0.000</span>      <span class="token number">0</span>:0.000     <span class="token boolean">false</span>      <span class="token boolean">true</span>       <span class="token number">19</span>    arthas-NettyHttpTelnetBootstrap- system           <span class="token number">5</span>           RUNNABLE   <span class="token number">0.0</span>        <span class="token number">0.000</span>      <span class="token number">0</span>:0.015     <span class="token boolean">false</span>      <span class="token boolean">true</span>       <span class="token number">20</span>    arthas-NettyWebsocketTtyBootstra system           <span class="token number">5</span>           RUNNABLE   <span class="token number">0.0</span>        <span class="token number">0.000</span>      <span class="token number">0</span>:0.000     <span class="token boolean">false</span>      <span class="token boolean">true</span>       <span class="token number">21</span>    arthas-NettyWebsocketTtyBootstra system           <span class="token number">5</span>           RUNNABLE   <span class="token number">0.0</span>        <span class="token number">0.000</span>      <span class="token number">0</span>:0.000     <span class="token boolean">false</span>      <span class="token boolean">true</span>       <span class="token number">22</span>    arthas-shell-server              system           <span class="token number">9</span>           TIMED_WAIT <span class="token number">0.0</span>        <span class="token number">0.000</span>      <span class="token number">0</span>:0.000     <span class="token boolean">false</span>      <span class="token boolean">true</span>       <span class="token number">23</span>    arthas-session-manager           system           <span class="token number">9</span>           TIMED_WAIT <span class="token number">0.0</span>        <span class="token number">0.000</span>      <span class="token number">0</span>:0.000     <span class="token boolean">false</span>      <span class="token boolean">true</span>       <span class="token number">24</span>    arthas-UserStat                  system           <span class="token number">9</span>           WAITING    <span class="token number">0.0</span>        <span class="token number">0.000</span>      <span class="token number">0</span>:0.000     <span class="token boolean">false</span>      <span class="token boolean">true</span>       <span class="token number">26</span>    arthas-NettyHttpTelnetBootstrap- system           <span class="token number">5</span>           RUNNABLE   <span class="token number">0.0</span>        <span class="token number">0.000</span>      <span class="token number">0</span>:0.072     <span class="token boolean">false</span>      <span class="token boolean">true</span>       <span class="token number">5</span>     Monitor Ctrl-Break               main             <span class="token number">5</span>           RUNNABLE   <span class="token number">0.0</span>        <span class="token number">0.000</span>      <span class="token number">0</span>:0.008     <span class="token boolean">false</span>      <span class="token boolean">true</span>       <span class="token number">11</span>    zs-thread-1                      main             <span class="token number">5</span>           BLOCKED    <span class="token number">0.0</span>        <span class="token number">0.000</span>      <span class="token number">0</span>:0.001     <span class="token boolean">false</span>      <span class="token boolean">false</span>      <span class="token number">12</span>    zs-thread-2                      main             <span class="token number">5</span>           BLOCKED    <span class="token number">0.0</span>        <span class="token number">0.000</span>      <span class="token number">0</span>:0.001     <span class="token boolean">false</span>      <span class="token boolean">false</span>      <span class="token number">13</span>    DestroyJavaVM                    main             <span class="token number">5</span>           RUNNABLE   <span class="token number">0.0</span>        <span class="token number">0.000</span>      <span class="token number">0</span>:0.073     <span class="token boolean">false</span>      <span class="token boolean">false</span>      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过arthas可以看到，所以一般给线程起一个通俗易懂的名字比较更方便的排查问题；</p><h2 id="38-CountDownLatch（倒计数器）了解吗？"><a href="#38-CountDownLatch（倒计数器）了解吗？" class="headerlink" title="38.CountDownLatch（倒计数器）了解吗？"></a>38.CountDownLatch（倒计数器）了解吗？</h2><p>CountDownLatch，倒计数器，有两个常见的应用场景[18]：</p><p><strong>场景1：协调子线程结束动作：等待所有子线程运行结束</strong></p><p>CountDownLatch允许一个或多个线程等待其他线程完成操作。</p><p>例如，我们很多人喜欢玩的王者荣耀，开黑的时候，得等所有人都上线之后，才能开打。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356996209-5fc93bab-8450-4518-9242-18a1099f7b0a.png" alt="img"></p><p>创建大乔、兰陵王、安其拉、哪吒和铠等五个玩家，主线程必须在他们都完成确认后，才可以继续运行。</p><p>在这段代码中，<code>new CountDownLatch(5)</code>用户创建初始的latch数量，各玩家通过<code>countDownLatch.countDown()</code>完成状态确认，主线程通过<code>countDownLatch.await()</code>等待。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">CountDownLatch</span> countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> 大乔 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>countDownLatch<span class="token operator">::</span><span class="token function">countDown</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> 兰陵王 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>countDownLatch<span class="token operator">::</span><span class="token function">countDown</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> 安其拉 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>countDownLatch<span class="token operator">::</span><span class="token function">countDown</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> 哪吒 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>countDownLatch<span class="token operator">::</span><span class="token function">countDown</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> 铠 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 稍等，上个卫生间，马上到...</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ignored<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    大乔<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    兰陵王<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    安其拉<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    哪吒<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    铠<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"所有玩家已经就位！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>场景2. 协调子线程开始动作：统一各线程动作开始的时机</strong></p><p>王者游戏中也有类似的场景，游戏开始时，各玩家的初始状态必须一致。不能有的玩家都出完装了，有的才降生。</p><p>所以大家得一块出生，在</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676356998618-e5ae59f9-8e33-44a3-89aa-f034c90f8456.png" alt="img"></p><p>在这个场景中，仍然用五个线程代表大乔、兰陵王、安其拉、哪吒和铠等五个玩家。需要注意的是，各玩家虽然都调用了<code>start()</code>线程，但是它们在运行时都在等待<code>countDownLatch</code>的信号，在信号未收到前，它们不会往下执行。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">CountDownLatch</span> countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> 大乔 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token function">waitToFight</span><span class="token punctuation">(</span>countDownLatch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> 兰陵王 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token function">waitToFight</span><span class="token punctuation">(</span>countDownLatch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> 安其拉 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token function">waitToFight</span><span class="token punctuation">(</span>countDownLatch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> 哪吒 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token function">waitToFight</span><span class="token punctuation">(</span>countDownLatch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> 铠 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token function">waitToFight</span><span class="token punctuation">(</span>countDownLatch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    大乔<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    兰陵王<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    安其拉<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    哪吒<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    铠<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"敌方还有5秒达到战场，全军出击！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">waitToFight</span><span class="token punctuation">(</span><span class="token class-name">CountDownLatch</span> countDownLatch<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在此等待信号再继续</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"收到，发起进攻！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>CountDownLatch的<strong>核心方法</strong>也不多：</p><ul><li><p><code>await()</code>：等待latch降为0；</p></li><li><p><code>boolean await(long timeout, TimeUnit unit)</code>：等待latch降为0，但是可以设置超时时间。比如有玩家超时未确认，那就重新匹配，总不能为了某个玩家等到天荒地老。</p></li><li><p><code>countDown()</code>：latch数量减1；</p></li><li><p><code>getCount()</code>：获取当前的latch数量。</p></li></ul><h2 id="39-CyclicBarrier（同步屏障）了解吗？"><a href="#39-CyclicBarrier（同步屏障）了解吗？" class="headerlink" title="39.CyclicBarrier（同步屏障）了解吗？"></a>39.CyclicBarrier（同步屏障）了解吗？</h2><p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一 组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p><p>它和CountDownLatch类似，都可以协调多线程的结束动作，在它们结束后都可以执行特定动作，但是为什么要有CyclicBarrier，自然是它有和CountDownLatch不同的地方。</p><p>不知道你听没听过一个新人UP主小约翰可汗，小约翰生平有两大恨——“想结衣结衣不依,迷爱理爱理不理。”我们来还原一下事情的经过：小约翰在亲政后认识了新垣结衣，于是决定第一次选妃，向结衣表白，等待回应。然而新垣结衣回应嫁给了星野源，小约翰伤心欲绝，发誓生平不娶，突然发现了铃木爱理，于是小约翰决定第二次选妃，求爱理搭理，等待回应。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357003401-f4c11a42-1cc6-417f-b647-03e301ecb49d.png" alt="img"></p><p>我们拿代码模拟这一场景，发现CountDownLatch无能为力了，因为CountDownLatch的使用是一次性的，无法重复利用，而这里等待了两次。此时，我们用CyclicBarrier就可以实现，因为它可以重复利用。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357005814-eb034af5-45de-4bc6-9936-3b9ddca4e78b.png" alt="img"></p><p>运行结果：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357008211-8f6b0701-c429-4303-a55e-40530d88ee30.png" alt="img"></p><p>CyclicBarrier最最核心的方法，仍然是await()：如果当前线程不是第一个到达屏障的话，它将会进入等待，直到其他线程都到达，除非发生<strong>被中断</strong>、<strong>屏障被拆除</strong>、<strong>屏障被重设</strong>等情况；</p><p>上面的例子抽象一下，本质上它的流程就是这样就是这样：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357010270-61d561a1-1c43-4d37-9081-3e2d27f934e7.png" alt="img"></p><h2 id="40-CyclicBarrier和CountDownLatch有什么区别？"><a href="#40-CyclicBarrier和CountDownLatch有什么区别？" class="headerlink" title="40.CyclicBarrier和CountDownLatch有什么区别？"></a>40.CyclicBarrier和CountDownLatch有什么区别？</h2><p>两者最核心的区别[18]：</p><p>1、CountDownLatch是一次性的，而CyclicBarrier则可以多次设置屏障，实现重复利用；</p><p>2、CountDownLatch中的各个子线程不可以等待其他线程，只能完成自己的任务；而CyclicBarrier中的各个线程可以等待其他线程</p><p>它们区别用一个表格整理：</p><h2 id="41-Semaphore（信号量）了解吗？"><a href="#41-Semaphore（信号量）了解吗？" class="headerlink" title="41.Semaphore（信号量）了解吗？"></a>41.Semaphore（信号量）了解吗？</h2><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</p><p>听起来似乎很抽象，现在汽车多了，开车出门在外的一个老大难问题就是停车 。停车场的车位是有限的，只能允许若干车辆停泊，如果停车场还有空位，那么显示牌显示的就是绿灯和剩余的车位，车辆就可以驶入；如果停车场没位了，那么显示牌显示的就是绿灯和数字0，车辆就得等待。如果满了的停车场有车离开，那么显示牌就又变绿，显示空车位数量，等待的车辆就能进停车场。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357012724-49ef5122-836e-408b-b4aa-7c6228a7a33d.jpeg" alt="img"></p><p>我们把这个例子类比一下，车辆就是线程，进入停车场就是线程在执行，离开停车场就是线程执行完毕，看见红灯就表示线程被阻塞，不能执行，Semaphore的本质就是<strong>协调多个线程对共享资源的获取</strong>。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357016715-c3840ec2-a6f9-46a5-b0ef-c0dacd836aeb.png" alt="img"></p><p>我们再来看一个Semaphore的用途：它可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。</p><p>假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制，如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SemaphoreTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">THREAD_COUNT</span> <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> threadPool <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token constant">THREAD_COUNT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Semaphore</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token constant">THREAD_COUNT</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                        s<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"save data"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        s<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        threadPool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在代码中，虽然有30个线程在执行，但是只允许10个并发执行。Semaphore的构造方法<code>Semaphore（int permits</code>）接受一个整型的数字，表示可用的许可证数量。<code>Semaphore（10）</code>表示允许10个线程获取许可证，也就是最大并发数是10。Semaphore的用法也很简单，首先线程使用 Semaphore的acquire()方法获取一个许可证，使用完之后调用release()方法归还许可证。还可以用tryAcquire()方法尝试获取许可证。</p><h2 id="42-Exchanger-了解吗？"><a href="#42-Exchanger-了解吗？" class="headerlink" title="42.Exchanger 了解吗？"></a>42.Exchanger 了解吗？</h2><p>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357020944-d1c87b25-f3bf-4cfc-afad-855898cb3b4b.png" alt="img"></p><p>这两个线程通过 exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</p><p>Exchanger可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。Exchanger也可以用于校对工作，比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExchangerTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Exchanger</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> exgr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Exchanger</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> threadPool <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">String</span> <span class="token class-name">A</span> <span class="token operator">=</span> <span class="token string">"银行流水A"</span><span class="token punctuation">;</span> <span class="token comment">// A录入银行流水数据 </span>                    exgr<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">String</span> <span class="token class-name">B</span> <span class="token operator">=</span> <span class="token string">"银行流水B"</span><span class="token punctuation">;</span> <span class="token comment">// B录入银行流水数据 </span>                    <span class="token class-name">String</span> <span class="token class-name">A</span> <span class="token operator">=</span> exgr<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A和B数据是否一致："</span> <span class="token operator">+</span> <span class="token class-name">A</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">B</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"，A录入的是："</span>                            <span class="token operator">+</span> <span class="token class-name">A</span> <span class="token operator">+</span> <span class="token string">"，B录入是："</span> <span class="token operator">+</span> <span class="token class-name">B</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        threadPool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假如两个线程有一个没有执行exchange()方法，则会一直等待，如果担心有特殊情况发生，避免一直等待，可以使用<code>exchange(V x, long timeOut, TimeUnit unit)</code>设置最大等待时长。</p><h2 id="43-什么是线程池？"><a href="#43-什么是线程池？" class="headerlink" title="43.什么是线程池？"></a>43.什么是线程池？</h2><p><strong>线程池：</strong> 简单理解，它就是一个管理线程的池子。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357024531-df689dc0-3e16-4486-a13e-01c40c476592.png" alt="img"></p><p><strong>它帮我们管理线程，避免增加创建线程和销毁线程的资源损耗</strong>。因为线程其实也是一个对象，创建一个对象，需要经过类加载过程，销毁一个对象，需要走GC垃圾回收流程，都是需要资源开销的。</p><p><strong>提高响应速度。</strong> 如果任务到达了，相对于从线程池拿线程，重新去创建一条线程执行，速度肯定慢很多。</p><p><strong>重复利用。</strong> 线程用完，再放回池子，可以达到重复利用的效果，节省资源。</p><h2 id="44-能说说工作中线程池的应用吗？"><a href="#44-能说说工作中线程池的应用吗？" class="headerlink" title="44.能说说工作中线程池的应用吗？"></a>44.能说说工作中线程池的应用吗？</h2><p>之前我们有一个和第三方对接的需求，需要向第三方推送数据，引入了多线程来提升数据推送的效率，其中用到了线程池来管理线程。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357026337-0ab9d452-4cae-44e0-9231-cc2e42b469c7.png" alt="img"></p><p>主要代码如下：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357028159-1d06f0f5-e0f8-4c21-b4ae-f51f497ff59b.png" alt="img"></p><p>线程池的参数如下：</p><ul><li><p>corePoolSize：线程核心参数选择了CPU数×2</p></li><li><p>maximumPoolSize：最大线程数选择了和核心线程数相同</p></li><li><p>keepAliveTime：非核心闲置线程存活时间直接置为0</p></li><li><p>unit：非核心线程保持存活的时间选择了 TimeUnit.SECONDS 秒</p></li><li><p>workQueue：线程池等待队列，使用 LinkedBlockingQueue阻塞队列</p></li></ul><p>同时还用了synchronized 来加锁，保证数据不会被重复推送：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">PushProcessServiceImpl</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>ps:这个例子只是简单地进行了数据推送，实际上还可以结合其他的业务，像什么数据清洗啊、数据统计啊，都可以套用。</p><h2 id="45-能简单说一下线程池的工作流程吗？"><a href="#45-能简单说一下线程池的工作流程吗？" class="headerlink" title="45.能简单说一下线程池的工作流程吗？"></a>45.能简单说一下线程池的工作流程吗？</h2><p>用一个通俗的比喻：</p><p>有一个营业厅，总共有六个窗口，现在开放了三个窗口，现在有三个窗口坐着三个营业员小姐姐在营业。</p><p>陈哥去办业务，可能会遇到什么情况呢？</p><p>1、陈哥发现有空间的在营业的窗口，直接去找小姐姐办理业务。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357032756-5aeb2ecf-7bbe-4458-b2c4-f422b47dbb35.png" alt="img"></p><p>2、陈哥发现没有空闲的窗口，就在排队区排队等。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357035674-5841bde6-7c75-43cf-af52-357d9eb6e980.png" alt="img"></p><p>3、陈哥发现没有空闲的窗口，等待区也满了，蚌埠住了，经理一看，就让休息的小姐姐赶紧回来上班，等待区号靠前的赶紧去新窗口办，陈哥去排队区排队。小姐姐比较辛苦，假如一段时间发现他们可以不用接着营业，经理就让她们接着休息。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357038054-7faa5b7c-076f-4a6a-9de5-f3f84bdd1c30.png" alt="img"></p><p>4、陈哥一看，六个窗口都满了，等待区也没位置了。陈哥急了，要闹，经理赶紧出来了，经理该怎么办呢？</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357039802-da447f21-f6b5-438f-9fef-cea5c9762720.png" alt="img"></p><p>1、我们银行系统已经瘫痪</p><p>2、谁叫你来办的你找谁去</p><p>3、看你比较急，去队里加个塞</p><p>4、今天没办法，不行你看改一天</p><p><strong>上面的这个流程几乎就跟 JDK 线程池的大致流程类似</strong>，</p><p>1、营业中的 3个窗口对应核心线程池数：corePoolSize</p><p>2、总的营业窗口数6对应：maximumPoolSize</p><p>3、打开的临时窗口在多少时间内无人办理则关闭对应：unit</p><p>4、排队区就是等待队列：workQueue</p><p>5、无法办理的时候银行给出的解决方法对应：RejectedExecutionHandler</p><p>6、threadFactory 该参数在 JDK 中是 线程工厂，用来创建线程对象，一般不会动。</p><p>所以我们线程池的工作流程也比较好理解了：</p><p>1、线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</p><p>2、当调用 execute() 方法添加一个任务时，线程池会做如下判断：</p><ul><li><p>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</p></li><li><p>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</p></li><li><p>如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</p></li><li><p>如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会根据拒绝策略来对应处理。</p></li></ul><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357042500-21f5eed7-909b-4f9c-ac50-00b6c716e35f.png" alt="img"></p><p>1、当一个线程完成任务时，它会从队列中取下一个任务来执行。</p><p>2、当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</p><h2 id="46-线程池主要参数有哪些？"><a href="#46-线程池主要参数有哪些？" class="headerlink" title="46.线程池主要参数有哪些？"></a>46.线程池主要参数有哪些？</h2><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357044420-fb9c86c8-627b-4d6d-ac09-737eb69c64e3.png" alt="img"></p><p>线程池有七大参数，需要重点关注<code>corePoolSize</code>、<code>maximumPoolSize</code>、<code>workQueue</code>、<code>handler</code>这四个。</p><p><strong>1、corePoolSize</strong></p><p>此值是用来初始化线程池中核心线程数，当线程池中线程池数&lt; <code>corePoolSize</code>时，系统默认是添加一个任务才创建一个线程池。当线程数 &#x3D; corePoolSize时，新任务会追加到workQueue中。</p><p><strong>2、maximumPoolSize</strong></p><p><code>maximumPoolSize</code>表示允许的最大线程数 &#x3D; (非核心线程数+核心线程数)，当<code>BlockingQueue</code>也满了，但线程池中总线程数 &lt; <code>maximumPoolSize</code>时候就会再次创建新的线程。</p><p><strong>3、keepAliveTime</strong></p><p>非核心线程 &#x3D;(maximumPoolSize - corePoolSize ) ,非核心线程闲置下来不干活最多存活时间。</p><p><strong>4、unit</strong></p><p>线程池中非核心线程保持存活的时间的单位</p><ul><li><p>TimeUnit.DAYS; 天</p></li><li><p>TimeUnit.HOURS; 小时</p></li><li><p>TimeUnit.MINUTES; 分钟</p></li><li><p>TimeUnit.SECONDS; 秒</p></li><li><p>TimeUnit.MILLISECONDS;  毫秒</p></li><li><p>TimeUnit.MICROSECONDS;  微秒</p></li><li><p>TimeUnit.NANOSECONDS;  纳秒</p></li></ul><p><strong>5、workQueue</strong></p><p>线程池等待队列，维护着等待执行的<code>Runnable</code>对象。当运行当线程数&#x3D; corePoolSize时，新的任务会被添加到<code>workQueue</code>中，如果<code>workQueue</code>也满了则尝试用非核心线程执行任务，等待队列应该尽量用有界的。</p><p><strong>6、threadFactory</strong></p><p>创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等。</p><p><strong>7、handler</strong></p><p><code>corePoolSize</code>、<code>workQueue</code>、<code>maximumPoolSize</code>都不可用的时候执行的饱和策略。</p><h2 id="47-线程池的拒绝策略有哪些？"><a href="#47-线程池的拒绝策略有哪些？" class="headerlink" title="47.线程池的拒绝策略有哪些？"></a>47.线程池的拒绝策略有哪些？</h2><p>类比前面的例子，无法办理业务时的处理方式，帮助记忆：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357047322-958d414b-46e2-4b9d-9027-1f5a6b4229db.png" alt="img"></p><p>1、AbortPolicy ：直接抛出异常，默认使用此策略</p><p>2、CallerRunsPolicy：用调用者所在的线程来执行任务</p><p>3、DiscardOldestPolicy：丢弃阻塞队列里最老的任务，也就是队列里靠前的任务</p><p>4、DiscardPolicy ：当前任务直接丢弃</p><p>想实现自己的拒绝策略，实现RejectedExecutionHandler接口即可。</p><h2 id="48-线程池有哪几种工作队列？"><a href="#48-线程池有哪几种工作队列？" class="headerlink" title="48.线程池有哪几种工作队列？"></a>48.线程池有哪几种工作队列？</h2><p>常用的阻塞队列主要有以下几种：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357049435-b107fe5c-36b8-45cb-8125-1031b8cd007b.png" alt="img"></p><p>ArrayBlockingQueue：ArrayBlockingQueue（有界队列）是一个用数组实现的有界阻塞队列，按FIFO排序量。</p><p>LinkedBlockingQueue：LinkedBlockingQueue（可设置容量队列）是基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE，吞吐量通常要高于ArrayBlockingQuene；newFixedThreadPool线程池使用了这个队列</p><p>DelayQueue：DelayQueue（延迟队列）是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。newScheduledThreadPool线程池使用了这个队列。</p><p>PriorityBlockingQueue：PriorityBlockingQueue（优先级队列）是具有优先级的无界阻塞队列</p><p>SynchronousQueue：SynchronousQueue（同步队列）是一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene，newCachedThreadPool线程池使用了这个队列。</p><h2 id="49-线程池提交execute和submit有什么区别？"><a href="#49-线程池提交execute和submit有什么区别？" class="headerlink" title="49.线程池提交execute和submit有什么区别？"></a>49.线程池提交execute和submit有什么区别？</h2><p>execute 用于提交不需要返回值的任务</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">threadsPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token comment">// TODO Auto-generated method stub &#125; </span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个 future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> future <span class="token operator">=</span> executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>harReturnValuetask<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span> <span class="token class-name">Object</span> s <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">// 处理中断异常 </span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">// 处理无法执行任务异常 </span><span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>     <span class="token comment">// 关闭线程池 executor.shutdown();</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="50-线程池怎么关闭知道吗？"><a href="#50-线程池怎么关闭知道吗？" class="headerlink" title="50.线程池怎么关闭知道吗？"></a>50.线程池怎么关闭知道吗？</h2><p>可以通过调用线程池的<code>shutdown</code>或<code>shutdownNow</code>方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。</p><p><strong>shutdown() 将线程池状态置为shutdown,并不会立即停止</strong>：</p><p>1、停止接收外部submit的任务</p><p>2、内部正在跑的任务和队列里等待的任务，会执行完</p><p>3、等到第二步完成后，才真正停止</p><p><strong>shutdownNow() 将线程池状态置为stop。一般会立即停止，事实上不一定</strong>：</p><p>1、和shutdown()一样，先停止接收外部提交的任务</p><p>2、忽略队列里等待的任务</p><p>3、尝试将正在跑的任务interrupt中断</p><p>4、返回未执行的任务列表</p><p>shutdown 和shutdownnow简单来说区别如下：</p><ul><li><p>shutdownNow()能立即停止线程池，正在跑的和正在等待的任务都停下了。这样做立即生效，但是风险也比较大。</p></li><li><p>shutdown()只是关闭了提交通道，用submit()是无效的；而内部的任务该怎么跑还是怎么跑，跑完再彻底停止线程池。</p></li></ul><h2 id="51-线程池的线程数应该怎么配置？"><a href="#51-线程池的线程数应该怎么配置？" class="headerlink" title="51.线程池的线程数应该怎么配置？"></a>51.线程池的线程数应该怎么配置？</h2><p>线程在Java中属于稀缺资源，线程池不是越大越好也不是越小越好。任务分为计算密集型、IO密集型、混合型。</p><p>计算密集型：大部分都在用CPU跟内存，加密，逻辑操作业务处理等。</p><p>IO密集型：数据库链接，网络通讯传输等。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357053581-bbed43b9-be4f-4744-8d65-0b1e92b4b678.png" alt="img"></p><p>一般的经验，不同类型线程池的参数配置：</p><p>计算密集型一般推荐线程池不要过大，一般是CPU数 + 1，+1是因为可能存在<strong>页缺失</strong>(就是可能存在有些数据在硬盘中需要多来一个线程将数据读入内存)。如果线程池数太大，可能会频繁的 进行线程上下文切换跟任务调度。获得当前CPU核心数代码如下：</p><pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">Runtime.getRuntime().availableProcessors();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>IO密集型：线程数适当大一点，机器的Cpu核心数*2。</p><p>混合型：可以考虑根绝情况将它拆分成CPU密集型和IO密集型任务，如果执行时间相差不大，拆分可以提升吞吐量，反之没有必要。</p><p>当然，实际应用中没有固定的公式，需要结合测试和监控来进行调整。</p><h2 id="52-有哪几种常见的线程池？"><a href="#52-有哪几种常见的线程池？" class="headerlink" title="52.有哪几种常见的线程池？"></a>52.有哪几种常见的线程池？</h2><p>面试常问，主要有四种，都是通过工具类Excutors创建出来的，需要注意，阿里巴巴《Java开发手册》里禁止使用这种方式来创建线程池。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357056125-1420465f-374c-4f3d-9afb-377be68cb97b.png" alt="img"></p><p>newFixedThreadPool  (固定数目线程的线程池)</p><p>newCachedThreadPool (可缓存线程的线程池)</p><p>newSingleThreadExecutor (单线程的线程池)</p><p>newScheduledThreadPool (定时及周期执行的线程池)</p><h2 id="53-能说一下四种常见线程池的原理吗？"><a href="#53-能说一下四种常见线程池的原理吗？" class="headerlink" title="53.能说一下四种常见线程池的原理吗？"></a>53.能说一下四种常见线程池的原理吗？</h2><p>前三种线程池的构造直接调用ThreadPoolExecutor的构造方法。</p><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>          <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>                                  <span class="token number">0L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">,</span>                                  <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                  threadFactory<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>线程池特点</strong></p><ul><li><p>核心线程数为1</p></li><li><p>最大线程数也为1</p></li><li><p>阻塞队列是无界队列LinkedBlockingQueue，可能会导致OOM</p></li><li><p>keepAliveTime为0</p></li></ul><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357058924-6339b9bd-f1ca-441f-b81b-7b0dc18d416e.png" alt="img"></p><p>工作流程：</p><ul><li><p>提交任务</p></li><li><p>线程池是否有一条线程在，如果没有，新建线程执行任务</p></li><li><p>如果有，将任务加到阻塞队列</p></li><li><p>当前的唯一线程，从队列取任务，执行完一个，再继续取，一个线程执行任务。</p></li></ul><p><strong>适用场景</strong></p><p>适用于串行执行任务的场景，一个任务一个任务地执行。</p><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">,</span> <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>                                    <span class="token number">0L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">,</span>                                    <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                    threadFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>线程池特点：</strong></p><ul><li><p>核心线程数和最大线程数大小一样</p></li><li><p>没有所谓的非空闲时间，即keepAliveTime为0</p></li><li><p>阻塞队列为无界队列LinkedBlockingQueue，可能会导致OOM</p></li></ul><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357061932-8f24dfe8-8ba2-4786-a521-1f226c0aebc0.png" alt="img"></p><p>工作流程：</p><ul><li><p>提交任务</p></li><li><p>如果线程数少于核心线程，创建核心线程执行任务</p></li><li><p>如果线程数等于核心线程，把任务添加到LinkedBlockingQueue阻塞队列</p></li><li><p>如果线程执行完任务，去阻塞队列取任务，继续执行。</p></li></ul><p><strong>使用场景</strong></p><p>FixedThreadPool 适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。</p><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">,</span>                                   <span class="token number">60L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">,</span>                                   <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                   threadFactory<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>线程池特点：</strong></p><ul><li><p>核心线程数为0</p></li><li><p>最大线程数为Integer.MAX_VALUE，即无限大，可能会因为无限创建线程，导致OOM</p></li><li><p>阻塞队列是SynchronousQueue</p></li><li><p>非核心线程空闲存活时间为60秒</p></li></ul><p>当提交任务的速度大于处理任务的速度时，每次提交一个任务，就必然会创建一个线程。极端情况下会创建过多的线程，耗尽 CPU 和内存资源。由于空闲 60 秒的线程会被终止，长时间保持空闲的 CachedThreadPool 不会占用任何资源。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357064355-c12b6db8-d7a6-4072-b67c-4600b10d0b06.png" alt="img"></p><p>工作流程：</p><ul><li><p>提交任务</p></li><li><p>因为没有核心线程，所以任务直接加到SynchronousQueue队列。</p></li><li><p>判断是否有空闲线程，如果有，就去取出任务执行。</p></li><li><p>如果没有空闲线程，就新建一个线程执行。</p></li><li><p>执行完任务的线程，还可以存活60秒，如果在这期间，接到任务，可以继续活下去；否则，被销毁。</p></li></ul><p><strong>适用场景</strong></p><p>用于并发执行大量短期的小任务。</p><h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NANOSECONDS</span><span class="token punctuation">,</span>          <span class="token keyword">new</span> <span class="token class-name">DelayedWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>线程池特点</strong></p><ul><li><p>最大线程数为Integer.MAX_VALUE，也有OOM的风险</p></li><li><p>阻塞队列是DelayedWorkQueue</p></li><li><p>keepAliveTime为0</p></li><li><p>scheduleAtFixedRate() ：按某种速率周期执行</p></li><li><p>scheduleWithFixedDelay()：在某个延迟后执行</p></li></ul><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357066939-5e8a0951-e313-43bb-afd5-9c755b5ee80f.png" alt="img"></p><p><strong>工作机制</strong></p><ul><li><p>线程从DelayQueue中获取已到期的ScheduledFutureTask（DelayQueue.take()）。到期任务是指ScheduledFutureTask的time大于等于当前时间。</p></li><li><p>线程执行这个ScheduledFutureTask。</p></li><li><p>线程修改ScheduledFutureTask的time变量为下次将要被执行的时间。</p></li><li><p>线程把这个修改time之后的ScheduledFutureTask放回DelayQueue中（DelayQueue.add()）。</p></li></ul><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357068949-1a85b428-fb10-4939-95b2-5d2736493610.png" alt="img"></p><p><strong>使用场景</strong></p><p>周期性执行任务的场景，需要限制线程数量的场景</p><p><strong>使用无界队列的线程池会导致什么问题吗？</strong></p><p>例如newFixedThreadPool使用了无界的阻塞队列LinkedBlockingQueue，如果线程获取一个任务后，任务的执行时间比较长，会导致队列的任务越积越多，导致机器内存使用不停飙升，最终导致OOM。</p><h2 id="54-线程池异常怎么处理知道吗？"><a href="#54-线程池异常怎么处理知道吗？" class="headerlink" title="54.线程池异常怎么处理知道吗？"></a>54.线程池异常怎么处理知道吗？</h2><p>在使用线程池处理任务的时候，任务代码可能抛出RuntimeException，抛出异常后，线程池可能捕获它，也可能创建一个新的线程来代替异常的线程，我们可能无法感知任务出现了异常，因此我们需要考虑线程池异常情况。</p><p>常见的异常处理方式：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357071412-345b2afb-dcf2-4f0e-b25a-b4c306c2fc4c.png" alt="img"></p><h2 id="55-能说一下线程池有几种状态吗？"><a href="#55-能说一下线程池有几种状态吗？" class="headerlink" title="55.能说一下线程池有几种状态吗？"></a>55.能说一下线程池有几种状态吗？</h2><p>线程池有这几个状态：RUNNING,SHUTDOWN,STOP,TIDYING,TERMINATED。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//线程池状态</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">RUNNING</span>    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">SHUTDOWN</span>   <span class="token operator">=</span>  <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">STOP</span>       <span class="token operator">=</span>  <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TIDYING</span>    <span class="token operator">=</span>  <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TERMINATED</span> <span class="token operator">=</span>  <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>线程池各个状态切换图：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357074733-c65a7e94-2daa-4b0d-a210-f4934ccca1bc.png" alt="img"></p><p><strong>RUNNING</strong></p><p>该状态的线程池会接收新任务，并处理阻塞队列中的任务;</p><p>调用线程池的shutdown()方法，可以切换到SHUTDOWN状态;</p><p>调用线程池的shutdownNow()方法，可以切换到STOP状态;</p><p><strong>SHUTDOWN</strong></p><p>该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；</p><p>队列为空，并且线程池中执行的任务也为空,进入TIDYING状态;</p><p><strong>STOP</strong></p><p>该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；</p><p>线程池中执行的任务为空,进入TIDYING状态;</p><p><strong>TIDYING</strong></p><p>该状态表明所有的任务已经运行终止，记录的任务数量为0。</p><p>terminated()执行完毕，进入TERMINATED状态</p><p><strong>TERMINATED</strong></p><p>该状态表示线程池彻底终止</p><h2 id="56-线程池如何实现参数的动态修改？"><a href="#56-线程池如何实现参数的动态修改？" class="headerlink" title="56.线程池如何实现参数的动态修改？"></a>56.线程池如何实现参数的动态修改？</h2><p>线程池提供了几个  setter方法来设置线程池的参数。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357076909-8553593e-bc32-448d-ba6f-6a86c15aabf3.png" alt="img"></p><p>这里主要有两个思路：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357079082-5571edf0-7933-4158-b0d2-083d2467a751.png" alt="img"></p><p>在我们微服务的架构下，可以利用配置中心如Nacos、Apollo等等，也可以自己开发配置中心。业务服务读取线程池配置，获取相应的线程池实例来修改线程池的参数。</p><p>如果限制了配置中心的使用，也可以自己去扩展<strong>ThreadPoolExecutor</strong>，重写方法，监听线程池参数变化，来动态修改线程池参数。</p><h2 id="57-线程池调优了解吗？"><a href="#57-线程池调优了解吗？" class="headerlink" title="57.线程池调优了解吗？"></a>57.线程池调优了解吗？</h2><p>线程池配置没有固定的公式，通常事前会对线程池进行一定评估，常见的评估方案如下：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357081500-c19a710a-740a-4fbc-9425-45d5157d23f5.png" alt="img"></p><p>上线之前也要进行充分的测试，上线之后要建立完善的线程池监控机制。</p><p>事中结合监控告警机制，分析线程池的问题，或者可优化点，结合线程池动态参数配置机制来调整配置。</p><p>事后要注意仔细观察，随时调整。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357083487-5bc0fe29-11ae-4f90-97c2-86c0f7e7a7f9.png" alt="img"></p><p>具体的调优案例可以查看参考[7]美团技术博客。</p><h2 id="58-你能设计实现一个线程池吗？"><a href="#58-你能设计实现一个线程池吗？" class="headerlink" title="58.你能设计实现一个线程池吗？"></a>58.你能设计实现一个线程池吗？</h2><p>⭐这道题在阿里的面试中出现频率比较高</p><p>线程池实现原理可以查看 要是以前有人这么讲线程池，我早就该明白了！ ，当然，我们自己实现， 只需要抓住线程池的核心流程-参考[6]：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357085324-9d049416-b482-438b-b8e6-835b3a16211a.png" alt="img"></p><p>我们自己的实现就是完成这个核心流程：</p><ul><li><p>线程池中有N个工作线程</p></li><li><p>把任务提交给线程池运行</p></li><li><p>如果线程池已满，把任务放入队列</p></li><li><p>最后当有空闲时，获取队列中任务来执行</p></li></ul><p>实现代码[6]：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357096574-4e7bde51-33da-4d50-8afb-567ce49fed85.png" alt="img"></p><p>这样，一个实现了线程池主要流程的类就完成了。</p><h2 id="59-单机线程池执行断电了应该怎么处理？"><a href="#59-单机线程池执行断电了应该怎么处理？" class="headerlink" title="59.单机线程池执行断电了应该怎么处理？"></a>59.单机线程池执行断电了应该怎么处理？</h2><p>我们可以对正在处理和阻塞队列的任务做事务管理或者对阻塞队列中的任务持久化处理，并且当断电或者系统崩溃，操作无法继续下去的时候，可以通过回溯日志的方式来撤销<code>正在处理</code>的已经执行成功的操作。然后重新执行整个阻塞队列。</p><p>也就是说，对阻塞队列持久化；正在处理任务事务控制；断电之后正在处理任务的回滚，通过日志恢复该次操作；服务器重启后阻塞队列中的数据再加载。</p><h2 id="60-Fork-x2F-Join框架了解吗？"><a href="#60-Fork-x2F-Join框架了解吗？" class="headerlink" title="60.Fork&#x2F;Join框架了解吗？"></a>60.Fork&#x2F;Join框架了解吗？</h2><p>Fork&#x2F;Join框架是Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p><p>要想掌握Fork&#x2F;Join框架，首先需要理解两个点，<strong>分而治之</strong>和<strong>工作窃取算法</strong>。</p><p><strong>分而治之</strong></p><p>Fork&#x2F;Join框架的定义，其实就体现了分治思想：将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357100106-fa62e55f-614f-42ff-b43e-71be98ba4e61.png" alt="img"></p><p><strong>工作窃取算法</strong></p><p>大任务拆成了若干个小任务，把这些小任务放到不同的队列里，各自创建单独线程来执行队列里的任务。</p><p>那么问题来了，有的线程干活块，有的线程干活慢。干完活的线程不能让它空下来，得让它去帮没干完活的线程干活。它去其它线程的队列里窃取一个任务来执行，这就是所谓的<strong>工作窃取</strong>。</p><p>工作窃取发生的时候，它们会访问同一个队列，为了减少窃取任务线程和被窃取任务线程之间的竞争，通常任务会使用双端队列，被窃取任务线程永远从双端队列的头部拿，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%AF%87.assets/1676357102488-3c60d9a5-0868-46de-8307-f796baaf4f00.png" alt="img"></p><p>看一个Fork&#x2F;Join框架应用的例子，计算1~n之间的和：<code>1+2+3+…+n</code></p><p>设置一个分割阈值，任务大于阈值就拆分任务</p><p>任务有结果，所以需要继承RecursiveTask</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountTask</span> <span class="token keyword">extends</span> <span class="token class-name">RecursiveTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">THRESHOLD</span> <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span> <span class="token comment">// 阈值</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> start<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> end<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> start<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> end<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token class-name">Integer</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 如果任务足够小就计算任务</span>        <span class="token keyword">boolean</span> canCompute <span class="token operator">=</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token constant">THRESHOLD</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>canCompute<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 如果任务大于阈值，就分裂成两个子任务计算</span>            <span class="token keyword">int</span> middle <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token class-name">CountTask</span> leftTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> middle<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">CountTask</span> rightTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span>middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 执行子任务</span>            leftTask<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            rightTask<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待子任务执行完，并得到其结果</span>            <span class="token keyword">int</span> leftResult <span class="token operator">=</span> leftTask<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> rightResult <span class="token operator">=</span> rightTask<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 合并子任务</span>            sum <span class="token operator">=</span> leftResult <span class="token operator">+</span> rightResult<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ForkJoinPool</span> forkJoinPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 生成一个计算任务，负责计算1+2+3+4</span>        <span class="token class-name">CountTask</span> task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行一个任务</span>        <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> result <span class="token operator">=</span> forkJoinPool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ForkJoinTask与一般Task的主要区别在于它需要实现compute方法，在这个方法里，首先需要判断任务是否足够小，如果足够小就直接执行任务。如果比较大，就必须分割成两个子任务，每个子任务在调用fork方法时，又会进compute方法，看看当前子任务是否需要继续分割成子任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会等待子任务执行完并得到其结果。</p><h2 id="描述一下notify和notifyAll的区别"><a href="#描述一下notify和notifyAll的区别" class="headerlink" title="描述一下notify和notifyAll的区别"></a>描述一下notify和notifyAll的区别</h2><ol><li>首先最好说一下 锁池 和 等待池 的概念</li><li>锁池:假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对</li></ol><p>象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的</p><p>synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程</p><p>A拥有，所以这些线程就进入了该对象的锁池中。</p><ol start="2"><li>等待池:假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁(因为</li></ol><p>wait()方法必须出现在synchronized中，这样自然在执行wait()方法之前线程A就已经拥</p><p>有了该对象的锁)，同时线程A就进入到了该对象的等待池中。如果另外的一个线程调用</p><p>了相同对象的notifyAll()方法，那么处于该对象的等待池中的线程就会全部进入该对象的</p><p>锁池中，准备争夺锁的拥有权。如果另外的一个线程调用了相同对象的notify()方法，那</p><p>么仅仅有一个处于该对象的等待池中的线程(随机)会进入该对象的锁池.</p><ol><li><p>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不</p><p>会去竞争该对象的锁</p></li><li><p>当有线程调用了对象的 notifyAll()方法(唤醒所有 wait 线程)或 notify()方法(只随机唤醒一</p><p>个 wait 线程)，被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象</p><p>锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争</p></li><li><p>所谓唤醒线程，另一种解释可以说是将线程由等待池移动到锁池，notifyAll调用后，会将全部 线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等 待锁被释放后再次参与竞争。而notify只会唤醒一个线程。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-并行跟并发有什么区别？&quot;&gt;&lt;a href=&quot;#1-并行跟并发有什么区别？&quot; class=&quot;headerlink&quot; title=&quot;1.并行跟并发有什么区别？&quot;&gt;&lt;/a&gt;1.并行跟并发有什么区别？&lt;/h2&gt;&lt;p&gt;从操作系统的角度来看，线程是CPU分配的最小单位。&lt;</summary>
      
    
    
    
    <category term="PROJECT" scheme="https://zspcer.gitee.io/categories/PROJECT/"/>
    
    <category term="我要进大厂" scheme="https://zspcer.gitee.io/categories/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/"/>
    
    
    <category term="面试" scheme="https://zspcer.gitee.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="我要进大厂" scheme="https://zspcer.gitee.io/tags/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/"/>
    
    <category term="多线程" scheme="https://zspcer.gitee.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="高并发" scheme="https://zspcer.gitee.io/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>mermaid</title>
    <link href="https://zspcer.gitee.io/note/TOOLS/markdown/mermaid/"/>
    <id>https://zspcer.gitee.io/note/TOOLS/markdown/mermaid/</id>
    <published>2023-04-28T14:32:00.000Z</published>
    <updated>2023-05-05T07:52:55.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mermaid"><a href="#mermaid" class="headerlink" title="mermaid"></a>mermaid</h1><h2 id="关于-Mermaid"><a href="#关于-Mermaid" class="headerlink" title="关于 Mermaid"></a>关于 Mermaid</h2><p><a href="https://github.com/mermaid-js/mermaid/blob/develop/README.zh-CN.md">https://github.com/mermaid-js/mermaid/blob/develop/README.zh-CN.md</a></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>下面是一些可以使用 Mermaid 创建的图表示例。点击 <a href="https://mermaid-js.github.io/mermaid/#/n00b-syntaxReference">语法</a> 查看详情。</strong></p><table><!-- <Flowchart> --><h3 id="流程图-文档"><a href="#流程图-文档" class="headerlink" title="流程图 [文档 ]"></a>流程图 [<a href="https://mermaid-js.github.io/mermaid/#/flowchart">文档</a> ]</h3><pre class="line-numbers language-none"><code class="language-none">flowchart LRA[Hard] --&gt;|Text| B(Round)B --&gt; C&#123;Decision&#125;C --&gt;|One| D[Result 1]C --&gt;|Two| E[Result 2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="mermaid">flowchart LRA[Hard] -->|Text| B(Round)B --> C{Decision}C -->|One| D[Result 1]C -->|Two| E[Result 2]</pre><h3 id="时序图-文档"><a href="#时序图-文档" class="headerlink" title="时序图 [文档 ]"></a>时序图 [<a href="https://mermaid-js.github.io/mermaid/#/sequenceDiagram">文档</a> ]</h3><pre class="line-numbers language-none"><code class="language-none">sequenceDiagramAlice-&gt;&gt;John: Hello John, how are you?loop Healthcheck    John-&gt;&gt;John: Fight against hypochondriaendNote right of John: Rational thoughts!John--&gt;&gt;Alice: Great!John-&gt;&gt;Bob: How about you?Bob--&gt;&gt;John: Jolly good!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="mermaid">sequenceDiagramAlice->>John: Hello John, how are you?loop Healthcheck    John->>John: Fight against hypochondriaendNote right of John: Rational thoughts!John-->>Alice: Great!John->>Bob: How about you?Bob-->>John: Jolly good!</pre><h3 id="甘特图-文档"><a href="#甘特图-文档" class="headerlink" title="甘特图 [文档 ]"></a>甘特图 [<a href="https://mermaid-js.github.io/mermaid/#/gantt">文档</a> ]</h3><pre class="line-numbers language-none"><code class="language-none">gantt    section Section    Completed :done,    des1, 2014-01-06,2014-01-08    Active        :active,  des2, 2014-01-07, 3d    Parallel 1   :         des3, after des1, 1d    Parallel 2   :         des4, after des1, 1d    Parallel 3   :         des5, after des3, 1d    Parallel 4   :         des6, after des4, 1d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="mermaid">gantt    section Section    Completed :done,    des1, 2014-01-06,2014-01-08    Active        :active,  des2, 2014-01-07, 3d    Parallel 1   :         des3, after des1, 1d    Parallel 2   :         des4, after des1, 1d    Parallel 3   :         des5, after des3, 1d    Parallel 4   :         des6, after des4, 1d</pre><h3 id="类图-文档"><a href="#类图-文档" class="headerlink" title="类图 [文档 ]"></a>类图 [<a href="https://mermaid-js.github.io/mermaid/#/classDiagram">文档</a> ]</h3><pre class="line-numbers language-none"><code class="language-none">classDiagramClass01 &lt;|-- AveryLongClass : Cool&lt;&lt;Interface&gt;&gt; Class01Class09 --&gt; C2 : Where am I?Class09 --* C3Class09 --|&gt; Class07Class07 : equals()Class07 : Object[] elementDataClass01 : size()Class01 : int chimpClass01 : int gorillaclass Class10 &#123;  &lt;&lt;service&gt;&gt;  int id  size()&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="mermaid">classDiagramClass01 <|-- AveryLongClass : Cool<<Interface>> Class01Class09 --> C2 : Where am I?Class09 --* C3Class09 --|> Class07Class07 : equals()Class07 : Object[] elementDataClass01 : size()Class01 : int chimpClass01 : int gorillaclass Class10 {  <<service>>  int id  size()}</pre><h3 id="状态图-文档"><a href="#状态图-文档" class="headerlink" title="状态图 [文档]"></a>状态图 [<a href="https://mermaid-js.github.io/mermaid/#/stateDiagram">文档</a>]</h3><pre class="line-numbers language-none"><code class="language-none">stateDiagram-v2[*] --&gt; StillStill --&gt; [*]Still --&gt; MovingMoving --&gt; StillMoving --&gt; CrashCrash --&gt; [*]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="mermaid">stateDiagram-v2[*] --> StillStill --> [*]Still --> MovingMoving --> StillMoving --> CrashCrash --> [*]</pre><h3 id="饼图-文档"><a href="#饼图-文档" class="headerlink" title="饼图 [文档 ]"></a>饼图 [<a href="https://mermaid-js.github.io/mermaid/#/pie">文档</a> ]</h3><pre class="line-numbers language-none"><code class="language-none">pie&quot;Dogs&quot; : 386&quot;Cats&quot; : 85&quot;Rats&quot; : 15<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="mermaid">pie"Dogs" : 386"Cats" : 85"Rats" : 15</pre><h3 id="Git-图-实验特性"><a href="#Git-图-实验特性" class="headerlink" title="Git 图 [实验特性 ]"></a>Git 图 [实验特性 ]</h3><h3 id="用户体验旅程图-文档"><a href="#用户体验旅程图-文档" class="headerlink" title="用户体验旅程图 [文档 ]"></a>用户体验旅程图 [<a href="https://mermaid-js.github.io/mermaid/#/user-journey">文档</a> ]</h3><pre class="line-numbers language-none"><code class="language-none">journey  title My working day  section Go to work    Make tea: 5: Me    Go upstairs: 3: Me    Do work: 1: Me, Cat  section Go home    Go downstairs: 5: Me    Sit down: 3: Me<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="mermaid">  journey    title My working day    section Go to work      Make tea: 5: Me      Go upstairs: 3: Me      Do work: 1: Me, Cat    section Go home      Go downstairs: 5: Me      Sit down: 3: Me</pre><h3 id="C4-图-文档"><a href="#C4-图-文档" class="headerlink" title="C4 图 [文档]"></a>C4 图 [<a href="https://mermaid-js.github.io/mermaid/#/c4c">文档</a>]</h3><pre class="line-numbers language-none"><code class="language-none">C4Contexttitle System Context diagram for Internet Banking SystemPerson(customerA, &quot;Banking Customer A&quot;, &quot;A customer of the bank, with personal bank accounts.&quot;)Person(customerB, &quot;Banking Customer B&quot;)Person_Ext(customerC, &quot;Banking Customer C&quot;)System(SystemAA, &quot;Internet Banking System&quot;, &quot;Allows customers to view information about their bank accounts, and make payments.&quot;)Person(customerD, &quot;Banking Customer D&quot;, &quot;A customer of the bank, &lt;br&#x2F;&gt; with personal bank accounts.&quot;)Enterprise_Boundary(b1, &quot;BankBoundary&quot;) &#123;  SystemDb_Ext(SystemE, &quot;Mainframe Banking System&quot;, &quot;Stores all of the core banking information about customers, accounts, transactions, etc.&quot;)  System_Boundary(b2, &quot;BankBoundary2&quot;) &#123;    System(SystemA, &quot;Banking System A&quot;)    System(SystemB, &quot;Banking System B&quot;, &quot;A system of the bank, with personal bank accounts.&quot;)  &#125;  System_Ext(SystemC, &quot;E-mail system&quot;, &quot;The internal Microsoft Exchange e-mail system.&quot;)  SystemDb(SystemD, &quot;Banking System D Database&quot;, &quot;A system of the bank, with personal bank accounts.&quot;)  Boundary(b3, &quot;BankBoundary3&quot;, &quot;boundary&quot;) &#123;    SystemQueue(SystemF, &quot;Banking System F Queue&quot;, &quot;A system of the bank, with personal bank accounts.&quot;)    SystemQueue_Ext(SystemG, &quot;Banking System G Queue&quot;, &quot;A system of the bank, with personal bank accounts.&quot;)  &#125;&#125;BiRel(customerA, SystemAA, &quot;Uses&quot;)BiRel(SystemAA, SystemE, &quot;Uses&quot;)Rel(SystemAA, SystemC, &quot;Sends e-mails&quot;, &quot;SMTP&quot;)Rel(SystemC, customerA, &quot;Sends e-mails to&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="mermaid">C4Contexttitle System Context diagram for Internet Banking SystemPerson(customerA, "Banking Customer A", "A customer of the bank, with personal bank accounts.")Person(customerB, "Banking Customer B")Person_Ext(customerC, "Banking Customer C")System(SystemAA, "Internet Banking System", "Allows customers to view information about their bank accounts, and make payments.")Person(customerD, "Banking Customer D", "A customer of the bank, <br/> with personal bank accounts.")Enterprise_Boundary(b1, "BankBoundary") {  SystemDb_Ext(SystemE, "Mainframe Banking System", "Stores all of the core banking information about customers, accounts, transactions, etc.")  System_Boundary(b2, "BankBoundary2") {    System(SystemA, "Banking System A")    System(SystemB, "Banking System B", "A system of the bank, with personal bank accounts.")  }  System_Ext(SystemC, "E-mail system", "The internal Microsoft Exchange e-mail system.")  SystemDb(SystemD, "Banking System D Database", "A system of the bank, with personal bank accounts.")  Boundary(b3, "BankBoundary3", "boundary") {    SystemQueue(SystemF, "Banking System F Queue", "A system of the bank, with personal bank accounts.")    SystemQueue_Ext(SystemG, "Banking System G Queue", "A system of the bank, with personal bank accounts.")  }}BiRel(customerA, SystemAA, "Uses")BiRel(SystemAA, SystemE, "Uses")Rel(SystemAA, SystemC, "Sends e-mails", "SMTP")Rel(SystemC, customerA, "Sends e-mails to")</pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mermaid&quot;&gt;&lt;a href=&quot;#mermaid&quot; class=&quot;headerlink&quot; title=&quot;mermaid&quot;&gt;&lt;/a&gt;mermaid&lt;/h1&gt;&lt;h2 id=&quot;关于-Mermaid&quot;&gt;&lt;a href=&quot;#关于-Mermaid&quot; class=&quot;head</summary>
      
    
    
    
    <category term="TOOLS" scheme="https://zspcer.gitee.io/categories/TOOLS/"/>
    
    <category term="MARKDOWN" scheme="https://zspcer.gitee.io/categories/TOOLS/MARKDOWN/"/>
    
    
    <category term="mermaid" scheme="https://zspcer.gitee.io/tags/mermaid/"/>
    
    <category term="markdown" scheme="https://zspcer.gitee.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>财务类系统设计原则</title>
    <link href="https://zspcer.gitee.io/note/PROJECT/%E8%B4%A2%E5%8A%A1%E7%B1%BB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>https://zspcer.gitee.io/note/PROJECT/%E8%B4%A2%E5%8A%A1%E7%B1%BB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</id>
    <published>2023-04-28T14:31:43.000Z</published>
    <updated>2023-05-05T07:52:55.254Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="45decd0dc3065f78bb2871b99fa5c1adcea0d9ca1d9b4f34422285d7f26e8b26">4481e58e69bf28fe8fa7a8d820fb67f5e9f850618a8149328e1352eb2761e008bdb07eb3cc455eb689d9fcc4deca6bf7a94c91737542fbcb99a48575b11a261661f6f1701401d974b53a92868f982795a325af453718a3743d333d87783bd7191b539d13e7ec6753ae28b97a85d1f38eec6527319b6326cfeacacc02fbb15a9e3e97944bc6bd5b6a1c19a490590e1457339fdffa4606686887e9c1e160f524c014ebe73676c5f399a0b667696c01ad11033c8a9f11c7c5707776bde414aaee71de650190e73d8e3130e148704e89f9ff0b19baceb5f1202b309202242ba5e4ff72107b8cef84b8a012709106cde81d6111d0143cc61375120174e1d615df6d48e081c105f633743963a6e1c7ddc310241f3bf3ac814134c8315d540a7414f4c3570d69ecd86e4dc26e59bbb1025853ae652366fc783b440ff38c2f25d4308140b4b1442a9c43607062204cdb792fe1d6bfb1e9819e281f3d1888d8fb8dbb3cf4e4074328a51a1e515bc9a377e485cef3b8a81c0c6ad58b25b9cecb5b4778a04f6901f58fd663f1cfb141d079cdb84b22d3ce93b0a714a9352dcc81e76ebfa7e514dec4fe3e526fa8683850425e5021654fb278b66e889518ea965b03bfaa5e1d0dd11e23511738d84eb3abd371db7a43398bd5c7d5e0be08b71da26798b06bbd9c4d1497d42b1d24d98f912a957559f351a1373293a4b9a8eb2c20e34ae36455cb4f6b3661d36c5bc4f8ad4bcef3c317b704affac051fe516f12fbc7b1cee1a06172097dc992deef10da532a35756fb133f04f7f74416be8a156ba6e51b1ce2ec67c8f2dac8eedfb2c250a97f0effc7cea67ff8e4c919e5d8a577a58de2017c296eb064284419d0ac28cc1201a1325edca59e07d751856805a2758cbb0014773258ef1b591b035f91b5282ab0c01f9ed406cd628c0023acd8f426a599ea3f65673a730a88a25ed4bca5173d6d05ffd466c6fbc139ccad83357fc7311582b638beea44e68badeb7eee32ec5e085d92bc5393bcfc3a627d971ee53be9b3e074f0ae2d2854d8d8f4f04dee0ebdeca2aae24eee18ce098a06acbfafdeaea051f761a07128d84f9c90314491a2f1850c2321f40dc7c92ca96062568ea95b44498929fd2de7b6f18ad922536762a1b924d4882260505509715989eacdcdae0715ff460f61c43883e5d95d08341da4a48d81991c80bb01191a0d1da5f293214014c97155712e0e120d71c4ea59df7ee08a7fcba920f78a445d62ac6ec93d0cb065b26e78fcc6cd73c30f641de99dd1d2b9d9b78d25f69884cc4a15c898c01af2ee590f574a9f00705800fcb466d6ce1dc09adce35d8bc455a664d5bd0f58ef0dbb2e083dc2e39dc1cee570a0f4a48171e8f02e5fdb62108abc975b0fa79da5ebc444298eb872f16210f450ba26da6160e0442cffbf5e7a9336ce45ff8bda315154f1a999a011b4b12775356ea7887a7df1964942f2b38e3048f40a22f976e301905c746704bfe4f92deb841a6e64153fd61b5a688a71494eef4e39ef26de082e18e6ec0054f5441e141032e9fb40727632066ab801829d8ce281093e2f5889d6088797b4e7218d6571917486e444a23866d45676dc9019e1d3751db092dfa81d275c9e97d5fa79a4124071fb959ebe8e47bd9558563a08c44752b993d11bfe2fc8cb9aeb35b42921c2a144534e9c6042cc688565363b12d795268046e8ceec391359697b8d7bf2a71fb34a2ddacf0968e20e86341efa5317592fe0b0fc5ca4aa41ff73d7a240d5320f8348fdca66aef2af1882c608d0b17783e51f6e10ac42bf1d9fbc542a29ffec63d85ada471274ca1d3eee20ce353d431d501d5c9e71871d7a29e094a9374e31864358a194aed30757b117a61d888ff24dab71002d395acdc0d5eae7c7db959f1a48e2beb6c8947f041e6fd69faa676ee12a9c22971305f44678443e1dac7b28600cc6d7a5de765a1f59e14f1c3c2d291e0bc6080d15dd61b9268c0a07da26a6f4b8ee2a161920ed997db3cd918d07c42a5651cd30f2021a32f800275a7facab15816a1b180b4ebe2839900012e04e8d3caa088a917f491adf0ab7f0080a239eb60355109d773724aa18bb75d67aebb037191429e7762e4b5f6e0a7753ebd0e42648b637beb977c73f74112821b98749fc9811dd662501a019b7c66f61e644d6a5010771672f3e57f029133246b3bbe40187fb064a1d10574e291d20dd364513197729beda323d479d79c17e75897b4315b867f606522137c546ac766402efda53f832a518819fc8695070a43a864aff1fddc64f7d9748d746092c7e888718702f21788e1ac956ba5a07b873a3c54b80f8ca1be7522c8658f6f87225dfd8b1657cbe494cf96c93f7c94759e9c6b45254d44c8795f2df67576b57a7f3b4fcff448db5cf0305bcfd90e0ce546ea426035ec6071a2b0edaa05d3fa5cee8379c506ae8a464666edd7f17aaa7bb7304f6ba13eb7f33ad08a41fe70dda26def7c25091945e657de716bb76aee063985326ac0f9f90684b542bfa13964413f89d6a533641dac1a2a1697ef9ecb6aed21140279e7b3ff9976c8cdba8b4f2f807aa6f166af6a8796b7e26cc9a3acf7080aeece5d92b75510368c83a40de6b70d641924b7b004b3b3e15d9c36bbf16bad2bcf78addba9dba28630bacd3ee9d4610a08b8cdfc56e83a7e68a69cca1e0f635883c21d761b952292305b225d52cca0170b1ce2cd01505d39078f652d59f63df1fafc4842f1fb43de4c3f86d78af1e788887d3c7ad5c7271880b0ac6d7f104608048c985018d68b17c3af832295a519f6d629448eae7fb7043355bbe78ddf8303301fa9985780dd39e097bb8dee6d73c5d2a8a8b9e19655269201e293a75917a634f75b6793ace970f8264d71840eb2557b2aaf9c5ff875b9aac2674598ec193340a589642ee187595228497e40e48f8a650e445cbb9062dfd5c1b35c19dfc3c7b348d0b4ee447d242fb6af1906403f8f80d443a541c7095acd32b49fe5051bb9ebfda5d0f59931adb9f588c5f2af951ef52a4730e7c3f735e5a398a300457caf5d61d94fae2299c08c7614d7f0534ced1ec95bb401532e167073c4f2caff71c3a8762a890479e02cb2ba71f62d3fdbabf4791863ae1042e415c2ae5b0194fcacb601aa9dadf2f70d65856626a5af5e26b2b3a9c83e661913ff395ea01a7a9c6a62b1a75703ebdd6346cebdc136ec7a3d00db3370f28e1a0aa08899cc719a5e6ae365e01da31d9548b3314a35a43fbed146c8dd04739cd00db04669a65c7071e1b9132b45d9c0080d180de5fb7a7738dafe2a70f052aa8ebc5fcd862d12cc0e56112588d196493c7438375cebf948383b05c6ec53fe7080dc9036f073fcab48a307c54b20084be314f37f84fee8095de736b0b6c31e04aa96eb2e4769b52f93ad71bc611d9446e7242f76ca3ee63506f33f7fc3d9644d451365adf9fba7bbb545cf2043bca1b74696779d039a5ec7fd6bf83bc9767c8bc5ab2c215d6d73fdfc286e2f2d008c9e9dd45d4a59f7113a056f99ce44c9e6723c0272468df15b9f0c1eee11bc70dfe4aadd0b2eb4af8678228a4895ba790b47acb990d878c024484d4c988ac58548ff2fb50ca01b306f42bc1c55d32cea8bc42371596406972fa8ed90c3ae0b987054455db4620912792475133a47810f3675cd56ee4aa2100796d36a94dc3a85e00862ce893575f94155795a8ee8c5554d586f86d656c4d2e676328192db8638e382b235014ed8c9f42cea7b57c593aad476235d32c2d72b2206565a632ccf02fbd4e9dd1231f5183620dadcfdda6744cae0b67afeeeb651e7c9ca3c1cf45293cad0b16a7f50b34930d0cd39657ea29361921007d7ace876c8a7eab38bbcd2a96e8f69fd559e6a423a4f54e2c8b4ac4a6403ed08271243d05e088413b2f59b9717ac372a6f4c234080ba118ad79a1f22dd6bfa327da836cb2d984e5a073dc11bafb55e94009e5c5d5775f4e57367399c2319b9ba698954b691084da7d75e9d7308e8774a1d22844d364e72b9af0e34244b6dd88447bbdcd7e26e97e2976a4899b462b30cc41f28e1f544834af097881848e18934b5bd89dc8d7eaa7203ffeaf8bb5b83308609af21523c7fc95f6a7b1cedaf8ae84fc5cc16adb3f8f5e4a08e61ce8ee86853422715a4fd47a4433dc7d369092b38357eb891ee740dc6952225eb6a747fa91ffba933d01e6caf07b2ef16e71da528f787ceff3449debd0f9bc51455904b435073cba4a033773d60be49e06ed4243fc67ff9793acddd1a3534b9642f8326f62d43c099a947a7aa5f36578d1e1a477488cc57c53c571b3f22879a7319414304e853577c27fbfdb358b7f8653c0f3b9895e4cae25ff0cf5bef98643046725cee81b9cc2af7cef554eb6cc4f3f42068836566eb1324b64947fbf75e6478d60fed8cc647333734bb23820085e774dca7bc2c4fa46b1155beef6cceccfbe35663a05240354ea3880d8d4233ff55991e24151a4eec9cad1553ff478f676b9e9c23f9013301f180b2bf984929dc07a60995f18df767cd9394d3ef7840696ac0b207d87457c8e8baa1a5ef8ec834125025cc81ab458e13abd26b08bfd4803c93faf2ad2ebd6843cd80b24e11a97490338be4c78521a05526f8619d29c623482a99434bfccdebdced0d439a5838ff147f750b0bb8ce6bb50ce38b3cf4156d93f95eab7ca32411c72c22d5d6384f761e80787da57eae9d50f5fd267a56ee39768c6d9ff0fc826d13253a6aeb72abf8721fcf3dbfb90f565405476460f722e6118bea2ded48a70a98ef85b348b1111b53ace8d2554b5176ee0134aa113616b3c6fd7ff013b7a0cce6111acd074f92324bc6ddc8fd17f888f26c6a5769d77d2448011fc041bc6ea9b58c2ed90561f613f4a802f2a27b2b88b4d2a48a0515a863bd3c4f6dd9ad0b931208ebbd8653d7ff0d1db204f6d53729a61d6e878d22b800751c585a0730461247898431b80455005b3693679f0f583ee10489a3f44bd9e82eaac0614cf02efa756e7de9b425602f1a004df4e17d2b9ba14e97e5ac435636fb2238298d7b7b43bf6340356c9abf00d82a855689b5b28452d4c95aee2abe2f4cf86db4e55cb6b857adaa24a8eca64b94dd8d20930118de55dd39e11d12b4a4375f2bf7ff2f285f2e825acd5d5204d060ff3bca52e36de17fc282ef9fed1aebe1e8865f4d9bad8b2400957e0d69cf11ceb51865d99ce85ebd36709ef76aa5d5126c1835efce25c3c64001bdc4ca46d79567f32303d37df65ca954965bf1eb12798b0448632d545f9cc470580fdb25a040b866feca0d7d65fb408ec00e03c0793f45ea51996ce7bc2cff52ec780862abe8c568d8bd6a863321fc90f89367d249d30bcd11733078fa52179c6697dab5cc0936be972a1ad70497bef557a92c040662edbf33808df8c1676647105743e8776959d1d4ffbc7523e3df5a24d4d86b36e5e22d517b347e6289f9d9d6a872f4eeedaae6d746a0a92360114e7fb5a01e3ba99ded18e04ed3ae1ebb0c276adb45967a7028148b7a20e399a382beede85863f3b74bb57fb53bb3b19cb5571cf0ea4203f307672f572e087f91cb6448c93d93d6cea7f6d17f8258f19f98d9b876e415663d6a1ab40f60e849a76e2f25710eac1b9e2891ffb3b1f1722f01846e87b2199c1f48695dda64adc3a4fcb628f8e3f9048472a34b392b0936ce423c22f89cbed9d13bee5eccc322147f2adcaa0c55a1edd1cca3b567633c57ae7d2fdbf0dc6f2ed10253354bbade521257e317281b31abf821112384b4340ad3c95b2fa55d5d856bc7eb3ad2cc2802b1263c619f3a476d69db96d3372bf515ff7804a8d9ed82dfb095601f0732f04af558ab01a7afad4801ed795940a1b0998b8721fe462dc538a168af90af6d8da63f0bed1bea1120cdc206b3f2c7f4cf68e72a9fc8ed8954047cd69c69b41d1c83f8e9603eb155db9f785e44145ffbc09566f48ad1f7d39512571b6f790da0dcaabc86871d56a730d15785e9fa3e42dcda78c6f8846d9f2c00bc8775e5479bfee8155f2941c34e84a6dc368cc30c12450d9091b2c06f7d75f7616608b13ed0b0de3a873433cd792b46c8ae835b2b93fac8503636c965742fa9ebfa297d7e323a577313dc06b6f7d2ff72a6cf137fd1ededda867bbf5fa2b8fc8a3ff40a7d4b844ccaf2649263c8c4b717ae7e88b24638fed275e274744dbf69f9b9701ec053662c82e8ebc338fe1d65726d31dd7e023167de2cfa9f9a310011f866e464f79a467b59b04a4b17702ee73d272ee252eb398becb2896d6f845bb9d87b8f84ea696fd373fbeed2f60229b9b2856381e8eb964f3d603a2ca5d87e2983b7ed9da27c3b0dfa671837902ed2b2abdaff715967172f5e1debb35d073dc1c55673f5622c8ce8da0ddbecd7685a84c06cf5e2185a66111399a1c25faf1a101eebbcd40a4977a2e9f4da815fd1d13730b3674079438acb2b47d019c4ce74f1ede908e4606b696a25074ad51d704077710c6e6fbd1108f4919e5b4385137e25cf2c66d954fcb6284153b531a49281c15b8f6a14a2851cdecffddedbd57d6a5567b4f420982fd04e81e5825826f08890cfd2c7c481e98fcb329dbcd51a46488572f682c4ab859cf4777d849701fdfed2fca328c94b3c9821bb4354094ae6e867b899cc7214eeeac4e0416b61401827b753ad93fb397375d8c5d7628f42abbf1cd87be55aba9de884f75aea4675806e98e42af78d4e4aca69b882cf5eca143ab5e6d51776728db5a3c15cf8c1a6fdd0105d62f254715c15278bbd4393e110dbabf7cfb8bd8c679117b94357c2b29bed00473d5219c975da275b1c21204d287705c764697688a4df19812411e70e4c1363a105cef70fa6968675e2081e54d3d301315e4f033039b005189a694af9202fe0cd38692ae236b0792d08d226733d7cd127680f8a33140d53fea905214db6a35a1bbf67524bf4f842b321dc8f66aea6e127881d58c4115f24accd0b9ef4e9d9727284458fc9d996e063707a459d442cc671fc84e7fa02d34b2c44d59573f414273ddafd700e7adc6b87eb77a051308f1c059cedfffbcd517e851c7f1fab6d3f956538f9676edbed2d9328fe39eaa2e935d0b0a94406a9ddc088c061bc46a199bce4ede2ff9c21c4561186cefcc566b0dcf310671ed05ab36dd451fb203ab404f728bdba51b4e534bfa16510dac030be18c3a21c4346d09372e3e57ecda96db13da9f87585bf714798292907035b60e996b7210f58d79124b8779a165e2b6fc756fd841642c0693acce7d1f33d2663552207186675bc45dce9d263b67b1176d1288bb541c003c443aab991dd593978c91f7db4635bd95a53f630a8e267948761ea251c05a9d1fcd634fe29b18c6abd41e33d9e8f9f672e29eaa70e1bd4ae9474cd8d63b3934584c05d092cd27e903f376db4d8b1c52abf481554d03361d5a408621b9dc5fa65849d558d5b81d61505738ac7fd6667e47f3c9451019958ef14b2e541f05846e682495e00c85070296845fdb8aa8aa05de44f1a14a63d5c08de0ee9bbaf706abce998d46e715a8ef7db3c1440a4fd7dffb0cb8612712301f37ac280fa8e535fbfe1796ce9d8a30b7b43408a8e9fdb98fe09dbc2227dc95e097af139ee0372b6d76de163dddd116a9743f3d78b0c0bcc19365e3d1b1db2cc80aa57eafe5ea4a13a799d18816300a158c477ba5d9484f51b6489cc9ad28deefd19a164b97531f06e242991613f2b55c022a9444a0cdeda7db7c7d7311feda25587f89dbdf8733488cb550ded5170e985f8b1ec5211f3ef19d630e0ce767724fbf17ffc18c88eac35201fb6bc60da273a896329d3831bdb138ed54d49c058b150a0c9d14a3a7c6bffa31eb5e5d7c7c09add326a80e55ff68e494b0fd735834e8bf4062af2aecee178802f54f310ea0ae05fa4ecde8ecd46a534579fad187e4ecd03fa8fddc01de8fcb74e2ff3c224187efda03586217bcf9cf4433226622d09eb5f5ddeff245940ed98767236f083dff1c1a6955ea78ac42c746951f18f6e3c24593d3e6798952010c58af95197d810d320548d2e4537da5e605301391f2441dc49bee443cb1b72fd3ce7575bc5b20d59fc41dc090807d3018a03206f04f618dba52d95782d0ac961afc26505d8f5b60317e669d503258204571c0a9c36a481afb4cc76d02f1b14f8f458602c9fd2470fee5bfcfd545c65518bd3221351cf46005078058a815dea82d257b2bdf3e167beb5934ce33faf33fb025edd5cf049168fcb3d9ed822533301a440b931812f91f714986dbd226e19103aa728c0945bb076b5a167a892f19c82bb944036b7bf45f253283da751c837dfc12729aa285d77a5c1f89203c1821fbae9a4ab7506bb01a46415a26b3c246f7db4ea250367f23358da2754b27abad4555cba7b050241e6937f3c77369fea336454930333d73dc50d33100e3096b4f7529267f0a95da974967bf945e0c7bbdad5f7dcd3d5767591ba37ba247c27897fc70560f846958838ff3bf92277ba2b1693f3c150763abba0a412abd324af51001132aae19cbcbe17b310b74efc7ec5593fe9a9732845cbc74d6a2c75e912d998dec2916834b1420dcf41f58268e08b2d34a6bcce2bf51f320339fb846ebdfc1d8523fd0c2ff26aad279fdefcfd9bfbb932386e690ed5fc1639899c0dd2543dccf3aaf0809d3504d807044ed18ee43ca9a787e2586a978fe0bf70d917e67088f59e6f53023a9b0ffc3b91f4a9b218f897d04c6bf051e831f3dbf14845d955e5fc6cbef5e6228d3f150fdeeb7040d1443a7843561ae04c441ad40de75c8cdc73f1637782de6e549cd71db24f130ba2cdd874b217ddf535bc7adea242ad77aabd274b94d9327301ee5d8812dd14a22dd2ee451e0bba1ea47e953de47178489055ad874e06e7fa13b87eb4421889d38a464bdfc3c51d84be5f4dcc13498feb032e023b6eb92f5a285220616eacb32c11b941b579c98315c814203142031225b3b9ae9df13d9bf5ba11fef65fa887c6457809eb906f97162b6a25ecaf91a3e923cbb7ac8a349735b598d72a93abaedb4b04e101c33a958ab5aae97ce35cdbf17e324cffa243ea74911ab349e68f4afa051b1f7d0259358495e808be8e93d701dc0752fc1fdf718616fd8f7cddd0320b19a4d177b95ebbb41df83675bf39f334f667b5bcb7e3c26d9ca67d456193977e41fc6da051b7ce355ac92cdaf29a16eb1d8a9a16f23b72da068ac61a535584330b1bc10618103bcdc2dadfe3cec3656cd55c7ea576d33158832ca2406d881c1ef325924372aafdc3fd92ca0d3ad44d123d33d562c3412c14af17f869842a0d3cfef0b263db93f02adf76edfcd6d600edc7c4b31449eb508e0d32b765589995a622393822677c7809d77c166331105cdc045facdbd61a22f02c50581812b8c66410d0d2f3aa6c208dfa1a60892f56071f9985d0fce86e55f9d3ee06d177d5d9db8504f1be8a8089fa21c8739c88cacffefceed3521a08f4025649ac6e9c72ab4e8f8e2eb871b8a5649191ddb747eb877e17daf2ca4d062de2ef1a6f7c30f395b8ee77f6594eb2e1f904955b21fb1a24e812e8217c9619cf7c1aae21c78b415c61fd22d4b91cc59fc8845001d0310de73e2cb69b27d6e247d4bfb55c19e2fad3233add90d93cf172912f240c7e76599f46167a0a7334ef08cfca456b558e7a10502a0cff237155f03efe5bd76225718dd8425acc2ca641c2333728735c8a820075267ea7b7c0f93c3ed92a663f01741f1cc5c1a7f52fe745bc4412affb663962fd78dc0ff1139a92e3ee3e238448d403b87f46e5de8e1b747732e9005e51cd2e98dacc90a4e4eb56ac22ee99d202f5172997be608322f85a44d5462e57886e6320d3d8613d70a377a3d186208d981e338d4d49e389a984d9fc76870d87c8a2b6011c48ab6f4faeabdde9c46a0e33928595c183b12ea24dab40aaf39b627f9bf7ecf0e396e9309986c4f3183f065c8643dff04939b2249c318f7078497182cd9c1f90d393f89429341d69457108e6112314df6de3e368573246423f5f1190fb66e58891ca72dd800078785b4675b14f222d56d857729b494e5400f640ec5cbf4c0ccc58af9f961fd38ff6d71d7a4e03b4ae2b0ade7ef5c636621e1845aa8256a0d3aad345d7f86bd8c96afb0868cc8decfa386a297d1654af85ec1bfa823a9a08c26257e7a5492c7ceb0ebeca4121cfb7ea39b901fb1a0c7468d6f2a0eba0be2d796f11cb8de989ee5a4f433176a88208414a9553cb8032034a471be8da9a1652b0a42c917ccae9ebf3968df21ba0f0acf758dae88198f882d1c365520f43309f41d911145df2220a96f219b0b0fee1bc7985ae81e7891d66325b6dd962461709b071247b6828402d8d5ae614b92d4761a5548b842e0f1c64cc19fd1d79e42826add42c138706c8488d13f5399b5b452fbb773a5b9000d09eba7188ce574d998d020cb01d57b2e9f038c7adeee9b5ba1ab4e952c5942b43b15197ab9de7b41a774407688b72486b8e517e9e297f7a4d841755f1c8695ee212fac352f8c3a8650aac11de2fac82168de1f93241729019c36b9d3452753a384ba0d276839bf81706ec239d260f9146b2e4f398f47905a44ff07f07bf0e3bdb142e40da6c09441d4164f0fdcf6105400037dbee5084761cbf10a006d1a5592899c21e971fde945ea2b776b5d692dc2338b5618cd1488b14224b481453db1919c2472de10e0dd73700ddf8feae56e9d26ee94278cd140a5436fef05ac0cbc71b55c44ebdeace422222f9c4d94038455d91ec9312d5d6fd2c83b63111c6babc29e29432f3531f33ed81036001f2ba16d64f284248581a981da50830e8ea71d5d340e73eb315573e5185e970f6a37328d5643736dc6648023f818283c44651f1d719474d5e57517bc0d5f027394c49dee6de70c6c72cbcea00fffb9b0d22d7006a4c2e4d3aff38974df4ac7bcf7b60abbb147057b607315c476f5486ffc82be7165860d8b70b59018a1a77635c3506d367b30607556e048f25b53cc60c9916fe927ddea22c3b8dec39fb44e7ae49ea48c51f1547340403decbec1e1ca815d61acaa13aed805cfbdd003bf552f0945b5316e2b41ff5cd442b8e3db580ae8d561594c671527e34129748b49d8a0564339c389b8aacd0969a0554af0e5f4295818828a04beea748fd078f86692bded6e238af750559e01bd0178e13b5fafdcfb6987ea7a8cd96384ae3f6ce8084a79d67086fff0f37cf2869422e3376563c74fbcdb08514c8862962d4e38be585ec6595a70693b3e2620a7a3cec66144b23298e110bb1bf5f6cb38f6de01a7b2109d77026e56075ae667ad6d8d321474921a3c278dd3627f4f569a894d810170580f603b07ac028c053aa22651b54f7899f48516dc338794021f7f0b87addcf82f3004bbc6a468dab65b01155f2cc91e6a05702ff0efd04285cf30cce1edf31a3d0a61b023732f8cf299b4081d798a6d9891d7d03818ec9ce1f33bce7b329851547c68838979659510a9efcdd1fe7748750f0c76f73683f7e4cb6fb7d4cf62002e587d35b2438c9a9f784619197ff32dd9fb1e28025b2e1caf2efedd4b74a7aae7be6b30c571a53050fa08e8d7fddfe0abb9a02a378e06cb3b44263e3f6e6786142cffed7de0b6bc8478a5c05d0c6d53c772bdaf78cea4bcf144e71bce0b3fc43bab0e786e65debae245fec6168a81d2e4c02d3efe68d51f6e797f427aedf291faa92781282087ca06650ed3757e6075856f7f14f728f2cc744e7e5c73460bb4fd907c283f957eb9203a56f29786354b60a95e897f23445fab0596c564d89c8522cf3bd19b5fa5cffc06effe172db7da96ac3de733900fb1db5244bb9140ce354e7439ade8fb9214fb6df530e50e46ea4b2326687409e06fabbcc374d402f12dd6a4544c14f9a9ad41072283ddae5ed36740aea174d786c14901fe0d416b557b9a6683e013922a26233551bdce2b26970ddcee96c090651ef357a5ae789c694e7048b8f6c96ce0d804fb1f030148f2f8b06ce869b52298f30ea6c00859d674b9d7d224679c39f4a247efbbac64517bbace0a3888e815a8d378b0c8f3063901cb79dd0001d7858e04ecb7788e7439e0b5ec9a69bcb5a6569fa506ccdb36bfb71f4a9796a92ef5b22d360485be33c062eaf88e3a4e092fc7695ee6bd481585c5aa9f0b2141bbc0afa41bbdfae5f5fdf0a5aaa82ad7b21e58848b5aa86072a8aefa4543c13ab39c76f59dbb40ff69e1d87a8980fd619e1b0b36fd4ae36955ca87ed3c70947f49c2566556a0bda0dc8385bf5a11ebd4c9a1a3245e3d213b91a991340b3c0d659f07079af43ae81caace635b8ed56553ad24fef846a6766408c659169dc5a73cff35237e56631646c1f224e32a516faf07ec238dbac571557645c3705c0b8f2d1a89b3f9f8e78b6115223d3a7c7014e85f9bf5184f7cd1feb92ed93c7daba56c5f630c2269dc99c05c0cbe55181d8b7c16bd73363a39aea90faeaaaeb8c8c5b84e7c4eac72a7554243492550f4de3699de73d90a43b4bde261f3b11a75689bd426cadb236aecfeed3be4f053dfeb49df19bc0937164b5e207e17fa203b53d4fce622c59249d06b5a55308eb777b3a4032c2a557f145f0e2392858b1f9c996ede8f15fac44092a1a59db92b71f6c27ca0d6ae443074caae36e0b35c345455e3365c7233e1c0b1980fc7e12099ea903897f90ca1d9d4bd0dc1527793a4572c154bdd037b6f8ab749207f679c00bbd1e52fc19327820bba07c2cdaac680046fbea59b9fa778dd6eaea65e0e1dfe65528b77df371042b9215ad011963d5743ca0984eab234a3920dcd04adb6cebf5e71292cea24e73d4d4cf4c00ed42b2d997538b2e1fdcf9dc9b7992046db012e972ceec79a55b04271e33629d0c452500a7c8a610ed7263e010d3de391db9086af6a8f1f55bfb4330cff39c2e9e7ac165354da99fafb205011a5898b747b5d4f512f9dad8927da6fb5e156e429e5e91330f0517fabf589f04433a9cbec3d6ba0ed00311b321198d4dc45018f679aaabf63bb73484c2ffb2d5ba2da76b57c3b5c1a5623a47fde46926eabfb4080ac0dc7aa6ea9868d4c2f4a8b2675c7808ae7405f208358a05c6ad821b0bce693832d5dd7021268dbbacb47a1628962c6202087dffa2d2a0a23b84fc4635302b41a0af6a79c447cc44bbe50a91240106f9ae41816a56957c99c5dfdac5c00f419e8e273343e9b516dc7159b1f58e2104050b18c6d094c8ba6cf5e94e401decf914c9aad7f2fb5558c88433d9bdc604de4931eeef590df8b310d22a45a0abbc0d406e32fcfc7dc6ec5277068277e452cace38c0e50094a6ecdb578061d569de8c569b13218ea6083cc5d18eda62dbfd172ca528d376857310a3544a8a3a9cf50f1471c1123de90ab0ec80d70683b8ad1d6dce25a2036e05daa8b645912cd29a2ff5e83c7e94a60ea3c7243c561c75ae7ca5b2cbf92ede2f72d5894d526a84e7408c42bb550b9ebc263b8c04d23424bfb8341b0e89c2490dfe9b80ce62a2728bdad6995e99bfa281b4be22e70cc1eec6b29c152fbea532ced004c2c53b5227799131a9e612c24fd815f01817aff2fd8aec17e401e57054f1317d3103e4042b86930c7f67a2dc379af211b7d701601b2246eea3ba489f3a29b321f6e8f393ffd7c5c01417b2486ec4f86d9deee236dce75b11cb7e467efd73828908341f908f430593e0b4b0d307ea81c05d00fe366df2e423da60b9c2b7b332a7c3382c8691c3a9115288049d1a3cf5d2362ba3d615497658d0b1777eb179a2a80a8f83baf6ddf7f34f1422413fdb719be7710c612d75d5cf3c99d661a8da846622b5a8e21ad5d445da81fe5455467fcd448e9ca5271136a408441797a2d77c991d3ad03471a6d6379cda4e4bab97c9b5d27c0a49f3c528fbaf83de0cbfca7d148bd86e60d6b9630cff7179977891a4d315e572167da8165eb85f472c8fd6fba65b8dcf7491e2a4a887ed2f30bc789874fffa4d0b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">有东西被加密了, 请输入密码查看.</summary>
    
    
    
    <category term="PROJECT" scheme="https://zspcer.gitee.io/categories/PROJECT/"/>
    
    
    <category term="项目" scheme="https://zspcer.gitee.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="时效" scheme="https://zspcer.gitee.io/tags/%E6%97%B6%E6%95%88/"/>
    
  </entry>
  
  <entry>
    <title>SourceTree提交报错Authentication failed for</title>
    <link href="https://zspcer.gitee.io/note/JAVA/GIT/SourceTree%E6%8F%90%E4%BA%A4%E6%8A%A5%E9%94%99Authentication%20failed%20for/"/>
    <id>https://zspcer.gitee.io/note/JAVA/GIT/SourceTree%E6%8F%90%E4%BA%A4%E6%8A%A5%E9%94%99Authentication%20failed%20for/</id>
    <published>2023-04-27T15:22:53.000Z</published>
    <updated>2023-05-05T07:52:54.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SourceTree提交报错Authentication-failed-for"><a href="#SourceTree提交报错Authentication-failed-for" class="headerlink" title="SourceTree提交报错Authentication failed for"></a>SourceTree提交报错Authentication failed for</h1><p>原因是因为系统中存的用户名和密码不对。</p><p>最简单的操作办法就是把系统中存在的用户名和密码删掉，然后重新填。</p><p>打开选项</p><img src="SourceTree提交报错Authentication failed for.assets/image-20230427152523652.png" alt="image-20230427152523652" style="zoom:80%;" /><p>将Git保存的密码全都删掉</p><img src="SourceTree提交报错Authentication failed for.assets/image-20230427152615391.png" alt="image-20230427152615391" style="zoom:80%;" /><p>然后再次重新提交，系统就会提示需要重新登录了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SourceTree提交报错Authentication-failed-for&quot;&gt;&lt;a href=&quot;#SourceTree提交报错Authentication-failed-for&quot; class=&quot;headerlink&quot; title=&quot;SourceTree提交报错</summary>
      
    
    
    
    <category term="JAVA" scheme="https://zspcer.gitee.io/categories/JAVA/"/>
    
    <category term="GIT" scheme="https://zspcer.gitee.io/categories/JAVA/GIT/"/>
    
    
    <category term="git" scheme="https://zspcer.gitee.io/tags/git/"/>
    
    <category term="mac" scheme="https://zspcer.gitee.io/tags/mac/"/>
    
    <category term="sourceTree" scheme="https://zspcer.gitee.io/tags/sourceTree/"/>
    
  </entry>
  
  <entry>
    <title>在页面上一键部署hexo</title>
    <link href="https://zspcer.gitee.io/note/TOOLS/hexo/%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B8%8A%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2hexo/"/>
    <id>https://zspcer.gitee.io/note/TOOLS/hexo/%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B8%8A%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2hexo/</id>
    <published>2023-03-15T04:24:10.518Z</published>
    <updated>2023-03-15T04:24:10.518Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/msoap/shell2http">https://github.com/msoap/shell2http</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/msoap/shell2http&quot;&gt;https://github.com/msoap/shell2http&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="TOOLS" scheme="https://zspcer.gitee.io/categories/TOOLS/"/>
    
    <category term="hexo" scheme="https://zspcer.gitee.io/categories/TOOLS/hexo/"/>
    
    
    <category term="hexo" scheme="https://zspcer.gitee.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>黑群晖使用DNSPod设置外网访问</title>
    <link href="https://zspcer.gitee.io/note/TOOLS/DSM/%E9%BB%91%E7%BE%A4%E6%99%96%E4%BD%BF%E7%94%A8DNSPod%E8%AE%BE%E7%BD%AE%E5%A4%96%E7%BD%91%E8%AE%BF%E9%97%AE/"/>
    <id>https://zspcer.gitee.io/note/TOOLS/DSM/%E9%BB%91%E7%BE%A4%E6%99%96%E4%BD%BF%E7%94%A8DNSPod%E8%AE%BE%E7%BD%AE%E5%A4%96%E7%BD%91%E8%AE%BF%E9%97%AE/</id>
    <published>2023-03-15T04:24:10.516Z</published>
    <updated>2023-03-15T04:24:10.516Z</updated>
    
    <content type="html"><![CDATA[<h1 id="黑群晖使用DNSPod设置外网访问"><a href="#黑群晖使用DNSPod设置外网访问" class="headerlink" title="黑群晖使用DNSPod设置外网访问"></a>黑群晖使用DNSPod设置外网访问</h1><p>我折腾群辉的 DDNS 已经很久了，之前使用的是花生壳，虽然能用，但是我觉得并不好用，所以使用了腾讯云的 DSNPod 做 DDNS</p><h2 id="步骤1-注册域名"><a href="#步骤1-注册域名" class="headerlink" title="步骤1:  注册域名"></a><strong>步骤1:  注册域名</strong></h2><ol><li><p>登录 <a href="https://console.dnspod.cn/"><strong>DNSPod 管理控制台</strong></a>，进行购买</p></li><li><p>完成购买后，即可进入 <a href="https://console.dnspod.cn/dns/list"><strong>我的域名</strong></a> 管理页面查看您注册的域名。</p></li></ol><h2 id="步骤2：启用-DDNS"><a href="#步骤2：启用-DDNS" class="headerlink" title="步骤2：启用 DDNS"></a><strong>步骤2：启用 DDNS</strong></h2><ol><li><p>在 “<a href="https://console.dnspod.cn/dns/list"><strong>我的域名</strong></a>” 管理页面，单击您已注册的域名，即可进入【记录管理】页面。</p></li><li><p>单击【添加记录】，添加一条主机记录为 @，记录值为 0.0.0.0  的 A 记录。如下图所示：</p></li></ol><p>注意：记录值可以填写为任意IP地址，完成操作步骤后将会自动更新为您的公网IP地址。此处以 0.0.0.0记录值为例。</p><img src="黑群晖使用DNSPod设置外网访问.assets/image-20230223171928275.png" alt="image-20230223171928275" style="zoom: 67%;" /><ol start="3"><li>进入 <a href="https://console.dnspod.cn/account/token"><strong>密钥管理</strong></a> 页面，单击【创建密钥】，输入自定义的密钥名称后并单击【确定】。如下图所示：</li></ol><img src="黑群晖使用DNSPod设置外网访问.assets/image-20230223172005486.png" alt="image-20230223172005486" style="zoom:80%;" /><ol start="4"><li>请妥善保管对话框中的 ID 与 Token。如下图所示：</li></ol><img src="黑群晖使用DNSPod设置外网访问.assets/image-20230223172030142.png" alt="image-20230223172030142" style="zoom:80%;" /><ol start="5"><li>请使用具有管理员权限的账号登录您的群晖（Synology） NAS，依次单击【控制面板】&gt;【外部访问】。如下图所示</li></ol><img src="黑群晖使用DNSPod设置外网访问.assets/image-20230223172051836.png" alt="image-20230223172051836" style="zoom:80%;" /><ol start="6"><li>在【DDNS】页签中，单击【新增】。如下图所示：</li></ol><img src="黑群晖使用DNSPod设置外网访问.assets/image-20230223172118673.png" alt="image-20230223172118673" style="zoom:80%;" /><ol start="7"><li>在弹出的对话框中的【服务供应商】选单内下拉选择【DNSPod.cn】,并填写相关信息。如下图所示：</li></ol><img src="黑群晖使用DNSPod设置外网访问.assets/image-20230223172142806.png" alt="image-20230223172142806" style="zoom:80%;" /><ul><li><strong>主机名称：</strong>填写您购买的域名。</li><li><strong>用户名&#x2F;电子邮箱：</strong>填写您获取到的DNSPod ID。</li><li><strong>密码&#x2F;密钥：</strong>填写您获取到的密钥。</li></ul><p>注意：您可单击【测试联机】，测试是否能成功联机。状态栏显示为正常，即代表成功联机。</p><ol start="8"><li><p>单击【确定】。</p></li><li><p>单击【立即更新】，确认状态栏显示正常。如下图所示：</p></li></ol><img src="黑群晖使用DNSPod设置外网访问.assets/image-20230223172238586.png" alt="image-20230223172238586" style="zoom:80%;" /><ol start="10"><li>返回 <a href="https://console.dnspod.cn/dns/list"><strong>我的域名</strong></a> 管理页面，查看记录值的是否已变更为您的公网 IP 地址，已变更为设置成功。未变更，请进行相关排查。</li></ol><p><strong>完成以上步骤，我们的DDNS就搭建好啦！</strong></p><h2 id="步骤3：配置外网访问"><a href="#步骤3：配置外网访问" class="headerlink" title="步骤3：配置外网访问"></a>步骤3：配置外网访问</h2><p>一般家庭网络，公网ip都是禁用80端口和443端口的，所以要想配置外网访问，只能修改端口</p><p>1.打开群辉的设置，选择【网络】，然后选择【DSM设置】，设置 http 端口和 https 端口</p><img src="黑群晖使用DNSPod设置外网访问.assets/image-20230223172711400.png" alt="image-20230223172711400" style="zoom:80%;" /><p>2.配置路由器端口转发</p><p>我用的是小米路由器，在【高级设置】中【端口转发】，将内网的要转发的端口转发出去</p><p>比如我这里的设置的就是：当从公网访问 1337 端口后，会转发到内网的 1337 端口上</p><p>注意：这里我只配置了 https 的端口，因为我绑定了证书，可以使用 https 访问，更加安全；如果没有https，可以使用http</p><img src="黑群晖使用DNSPod设置外网访问.assets/image-20230223173032070.png" alt="image-20230223173032070" style="zoom: 67%;" /><p>3.这样，你就可以通过公网访问了。</p><img src="黑群晖使用DNSPod设置外网访问.assets/image-20230223173158744.png" alt="image-20230223173158744" style="zoom:67%;" /><h2 id="步骤4：配置https安全访问"><a href="#步骤4：配置https安全访问" class="headerlink" title="步骤4：配置https安全访问"></a>步骤4：配置https安全访问</h2><p>要想配置 https 访问，首先必须要有 证书，证书可以直接取 DNSPod 控制台免费申请，一个账号可以免费申请 20本 证书，足够用了</p><p>这里的步骤，简单的描述就是：</p><ul><li>申请证书</li><li>把证书导入到群辉</li><li>将证书设置为默认证书</li><li>搞定</li></ul><p>具体的步骤可以直接参考DNSPod的官方文档：<a href="#https://cloud.tencent.com/document/product/302/79821">群晖（Synology）NAS 安装免费 SSL 证书</a></p><img src="黑群晖使用DNSPod设置外网访问.assets/image-20230223203835651.png" alt="image-20230223203835651" style="zoom:80%;" /><p>至此，HTTPS 安全访问就可以了，也就意味着，你可以通过公网，使用https访问你的群辉了。</p><p>注意在路由器中，将你的 https 服务对应的端口号转发出去哦</p><img src="黑群晖使用DNSPod设置外网访问.assets/image-20230223173158744.png" alt="image-20230223173158744" style="zoom:67%;" /><h2 id="步骤5：配置其他服务的HTTPS访问"><a href="#步骤5：配置其他服务的HTTPS访问" class="headerlink" title="步骤5：配置其他服务的HTTPS访问"></a>步骤5：配置其他服务的HTTPS访问</h2><p>经过上面的配置，我们的群辉已经可以通过外网安全访问了。</p><p>使用我们的域名：xxxx.xxx</p><p>使用我们配置的https的端口：1337</p><p>就可以在外网通过  xxxx.xxx:1337  愉快的访问群辉了。</p><p>下面我们来看看：在群辉中，我有一个内网服务，怎么把这个内网服务映射到外网中。</p><p>我以 firefox 为例子；配置一个可以外网访问的 firefox 浏览器，可以在外网访问家里内网的各种服务</p><p>通过域名：firefox.xxxx.xxx:1337 访问内网的firefox浏览器，就像下面这样：</p><img src="黑群晖使用DNSPod设置外网访问.assets/image-20230223204238222.png" alt="image-20230223204238222" style="zoom:80%;" /><p><strong>在 docker 中安装 firefox</strong></p><p>在 docker 中搜索 firefox，并安装：</p><p>docker 镜像：<a href="https://registry.hub.docker.com/r/jlesage/firefox/">https://registry.hub.docker.com/r/jlesage/firefox/</a></p><p>github网站：<a href="https://github.com/jlesage/docker-firefox">GitHub - jlesage&#x2F;docker-firefox: Docker container for Firefox</a></p><img src="黑群晖使用DNSPod设置外网访问.assets/image-20230223204413138.png" alt="image-20230223204413138" style="zoom:80%;" /> <p>安装教程和相关文档，作者已经说得很清楚了。我这里再简单的描述一下</p><p>本地新建一个文件夹：&#x2F;docker&#x2F;firefo&#x2F;data</p><p>然后配置docker</p><p><strong>端口配置</strong>：</p><img src="黑群晖使用DNSPod设置外网访问.assets/image-20230223204644619.png" alt="image-20230223204644619" style="zoom:80%;" /><p><strong>存储空间配置</strong>：</p><img src="黑群晖使用DNSPod设置外网访问.assets/image-20230223204702767.png" alt="image-20230223204702767" style="zoom:80%;" /><p><strong>环境变量配置</strong>：</p><img src="黑群晖使用DNSPod设置外网访问.assets/image-20230223204955490.png" alt="image-20230223204955490" style="zoom:80%;" /><p>然后启动docker</p><p>因为字体包比较大， 所以启动的时间会比较慢，等，，我等了15分钟左右</p><p>启动之后，在本地就可以通过 192.168.x.x:5888 端口访问 firefox 了；</p><p><strong>配置外网访问</strong></p><p>因为上面我们对群辉配置了 https 安全访问，所以 firefox 也要设置https安全访问</p><p>通过作者的文档可以看到，firefox是支持https访问的</p><p>只需要将配置项：SECURE_CONNECTION 设置为 1 就可以了</p><p>设置为 1 之后，会自动生成 证书文件， 放在 config&#x2F;certs 文件夹下面</p><p><strong>但是呢</strong></p><p>上面的方法，我亲身验证，其实并不需要这么做。 所以我们不需要设置：SECURE_CONNECTION ，让它保持默认值 0 就可以啦。</p><p>那怎么配置呢？</p><p>打开群辉，【设置】【Synology应用程序门户】【反向代理服务器】【新增】一个反向代理配置</p><p>配置入图</p><img src="黑群晖使用DNSPod设置外网访问.assets/image-20230223205555072.png" alt="image-20230223205555072" style="zoom:80%;" /><p>到这里，群辉的配置就结束了。</p><p>但是别忘了，要想使用 https 安全的访问firefox还需要什么？ 对头，还需要证书！</p><p>所以我们要为我们的二级域名，也就是 ：firefox.xxxx.xxx 去单独申请一个证书。</p><p><strong>申请二级域名证书</strong></p><ol><li><p>在 “<a href="https://console.dnspod.cn/dns/list"><strong>我的域名</strong></a>” 管理页面，单击您已注册的域名，即可进入【记录管理】页面。</p></li><li><p>单击【添加记录】，添加一条主机记录为 firefox，记录值为 xxxx.xxx(这里是指你的域名)  的 CNAME 解析记录。如下图所示：</p></li></ol><img src="黑群晖使用DNSPod设置外网访问.assets/image-20230223205841510.png" alt="image-20230223205841510" style="zoom:80%;" /><p>然后在这个记录后面，去申请 SSL 证书，申请方法和上面讲的一样，这里不再赘述；</p><p>证书申请下来之后</p><p>按照DNSPod的官方文档：<a href="#https://cloud.tencent.com/document/product/302/79821">群晖（Synology）NAS 安装免费 SSL 证书</a>，导入到群辉中，<strong>注意，只是导入进来， 不需要任何配置</strong></p><p>也就是说，步骤是：</p><ul><li>申请证书</li><li>把证书导入到群辉</li><li><del>将证书设置为默认证书（<strong>这一步可千万不要做如果你做了，就在改回来</strong>，）</del></li><li>搞定</li></ul><p>搞定之后，我们来到群辉中，打开【设置】【安全性】【证书】在进行接下来的配置</p><p>按照图片上的内容，进行如下的配置</p><img src="黑群晖使用DNSPod设置外网访问.assets/image-20230223210520238.png" alt="image-20230223210520238" style="zoom:80%;" /><p>等你配置完之后，就完结撒花了。</p><p>在浏览器中，就可以通过 <a href="https://firefox.xxx.xx:1337/">https://firefox.xxx.xx:1337</a> 访问你的firefox火狐浏览器啦。</p><p>举一反三：其他任何的内网服务，都可以通过这样的步骤，暴露到公网中。 </p><p>所以，每一个二级域名，都要单独申请一本证书，还是挺麻烦的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;黑群晖使用DNSPod设置外网访问&quot;&gt;&lt;a href=&quot;#黑群晖使用DNSPod设置外网访问&quot; class=&quot;headerlink&quot; title=&quot;黑群晖使用DNSPod设置外网访问&quot;&gt;&lt;/a&gt;黑群晖使用DNSPod设置外网访问&lt;/h1&gt;&lt;p&gt;我折腾群辉的 DDN</summary>
      
    
    
    
    <category term="TOOLS" scheme="https://zspcer.gitee.io/categories/TOOLS/"/>
    
    <category term="DSM" scheme="https://zspcer.gitee.io/categories/TOOLS/DSM/"/>
    
    
    <category term="dsm" scheme="https://zspcer.gitee.io/tags/dsm/"/>
    
    <category term="群辉" scheme="https://zspcer.gitee.io/tags/%E7%BE%A4%E8%BE%89/"/>
    
    <category term="ddns" scheme="https://zspcer.gitee.io/tags/ddns/"/>
    
  </entry>
  
  <entry>
    <title>我的面试问题</title>
    <link href="https://zspcer.gitee.io/note/MYSELF/%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <id>https://zspcer.gitee.io/note/MYSELF/%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</id>
    <published>2023-03-15T04:24:10.515Z</published>
    <updated>2023-03-15T04:24:10.515Z</updated>
    
    <content type="html"><![CDATA[<p>redis的基本类型有哪些？<br>redis的有哪些使用场景？<br>String类型里面有bitmap，了解过吗？<br>sorted_set的底层原理是什么？<br>    跳表<br>redis的事务<br>    如果A，B两个事务，A事务修改了k1的值，然后查询k1，B事务删了k1，如果B的exec先发送完，A的exec后发送，会出现什么现象<br>    怎么解决这个现象呢？<br>缓存穿透？布隆过滤器？<br>Redis的持久化？RDB和AOF的区别<br>    RDB的原理：父子进程fork 和 copy on write； 指针指向同一个key，如果这个key修改了怎么办？<br>Redis主从中怎么保证数据的一致性（主从复制怎么实现的）<br>    - 通过RDB文件进行同步的，同步有两种方式网络和磁盘<br>    redis的管道pipline用过吗<br>    redis的内存如果用完了，会怎么样？<br>    - Redis有哪几种数据淘汰策略？<br>    - LRU<br>    - 怎么保证都是热点数据<br>    redis的集群有了解吗?<br>    普通哈希，一致性哈希（哈希环），哈希槽</p><p>一条查询语句是怎么执行的？</p><p>事务的四个特性，Mysql是怎么实现这四个特性的<br>事务有哪些隔离级别？<br>RR是怎么解决脏读的？<br>生产使用的隔离级别是哪种？<br>MySQL日志有哪几种？区别呢？</p><p>如何强制使用某个索引？<br>如果有一个很长的url存到了库中，我要利用这个字段去精确查询某行记录，怎么创建索引更好？<br>前缀索引怎么确定长度？</p><p>mysql有哪些调优方案？<br>    - 索引，使用覆盖索引，索引下推；<br>mysql会不会选错索引？选错了怎么办？<br>    - sql中手动指定索引<br>    - 删除掉走错的索引<br>mysql为什么会选错索引？<br>    - 统计不准，可以anlize table；<br>analize table准确吗？<br>    - 不准确，抽样采集的；</p><p>涉及到财务的系统设计</p><ul><li><a href="http://confluence.sf-express.com/pages/viewpage.action?pageId=189135181">http://confluence.sf-express.com/pages/viewpage.action?pageId=189135181</a></li><li>快递  银行  商家</li><li>快递根据快递单生成账单，根据账单的金额，调用银行进行打款申请，打款给商家；</li><li>快递单号，发件人，发件人银行账号，收件人，快递金额</li><li>用户可能涉及的状态：</li></ul><p>DDD的一些基本概念：</p><ul><li>实体和值对象的区别是什么？</li><li>一个查询请求过来，打到DDD后台之后，你们的分层是怎么样的，这个请求的链路是什么样子的</li><li>防腐层是什么？</li></ul><p>mysql</p><ul><li>对一个字段创建索引，是选择普通索引，还是唯一索引（buffer）？</li><li>对一个很长的字段，想精确查询，怎么建立索引？</li><li>回表？ 怎么减少回表<ul><li>有没有可能经过索引优化，避免回表过程呢？（覆盖索引）</li></ul></li><li><h2 id="索引的B-树"><a href="#索引的B-树" class="headerlink" title="索引的B+树"></a>索引的B+树</h2></li><li>mysql的事务特性<ul><li>日志</li></ul></li></ul><p>分布式的基本概念：</p><p>二阶段提交流程是什么？有什么问题？</p><p><a href="https://baijiahao.baidu.com/s?id=1698550212539924249&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1698550212539924249&amp;wfr=spider&amp;for=pc</a></p><p><a href="https://baijiahao.baidu.com/s?id=1694171547415193602&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1694171547415193602&amp;wfr=spider&amp;for=pc</a></p><p><a href="https://blog.csdn.net/qq_27184497/article/details/103673548">https://blog.csdn.net/qq_27184497/article/details/103673548</a></p><p><a href="https://blog.csdn.net/qq_27184497/article/details/103673548">https://blog.csdn.net/qq_27184497/article/details/103673548</a></p><p><a href="https://zhuanlan.zhihu.com/p/78599954">https://zhuanlan.zhihu.com/p/78599954</a></p><p><a href="https://www.cnblogs.com/Courage129/p/14528981.html">https://www.cnblogs.com/Courage129/p/14528981.html</a></p><p><a href="https://www.sdk.cn/details/EmGNy6EYwpyl6WewAX">https://www.sdk.cn/details/EmGNy6EYwpyl6WewAX</a></p><p><a href="https://www.sdk.cn/details/EmGNy6EYwpyl6WewAX">https://www.sdk.cn/details/EmGNy6EYwpyl6WewAX</a></p><p><a href="https://zhuanlan.zhihu.com/p/61129707">https://zhuanlan.zhihu.com/p/61129707</a></p><p><a href="https://blog.csdn.net/qq_38747892/article/details/122326276">https://blog.csdn.net/qq_38747892/article/details/122326276</a></p><p><a href="https://zhuanlan.zhihu.com/p/42056183">https://zhuanlan.zhihu.com/p/42056183</a></p><p>JVM垃圾回收</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;redis的基本类型有哪些？&lt;br&gt;redis的有哪些使用场景？&lt;br&gt;String类型里面有bitmap，了解过吗？&lt;br&gt;sorted_set的底层原理是什么？&lt;br&gt;    跳表&lt;br&gt;redis的事务&lt;br&gt;    如果A，B两个事务，A事务修改了k1的值，然后查询</summary>
      
    
    
    
    <category term="MYSELF" scheme="https://zspcer.gitee.io/categories/MYSELF/"/>
    
    
    <category term="面试" scheme="https://zspcer.gitee.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>群辉记录</title>
    <link href="https://zspcer.gitee.io/note/MYSELF/%E7%BE%A4%E8%BE%89%E8%AE%B0%E5%BD%95/"/>
    <id>https://zspcer.gitee.io/note/MYSELF/%E7%BE%A4%E8%BE%89%E8%AE%B0%E5%BD%95/</id>
    <published>2023-03-15T04:24:10.515Z</published>
    <updated>2023-03-15T04:24:10.515Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="36801f52761ba08ee98dd66d44281643d7607f96f26584cdc9120d87bd2b0916">8c00d3d27fb3c22fd589b44480636208283bc4f252b9d9a315fe285b7e6fdd7f930a20fa3f69a5692dc74a7bfb3323d7e419308d04e4d1b2c69d6ce874d15309d9b162fc742adecea1031d6df21b4970298cac3e5f2c75a9773931a94ddbd44d82b561c49a1b41237030cec8a279f390d19b6c0e8e9445c6208e1dd88fdd5bd073919cb914a7302022c8b7134022ff8d8ffd9e17841462ef970cc3a330c9ed4b9e221ce8a1c472a795238e964e6a9bd39568d3ffb023b9bc150a23e5b94b3e472d35e981d51e9b1572cc8b2fab654670b4de33ec8ac492d501ec51ea8df2ef5b5d2b46cd2510351b4efc93ef1de3567119a316f11dcb488fa3435ec0ef7e5640f22a0c234b5d23a03246e045960a49c8405be82177305068354452b4a0d6f757f0ab3f5293a708f2683055c48382288dc61763ed5116eeba89374b81210b6b7ae891fd510f624f99bdd10a28537060f6125b9435738e1ee43ce46a3dd608f1399e987f29eaef971c0369b9a0e2d671b2f141f106b2859fe1ba00bd3c55b9a7105aa9e57910b314839c2cf1948d54e7fe780e0d241387ea446e6fd6d2b726e91ed597fecdbb6f1baf9a80192119a71c0dfe57c2df5c97bbe8ee2c1571eab5d01a959c014a389864b18142644f8b4001184c72a99a440e4999187b84c10abb308fe1ad28847c8ae2ab26b8f5223d5a0737b643702de328933a40909629e7f5ef4003634de8a5796156940b8482e36827fe015f2e4e18edc63feb5fa45f0da7061b528d9aac93f910d48642a7d44df5be7c5ea847f539e60d63bd94d4b326c6d4aaad071d97c9b7ae3d6e75327c0833b6bc65b3f3439d2028c282d965576dc54a920f12f65c925b620d711d6442656fbbc1c8b0aa800d6cce48c90fbe2f9146bfcdb7fe2522b1d649ee7541233c45b620be3122aa7b80e15989b0887cc138e48b554263b16418bc28fbaf7aee0f8bb2a099472d1ccbeda82a0cb9b9f952543b80ce1209711544edf3b424e13a05a8c9f861753a4a1abb91cfb990fd15c13ab5693c81a8039739c10b3f7e0e2238916438e076903d4e17d2604d9f8b5667365ea504132f978b4fadfe8fd7cc637e3cfb20d848f9d366e3c5c49e2fda6b3bc59e4c8597f04633a3bfb4b003478d10de34d71bce4e7c98acc3154282ed33978560af91e9a491721dd49b76ace914a02257f7228e4d32c069e4306b79922090d7c186329c4ce2b4614c6a566a460c3216d7843eb69502e48a4a73e93ae53ae1a0c94da59d2b98185c29d16cc4896e76aed4aff0eca87328264d6b2f6dbd5038c8d6e3376ad069c77fad258c4ebbcf666e3a0593e4cb022fc3289ffb221c99f471af3bc6d8939cfa51867fd46f521218e84f988ce443a5644c5ae6ae959b2c96e62fbe701bca4d70211a84a960deae73027334f47d8dc7fdd5bb5914f2522a89c554375a07fec336bca228889955339aa41fde8eb915f3fc0dd20b38d5698e679076c962e0db9f3eb47cd8a4874dfac77b9586bee6b2eb7ec0782abac5eccd5c120dd52245baa3b66fa2328ce86e9a5f04ae136edbc3ed4c181a3443d9a007edd4422c226ce8d6d784b7d0391f323b31f7cded985fe9ddd01ce140f742a59694bf5a64b3a1843591800bb902c21fc50527123e06e68e852e9d04e88830a03f61a1ec5f51e459b46529bd449d9939759049f538a77162f6cade43b9d119830b0788d55fe0f6aa7e88ed1001cc941952e9165701a6459bfee9a663e26ea80ba8ec9b1644fb0b18f5fe5e24a111f3b3e662e088c4794a0f28b6b7aa82aed04118bff1457d1c287bc518c407e67772b56bc52e0ac63d0512448afbb2cec79f2e95c9f9d3d2fd16f928cc83ba40d1fe5cf2310c45eb31b8e99488c83c8d21d67aa2a6436e4871e744531d5d17f285d3fadf2bd410c66bd38ce464c1c80621f4ba8b091e1ec4abffc7b41b59506f7734df721630162e8b24673917de7a01d16ce3c5ef7f9b7dbdf587c604ee1eadc20d8b3cb21703c84eca4ea18eac46576beecc540784ca824a0a95f82bce0fa8e7c0331807bd2629ad8a652c39f4131b12342a15867c20cde7c9f2cdd6f4902996fa8bca7b1399d87524949eb8d8a0115cad805b5494c841277e796fed1011ad733ee8f2d582d17b50c163e7d8e76847d531cdf52f45628c436132e11ab5f2f3df0e667fd0069e2e77bed9ad578a8c6a83a2930984eeffc2e207c2d8c06ad04039da6845a16cd0ad1ac9469f0f2342d97f1ec45ac63dbf763819927591e8b0ea0f0e0f3d10f5409077610d9043083f3c584a9bc9b76da0ae65769dca3921a99f798031f925bbd4c2dcb3f03ae9a27d2ab20b83b221e9839c8db325eaf41411d09ca125c951771e1060ccf1d6bb8a1e9b6e1bc4e05450c508e713cd24123fe0f03a8a8bf0bf1f235567b5a43d417f7fb3627bc2bf4d288ea036edbe8c6bf01c792a96898ef8093707a3a06e97664abe03675182eb8ba5e447ef67a01f2cb70b12a6394e29c2a3a9fee5a9c045beb5b5da6de8d3fb90d249f3d903fea4cbea0b65462ffb140f6ca296335169725990f9a9a7c177c81e6b7cc3d304b38d4760d8c65d033ae894ed10f268be820eb2f0545ac84064a7c72731ab2e307b6c86faf8bcd241ceb20664f7941355a4a246c2bce955d1084d7fe650dfd60707efd18c16a0c4c7073cd03ab8c8e092cb3df9fc2d2e45698b5bddf6bf1962fb00edf35994f16fd6d110204acf27b3d2d417a6624b8f64b3625c0d3b3e488838b9d6ccc97699794d09b48ec8a565b966fa4bd0f160da44f10214b41c6edd302c7983a99752d760f5083bd02c65d6d5c724920c3731dd49fc8ab2e4253deb9eb3e021ff52c773f7699668dc0c3b4caad2e1fed08419741d5028db08a4733ae6e6abb3f4250bf69caa32ab9fac09e5d4fff2925f158f6ad6c05d3b02c5555948e01b97f61ca226333e094a37df3f380914c7b25d0f224652954b9ba882c95f6388cd0ba4b0f109f93f6d2738cd8918426554fc4bcbf605aff1739a94743e715d10ee9895d2015bde2a3d0ebff32b6e95378dcfb3cf5ddbc8295409ed451c22ad93fa367c3a3009fb8bbc84039181909ece03b16fa05e5f790857cf177db778a0c84995ce7605ea8c98bfad6d43a3fd5159e42d8041bbd71c79b819f2d0637e427eb8aabdd11d9d21d8fb80f9ac5e1d7c502076e3c8b14161b9300819ea78f2ce116968caab494168ed1965b91d2318e1f21f416bd6e56499898a1a0989345b8fabbcd94d18b673047096cfaf614d831973e6cfc1f91349c5ce5451466f07cc05522020e49aca884fd5ea5730418256a2a191c74b6f86cec40b1e74ddf7315dd1698213437bd83e7eb13cce464e64f5836b95afbd8f7da9364a2861129c9594a6917b608bc5f3577f8556fe057f4d12b710c24de63e2784f273ee4e85ec02cdd17298066545938da2b5e97a48875d910b9df36210c5c75b9874c0f80258de5d54309a0d1891e5f5d9745f0cfb188dbbbc22accc81c88b384330c89d43bde076ee34c544824ba438491cfff953c0fd4e691e1fb9981f79467520b9acb79f914325e593f32fd264ae25333bdb942fae10e6226ef73564dae0f211777f05ca65ddc31b195afca4c88f2ba66d27e86dd74307e3e5e9baf7726f2802c61c8ed730be412607ca2fffd042cd8062598fc5e6cedc4ea4e88b2ed0b0126c8ac7947bfe09fc85593640978ed53b7481778be70170c6b1fd86a74d84aed95bc4a67a3e652188c957ef0dd478901aadd58a49e3aa8c0debfb0308575e60ff848e4757b2e1f99fe4aef9c430cb4c6135b1ea95b9d882fff16a79d31eda19c5e424dae31da62abcf1ef343c549ddb393bacff6f4576050f7ff1fa5132443d07d1ac7fdea622fb1d1f6388a8bf2150597c46a7c6124eaa18aa3ebda5cc3e5761b604d2e24e07ace01998220e31bfe9911ea15f35d7cb97ae74f2eb2b548bf81d14820b74d1d1ae3919adce3d6aa0119461db64303901d48351d2f59fe16faaf8ce07e9484453dc87b815977b976db4f3108cb0581a447079b49a0178445bc86dd5d33b274460d179b5444c099f85628a7a133f3c097f3e6a419c5b04cbff68e747f68e44b58edd759036929af2862e77d3c9d19d7e8cbb8807bd47a2439991e163cec751d36577ef69ebbd52de6ddb87a16a4cb8766a5b17fa975e11102bbf90c9a08bbaf239f87d75579a5e49924aed20c11f3a1bc151159cb36acb0fadb1bde482b99b04ed2cb97cea12cd393e4c868780cbbb59c5e4b6c6535974e0108c652ed77c04d5db43e47661ab09334cb688c045c014d757e5678ae2ce81ef9a3d4860051648f3f7750f68f72baee2fb9778ad4f34fbea497407e59b83d4ba583a9a3f6efdfb32a848f5948e7e426e70d85b471a987a1dc9c010c6c6299aaafc56588642bbfcf346c3cdf74dd089c9b5ff69fa742d210a7355023632ab32d646a31f9ebb50fc2462e01ea31247373fb051923abd8ad51c5063d64781026e35de5e9973fc8dc5d58727066c68559cedb39d847f7cc372d0bf72672197d38bac18f41b1dfd83b7c1969a60</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">有东西被加密了, 请输入密码查看.</summary>
    
    
    
    <category term="MYSELF" scheme="https://zspcer.gitee.io/categories/MYSELF/"/>
    
    
    <category term="个人账号" scheme="https://zspcer.gitee.io/tags/%E4%B8%AA%E4%BA%BA%E8%B4%A6%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>mysql的索引从入门到入土</title>
    <link href="https://zspcer.gitee.io/note/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL/mysql%E7%9A%84%E7%B4%A2%E5%BC%95%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/"/>
    <id>https://zspcer.gitee.io/note/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL/mysql%E7%9A%84%E7%B4%A2%E5%BC%95%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/</id>
    <published>2023-03-15T04:24:10.514Z</published>
    <updated>2023-03-15T04:24:10.514Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql的索引从入门到入土"><a href="#mysql的索引从入门到入土" class="headerlink" title="mysql的索引从入门到入土"></a>mysql的索引从入门到入土</h1><h2 id="索引的XMIND图"><a href="#索引的XMIND图" class="headerlink" title="索引的XMIND图"></a>索引的XMIND图</h2><p>文件位置：<a href="./mysql%E7%9A%84%E7%B4%A2%E5%BC%95%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F.assets/Mysql%E7%B4%A2%E5%BC%95.xmind">点我打开</a></p><h2 id="索引的常见数据结构"><a href="#索引的常见数据结构" class="headerlink" title="索引的常见数据结构"></a>索引的常见数据结构</h2><p>哈希表</p><ul><li>哈希表这种结构适用于只有等值查询的场景，比如 Memcached 及其他一些 NoSQL 引擎。</li></ul><p>有序数组</p><ul><li><p>有序数组在等值查询和范围查询场景中的性能就都非常优秀。</p></li><li><p>有序数组索引只适用于静态存储引擎</p></li></ul><p>搜索树</p><ul><li><p>二叉搜索树：父节点左子树所有结点的值小于父节点的值，右子树所有结点的值大于父节点的值。</p></li><li><p>平衡二叉树：</p></li><li><p>N叉树：</p></li></ul><h2 id="InnoDB为什么选择B-树（对比其他树）"><a href="#InnoDB为什么选择B-树（对比其他树）" class="headerlink" title="InnoDB为什么选择B+树（对比其他树）"></a>InnoDB为什么选择B+树（对比其他树）</h2><h3 id="为什么选择树"><a href="#为什么选择树" class="headerlink" title="为什么选择树"></a>为什么选择树</h3><p>树的查询效率高，还可以保持有序。</p><h3 id="为什么不用二叉搜索树"><a href="#为什么不用二叉搜索树" class="headerlink" title="为什么不用二叉搜索树"></a>为什么不用二叉搜索树</h3><h4 id="什么是二叉搜索树（也叫二叉排序树或者二叉查找树）"><a href="#什么是二叉搜索树（也叫二叉排序树或者二叉查找树）" class="headerlink" title="什么是二叉搜索树（也叫二叉排序树或者二叉查找树）"></a>什么是二叉搜索树（也叫二叉排序树或者二叉查找树）</h4><p>以下是二叉查找树的结构：</p><img src="mysql的索引从入门到入土.assets/image-20221219173305682.png" alt="image-20221219173305682" style="zoom:50%;" /><p>它的<strong>特点</strong>是：</p><ul><li>父节点左子树所有结点的值小于父节点的值，右子树所有结点的值大于父节点的值。</li><li>只有两个叉</li><li>查询的时间复杂度是：O(log(N))</li><li>从算法逻辑来讲，二叉搜索树的查找速度和比较次数都是最小的。</li></ul><h4 id="为什么不用二叉搜索树（查找耗磁盘IO）"><a href="#为什么不用二叉搜索树（查找耗磁盘IO）" class="headerlink" title="为什么不用二叉搜索树（查找耗磁盘IO）"></a>为什么不用二叉搜索树（查找耗磁盘IO）</h4><p>因为考虑到磁盘IO的性能。</p><p>为什么这么说：InnoDB在查找的时候，是不能将所有的索引全部加载到内存中的，所以必然涉及到磁盘IO。</p><p>比如下面这个，二叉搜索树，我们想获取到10，需要经历几次磁盘IO：</p><img src="mysql的索引从入门到入土.assets/image-20221219173305682.png" alt="image-20221219173305682" style="zoom:50%;" /><p>答案是：4次</p><ul><li>第一次磁盘IO，读取9</li><li>第二次磁盘IO，读取13</li><li>第三次磁盘IO，读取11</li><li>第四次磁盘IO，读取10</li></ul><p>这样性能是很低的。</p><p>所以InnoDB并没有采用二叉搜索树来作为索引的数据结构。</p><p>但是InnoDB的设计者，又不能抛弃树这个数据结构带来的遍历，所以只能将 “瘦高” 的二叉搜索树，让它变得 “矮胖”。以便于节省磁盘IO。这就是<code>B树</code>的特征之一</p><h3 id="什么是B树"><a href="#什么是B树" class="headerlink" title="什么是B树"></a>什么是B树</h3><h4 id="什么是B树-1"><a href="#什么是B树-1" class="headerlink" title="什么是B树"></a>什么是B树</h4><p>B树 是一种<code>多路平衡查找树</code>，它的每一个节点最多包含<code>m</code>个孩子，<code>m</code>被称为<code>B树</code>的阶。</p><p>上面说了，InnoDB的设计者为了想保留树带来的便利，只能将： “瘦高” 的二叉搜索树，让它变得 “矮胖”。以便于节省磁盘IO。</p><p>下图就是一个 <code>3阶的B树</code> 示意图</p><img src="mysql的索引从入门到入土.assets/image-20221219180143637.png" alt="image-20221219180143637" style="zoom:50%;" /><p>一颗<code>m阶的B树</code>，它的特点是：</p><ul><li><code>m阶</code>表示每一个节点最多拥有<code>m</code>个孩子</li><li>根节点至少有 <code>2</code> 个子女</li><li>有<code>k</code>个孩子的节点包含有k-1个元素，其中： <code>ceil(m/2) &lt;= k &lt;= m</code>，（ceil表示向上取整）</li><li>每一个叶子节点都包含<code>k-1</code>个元素，其中：<code>ceil(m/2) &lt;= k &lt;= m</code>，（ceil表示向上取整）</li><li>所有的叶子节点都位于同一层</li><li>每个节点的元素从小到大排列，并且当该结点的孩子是非叶子结点时，节点中第<code>k-1</code>个元素正好是<code>k</code>个孩子包含的元素的值域分划。</li></ul><p>我们一一来看这些特点，其中</p><ul><li>一颗<code>3阶</code>的树，每个节点最多包含<code>3</code>个孩子，m &#x3D; 3</li><li><code>9</code>是根节点，有<code>2</code>个孩子<code>（2,6）</code>和 <code>12</code>。(根节点至少<code>2</code>个)</li><li><code>（2,6）</code>这个中间节点包含<code>2</code>个元素：<code>2</code>和<code>6</code>，有<code>3</code>个孩子。 <code>2 &lt;= k &lt;= 3</code></li><li><code>12 </code>这个中间节点包含<code>1</code>一个元素：<code>12</code>，有<code>2</code>个孩子。满足规则</li><li>叶子节点<code>1</code>,<code>(3,5)</code>,<code>8</code>,<code>11</code>,<code>(13,15)</code>位于同一层</li><li>每个节点的元素从小到大排列，<code>(3,5)</code>在<code>(2,6)</code>的值域之间。</li></ul><h4 id="B树的等值查找"><a href="#B树的等值查找" class="headerlink" title="B树的等值查找"></a>B树的等值查找</h4><p>在下面的一个3阶B树中，查找5，需要经历几次磁盘IO：</p><img src="mysql的索引从入门到入土.assets/image-20221219180143637.png" alt="image-20221219180143637" style="zoom:50%;" /><p>答案是：三次</p><ul><li>第一次磁盘IO：<code>9</code></li><li>第二次磁盘IO：<code>（2,6）</code></li><li>第三次磁盘IO：<code>（3,5）</code></li></ul><h4 id="B树的范围查找"><a href="#B树的范围查找" class="headerlink" title="B树的范围查找"></a>B树的范围查找</h4><p>在下面的一个3阶B树中，查找范围是 3-11 的元素，需要经历几次磁盘IO：</p><img src="mysql的索引从入门到入土.assets/image-20221219180143637.png" alt="image-20221219180143637" style="zoom:50%;" /><p>答案是：好多好多次</p><ul><li>3次磁盘IO后，找到范围下限：3 所在的（3,5）这个节点</li><li>中序遍历到 元素6</li><li>中序遍历到 元素8</li><li>中序遍历到 元素9</li><li>中序遍历到 元素11，遍历结束</li></ul><p>由此可见，B树的范围查找，很繁琐。</p><h4 id="B树的插入（自平衡）"><a href="#B树的插入（自平衡）" class="headerlink" title="B树的插入（自平衡）"></a>B树的插入（自平衡）</h4><p>插入比较复杂</p><p>以下面的为例子：在一个3阶的B树中，插入 4</p><img src="mysql的索引从入门到入土.assets/image-20221219180143637.png" alt="image-20221219180143637" style="zoom:50%;" /><p>由于 4 在 （3,5）之间。</p><img src="mysql的索引从入门到入土.assets/image-20221219185214252.png" alt="image-20221219185214252" style="zoom:50%;" /><ul><li>这是一颗<code>3阶</code>的B树，由于每个节点最多包含 <code>k-1</code> 个元素，其中  <code>2 &lt;= k &lt;= 3</code>，所以每个节点可以包含<code>1个</code>，<code>2个</code>元素；</li><li>要在<code>（3,5）</code>之间插入 <code>4</code>，<code>（3,5）</code>已经是<code>2</code>个元素了，不能在插入了。</li><li><code>（3,5）</code>的父节点<code>（2,6）</code>也是<code>2</code>个元素，也不能在插入了</li><li>根节点 <code>9</code> 是<code>1</code>个元素，可以在升级为2个元素。</li><li>于是：</li></ul><img src="mysql的索引从入门到入土.assets/image-20221219190355215.png" alt="image-20221219190355215" style="zoom:50%;" /><p>总结：</p><ul><li>仅仅是插入一个元素，就让整个B树发生了连锁反应</li><li>虽然麻烦，但是也正因为如此，可以让B树始终保持多路平衡。（<strong>自平衡</strong>）</li></ul><h4 id="B树的删除（左旋）"><a href="#B树的删除（左旋）" class="headerlink" title="B树的删除（左旋）"></a>B树的删除（左旋）</h4><p>在如下的一个3阶B树中，删除元素11</p><img src="mysql的索引从入门到入土.assets/image-20221219190937755.png" alt="image-20221219190937755" style="zoom:50%;" /><ul><li>首先这是一颗3阶B树，由于B树的规则，每个中间节点都包含<code>k-1</code>个元素和<code>k</code>个孩子，其中 <code> 2&lt;= k &lt;= 3</code></li><li>所以：11删除之后，父节点12就只剩下1个孩子了，不符合规则，3阶的B树每个中间节点至少有2个孩子。</li><li>因为，需要找出删除11后，剩余的三个元素12,13,15的中位数，取代节点12；然后节点12下移成为孩子（<strong>左旋</strong>）</li></ul><img src="mysql的索引从入门到入土.assets/image-20221219191850585.png" alt="image-20221219191850585" style="zoom:50%;" /><h4 id="B树的卫星数据"><a href="#B树的卫星数据" class="headerlink" title="B树的卫星数据"></a>B树的卫星数据</h4><p>所谓的卫星数据（Satellite Information），指的是索引元素所指向的数据记录；</p><p>在B树中，每一个节点都带有卫星数据。</p><img src="mysql的索引从入门到入土.assets/image-20221219221417559.png" alt="image-20221219221417559" style="zoom:50%;" /><h3 id="为什么选择B-树"><a href="#为什么选择B-树" class="headerlink" title="为什么选择B+树"></a>为什么选择B+树</h3><h4 id="什么是B-树"><a href="#什么是B-树" class="headerlink" title="什么是B+树"></a>什么是B+树</h4><p>B+树是基于B树的一种变体。有着比B树更高的查询性能</p><p>下面是一个3阶的B+树的示意图：节点之间含有重复元素，叶子节点还用指针连在一起</p><img src="mysql的索引从入门到入土.assets/image-20221219215758443.png" alt="image-20221219215758443" style="zoom:50%;" /><p>一颗m阶的B+树有以下特点：</p><ul><li>有k个子树的中间节点包含有k个元素（B树中是k-1个元素）</li><li>每个元素不保存数据，只用来索引，所有的数据保存在叶子节点</li><li>所有的叶子节点包含了全部元素的信息，而且每个叶子节点都带有指向下一个节点的指针，形成了一个有序链表</li><li>叶子节点本身依关键字大小自小而大顺序链接</li><li>每一个父节点的元素都出现在子节点中，而且是子节点中最大（或最小）的元素</li><li>无论插入多少元素，都要保持最大元素在根节点中</li></ul><h4 id="B-树的卫星数据"><a href="#B-树的卫星数据" class="headerlink" title="B+树的卫星数据"></a>B+树的卫星数据</h4><p>所谓的卫星数据（Satellite Information），指的是索引元素所指向的数据记录；</p><p>在B+树中，只有叶子节点带有卫星数据。</p><p>在mysql中，表中的一行记录就是一个卫星数据。</p><p>不过需要注意的是：</p><ul><li>在mysql中，主键索引的叶子结点存的是<code>卫星数据</code>（就是行记录）</li><li>在mysql中，非主键索引的叶子节点存的是<code>指向卫星数据的指针</code>（就是行记录的主键id）</li></ul><img src="mysql的索引从入门到入土.assets/image-20221219221505548.png" alt="image-20221219221505548" style="zoom:50%;" /><h4 id="B-树的等值查找"><a href="#B-树的等值查找" class="headerlink" title="B+树的等值查找"></a>B+树的等值查找</h4><p>在下面这颗3阶的B+树上查找元素 3，会经历几次磁盘IO：</p><img src="mysql的索引从入门到入土.assets/image-20221219215758443.png" alt="image-20221219215758443" style="zoom:50%;" /><p>结果：</p><ul><li>第一次磁盘IO：（8,15）</li><li>第二次磁盘IO：（2,5,8）</li><li>第三次磁盘IO：（3,5）</li></ul><p>由于B+树的中间节点并没有存放卫星数据，所以比B树更加“矮胖”，也即是说：在相同数据量的情况下，B+树会比B树访问到更少的磁盘IO。</p><p>由于 B+树 的中间节点没有存放卫星数据，所以要想拿到记录，必须访问到叶子节点。</p><p>而 B树 由于每个节点都存放了卫星数据，所以只要匹配到，就可以获取到记录。</p><p>对B树来说：最好的情况是只访问根节点就能拿到记录，最坏的情况就是访问到叶子结点。换言之：B树的查找性能不稳定</p><p>对B+树来说：由于每一次都要访问到叶子节点，所以B+树的查找性能是稳定的。</p><h4 id="B-树的范围查找"><a href="#B-树的范围查找" class="headerlink" title="B+树的范围查找"></a>B+树的范围查找</h4><p>在下面这颗3阶的B+树上，查找范围是 3-11 的元素，需要经历几次磁盘IO：</p><img src="mysql的索引从入门到入土.assets/image-20221219215758443.png" alt="image-20221219215758443" style="zoom:50%;" /><p>答案是：5次</p><ul><li>第一次磁盘IO：找到：（8,15）</li><li>第二次磁盘IO：找到：（2,5,8）</li><li>第三次磁盘IO：找到：（3,5），此时找到范围下限：3 所在的（3,5）这个节点</li><li>然后通过叶子结点上的指针，直接遍历叶子节点。（3,5），（6,8），（9,11）</li><li>直接确定到范围</li></ul><p>相比于B树范围查找的繁琐，B+树就简单的多了。</p><h3 id="B-树的B树的比较"><a href="#B-树的B树的比较" class="headerlink" title="B+树的B树的比较"></a>B+树的B树的比较</h3><p>B+树相比B树的优势有三个</p><ul><li>IO次数更少</li><li>查询性能稳定</li><li>范围查询简便</li></ul><p>至于插入和删除，两者大同小异。</p><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><p>了解下面列出来的索引概念：</p><ul><li>主键索引</li><li>普通索引</li><li>聚簇索引</li><li>非聚簇索引</li><li>二级索引</li><li>唯一索引</li><li>全文索引</li><li>联合索引</li><li>覆盖索引</li><li>前缀索引</li></ul><h3 id="主键索引和普通索引"><a href="#主键索引和普通索引" class="headerlink" title="主键索引和普通索引"></a>主键索引和普通索引</h3><p>主键索引：也叫聚簇索引，它 是一种特殊的唯一索引，<strong>不允许有空值</strong>。</p><p>普通索引：也叫二级索引，最基本的索引，没有任何限制</p><p>主键索引在InnoDB中是聚簇索引；普通索引在InnoDB中是非聚簇索引</p><h3 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h3><p>聚簇索引并不是单独的索引类型，而是一种数据存储方式，指的是：数据和对应的索引紧凑的存储在一起。</p><p>非聚簇索引指的就是：数据和索引分开存储。</p><p>举例来说：</p><p>对于InnoDB：主键索引的叶子节点存的是主键id和数据，它们是保存在一起的；非主键索引的叶子节点存的是主键id，和真实的数据是分开的。所以主键索引是聚簇索引，非主键索引是非聚簇索引。（InnoDB的索引和数据是放在同一个文件中的：数据即索引，索引即数据）</p><p>对于MyISAM：索引和记录本身就是分开存储的，是不同的文件。所以MyISAM中所有的索引都是非聚簇索引。</p><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>唯一索引：与”普通索引”类似，不同的就是：索引列的值必须唯一，但<strong>允许有空值</strong>。</p><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>全文索引：仅可用于 MyISAM 表，针对较大的数据，生成全文索引很耗时耗空间。</p><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>也叫组合索引，为了更多的提高mysql效率可建立组合索引，遵循”最左前缀“原则。</p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>当一个SQL查询语句所需要查询的字段，被所使用的的索引可以直接满足需求，不需要回表了，称之为覆盖索引</p><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>当需要索引的字段很长，而且该字段后半部分的选择性很低，比如邮箱地址；后面都是一样的。</p><p>对于这种我们就可以建立前缀索引：使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">alter</span> <span class="token keyword">table</span> SUser <span class="token keyword">add</span> <span class="token keyword">index</span> index2<span class="token punctuation">(</span>email<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>前缀索引会导致覆盖索引失效，因为前缀索引是截取后的部分做的索引，不得不在回表查一次完整的信息。</p><h2 id="索引特点"><a href="#索引特点" class="headerlink" title="索引特点"></a>索引特点</h2><h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><p>假设有一个用户表，我们给 （name, age）加上联合索引。</p><p>如果我们要查询所有名字第一个字是“张”的人，SQL语句可能会这么写：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">'张%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这种情况下，也是可以使用到这个索引的。这就是索引的最左匹配原则。</p><ul><li>最左匹配原则可以是联合索引的最左N的字段，也可以是一个字符串的最左M个字符；</li><li>在建立联合索引的时候，如何安排索引内的字段顺序，需要仔细考量了。</li></ul><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>mysql 5.6 引入了 索引下推优化。可以在索引遍历的过程中，对索引中包含的字段先做判断，直接过滤掉不满足的记录，减少回表次数。</p><p>假如有一个用户表，我们给（name，age）加上联合索引。</p><p>如果我们要查询所有名字第一个字是“张”的人，并且年龄大于10岁的男人。SQL语句可能会这么写</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">'张%'</span> <span class="token operator">and</span> age <span class="token operator">></span> <span class="token number">10</span> <span class="token operator">and</span> male<span class="token operator">=</span><span class="token string">'男'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于这个语句，我们知道由于最左匹配原则，使用到了（name，age）这个索引。</p><p>然后，接下来呢？</p><p>在mysql 5.6之前，接下来就需要回表了。对扫描的每一条记录，都回表判断 age 和 male 是否满足；</p><p>在mysql 5.6之后，由于有索引下推优化，对于age的判断可以直接完成，过滤掉age不符合的记录，然后对剩下的记录在此回表判断male是否满足。（减少了回表次数）</p><h3 id="索引潜水"><a href="#索引潜水" class="headerlink" title="索引潜水"></a>索引潜水</h3><p>英文单词：index dive</p><p>主要是用于 IN 查询语句的优化，</p><p>跟这个词语相关的，还有一个配置参数 <code>eq_range_index_dive_limit</code>。</p><p>MySQL5.7.3之前的版本，这个值默认是10，之后的版本，这个值默认是200。</p><p>简单的理解就是：IN 语句的数量如果少于200个，就使用<strong>索引潜水（Index dive）</strong>预估扫描行数，很精确，所以选择索引的时候就不容易出错；</p><p>如果 IN 语句的数量大于200个，就使用 <strong>索引统计（Index statistics）</strong>预估扫描行数，误差很大，所以会导致选择索引容易选错，导致性能下降</p><p>关于索引潜水，具体见：Mysql性能调优从入门到入土</p><h3 id="普通索引默认联合主键索引"><a href="#普通索引默认联合主键索引" class="headerlink" title="普通索引默认联合主键索引"></a>普通索引默认联合主键索引</h3><p>二级索引会默认与主键索引做联合索引。</p><p>为什么？</p><p>因为二级索引的叶子节点存放的就是主键。</p><h2 id="索引比较"><a href="#索引比较" class="headerlink" title="索引比较"></a>索引比较</h2><p>任何索引之间的比较，都从 增删改查 四个角度来具体分析，就不迷惑了。</p><h3 id="普通索引和主键索引有什么区别？"><a href="#普通索引和主键索引有什么区别？" class="headerlink" title="普通索引和主键索引有什么区别？"></a>普通索引和主键索引有什么区别？</h3><p>主键索引的查询，不需要回表了。</p><p>普通索引的查询，如果要查询的字段没有被当前索引覆盖，是需要回表的。</p><p>针对回表的优化：</p><ul><li>覆盖索引可以减少回表</li><li>索引下推可以减少回表</li></ul><h3 id="普通索引和唯一索引有什么区别？"><a href="#普通索引和唯一索引有什么区别？" class="headerlink" title="普通索引和唯一索引有什么区别？"></a>普通索引和唯一索引有什么区别？</h3><h4 id="对查询的影响"><a href="#对查询的影响" class="headerlink" title="对查询的影响"></a>对查询的影响</h4><ul><li>微乎其微。</li><li>普通索引的查询：定位到当前记录之后，还要继续判断下一条记录是否满足条件。</li><li>唯一索引的查询：定位到当前记录之后，由于是唯一的，不再需要判断下一条记录了。</li></ul><p>不过，后面看到加锁规则这部分的时候，有一个加锁规则是：唯一索引上的范围查询，会访问到不满足查询条件的第一个值为止。 </p><p>也就是说：</p><ul><li>对于范围查询，普通索引和唯一索引是一样的，都需要访问下一条记录。</li><li>对于等值查询，唯一索引比普通索引少了一次查找下一条记录的性能消耗。</li></ul><h4 id="对更新的影响"><a href="#对更新的影响" class="headerlink" title="对更新的影响"></a>对更新的影响</h4><ul><li><p>参考：《mysql的日志从入门到入土》这篇文章中讲到了changebuffer：</p><ul><li>changebuffer（对更新的优化，对比redolog）</li><li>changebuffer在 5.5 版本之前叫做：insert buffer，只支持插入操作；在5.5之后，支持了更新操作</li><li>changebuffer的作用：</li><li>更新的时候不需要从内存中加载数据页，而是直接将更新后的记录写到changebuffer中（内存中）就可以返回了</li><li>那么changebuffer中的数据什么时候刷盘呢？</li><li>因为写入changebuffer了，一定会写入redolog，后台会定时将redolog中的数据应用到数据页中，同时也会将changebuffer的数据应用到数据页，这是两个后台线程，他俩没有任何关系。操作的都是内存中的数据页，然后刷脏页</li><li>具体的可以参考：《mysql的日志从入门到入土》</li></ul></li><li><p>为什么唯一索引的更新就不能使用 change buffer，只有普通索引可以使用。</p><ul><li><p>因为唯一索引的更新，需要判断当前的这个更新会不会影响到唯一索引的唯一性。</p></li><li><p>所以必须判断要将数据页加载到内存中，进行判断才可以。</p></li></ul></li><li><p>change buffer适应于：写多读少的场景和写多读多的场景；</p></li><li><p>change buffer 和 redo log的联系和区别。</p><ul><li>change buffer减少了磁盘的随机读（减少了加载数据页的操作）</li><li>redo log减少的磁盘的随机写（WAL机制）</li></ul></li></ul><h3 id="前缀索引对覆盖索引的影响"><a href="#前缀索引对覆盖索引的影响" class="headerlink" title="前缀索引对覆盖索引的影响"></a>前缀索引对覆盖索引的影响</h3><p>我们知道覆盖索引可以减少回表，提升查询性能；</p><p>但是当我们的覆盖索引是前缀索引的时候，此时覆盖索引是不生效的。</p><p>因为前缀索引是截取后的信息作为索引，要想获取完整的字段，就不得不回表在查询一次。</p><h2 id="选错索引（索引统计，强制索引）"><a href="#选错索引（索引统计，强制索引）" class="headerlink" title="选错索引（索引统计，强制索引）"></a>选错索引（索引统计，强制索引）</h2><ul><li><p>由于索引统计的更新机制，索引统计信息不准确导致的。</p></li><li><p>解决：重新采集统计信息：analyze table</p></li><li><p>解决：手动指定索引；force index</p></li></ul><h3 id="优化器是怎么选择索引的"><a href="#优化器是怎么选择索引的" class="headerlink" title="优化器是怎么选择索引的"></a>优化器是怎么选择索引的</h3><p>选择索引是优化器的工作。</p><p>而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。</p><p>在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的 CPU 资源越少。</p><p>但是扫描行数并不是唯一确定索引的因素。优化器还会结合是否使用临时表、是否排序等因素进行综合判断。</p><h3 id="怎么确定扫描行数呢？"><a href="#怎么确定扫描行数呢？" class="headerlink" title="怎么确定扫描行数呢？"></a><strong>怎么确定扫描行数呢？</strong></h3><p>在确定扫描行数之前，mysql 会先看看 索引基数。索引基数决定了要不要使用索引</p><ul><li>如果索引基数太小，就会弃用索引。</li><li>当索引基数比较大的时候，要不要走这个索引，还得看扫描行数，回表，子查询等等，最后优化器根据预估的成本决定是否走这个索引。</li></ul><h4 id="什么是索引基数呢"><a href="#什么是索引基数呢" class="headerlink" title="什么是索引基数呢"></a>什么是索引基数呢</h4><p>MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据<strong>统计信息</strong>来估算记录数。</p><p>这个<strong>统计信息</strong>就是索引的“<strong>区分度</strong>”。</p><p>显然，一个索引上不同的值越多，这个索引的区分度就越好。</p><p>而一个索引上不同的值的个数，我们称之为<strong>“基数”（cardinality）</strong>。</p><p>也就是说，这个基数越大，索引的区分度越好。</p><p>我们可以使用 show index 方法，看到一个索引的基数。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> <span class="token keyword">index</span> <span class="token keyword">from</span> t<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+</span><span class="token operator">|</span> <span class="token keyword">Table</span> <span class="token operator">|</span> Non_unique <span class="token operator">|</span> Key_name <span class="token operator">|</span> Seq_in_index <span class="token operator">|</span> Column_name <span class="token operator">|</span> Collation <span class="token operator">|</span> Cardinality <span class="token operator">|</span> Sub_part <span class="token operator">|</span> Packed <span class="token operator">|</span> <span class="token boolean">Null</span> <span class="token operator">|</span> Index_type <span class="token operator">|</span> <span class="token keyword">Comment</span> <span class="token operator">|</span> Index_comment <span class="token operator">|</span> Visible <span class="token operator">|</span> Expression <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+</span><span class="token operator">|</span> t     <span class="token operator">|</span>          <span class="token number">0</span> <span class="token operator">|</span> <span class="token keyword">PRIMARY</span>  <span class="token operator">|</span>            <span class="token number">1</span> <span class="token operator">|</span> id          <span class="token operator">|</span> A         <span class="token operator">|</span>           <span class="token number">6</span> <span class="token operator">|</span>     <span class="token boolean">NULL</span> <span class="token operator">|</span>   <span class="token boolean">NULL</span> <span class="token operator">|</span>      <span class="token operator">|</span> <span class="token keyword">BTREE</span>      <span class="token operator">|</span>         <span class="token operator">|</span>               <span class="token operator">|</span> YES     <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span><span class="token operator">|</span> t     <span class="token operator">|</span>          <span class="token number">1</span> <span class="token operator">|</span> c        <span class="token operator">|</span>            <span class="token number">1</span> <span class="token operator">|</span> c           <span class="token operator">|</span> A         <span class="token operator">|</span>           <span class="token number">6</span> <span class="token operator">|</span>     <span class="token boolean">NULL</span> <span class="token operator">|</span>   <span class="token boolean">NULL</span> <span class="token operator">|</span> YES  <span class="token operator">|</span> <span class="token keyword">BTREE</span>      <span class="token operator">|</span>         <span class="token operator">|</span>               <span class="token operator">|</span> YES     <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+</span><span class="token number">2</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.03</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>MySQL 是怎样得到索引的基数的呢？</strong></p><p>MySQL 使用采样统计的方法进行统计索引的基数。</p><p>为什么要采样统计呢？因为把整张表取出来一行行统计，虽然可以得到精确的结果，但是代价太高了，所以只能选择“采样统计”。</p><p>采样统计的时候，InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。</p><p>而数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过 1&#x2F;M 的时候，会自动触发重新做一次索引统计。</p><p>举个例子：</p><p>取n&#x3D;3个数据页统计，假设共有10个索引数据页； page1：10个不同值； page2：20个不同值； page3：15 个不同值； 索引基数&#x3D;(10+20+15)&#x2F;3*10&#x3D;150；</p><p><strong>上文所说的 N  和 M 具体是多少呢？</strong></p><p>在 MySQL 中，有两种存储索引统计的方式，可以通过设置参数 innodb_stats_persistent 的值来选择：</p><ul><li>设置为 on 的时候，表示统计信息会持久化存储。这时，默认的 N 是 20，M 是 10。</li><li>设置为 off 的时候，表示统计信息只存储在内存中。这时，默认的 N 是 8，M 是 16。</li></ul><p>由于是采样统计，所以不管 N 是 20 还是 8，这个基数都是很容易不准的。</p><h4 id="怎么确定扫描行数呢？-1"><a href="#怎么确定扫描行数呢？-1" class="headerlink" title="怎么确定扫描行数呢？"></a>怎么确定扫描行数呢？</h4><p>知道了索引基数，优化器还要继续预估执行这个语句，具体需要扫描多少行</p><p>通过 explain 命令可以看到优化器预估的扫描行数，至于mysql是怎么预估扫描行数的，这里就不在展开了。</p><h3 id="怎么解决选错索引的问题"><a href="#怎么解决选错索引的问题" class="headerlink" title="怎么解决选错索引的问题"></a>怎么解决选错索引的问题</h3><p>如果你通过 explain 命令，看到是由于 预估行数 错误，导致了mysql选错了索引。</p><p>可以使用：analyze table t 命令，可以用来重新统计索引信息。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">analyze</span> <span class="token keyword">table</span> t<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">-------+---------+----------+----------+</span><span class="token operator">|</span> <span class="token keyword">Table</span> <span class="token operator">|</span> Op      <span class="token operator">|</span> Msg_type <span class="token operator">|</span> Msg_text <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-------+---------+----------+----------+</span><span class="token operator">|</span> zs<span class="token punctuation">.</span>t  <span class="token operator">|</span> <span class="token keyword">analyze</span> <span class="token operator">|</span> <span class="token keyword">status</span>   <span class="token operator">|</span> OK       <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-------+---------+----------+----------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.04</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外，我们知道索引的选择，并不是仅仅靠 扫描行数 这一个影响因素来决定的</p><p>如果在实际的生产环境中，我们发现使用 索引a 就是比 索引b 有更好的性能</p><p>我们可以使用 force index 强制这个sql语句使用索引a，而不是索引b</p><h2 id="索引排序（order-by）"><a href="#索引排序（order-by）" class="headerlink" title="索引排序（order by）"></a>索引排序（order by）</h2><p>在日常的开发过程中，经常会使用<code>order by</code>语句，那么排序的原理是什么呢？</p><p>排序分为两种情况</p><ul><li>排序的字段有索引</li><li>排序的字段没有索引</li></ul><h3 id="有索引的排序"><a href="#有索引的排序" class="headerlink" title="有索引的排序"></a>有索引的排序</h3><p>我们知道索引是有序的，所以有索引的排序会直接使用索引；</p><p>直接使用索引排序的话，<code>explain</code>结果中是不会有 Using filesort 的</p><p>结果中有 Using filesort ，表示的就是需要排序，而且没有用到索引</p><h3 id="没有索引的排序"><a href="#没有索引的排序" class="headerlink" title="没有索引的排序"></a>没有索引的排序</h3><p>没有索引的排序，相对来说复杂一下。</p><p>一个语句是否使用了排序，可以通过：<code>explain</code>命令查看，结果中有 Using filesort ，表示的就是需要排序。</p><p>MySQL 会给每个线程分配一块<code>内存</code>用于排序，称为<code> sort_buffer</code>。</p><h4 id="sort-buffer是什么"><a href="#sort-buffer是什么" class="headerlink" title="sort_buffer是什么"></a>sort_buffer是什么</h4><p>MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer；</p><p>sort_buffer既然是内存区域，就不可能无限的扩大，是可以通过参数<code>sort_buffer_size</code>控制的</p><h4 id="sort-buffer有多大（内部排序和外部排序）"><a href="#sort-buffer有多大（内部排序和外部排序）" class="headerlink" title="sort buffer有多大（内部排序和外部排序）"></a>sort buffer有多大（内部排序和外部排序）</h4><p>通过参数<code>sort_buffer_size</code>控制的，默认是：262144（公司是：8388608）</p><p>sort_buffer_size，就是 MySQL 为排序开辟的内存（sort_buffer）的大小。</p><p>如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。 这叫做：<code>内部排序</code></p><p>但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。这叫做：<code>外部排序</code></p><p>内存放不下时，就需要使用外部排序，外部排序一般使用归并排序算法。</p><p>可以这么简单理解，MySQL 将需要排序的数据分成 N 份，每一份单独排序后存在这些临时文件中。然后把这 N 个有序文件再合并成一个有序的大文件。</p><p>内部排序：使用快速排序</p><p>外部排序：使用归并排序</p><h4 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h4><p>示例数据</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>t<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>city<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>addr<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>city<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>city<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span><span class="token comment">-- 初始化10条数据</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们执行下面的查询语句的时候</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> city<span class="token punctuation">,</span>name<span class="token punctuation">,</span>age <span class="token keyword">from</span> t <span class="token keyword">where</span> city<span class="token operator">=</span><span class="token string">'杭州'</span> <span class="token keyword">order</span> <span class="token keyword">by</span> name <span class="token keyword">limit</span> <span class="token number">1000</span>  <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它的排序执行流程如下：</p><ul><li>初始化 sort_buffer，确定放入 name、city、age 这三个字段；</li><li>从索引 city 找到第一个满足 city&#x3D;’杭州’条件的主键 id；</li><li>到主键 id 索引取出整行，取 name、city、age 三个字段的值，存入 sort_buffer 中</li><li>从索引 city 取下一个记录的主键 id；</li><li>重复步骤 3、4 直到 city 的值不满足查询条件为止；</li><li>对 sort_buffer 中的数据按照字段 name 做快速排序；</li><li>按照排序结果取前 1000 行返回给客户端。</li></ul><p>在上面这个过程里面，只对原表的数据读了一遍，剩下的操作都是在 sort_buffer 和临时文件中执行的。</p><p>但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么 sort_buffer 里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。</p><p>那么，如果 MySQL 认为排序的单行长度太大会怎么做呢？</p><h4 id="rowId排序"><a href="#rowId排序" class="headerlink" title="rowId排序"></a>rowId排序</h4><p>如果 MySQL 认为排序的单行长度太大会怎么做呢？</p><p><code>max_length_for_sort_data</code>：是 MySQL 中专门控制用于排序的行数据的长度的一个参数。</p><p>它的意思是，如果单行的长度超过这个值，MySQL 就认为单行太大，要换一个算法。</p><p>示例数据</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>t<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>city<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>addr<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>city<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>city<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span><span class="token comment">-- 初始化10条数据</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们执行下面的查询语句的时候</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> city<span class="token punctuation">,</span>name<span class="token punctuation">,</span>age <span class="token keyword">from</span> t <span class="token keyword">where</span> city<span class="token operator">=</span><span class="token string">'杭州'</span> <span class="token keyword">order</span> <span class="token keyword">by</span> name <span class="token keyword">limit</span> <span class="token number">1000</span>  <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>city、name、age 这三个字段的定义总长度是 36，我把 max_length_for_sort_data 设置为 16，我们再来看看计算过程有什么改变。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> max_length_for_sort_data <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新的算法放入 sort_buffer 的字段，只有要排序的列（即 name 字段）和主键 id。</p><p>但这时，排序的结果就因为少了 city 和 age 字段的值，不能直接返回了，整个执行流程就变成如下所示的样子：</p><ul><li>初始化 sort_buffer，确定放入两个字段，即 name 和 id；</li><li>从索引 city 找到第一个满足 city&#x3D;’杭州’条件的主键 id；</li><li>到主键 id 索引取出整行，取 name、id 这两个字段，存入 sort_buffer 中；</li><li>从索引 city 取下一个记录的主键 id；</li><li>重复步骤 3、4 直到不满足 city&#x3D;’杭州’条件为止；</li><li>对 sort_buffer 中的数据按照字段 name 进行排序；</li><li>遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端。</li></ul><h4 id="全字段排序-VS-rowid-排序"><a href="#全字段排序-VS-rowid-排序" class="headerlink" title="全字段排序 VS rowid 排序"></a>全字段排序 VS rowid 排序</h4><ul><li>MySQL 如果觉得排序内存太小，会影响排序效率，会采用 rowid 排序算法，这样排序过程中一次可以排序更多行，但是需要回表</li><li>MySQL 认为内存足够大，会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，可以减少回表</li></ul><h2 id="索引为什么不生效"><a href="#索引为什么不生效" class="headerlink" title="索引为什么不生效"></a>索引为什么不生效</h2><p>以下三种情况，都会影响索引的使用</p><ul><li>条件字段使用函数</li><li>隐式类型转换</li><li>隐式字符编码转换</li></ul><h3 id="条件字段函数操作会影响索引"><a href="#条件字段函数操作会影响索引" class="headerlink" title="条件字段函数操作会影响索引"></a>条件字段函数操作会影响索引</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 查询创建时间是7月份的记录，created_time有索引</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> <span class="token keyword">month</span><span class="token punctuation">(</span>created_time<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>由于加了 month() 函数操作，created_time索引树里面，并不认识7，所以MySQL 无法再使用索引快速定位功能，而<strong>只能使用全索引扫描</strong>。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> id <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>虽然这个加 1 操作并不会改变主键索引的有序性，但是 MySQL 优化器还是不能用 id 索引快速定位到 id&#x3D;4 这一行。</p><p>所以，需要你在写 SQL 语句的时候，手动改写成 where id &#x3D; 5 -1 才可以。</p><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>这个坑，今天刚踩过，表里对于单号 order_no 有索引，order_no 字段是varchar类型，但是我的语句是这么写的</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> order_no<span class="token operator">=</span><span class="token number">110717</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>explain 的结果显示：这条语句需要走全表扫描</p><p>因为：order_no 字段是varchar类型，而我的查询条件里用到的是整型。所以mysql会默认用到类型转换，<strong>导致索引失效</strong></p><p><strong>字符串和数字做比较的话，是将字符串转换成数字</strong>；所以，上面那个语句等同于</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> CAST<span class="token punctuation">(</span>order_no signed <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">110717</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这也就明白了，为什么不会走索引了。</p><p>然后考虑下面这个语句，会走主键索引吗</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token string">'11'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>答案是：会走索引，因为：字符串和数字做比较的话，是将字符串转换成数字，所以没有对条件字段使用函数。索引不会失效</p><h3 id="隐式字符编码转换"><a href="#隐式字符编码转换" class="headerlink" title="隐式字符编码转换"></a>隐式字符编码转换</h3><p>如果关联的两张表，使用的字符集不同的话，比如一个使用utf8，一个使用utf8mb4； 所以做表连接查询的时候用不上关联字段的索引。</p><p>为什么字符集不一样，不能用索引呢？</p><p>因为字符集 utf8mb4 是 utf8 的超集，所以当这两个类型的字符串在做比较的时候，MySQL 内部的操作是，先把 utf8 字符串转成 utf8mb4 字符集，再做比较。</p><p>（自动类型转换的时候，为了避免数据在转换过程中由于截断导致数据错误，也都是“<strong>按数据长度增加的方向</strong>”进行转换的。）</p><h2 id="InnoB的索引模型（B-树）"><a href="#InnoB的索引模型（B-树）" class="headerlink" title="InnoB的索引模型（B+树）"></a>InnoB的索引模型（B+树）</h2><h3 id="复习B-树"><a href="#复习B-树" class="headerlink" title="复习B+树"></a>复习B+树</h3><p>每一个索引在 InnoDB 里面对应一棵 B+ 树。在复习一下B+树</p><p>下面是一个3阶的B+树的示意图：</p><ul><li>节点之间含有重复元素</li><li>叶子节点还用指针连在一起</li></ul><img src="mysql的索引从入门到入土.assets/image-20221219215758443.png" alt="image-20221219215758443" style="zoom:50%;" /><p>接下来：</p><ul><li>我们考虑各个索引在InnoDB中具体的B+树结构是什么样子的</li><li>这些索引是怎么维护的（插入数据，删除数据，更新数据对索引的影响，页分裂，页合并）</li><li>这些索引是怎么使用的（等值查询，范围查询）</li></ul><h3 id="案例数据"><a href="#案例数据" class="headerlink" title="案例数据"></a>案例数据</h3><p>准备一张表：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>city<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>address<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>city<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>city<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>name_age<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">,</span><span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>表里有一个主键 id</li><li>表里有一个普通索引 city</li><li>表里有一个联合索引 name_age</li><li>接下来，我们看看，不停的向表里写入数据，会发生什么</li></ul><p><strong>重要声明</strong>：</p><ul><li>我们知道mysql的数据是按照 数据页 来进行存储的，对于索引来说，同样也是 数据页 存储的。</li><li>一个数据页是 16KB，所以一个数据库能存放的元素是有限的。</li><li>在测试的时候：我们假设<ul><li><code>id</code>是 int 类型，占<code>4</code>个字节</li><li><code>name</code>是 varchar 类型，因为是不定长的，假设 name 不论写入什么，都占<code>8</code>个字节</li><li><code>age</code>是 int 类型，占<code>4</code>个字节</li><li><code>city</code>是 varchar 类型，因为是不定长的，假设 city 不论写入什么，都占<code>8</code>个字节</li><li><code>address</code>是 varchar 类型，因为是不定长的，假设 address 不论写入什么，都占<code>8</code>个字节</li></ul></li><li>正常情况下，一个数据页是16KB，我们这里假设，一个数据页只有：<code>36字节</code><ul><li>意味着：一个数据页最多能存9个id索引元素(4x9&#x3D;36)；最多能存4个city索引元素(8x4&#x3D;32)，最多能存3个 name_age 联合索引元素(12x3&#x3D;36);</li></ul></li></ul><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>我们上边介绍的<code>B+</code>树本身就是一个目录，或者说本身就是一个索引。它有两个特点：</p><ol><li><p>使用记录主键值的大小进行记录和数据页的排序，这包括三个方面的含义：</p><ul><li>数据页中的记录是按照主键的大小顺序排成一个单向链表。</li><li>各个 存放用户记录的数据页 也是 根据 数据页中用户记录的主键大小 顺序排成一个双向链表。</li><li>存放 目录项记录的数据页 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。</li></ul></li><li><p><code>B+</code>树的叶子节点存储的是完整的用户记录。</p><p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p></li></ol><p>我们把具有这两种特性的<code>B+</code>树称为<code>聚簇索引</code>，所有完整的用户记录都存放在这个<code>聚簇索引</code>的叶子节点处。这种<code>聚簇索引</code>并不需要我们在<code>MySQL</code>语句中显式的使用<code>INDEX</code>语句去创建（后边会介绍索引相关的语句），<code>InnoDB</code>存储引擎会自动的为我们创建聚簇索引。另外有趣的一点是，在<code>InnoDB</code>存储引擎中，<code>聚簇索引</code>就是数据的存储方式（所有的用户记录都存储在了<code>叶子节点</code>），也就是所谓的索引即数据，数据即索引。</p><h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><h3 id="联合索引-1"><a href="#联合索引-1" class="headerlink" title="联合索引"></a>联合索引</h3><p><code>B+</code>树按照<code>name</code>和<code>age</code>列的大小进行排序，这个包含两层含义：</p><ul><li>先把各个记录和页按照<code>name</code>列进行排序。</li><li>在记录的<code>name</code>列相同的情况下，采用<code>age</code>列进行排序</li></ul><h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><p>索引维护（更新，页分裂，页合并）</p><p>为什么我们一般在建表的时候都会创建一个自增主键，及时表中有业务唯一的id，也会创建一个自增主键？</p><p>1、因为主键只会自增，在B+树中一直都是往后写的，不会触发页分裂；但是如果删除过多的话，会触发页合并；</p><p>2、要考虑业务唯一的id的长度，比如身份证号，如果用身份证号作为主键，比直接使用整型自增的主键占用的字节数要多，这样每一个页存放的数据就会少，每个页存的数据少了，这样查询的时候，效率就会低。 同时主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</p><p>3、所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。</p><p>索引的页分裂和页合并是怎么导致的，会有什么影响？具体的分裂和合并的过程是什么样子的？</p><p>为什么mysql的b+树，在非叶子节点中，也保留了双向列表</p><p><a href="https://www.zhihu.com/question/478187330/answer/2050494617">https://www.zhihu.com/question/478187330/answer/2050494617</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mysql的索引从入门到入土&quot;&gt;&lt;a href=&quot;#mysql的索引从入门到入土&quot; class=&quot;headerlink&quot; title=&quot;mysql的索引从入门到入土&quot;&gt;&lt;/a&gt;mysql的索引从入门到入土&lt;/h1&gt;&lt;h2 id=&quot;索引的XMIND图&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="JAVA" scheme="https://zspcer.gitee.io/categories/JAVA/"/>
    
    <category term="数据库" scheme="https://zspcer.gitee.io/categories/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MYSQL" scheme="https://zspcer.gitee.io/categories/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL/"/>
    
    
    <category term="mysql" scheme="https://zspcer.gitee.io/tags/mysql/"/>
    
    <category term="索引" scheme="https://zspcer.gitee.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>mysql的性能调优从入门到入土</title>
    <link href="https://zspcer.gitee.io/note/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL/mysql%E7%9A%84%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/"/>
    <id>https://zspcer.gitee.io/note/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL/mysql%E7%9A%84%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/</id>
    <published>2023-03-15T04:24:10.513Z</published>
    <updated>2023-03-15T04:24:10.513Z</updated>
    
    <content type="html"><![CDATA[<hr><p>资料：打开</p><p>mysql的索引优化，联合索引使用的时候，时间+站点+code， 通过时间筛选之后，数据还比较多，此时效率很低。可以把所以改成：站点+时间+code，这样通过站点筛选之后的数据，就剩下很少了，此时效率很高。</p><p>事务中，行锁是在语句执行时才加上的，不是事务开始就加上，但释放是统一在事务结束时才释放。根据这个特性，对于高并发的行记录的操作语句就可以尽可能的安排到最后面，以减少锁等待的时间，提高并发性能</p><p>减少大事务，可以减少主备延迟，可以降低锁的时间，减少死锁的产生，减少死锁检测的性能消耗。</p><p>减少并发量（减少对于同一行更新的并发量），可以减少死锁的产生，可以减少死锁检测的性能消耗</p><p>在删除数据的时候尽量加 limit。这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围。</p><p>在出现IO瓶颈的时候，可以将sync_binglog设置为100-1000内的值，表示累计多少个事务之后才会刷盘，默认是1表示每一个事务都会刷盘写binlog；</p><p>在出现IO瓶颈的时候，可以设置binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count，表示提升binlog的组提交的效果，但是会增加sql的响应时间</p><p>写多读少的场景，由于 change buffer 的优化机制，因此如果业务可以接受，从性能角度出发我建议你优先考虑普通索引。</p><p>mysql要调优，就要知道它为什么慢，哪里慢</p><p>在低版本：show profiles</p><p>在高版本：performance schema</p><p>以上有什么用？</p><ul><li>比如在实际环境中，有一个sql，非常慢</li><li>sql本身没有问题，看执行计划也比较慢，这个时候就可以用到上面的</li><li>可以更加详细的看到，这个sql到底是哪里慢</li></ul><p>process list 可以查看mysql的连接数量，顺丰云上的回话连接是不是？</p><p>不过一般有druid，不用太关注这个。但是呢，druid是什么，要去看看github上面的官网了。了解一下它的优点</p><p>MRR优化，将主键ID回表的随机读，改成主键ID的顺序读，但是默认是关闭的，优化器不倾向于使用MRR，不知道为啥；MRR 能够提升性能的核心在于，这条查询语句在索引 a 上做的是一个范围查询（也就是说，这是一个多值查询），可以得到足够多的主键 id。这样通过排序以后，再去主键索引查数据，才能体现出“顺序性”的优势。</p><p>字符集和字符编码的区别</p><p>大表拆分，将不常用的数据从表里拆出去，表小了之后，每个数据页存的数据就会多，查询的时候，就会减少磁盘IO</p><p>优化：</p><ul><li>不同的数据选择对应的mysql自建数据类型，比如数字就用数字类型，不要用字符串，时间就用时间类型，不要用字符串；用错了数据类型，对业务可能没影响，但是对mysql来说，内部多了一层转换，sql执行会比较慢</li><li>事件类型，建议用date，而不是timestamp，date类型</li></ul><p>大事务不仅会影响到主库，也是造成备库复制延迟的主要原因之一。因此，在平时的开发工作中，我建议你尽量减少大事务操作，把大事务拆成小事务。</p><p>show processlist</p><ul><li><p>看到的只是当前的并发连接数，如果你的系统动不动就成千上百个连接，其实都没关系，只是占用一些内存而已</p></li><li><p>&#96;&#96;&#96;sql<br>mysql&gt; show processlist;<br>+—-+—————–+—————–+——+———+——–+————————+——————+<br>| Id | User            | Host            | db   | Command | Time   | State                  | Info             |<br>+—-+—————–+—————–+——+———+——–+————————+——————+<br>|  5 | event_scheduler | localhost       | NULL | Daemon  | 865562 | Waiting on empty queue | NULL             |<br>| 23 | root            | localhost:60179 | NULL | Query   |      0 | init                   | show processlist |<br>+—-+—————–+—————–+——+———+——–+————————+——————+<br>2 rows in set (0.00 sec)</p><pre class="line-numbers language-none"><code class="language-none">- 真正需要关注的是并发执行数，也就是并发执行的线程，因为连接存在，这个连接不一定在执行。- innodb的并发执行数，通过&#96;innodb_thread_concurrency&#96;这个参数来控制的，默认是0表示不限制。- &#96;innodb_thread_concurrency&#96;的计算规则是：正在执行的线程+1，如果一个线程在执行过程中，遇到了锁，需要等待，线程-1---# IN 查询优化这个名字还真不是我起的，今天要讲的知识点就叫**索引潜水（Index dive）**。先要从一件怪事说起：我先造点数据复现一下问题，创建一张用户表：&#96;&#96;&#96;sqlCREATE TABLE &#96;user&#96; (  &#96;id&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;主键ID&#39;,  &#96;name&#96; varchar(100) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;姓名&#39;,  &#96;age&#96; int(11) NOT NULL DEFAULT 0 COMMENT &#39;年龄&#39;,  PRIMARY KEY (&#96;id&#96;),  KEY &#96;idx_age&#96; (&#96;age&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>通过一批用户年龄，查询该年龄的用户信息，并查看一下SQL执行计划：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> age <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="mysql的性能调优从入门到入土.assets/image-20230209164837331.png" alt="image-20230209164837331" style="zoom:60%;" /><p>where条件中有9个参数，重点关注一下执行计划中的预估扫描行数为279行。</p><p>到这里没什么问题，预估的非常准，实际就是279行。</p><img src="mysql的性能调优从入门到入土.assets/image-20230209164853902.png" alt="image-20230209164853902" /><p>但是，问题来了，当我们在where条件中，再加一个参数，变成了10个参数，预估扫描行数本应该增加，结果却大大减少了。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> age <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="mysql的性能调优从入门到入土.assets/image-20230209164903103.png" alt="image-20230209164903103" /><p>一下子减少到了30行，可是实际行数是多少呢？</p><img src="mysql的性能调优从入门到入土.assets/image-20230209164911034.png" alt="image-20230209164911034" /><p>实际是310行，预估扫描行数是30行，真是错到姥姥家了。</p><p><strong>MySQL咋回事啊，到底还能不能预估？</strong></p><p><strong>不能预估的话，换其他人！</strong></p><p>大家肯定也是满脸疑惑，直到我去官网上看到了一个词语，<strong>索引潜水（Index dive）</strong>。</p><p>跟这个词语相关的，还有一个配置参数 <strong>eq_range_index_dive_limit</strong>。</p><p><strong>MySQL5.7.3</strong>之前的版本，这个值默认是10，之后的版本，这个值默认是200。</p><p>可以使用命令查看一下这个值的大小：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'%eq_range_index_dive_limit%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="mysql的性能调优从入门到入土.assets/image-20230209164922082.png" alt="image-20230209164922082" /><p>当然，我们也可以手动修改这个值的大小：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">set</span> eq_range_index_dive_limit<span class="token operator">=</span><span class="token number">200</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个 <strong>eq_range_index_dive_limit</strong> 配置的作用就是：</p><p>当where语句in条件中参数个数小于这个值的时候，MySQL就采用<strong>索引潜水（Index dive）</strong>的方式预估扫描行数，非常准确。</p><p>当where语句in条件中参数个数大于等于这个值的时候，MySQL就采用另一种方式<strong>索引统计（Index statistics）</strong>预估扫描行数，误差较大。</p><p><strong>MySQL为什么要这么做呢？</strong></p><p>都用<strong>索引潜水（Index dive）</strong>的方式预估扫描行数，不好吗？</p><p>其实这是基于成本的考虑，<strong>索引潜水</strong>估算成本较高，适合小数据量。<strong>索引统计</strong>估算成本较低，适合大数据量。</p><p>一般情况下，我们的where语句的in条件的参数不会太多，适合使用<strong>索引潜水</strong>预估扫描行数。</p><p>建议还在使用<strong>MySQL5.7.3</strong>之前版本的同学们，手动修改一下<strong>索引潜水</strong>的配置参数，改成合适的数值。</p><p>如果你们项目中in条件最多有500个参数，就把配置参数改成501。</p><p>这样MySQL预估扫描行数更准确，可以选择更合适的索引。</p><hr><h2 id="performance-schema详解"><a href="#performance-schema详解" class="headerlink" title="performance schema详解"></a>performance schema详解</h2><h3 id="performance-schema的介绍"><a href="#performance-schema的介绍" class="headerlink" title="performance_schema的介绍"></a>performance_schema的介绍</h3><p>MySQL的performance schema 用于监控MySQL server在一个较低级别的运行过程中的资源消耗、资源等待等情况。</p><p>特点如下：</p><ul><li><p>提供了一种在数据库运行时实时检查server的内部执行情况的方法</p><ul><li><p>performance_schema 数据库中的表使用PERFORMANCE_SCHEMA存储引擎。</p></li><li><p>performance_schema 数据库主要关注数据库运行过程中的性能相关的数据</p></li><li><p>information_schema 数据库主要关注server运行过程中的元数据信息</p></li></ul></li><li><p>performance_schema 通过监视server的事件来实现监视server内部运行情况，</p><ul><li><p>“事件”：就是server内部活动中所做的任何事情以及对应的时间消耗（比如函数调用、操作系统的等待、SQL语句执行的阶段）</p></li><li><p>performance_schema中的事件与binlog中的记录的事件不同</p><ul><li>binlog中的事件是：描述数据修改的events</li><li>performance_schema中的事件是：计划调度程序（这是一种存储程序）的事件</li></ul></li><li><p>performance_schema中的事件记录的是：server执行某些活动对某些资源的消耗、耗时、这些活动执行的次数等情况。</p></li><li><p>performance_schema中的事件只记录在本地server的performance_schema中，不会被写入binlog中，也不会被复制到其他server中。</p></li><li><p>performance_schema的表中的数据不会持久化存储在磁盘中，而是保存在内存中，一旦服务器重启，这些数据会丢失</p></li></ul></li></ul><h3 id="performance-schema入门"><a href="#performance-schema入门" class="headerlink" title="performance schema入门"></a>performance schema入门</h3><p>在mysql的5.7版本中，性能模式是默认开启的，如果想要显式的关闭的话需要修改配置文件，不能直接进行修改，会报错Variable ‘performance_schema’ is a read only variable。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 查看performance_schema的属性</span>mysql<span class="token operator">></span> <span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'performance_schema'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------------------+-------+</span><span class="token operator">|</span> Variable_name      <span class="token operator">|</span> <span class="token keyword">Value</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------------+-------+</span><span class="token operator">|</span> performance_schema <span class="token operator">|</span> <span class="token keyword">ON</span>    <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------------+-------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span><span class="token comment">-- 在配置文件中修改performance_schema的属性值，on表示开启，off表示关闭</span><span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span>performance_schema<span class="token operator">=</span><span class="token keyword">ON</span><span class="token comment">-- 切换数据库</span><span class="token keyword">use</span> performance_schema<span class="token punctuation">;</span><span class="token comment">-- 查看当前数据库下的所有表,会看到有很多表存储着相关的信息</span><span class="token keyword">show</span> <span class="token keyword">tables</span><span class="token punctuation">;</span><span class="token comment">-- 可以通过show create table tablename来查看创建表的时候的表结构</span>mysql<span class="token operator">></span> <span class="token keyword">show</span> <span class="token keyword">create</span> <span class="token keyword">table</span> setup_consumers<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">-----------------+---------------------------------</span><span class="token operator">|</span> <span class="token keyword">Table</span>           <span class="token operator">|</span> <span class="token keyword">Create</span> <span class="token keyword">Table</span>                    <span class="token operator">+</span><span class="token comment">-----------------+---------------------------------</span><span class="token operator">|</span> setup_consumers <span class="token operator">|</span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>setup_consumers<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>NAME<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>                        <span class="token identifier"><span class="token punctuation">`</span>ENABLED<span class="token punctuation">`</span></span> <span class="token keyword">enum</span><span class="token punctuation">(</span><span class="token string">'YES'</span><span class="token punctuation">,</span><span class="token string">'NO'</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>               <span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span>PERFORMANCE_SCHEMA <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8 <span class="token operator">|</span>  <span class="token operator">+</span><span class="token comment">-----------------+---------------------------------</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>                             <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><p>想要搞明白后续的内容，同学们需要理解两个基本概念：</p><ul><li>instruments: 生产者，用于采集mysql中各种各样的操作产生的事件信息，对应配置表中的配置项我们可以称为监控采集配置项。</li><li>consumers: 消费者，对应的消费者表用于存储来自instruments采集的数据，对应配置表中的配置项我们可以称为消费存储配置项。</li></ul><h3 id="performance-schema表的分类"><a href="#performance-schema表的分类" class="headerlink" title="performance_schema表的分类"></a>performance_schema表的分类</h3><p>performance_schema库下的表可以按照监视纬度的不同进行分组。</p><h4 id="语句事件记录表"><a href="#语句事件记录表" class="headerlink" title="语句事件记录表"></a>语句事件记录表</h4><p>语句事件记录表，这些表记录了语句事件信息，当前语句事件表events_statements_current、历史语句事件表events_statements_history和长语句历史事件表events_statements_history_long、以及聚合后的摘要表summary，其中，summary表还可以根据帐号(account)，主机(host)，程序(program)，线程(thread)，用户(user)和全局(global)再进行细分)</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">tables</span> <span class="token operator">like</span> <span class="token string">'%statement%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="等待事件记录表"><a href="#等待事件记录表" class="headerlink" title="等待事件记录表"></a>等待事件记录表</h4><p>等待事件记录表，与语句事件类型的相关记录表类似：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">tables</span> <span class="token operator">like</span> <span class="token string">'%wait%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="阶段事件记录表"><a href="#阶段事件记录表" class="headerlink" title="阶段事件记录表"></a>阶段事件记录表</h4><p>阶段事件记录表，记录语句执行的阶段事件的表</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">tables</span> <span class="token operator">like</span> <span class="token string">'%stage%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="事务事件记录表"><a href="#事务事件记录表" class="headerlink" title="事务事件记录表"></a>事务事件记录表</h4><p>事务事件记录表，记录事务相关的事件的表</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">tables</span> <span class="token operator">like</span> <span class="token string">'%transaction%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="监控文件系统层调用的表"><a href="#监控文件系统层调用的表" class="headerlink" title="监控文件系统层调用的表"></a>监控文件系统层调用的表</h4><p>监控文件系统层调用的表</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">tables</span> <span class="token operator">like</span> <span class="token string">'%file%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="监视内存使用的表"><a href="#监视内存使用的表" class="headerlink" title="监视内存使用的表"></a>监视内存使用的表</h4><p>监视内存使用的表</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">tables</span> <span class="token operator">like</span> <span class="token string">'%memory%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="配置表"><a href="#配置表" class="headerlink" title="配置表"></a>配置表</h4><p>动态对performance_schema进行配置的配置表</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">tables</span> <span class="token operator">like</span> <span class="token string">'%setup%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="performance-schema的简单配置与使用"><a href="#performance-schema的简单配置与使用" class="headerlink" title="performance_schema的简单配置与使用"></a>performance_schema的简单配置与使用</h3><p>数据库刚刚初始化并启动时，并非所有instruments(事件采集项，在采集项的配置表中每一项都有一个开关字段，或为YES，或为NO)和consumers(与采集项类似，也有一个对应的事件类型保存表配置项，为YES就表示对应的表保存性能数据，为NO就表示对应的表不保存性能数据)都启用了，所以默认不会收集所有的事件，可能你需要检测的事件并没有打开，需要进行设置，可以使用如下两个语句打开对应的instruments和consumers（行计数可能会因MySQL版本而异)。</p><h4 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 打开等待事件的采集器配置项开关，需要修改setup_instruments配置表中对应的采集器配置项</span><span class="token keyword">UPDATE</span> setup_instruments <span class="token keyword">SET</span> ENABLED <span class="token operator">=</span> <span class="token string">'YES'</span><span class="token punctuation">,</span> TIMED <span class="token operator">=</span> <span class="token string">'YES'</span><span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">'wait%'</span><span class="token punctuation">;</span><span class="token comment">-- 打开等待事件的保存表配置开关，修改setup_consumers配置表中对应的配置项</span><span class="token keyword">UPDATE</span> setup_consumers <span class="token keyword">SET</span> ENABLED <span class="token operator">=</span> <span class="token string">'YES'</span><span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">'%wait%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查看当前server正在做什么"><a href="#查看当前server正在做什么" class="headerlink" title="查看当前server正在做什么"></a>查看当前server正在做什么</h4><p>当配置完成之后可以查看当前server正在做什么，可以通过查询events_waits_current表来得知，该表中每个线程只包含一行数据，用于显示每个线程的最新监视事件</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> events_waits_current\G<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">1.</span> <span class="token keyword">row</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>            THREAD_ID: <span class="token number">11</span>             EVENT_ID: <span class="token number">570</span>         END_EVENT_ID: <span class="token number">570</span>           EVENT_NAME: wait<span class="token operator">/</span>synch<span class="token operator">/</span>mutex<span class="token operator">/</span><span class="token keyword">innodb</span><span class="token operator">/</span>buf_dblwr_mutex               SOURCE:           TIMER_START: <span class="token number">4508505105239280</span>            TIMER_END: <span class="token number">4508505105270160</span>           TIMER_WAIT: <span class="token number">30880</span>                SPINS: <span class="token boolean">NULL</span>        OBJECT_SCHEMA: <span class="token boolean">NULL</span>          OBJECT_NAME: <span class="token boolean">NULL</span>           INDEX_NAME: <span class="token boolean">NULL</span>          OBJECT_TYPE: <span class="token boolean">NULL</span>OBJECT_INSTANCE_BEGIN: <span class="token number">67918392</span>     NESTING_EVENT_ID: <span class="token boolean">NULL</span>   NESTING_EVENT_TYPE: <span class="token boolean">NULL</span>            OPERATION: <span class="token keyword">lock</span>      NUMBER_OF_BYTES: <span class="token boolean">NULL</span>                FLAGS: <span class="token boolean">NULL</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该信息表示线程id为11的线程正在等待buf_dblwr_mutex锁，等待事件为30880<br>属性说明：</p><ul><li>id:事件来自哪个线程，事件编号是多少</li><li>event_name:表示检测到的具体的内容</li><li>source:表示这个检测代码在哪个源文件中以及行号</li><li>timer_start:表示该事件的开始时间</li><li>timer_end:表示该事件的结束时间</li><li>timer_wait:表示该事件总的花费时间</li></ul><p>注意：_current表中每个线程只保留一条记录，一旦线程完成工作，该表中不会再记录该线程的事件信息</p><h4 id="查看每个线程已经执行完成的事件信息"><a href="#查看每个线程已经执行完成的事件信息" class="headerlink" title="查看每个线程已经执行完成的事件信息"></a>查看每个线程已经执行完成的事件信息</h4><p>_history表中记录每个线程应该执行完成的事件信息，但每个线程的事件信息只会记录10条，再多就会被覆盖，*_history_long表中记录所有线程的事件信息，但总记录数量是10000，超过就会被覆盖掉</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> thread_id<span class="token punctuation">,</span>event_id<span class="token punctuation">,</span>event_name<span class="token punctuation">,</span>timer_wait <span class="token keyword">from</span> events_waits_history <span class="token keyword">order</span> <span class="token keyword">by</span> thread_id <span class="token keyword">limit</span> <span class="token number">21</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="查看事件的汇总信息"><a href="#查看事件的汇总信息" class="headerlink" title="查看事件的汇总信息"></a>查看事件的汇总信息</h4><p>summary表提供所有事件的汇总信息，该组中的表以不同的方式汇总事件数据（如：按用户，按主机，按线程等等）。例如：要查看哪些instruments占用最多的时间，可以通过对events_waits_summary_global_by_event_name表的COUNT_STAR或SUM_TIMER_WAIT列进行查询（这两列是对事件的记录数执行COUNT（*）、事件记录的TIMER_WAIT列执行SUM（TIMER_WAIT）统计而来）</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> EVENT_NAME<span class="token punctuation">,</span>COUNT_STAR <span class="token keyword">FROM</span> events_waits_summary_global_by_event_name  <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> COUNT_STAR <span class="token keyword">DESC</span> <span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="查看被检测的对象"><a href="#查看被检测的对象" class="headerlink" title="查看被检测的对象"></a>查看被检测的对象</h4><p>instance表记录了哪些类型的对象会被检测。这些对象在被server使用时，在该表中将会产生一条事件记录，例如，file_instances表列出了文件I&#x2F;O操作及其关联文件名</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> file_instances <span class="token keyword">limit</span> <span class="token number">20</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="常用配置项的参数说明"><a href="#常用配置项的参数说明" class="headerlink" title="常用配置项的参数说明"></a>常用配置项的参数说明</h3><h4 id="启动选项"><a href="#启动选项" class="headerlink" title="启动选项"></a>启动选项</h4><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>performance_schema_consumer_events_statements_current&#x3D;TRUE</td><td>是否在mysql server启动时就开启events_statements_current表的记录功能(该表记录当前的语句事件信息)，启动之后也可以在setup_consumers表中使用UPDATE语句进行动态更新setup_consumers配置表中的events_statements_current配置项，默认值为TRUE</td></tr><tr><td>performance_schema_consumer_events_statements_history&#x3D;TRUE</td><td>与performance_schema_consumer_events_statements_current选项类似，但该选项是用于配置是否记录语句事件短历史信息，默认为TRUE</td></tr><tr><td>performance_schema_consumer_events_stages_history_long&#x3D;FALSE</td><td>与performance_schema_consumer_events_statements_current选项类似，但该选项是用于配置是否记录语句事件长历史信息，默认为FALSE</td></tr><tr><td>*</td><td>除了statement(语句)事件之外，还支持：wait(等待)事件、state(阶段)事件、transaction(事务)事件，他们与statement事件一样都有三个启动项分别进行配置，但这些等待事件默认未启用，如果需要在MySQL Server启动时一同启动，则通常需要写进my.cnf配置文件中</td></tr><tr><td>performance_schema_consumer_global_instrumentation&#x3D;TRUE</td><td>是否在MySQL Server启动时就开启全局表（如：mutex_instances、rwlock_instances、cond_instances、file_instances、users、hostsaccounts、socket_summary_by_event_name、file_summary_by_instance等大部分的全局对象计数统计和事件汇总统计信息表 ）的记录功能，启动之后也可以在setup_consumers表中使用UPDATE语句进行动态更新全局配置项<br/>默认值为TRUE</td></tr><tr><td>performance_schema_consumer_statements_digest&#x3D;TRUE</td><td>是否在MySQL Server启动时就开启events_statements_summary_by_digest 表的记录功能，启动之后也可以在setup_consumers表中使用UPDATE语句进行动态更新digest配置项<br/>默认值为TRUE</td></tr><tr><td>performance_schema_consumer_thread_instrumentation&#x3D;TRUE</td><td>是否在MySQL Server启动时就开启events_xxx_summary_by_yyy_by_event_name表的记录功能，启动之后也可以在setup_consumers表中使用UPDATE语句进行动态更新线程配置项<br/>默认值为TRUE</td></tr><tr><td>performance_schema_instrument[&#x3D;name]</td><td>是否在MySQL Server启动时就启用某些采集器，由于instruments配置项多达数千个，所以该配置项支持key-value模式，还支持%号进行通配等</td></tr></tbody></table><p>注意，这些启动选项要生效的前提是，需要设置performance_schema&#x3D;ON。另外，这些启动选项虽然无法使用show variables语句查看，但我们可以通过setup_instruments和setup_consumers表查询这些选项指定的值。</p><h4 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'%performance_schema%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重要的属性解释</p><table><thead><tr><th>属性</th><th>解释</th></tr></thead><tbody><tr><td>performance_schema&#x3D;ON</td><td>控制performance_schema功能的开关，要使用MySQL的performance_schema，需要在mysqld启动时启用，以启用事件收集功能<br/>该参数在5.7.x之前支持performance_schema的版本中默认关闭，5.7.x版本开始默认开启<br/>注意：如果mysqld在初始化performance_schema时发现无法分配任何相关的内部缓冲区，则performance_schema将自动禁用，并将performance_schema设置为OFF</td></tr><tr><td>performance_schema_digests_size&#x3D;10000</td><td>控制events_statements_summary_by_digest表中的最大行数。如果产生的语句摘要信息超过此最大值，便无法继续存入该表，此时performance_schema会增加状态变量</td></tr><tr><td>performance_schema_events_statements_history_long_size&#x3D;10000</td><td>控制events_statements_history_long表中的最大行数，该参数控制所有会话在events_statements_history_long表中能够存放的总事件记录数，超过这个限制之后，最早的记录将被覆盖</td></tr><tr><td>performance_schema_events_statements_history_size&#x3D;10</td><td>控制events_statements_history表中单个线程（会话）的最大行数，该参数控制单个会话在events_statements_history表中能够存放的事件记录数，超过这个限制之后，单个会话最早的记录将被覆盖</td></tr><tr><td>performance_schema_max_digest_length&#x3D;1024</td><td>用于控制标准化形式的SQL语句文本在存入performance_schema时的限制长度，该变量与max_digest_length变量相关(max_digest_length变量含义请自行查阅相关资料)<br/>全局变量，只读变量，默认值1024字节，整型值，取值范围0~1048576</td></tr><tr><td>performance_schema_max_sql_text_length&#x3D;1024</td><td>控制存入events_statements_current，events_statements_history和events_statements_history_long语句事件表中的SQL_TEXT列的最大SQL长度字节数。 超出系统变量performance_schema_max_sql_text_length的部分将被丢弃，不会记录，一般情况下不需要调整该参数，除非被截断的部分与其他SQL比起来有很大差异<br/>全局变量，只读变量，整型值，默认值为1024字节，取值范围为0~1048576，5.7.6版本引入<br/>降低系统变量performance_schema_max_sql_text_length值可以减少内存使用，但如果汇总的SQL中，被截断部分有较大差异，会导致没有办法再对这些有较大差异的SQL进行区分。 增加该系统变量值会增加内存使用，但对于汇总SQL来讲可以更精准地区分不同的部分。</td></tr></tbody></table><h3 id="重要配置表的相关说明"><a href="#重要配置表的相关说明" class="headerlink" title="重要配置表的相关说明"></a>重要配置表的相关说明</h3><p>配置表之间存在相互关联关系</p><h4 id="performance-timers表"><a href="#performance-timers表" class="headerlink" title="performance_timers表"></a>performance_timers表</h4><p>performance_timers表中记录了server中有哪些可用的事件计时器</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> performance_timers<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>timer_name</td><td>表示可用计时器名称，CYCLE是基于CPU周期计数器的定时器</td></tr><tr><td>timer_frequency</td><td>表示每秒钟对应的计时器单位的数量,CYCLE计时器的换算值与CPU的频率相关</td></tr><tr><td>timer_resolution</td><td>计时器精度值，表示在每个计时器被调用时额外增加的值</td></tr><tr><td>timer_overhead</td><td>表示在使用定时器获取事件时开销的最小周期值</td></tr></tbody></table><h4 id="setup-timers表"><a href="#setup-timers表" class="headerlink" title="setup_timers表"></a>setup_timers表</h4><p>setup_timers表中记录当前使用的事件计时器信息</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> setup_timers<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>name</td><td>计时器类型，对应某个事件类别</td></tr><tr><td>timer_name</td><td>计时器类型名称</td></tr></tbody></table><h4 id="setup-consumers表"><a href="#setup-consumers表" class="headerlink" title="setup_consumers表"></a>setup_consumers表</h4><p>setup_consumers表中列出了consumers可配置列表项</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> setup_consumers<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>NAME</td><td>consumers配置名称</td></tr><tr><td>ENABLED</td><td>consumers是否启用，有效值为YES或NO，此列可以使用UPDATE语句修改。</td></tr></tbody></table><h4 id="setup-instruments-表"><a href="#setup-instruments-表" class="headerlink" title="setup_instruments 表"></a>setup_instruments 表</h4><p>setup_instruments 表列出了instruments 列表配置项，即代表了哪些事件支持被收集：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> setup_instruments<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>NAME</td><td>instruments名称，instruments名称可能具有多个部分并形成层次结构</td></tr><tr><td>ENABLED</td><td>instrumetns是否启用，有效值为YES或NO，此列可以使用UPDATE语句修改。如果设置为NO，则这个instruments不会被执行，不会产生任何的事件信息</td></tr><tr><td>TIMED</td><td>instruments是否收集时间信息，有效值为YES或NO，此列可以使用UPDATE语句修改，如果设置为NO，则这个instruments不会收集时间信息</td></tr></tbody></table><h4 id="setup-actors表"><a href="#setup-actors表" class="headerlink" title="setup_actors表"></a>setup_actors表</h4><p>setup_actors表的初始内容是匹配任何用户和主机，因此对于所有前台线程，默认情况下启用监视和历史事件收集功能</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> setup_actors<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>HOST</td><td>与grant语句类似的主机名，一个具体的字符串名字，或使用“％”表示“任何主机”</td></tr><tr><td>USER</td><td>一个具体的字符串名称，或使用“％”表示“任何用户”</td></tr><tr><td>ROLE</td><td>当前未使用，MySQL 8.0中才启用角色功能</td></tr><tr><td>ENABLED</td><td>是否启用与HOST，USER，ROLE匹配的前台线程的监控功能，有效值为：YES或NO</td></tr><tr><td>HISTORY</td><td>是否启用与HOST， USER，ROLE匹配的前台线程的历史事件记录功能，有效值为：YES或NO</td></tr></tbody></table><h4 id="setup-objects表"><a href="#setup-objects表" class="headerlink" title="setup_objects表"></a>setup_objects表</h4><p>setup_objects表控制performance_schema是否监视特定对象。默认情况下，此表的最大行数为100行。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> setup_objects<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>OBJECT_TYPE</td><td>instruments类型，有效值为：“EVENT”（事件调度器事件）、“FUNCTION”（存储函数）、“PROCEDURE”（存储过程）、“TABLE”（基表）、“TRIGGER”（触发器），TABLE对象类型的配置会影响表I&#x2F;O事件（wait&#x2F;io&#x2F;table&#x2F;sql&#x2F;handler instrument）和表锁事件（wait&#x2F;lock&#x2F;table&#x2F;sql&#x2F;handler instrument）的收集</td></tr><tr><td>OBJECT_SCHEMA</td><td>某个监视类型对象涵盖的数据库名称，一个字符串名称，或“％”(表示“任何数据库”)</td></tr><tr><td>OBJECT_NAME</td><td>某个监视类型对象涵盖的表名，一个字符串名称，或“％”(表示“任何数据库内的对象”)</td></tr><tr><td>ENABLED</td><td>是否开启对某个类型对象的监视功能，有效值为：YES或NO。此列可以修改</td></tr><tr><td>TIMED</td><td></td></tr></tbody></table><h4 id="threads表"><a href="#threads表" class="headerlink" title="threads表"></a>threads表</h4><p>threads表对于每个server线程生成一行包含线程相关的信息，</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> threads<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>THREAD_ID</td><td>线程的唯一标识符（ID）</td></tr><tr><td>NAME</td><td>与server中的线程检测代码相关联的名称(注意，这里不是instruments名称)</td></tr><tr><td>TYPE</td><td>线程类型，有效值为：FOREGROUND、BACKGROUND。分别表示前台线程和后台线程</td></tr><tr><td>PROCESSLIST_ID</td><td>对应INFORMATION_SCHEMA.PROCESSLIST表中的ID列</td></tr><tr><td>PROCESSLIST_USER</td><td>与前台线程相关联的用户名，对于后台线程为NULL</td></tr><tr><td>PROCESSLIST_HOST</td><td>与前台线程关联的客户端的主机名，对于后台线程为NULL</td></tr><tr><td>PROCESSLIST_DB</td><td>线程的默认数据库，如果没有，则为NULL</td></tr><tr><td>PROCESSLIST_COMMAND</td><td>对于前台线程，该值代表着当前客户端正在执行的command类型，如果是sleep则表示当前会话处于空闲状态</td></tr><tr><td>PROCESSLIST_TIME</td><td>当前线程已处于当前线程状态的持续时间（秒）</td></tr><tr><td>PROCESSLIST_STATE</td><td>表示线程正在做什么事情</td></tr><tr><td>PROCESSLIST_INFO</td><td>线程正在执行的语句，如果没有执行任何语句，则为NULL</td></tr><tr><td>PARENT_THREAD_ID</td><td>如果这个线程是一个子线程（由另一个线程生成），那么该字段显示其父线程ID</td></tr><tr><td>ROLE</td><td>暂未使用</td></tr><tr><td>INSTRUMENTED</td><td>线程执行的事件是否被检测。有效值：YES、NO</td></tr><tr><td>HISTORY</td><td>是否记录线程的历史事件。有效值：YES、NO</td></tr><tr><td>THREAD_OS_ID</td><td>由操作系统层定义的线程或任务标识符（ID）</td></tr></tbody></table><p>注意：在performance_schema库中还包含了很多其他的库和表，能对数据库的性能做完整的监控，大家需要参考官网详细了解。</p><h3 id="performance-schema实践操作"><a href="#performance-schema实践操作" class="headerlink" title="performance_schema实践操作"></a>performance_schema实践操作</h3><p>基本了解了表的相关信息之后，可以通过这些表进行实际的查询操作来进行实际的分析。</p><h4 id="哪类的SQL执行最多？"><a href="#哪类的SQL执行最多？" class="headerlink" title="哪类的SQL执行最多？"></a>哪类的SQL执行最多？</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> DIGEST_TEXT<span class="token punctuation">,</span>COUNT_STAR<span class="token punctuation">,</span>FIRST_SEEN<span class="token punctuation">,</span>LAST_SEEN <span class="token keyword">FROM</span> events_statements_summary_by_digest <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> COUNT_STAR <span class="token keyword">DESC</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="哪类SQL的平均响应时间最多？"><a href="#哪类SQL的平均响应时间最多？" class="headerlink" title="哪类SQL的平均响应时间最多？"></a>哪类SQL的平均响应时间最多？</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> DIGEST_TEXT<span class="token punctuation">,</span>AVG_TIMER_WAIT <span class="token keyword">FROM</span> events_statements_summary_by_digest <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> COUNT_STAR <span class="token keyword">DESC</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="哪类SQL排序记录数最多？"><a href="#哪类SQL排序记录数最多？" class="headerlink" title="哪类SQL排序记录数最多？"></a>哪类SQL排序记录数最多？</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> DIGEST_TEXT<span class="token punctuation">,</span>SUM_SORT_ROWS <span class="token keyword">FROM</span> events_statements_summary_by_digest <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> COUNT_STAR <span class="token keyword">DESC</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="哪类SQL扫描记录数最多？"><a href="#哪类SQL扫描记录数最多？" class="headerlink" title="哪类SQL扫描记录数最多？"></a>哪类SQL扫描记录数最多？</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> DIGEST_TEXT<span class="token punctuation">,</span>SUM_ROWS_EXAMINED <span class="token keyword">FROM</span> events_statements_summary_by_digest <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> COUNT_STAR <span class="token keyword">DESC</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="哪类SQL使用临时表最多？"><a href="#哪类SQL使用临时表最多？" class="headerlink" title="哪类SQL使用临时表最多？"></a>哪类SQL使用临时表最多？</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> DIGEST_TEXT<span class="token punctuation">,</span>SUM_CREATED_TMP_TABLES<span class="token punctuation">,</span>SUM_CREATED_TMP_DISK_TABLES <span class="token keyword">FROM</span> events_statements_summary_by_digest <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> COUNT_STAR <span class="token keyword">DESC</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="哪类SQL返回结果集最多？"><a href="#哪类SQL返回结果集最多？" class="headerlink" title="哪类SQL返回结果集最多？"></a>哪类SQL返回结果集最多？</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> DIGEST_TEXT<span class="token punctuation">,</span>SUM_ROWS_SENT <span class="token keyword">FROM</span> events_statements_summary_by_digest <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> COUNT_STAR <span class="token keyword">DESC</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="哪个表物理IO最多？"><a href="#哪个表物理IO最多？" class="headerlink" title="哪个表物理IO最多？"></a>哪个表物理IO最多？</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> file_name<span class="token punctuation">,</span>event_name<span class="token punctuation">,</span>SUM_NUMBER_OF_BYTES_READ<span class="token punctuation">,</span>SUM_NUMBER_OF_BYTES_WRITE <span class="token keyword">FROM</span> file_summary_by_instance <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> SUM_NUMBER_OF_BYTES_READ <span class="token operator">+</span> SUM_NUMBER_OF_BYTES_WRITE <span class="token keyword">DESC</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="哪个表逻辑IO最多？"><a href="#哪个表逻辑IO最多？" class="headerlink" title="哪个表逻辑IO最多？"></a>哪个表逻辑IO最多？</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> object_name<span class="token punctuation">,</span>COUNT_READ<span class="token punctuation">,</span>COUNT_WRITE<span class="token punctuation">,</span>COUNT_FETCH<span class="token punctuation">,</span>SUM_TIMER_WAIT <span class="token keyword">FROM</span> table_io_waits_summary_by_table <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> sum_timer_wait <span class="token keyword">DESC</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="哪个索引访问最多？"><a href="#哪个索引访问最多？" class="headerlink" title="哪个索引访问最多？"></a>哪个索引访问最多？</h5><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> OBJECT_NAME<span class="token punctuation">,</span>INDEX_NAME<span class="token punctuation">,</span>COUNT_FETCH<span class="token punctuation">,</span>COUNT_INSERT<span class="token punctuation">,</span>COUNT_UPDATE<span class="token punctuation">,</span>COUNT_DELETE <span class="token keyword">FROM</span> table_io_waits_summary_by_index_usage <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> SUM_TIMER_WAIT <span class="token keyword">DESC</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="哪个索引从来没有用过？"><a href="#哪个索引从来没有用过？" class="headerlink" title="哪个索引从来没有用过？"></a>哪个索引从来没有用过？</h5><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> OBJECT_SCHEMA<span class="token punctuation">,</span>OBJECT_NAME<span class="token punctuation">,</span>INDEX_NAME <span class="token keyword">FROM</span> table_io_waits_summary_by_index_usage <span class="token keyword">WHERE</span> INDEX_NAME <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token operator">AND</span> COUNT_STAR <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">AND</span> OBJECT_SCHEMA <span class="token operator">&lt;></span> <span class="token string">'mysql'</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> OBJECT_SCHEMA<span class="token punctuation">,</span>OBJECT_NAME<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="哪个等待事件消耗时间最多？"><a href="#哪个等待事件消耗时间最多？" class="headerlink" title="哪个等待事件消耗时间最多？"></a>哪个等待事件消耗时间最多？</h5><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> EVENT_NAME<span class="token punctuation">,</span>COUNT_STAR<span class="token punctuation">,</span>SUM_TIMER_WAIT<span class="token punctuation">,</span>AVG_TIMER_WAIT <span class="token keyword">FROM</span> events_waits_summary_global_by_event_name <span class="token keyword">WHERE</span> event_name <span class="token operator">!=</span> <span class="token string">'idle'</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> SUM_TIMER_WAIT <span class="token keyword">DESC</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="剖析某条SQL的执行情况，包括statement信息，stege信息，wait信息"><a href="#剖析某条SQL的执行情况，包括statement信息，stege信息，wait信息" class="headerlink" title="剖析某条SQL的执行情况，包括statement信息，stege信息，wait信息"></a>剖析某条SQL的执行情况，包括statement信息，stege信息，wait信息</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> EVENT_ID<span class="token punctuation">,</span>sql_text <span class="token keyword">FROM</span> events_statements_history <span class="token keyword">WHERE</span> sql_text <span class="token operator">LIKE</span> <span class="token string">'%count(*)%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="查看每个阶段的时间消耗"><a href="#查看每个阶段的时间消耗" class="headerlink" title="查看每个阶段的时间消耗"></a>查看每个阶段的时间消耗</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> event_id<span class="token punctuation">,</span>EVENT_NAME<span class="token punctuation">,</span>SOURCE<span class="token punctuation">,</span>TIMER_END <span class="token operator">-</span> TIMER_START <span class="token keyword">FROM</span> events_stages_history_long <span class="token keyword">WHERE</span> NESTING_EVENT_ID <span class="token operator">=</span> <span class="token number">1553</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="查看每个阶段的锁等待情况"><a href="#查看每个阶段的锁等待情况" class="headerlink" title="查看每个阶段的锁等待情况"></a>查看每个阶段的锁等待情况</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> event_id<span class="token punctuation">,</span>event_name<span class="token punctuation">,</span>source<span class="token punctuation">,</span>timer_wait<span class="token punctuation">,</span>object_name<span class="token punctuation">,</span>index_name<span class="token punctuation">,</span>operation<span class="token punctuation">,</span>nesting_event_id <span class="token keyword">FROM</span> events_waits_history_long <span class="token keyword">WHERE</span> nesting_event_id <span class="token operator">=</span> <span class="token number">1553</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="看懂mysql执行计划"><a href="#看懂mysql执行计划" class="headerlink" title="看懂mysql执行计划"></a>看懂mysql执行计划</h2><p>​       在企业的应用场景中，为了知道优化SQL语句的执行，需要查看SQL语句的具体执行过程，以加快SQL语句的执行效率。</p><p>​       可以使用explain+SQL语句来模拟优化器执行SQL查询语句，从而知道mysql是如何处理sql语句的。</p><p>​   官网地址： <a href="https://dev.mysql.com/doc/refman/5.5/en/explain-output.html">https://dev.mysql.com/doc/refman/5.5/en/explain-output.html</a> </p><h3 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">/*Navicat MySQL Data TransferSource Server         : mybatisSource Server Version : 50722Source Host           : localhost:3306Source Database       : dempTarget Server Type    : MYSQLTarget Server Version : 50722File Encoding         : 65001Date: 2020-02-11 20:05:02*/</span><span class="token keyword">SET</span> FOREIGN_KEY_CHECKS<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">-- ----------------------------</span><span class="token comment">-- Table structure for dept</span><span class="token comment">-- ----------------------------</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token identifier"><span class="token punctuation">`</span>dept<span class="token punctuation">`</span></span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>dept<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>DEPTNO<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>DNAME<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>LOC<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>DEPTNO<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span class="token comment">-- ----------------------------</span><span class="token comment">-- Records of dept</span><span class="token comment">-- ----------------------------</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>dept<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'10'</span><span class="token punctuation">,</span> <span class="token string">'ACCOUNTING'</span><span class="token punctuation">,</span> <span class="token string">'NEW YORK'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>dept<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'20'</span><span class="token punctuation">,</span> <span class="token string">'RESEARCH'</span><span class="token punctuation">,</span> <span class="token string">'DALLAS'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>dept<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'30'</span><span class="token punctuation">,</span> <span class="token string">'SALES'</span><span class="token punctuation">,</span> <span class="token string">'CHICAGO'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>dept<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'40'</span><span class="token punctuation">,</span> <span class="token string">'OPERATIONS'</span><span class="token punctuation">,</span> <span class="token string">'BOSTON'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- ----------------------------</span><span class="token comment">-- Table structure for emp</span><span class="token comment">-- ----------------------------</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token identifier"><span class="token punctuation">`</span>emp<span class="token punctuation">`</span></span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>emp<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>EMPNO<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>ENAME<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>JOB<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>MGR<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>HIREDATE<span class="token punctuation">`</span></span> <span class="token keyword">date</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>SAL<span class="token punctuation">`</span></span> <span class="token keyword">double</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>COMM<span class="token punctuation">`</span></span> <span class="token keyword">double</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>DEPTNO<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>EMPNO<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span class="token comment">-- ----------------------------</span><span class="token comment">-- Records of emp</span><span class="token comment">-- ----------------------------</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>emp<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'7369'</span><span class="token punctuation">,</span> <span class="token string">'SMITH'</span><span class="token punctuation">,</span> <span class="token string">'CLERK'</span><span class="token punctuation">,</span> <span class="token string">'7902'</span><span class="token punctuation">,</span> <span class="token string">'1980-12-17'</span><span class="token punctuation">,</span> <span class="token string">'800.00'</span><span class="token punctuation">,</span> <span class="token boolean">null</span><span class="token punctuation">,</span> <span class="token string">'20'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>emp<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'7499'</span><span class="token punctuation">,</span> <span class="token string">'ALLEN'</span><span class="token punctuation">,</span> <span class="token string">'SALESMAN'</span><span class="token punctuation">,</span> <span class="token string">'7698'</span><span class="token punctuation">,</span> <span class="token string">'1981-02-20'</span><span class="token punctuation">,</span> <span class="token string">'1600.00'</span><span class="token punctuation">,</span> <span class="token string">'300.00'</span><span class="token punctuation">,</span> <span class="token string">'30'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>emp<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'7521'</span><span class="token punctuation">,</span> <span class="token string">'WARD'</span><span class="token punctuation">,</span> <span class="token string">'SALESMAN'</span><span class="token punctuation">,</span> <span class="token string">'7698'</span><span class="token punctuation">,</span> <span class="token string">'1981-02-22'</span><span class="token punctuation">,</span> <span class="token string">'1250.00'</span><span class="token punctuation">,</span> <span class="token string">'500.00'</span><span class="token punctuation">,</span> <span class="token string">'30'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>emp<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'7566'</span><span class="token punctuation">,</span> <span class="token string">'JONES'</span><span class="token punctuation">,</span> <span class="token string">'MANAGER'</span><span class="token punctuation">,</span> <span class="token string">'7839'</span><span class="token punctuation">,</span> <span class="token string">'1981-02-02'</span><span class="token punctuation">,</span> <span class="token string">'2975.00'</span><span class="token punctuation">,</span> <span class="token boolean">null</span><span class="token punctuation">,</span> <span class="token string">'20'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>emp<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'7654'</span><span class="token punctuation">,</span> <span class="token string">'MARTIN'</span><span class="token punctuation">,</span> <span class="token string">'SALESMAN'</span><span class="token punctuation">,</span> <span class="token string">'7698'</span><span class="token punctuation">,</span> <span class="token string">'1981-09-28'</span><span class="token punctuation">,</span> <span class="token string">'1250.00'</span><span class="token punctuation">,</span> <span class="token string">'1400.00'</span><span class="token punctuation">,</span> <span class="token string">'30'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>emp<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'7698'</span><span class="token punctuation">,</span> <span class="token string">'BLAKE'</span><span class="token punctuation">,</span> <span class="token string">'MANAGER'</span><span class="token punctuation">,</span> <span class="token string">'7839'</span><span class="token punctuation">,</span> <span class="token string">'1981-01-05'</span><span class="token punctuation">,</span> <span class="token string">'2850.00'</span><span class="token punctuation">,</span> <span class="token boolean">null</span><span class="token punctuation">,</span> <span class="token string">'30'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>emp<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'7782'</span><span class="token punctuation">,</span> <span class="token string">'CLARK'</span><span class="token punctuation">,</span> <span class="token string">'MANAGER'</span><span class="token punctuation">,</span> <span class="token string">'7839'</span><span class="token punctuation">,</span> <span class="token string">'1981-09-06'</span><span class="token punctuation">,</span> <span class="token string">'2450.00'</span><span class="token punctuation">,</span> <span class="token boolean">null</span><span class="token punctuation">,</span> <span class="token string">'10'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>emp<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'7839'</span><span class="token punctuation">,</span> <span class="token string">'KING'</span><span class="token punctuation">,</span> <span class="token string">'PRESIDENT'</span><span class="token punctuation">,</span> <span class="token boolean">null</span><span class="token punctuation">,</span> <span class="token string">'1981-11-17'</span><span class="token punctuation">,</span> <span class="token string">'5000.00'</span><span class="token punctuation">,</span> <span class="token boolean">null</span><span class="token punctuation">,</span> <span class="token string">'10'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>emp<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'7844'</span><span class="token punctuation">,</span> <span class="token string">'TURNER'</span><span class="token punctuation">,</span> <span class="token string">'SALESMAN'</span><span class="token punctuation">,</span> <span class="token string">'7698'</span><span class="token punctuation">,</span> <span class="token string">'1981-09-08'</span><span class="token punctuation">,</span> <span class="token string">'1500.00'</span><span class="token punctuation">,</span> <span class="token string">'0.00'</span><span class="token punctuation">,</span> <span class="token string">'30'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>emp<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'7900'</span><span class="token punctuation">,</span> <span class="token string">'JAMES'</span><span class="token punctuation">,</span> <span class="token string">'CLERK'</span><span class="token punctuation">,</span> <span class="token string">'7698'</span><span class="token punctuation">,</span> <span class="token string">'1981-12-03'</span><span class="token punctuation">,</span> <span class="token string">'950.00'</span><span class="token punctuation">,</span> <span class="token boolean">null</span><span class="token punctuation">,</span> <span class="token string">'30'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>emp<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'7902'</span><span class="token punctuation">,</span> <span class="token string">'FORD'</span><span class="token punctuation">,</span> <span class="token string">'ANALYST'</span><span class="token punctuation">,</span> <span class="token string">'7566'</span><span class="token punctuation">,</span> <span class="token string">'1981-12-03'</span><span class="token punctuation">,</span> <span class="token string">'3000.00'</span><span class="token punctuation">,</span> <span class="token boolean">null</span><span class="token punctuation">,</span> <span class="token string">'20'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>emp<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'7934'</span><span class="token punctuation">,</span> <span class="token string">'MILLER'</span><span class="token punctuation">,</span> <span class="token string">'CLERK'</span><span class="token punctuation">,</span> <span class="token string">'7782'</span><span class="token punctuation">,</span> <span class="token string">'1982-01-23'</span><span class="token punctuation">,</span> <span class="token string">'1300.00'</span><span class="token punctuation">,</span> <span class="token boolean">null</span><span class="token punctuation">,</span> <span class="token string">'10'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- ----------------------------</span><span class="token comment">-- Table structure for salgrade</span><span class="token comment">-- ----------------------------</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token identifier"><span class="token punctuation">`</span>salgrade<span class="token punctuation">`</span></span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>salgrade<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>GRADE<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>LOSAL<span class="token punctuation">`</span></span> <span class="token keyword">double</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>HISAL<span class="token punctuation">`</span></span> <span class="token keyword">double</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>GRADE<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span class="token comment">-- ----------------------------</span><span class="token comment">-- Records of salgrade</span><span class="token comment">-- ----------------------------</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>salgrade<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'700'</span><span class="token punctuation">,</span> <span class="token string">'1200'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>salgrade<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'1201'</span><span class="token punctuation">,</span> <span class="token string">'1400'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>salgrade<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'1401'</span><span class="token punctuation">,</span> <span class="token string">'2000'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>salgrade<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'4'</span><span class="token punctuation">,</span> <span class="token string">'2001'</span><span class="token punctuation">,</span> <span class="token string">'3000'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>salgrade<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'5'</span><span class="token punctuation">,</span> <span class="token string">'3001'</span><span class="token punctuation">,</span> <span class="token string">'9999'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="执行计划中包含的信息"><a href="#执行计划中包含的信息" class="headerlink" title="执行计划中包含的信息"></a>执行计划中包含的信息</h3><table><thead><tr><th align="center">列</th><th>含义</th></tr></thead><tbody><tr><td align="center">id</td><td>select查询的序列号</td></tr><tr><td align="center">select_type</td><td>查询的类型，是普通查询还是联合查询还是子查询</td></tr><tr><td align="center">table</td><td>对应行正在访问哪一个表，表名或者别名，可能是临时表或者union合并结果集</td></tr><tr><td align="center">partitions</td><td>表示当前查询访问的分区，如果是NULL，表示当前不是分区表</td></tr><tr><td align="center">type</td><td>type显示的是访问类型，访问类型表示我是以何种方式去访问我们的数据，最容易想的是全表扫描</td></tr><tr><td align="center">possible_keys</td><td>显示当前查询语句可能会被使用的索引，一个或多个，但不一定被查询实际使用</td></tr><tr><td align="center">key</td><td>实际使用的索引，如果为null，则没有使用索引</td></tr><tr><td align="center">key_len</td><td>表示索引中使用的字节数，可以通过key_len计算查询中使用的索引长度，在不损失精度的情况下长度越短越好</td></tr><tr><td align="center">ref</td><td>显示索引的哪一列被使用了，如果可能的话，是一个常数</td></tr><tr><td align="center">rows</td><td>根据表的统计信息及索引使用情况，大致估算出找出所需记录需要读取的行数</td></tr><tr><td align="center">filtered</td><td>某个表经过搜索条件过滤后剩余记录条数的百分比，rows 乘以 filtered 的结果表示要与下表连接的行数</td></tr><tr><td align="center">extra</td><td>额外的信息</td></tr></tbody></table><h4 id="id"><a href="#id" class="headerlink" title="id"></a><strong>id</strong></h4><p>select查询的序列号，包含一组数字，表示查询中执行select子句或者操作表的顺序</p><p>id号分为三种情况：</p><ul><li>如果id相同，那么执行顺序从上到下</li><li>如果id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li><li>同时存在id相同和不同的：相同的可以认为是一组，从上往下顺序执行，在所有组中，id值越大，优先级越高，越先执行</li></ul><h4 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a><strong>select_type</strong></h4><p>主要用来分辨查询的类型，是普通查询还是联合查询还是子查询</p><ul><li><code>sample</code>：简单的查询，不包含子查询和union</li><li><code>primary</code>：查询中若包含任何复杂的子查询，最外层查询则被标记为Primary</li><li><code>union</code>：若第二个select出现在union之后，则被标记为union</li><li><code>dependent union</code> ： 跟union类似，此处的depentent表示union或union all联合而成的结果会受外部表影响</li><li><code>union result</code>：从union表获取结果的select</li><li><code>subquery</code>：在select或者where列表中包含子查询</li><li><code>dependent subquery</code>：subquery的子查询要受到外部表查询的影响</li><li><code>derived</code>：from子句中出现的子查询</li><li><code>uncacheable subquery</code>：表示使用子查询的结果不能被缓存</li><li><code>uncacheable union</code>：表示union的查询结果不能被缓存：sql语句未验证</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- sample:简单的查询，不包含子查询和union</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp<span class="token punctuation">;</span><span class="token comment">-- primary:查询中若包含任何复杂的子查询，最外层查询则被标记为Primary</span><span class="token keyword">explain</span> <span class="token keyword">select</span> staname<span class="token punctuation">,</span>ename supname <span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">select</span> ename staname<span class="token punctuation">,</span>mgr <span class="token keyword">from</span> emp<span class="token punctuation">)</span> t <span class="token keyword">join</span> emp <span class="token keyword">on</span> t<span class="token punctuation">.</span>mgr<span class="token operator">=</span>emp<span class="token punctuation">.</span>empno <span class="token punctuation">;</span><span class="token comment">-- union:若第二个select出现在union之后，则被标记为union</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> deptno <span class="token operator">=</span> <span class="token number">10</span> <span class="token keyword">union</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> sal <span class="token operator">></span><span class="token number">2000</span><span class="token punctuation">;</span><span class="token comment">-- dependent union : 跟union类似，此处的depentent表示union或union all联合而成的结果会受外部表影响</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp e <span class="token keyword">where</span> e<span class="token punctuation">.</span>empno  <span class="token operator">in</span> <span class="token punctuation">(</span> <span class="token keyword">select</span> empno <span class="token keyword">from</span> emp <span class="token keyword">where</span> deptno <span class="token operator">=</span> <span class="token number">10</span> <span class="token keyword">union</span> <span class="token keyword">select</span> empno <span class="token keyword">from</span> emp <span class="token keyword">where</span> sal <span class="token operator">></span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token comment">-- union result:从union表获取结果的select</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> deptno <span class="token operator">=</span> <span class="token number">10</span> <span class="token keyword">union</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> sal <span class="token operator">></span><span class="token number">2000</span><span class="token punctuation">;</span><span class="token comment">-- subquery:在select或者where列表中包含子查询</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> sal <span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token function">avg</span><span class="token punctuation">(</span>sal<span class="token punctuation">)</span> <span class="token keyword">from</span> emp<span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token comment">-- dependent subquery:subquery的子查询要受到外部表查询的影响</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp e <span class="token keyword">where</span> e<span class="token punctuation">.</span>deptno <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token keyword">distinct</span> deptno <span class="token keyword">from</span> dept<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- DERIVED: from子句中出现的子查询，也叫做派生类，</span><span class="token keyword">explain</span> <span class="token keyword">select</span> staname<span class="token punctuation">,</span>ename supname <span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">select</span> ename staname<span class="token punctuation">,</span>mgr <span class="token keyword">from</span> emp<span class="token punctuation">)</span> t <span class="token keyword">join</span> emp <span class="token keyword">on</span> t<span class="token punctuation">.</span>mgr<span class="token operator">=</span>emp<span class="token punctuation">.</span>empno <span class="token punctuation">;</span><span class="token comment">-- UNCACHEABLE SUBQUERY：表示使用子查询的结果不能被缓存</span> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> empno <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">select</span> empno <span class="token keyword">from</span> emp <span class="token keyword">where</span> deptno<span class="token operator">=</span>@<span class="token variable">@sort_buffer_size</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- uncacheable union:表示union的查询结果不能被缓存：sql语句未验证</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="table"><a href="#table" class="headerlink" title="table"></a><strong>table</strong></h4><p>对应行正在访问哪一个表，表名或者别名，可能是临时表或者union合并结果集</p><ul><li>如果是具体的表名，则表明从实际的物理表中获取数据，当然也可以是表的别名</li><li>表名是derivedN的形式，表示使用了id为N的查询产生的衍生表</li><li>当有union result的时候，表名是union n1,n2等的形式，n1,n2表示参与union的id</li></ul><h4 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a><strong>partitions</strong></h4><p>表示当前查询访问的分区，如果是NULL，表示当前不是分区表</p><h4 id="type"><a href="#type" class="headerlink" title="type"></a><strong>type</strong></h4><p>type显示的是访问类型，访问类型表示我是以何种方式去访问我们的数据，最容易想的是全表扫描，直接暴力的遍历一张表去寻找需要的数据，效率非常低下，访问的类型有很多，效率从最好到最坏依次是：</p><ul><li><code>system</code>：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现</li><li><code>const</code>：这个表至多有一个匹配行，并不是说表里只有一条记录，一般使用主键id查询的时候是这种情况</li><li><code>eq_ref</code>：使用唯一性索引进行数据查找</li><li><code>ref</code>：使用了非唯一性索引进行数据的查找</li><li><code>fulltext</code></li><li><code>ref_or_null</code>：对于某个字段即需要关联条件，也需要null值的情况下，查询优化器会选择这种访问方式</li><li><code>index_merge</code>：在查询过程中需要多个索引组合使用</li><li><code>unique_subquery</code>：该连接类型类似与index_subquery,使用的是唯一索引</li><li><code>index_subquery</code>：利用索引来关联子查询，不再扫描全表</li><li><code>range</code>：表示利用索引查询的时候限制了范围，在指定范围内进行查询，这样避免了index的全索引扫描</li><li><code>index</code>：全索引扫描这个比all的效率要好，主要有两种情况，一种是当前的查询是覆盖索引，或者是使用了索引进行排序，这样就避免数据的重排序</li><li><code>all</code>：全表扫描，一般情况下出现这样的sql语句而且数据量比较大的话那么就需要进行优化。</li></ul><p>一般情况下，得保证查询至少达到range级别，最好能达到ref</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- all:全表扫描，一般情况下出现这样的sql语句而且数据量比较大的话那么就需要进行优化。</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp<span class="token punctuation">;</span><span class="token comment">-- index：全索引扫描这个比all的效率要好，主要有两种情况，一种是当前的查询是覆盖索引，即我们需要的数据在索引中就可以索取，或者是使用了索引进行排序，这样就避免数据的重排序</span><span class="token keyword">explain</span>  <span class="token keyword">select</span> empno <span class="token keyword">from</span> emp<span class="token punctuation">;</span><span class="token comment">-- range：表示利用索引查询的时候限制了范围，在指定范围内进行查询，这样避免了index的全索引扫描，适用的操作符： =, &lt;>, >, >=, &lt;, &lt;=, IS NULL, BETWEEN, LIKE, or IN() </span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> empno <span class="token operator">between</span> <span class="token number">7000</span> <span class="token operator">and</span> <span class="token number">7500</span><span class="token punctuation">;</span><span class="token comment">-- index_subquery：利用索引来关联子查询，不再扫描全表</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> emp<span class="token punctuation">.</span>job <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token keyword">select</span> job <span class="token keyword">from</span> t_job<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- unique_subquery:该连接类型类似与index_subquery,使用的是唯一索引</span> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp e <span class="token keyword">where</span> e<span class="token punctuation">.</span>deptno <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token keyword">distinct</span> deptno <span class="token keyword">from</span> dept<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- index_merge：在查询过程中需要多个索引组合使用，没有模拟出来</span><span class="token comment">-- ref_or_null：对于某个字段即需要关联条件，也需要null值的情况下，查询优化器会选择这种访问方式</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> mgr <span class="token operator">is</span> <span class="token boolean">null</span> <span class="token operator">or</span> mgr<span class="token operator">=</span><span class="token number">7369</span><span class="token punctuation">;</span><span class="token comment">-- ref：使用了非唯一性索引进行数据的查找</span> <span class="token keyword">create</span> <span class="token keyword">index</span> idx_3 <span class="token keyword">on</span> emp<span class="token punctuation">(</span>deptno<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp e<span class="token punctuation">,</span>dept d <span class="token keyword">where</span> e<span class="token punctuation">.</span>deptno <span class="token operator">=</span>d<span class="token punctuation">.</span>deptno<span class="token punctuation">;</span><span class="token comment">-- eq_ref ：使用唯一性索引进行数据查找</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp<span class="token punctuation">,</span>emp2 <span class="token keyword">where</span> emp<span class="token punctuation">.</span>empno <span class="token operator">=</span> emp2<span class="token punctuation">.</span>empno<span class="token punctuation">;</span><span class="token comment">-- const：这个表至多有一个匹配行，并不是说表里只有一条记录，一般使用主键id查询的时候会有这个type</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> empno <span class="token operator">=</span> <span class="token number">7369</span><span class="token punctuation">;</span> <span class="token comment">-- system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a><strong>possible_keys</strong></h4><p>显示当前查询语句可能会被使用的索引，一个或多个，但不一定被查询实际使用</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp<span class="token punctuation">,</span>dept <span class="token keyword">where</span> emp<span class="token punctuation">.</span>deptno <span class="token operator">=</span> dept<span class="token punctuation">.</span>deptno <span class="token operator">and</span> emp<span class="token punctuation">.</span>deptno <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="key"><a href="#key" class="headerlink" title="key"></a><strong>key</strong></h4><p>实际使用的索引，如果为null，则没有使用索引，查询中若使用了覆盖索引，则该索引和查询的select字段重叠。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp<span class="token punctuation">,</span>dept <span class="token keyword">where</span> emp<span class="token punctuation">.</span>deptno <span class="token operator">=</span> dept<span class="token punctuation">.</span>deptno <span class="token operator">and</span> emp<span class="token punctuation">.</span>deptno <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a><strong>key_len</strong></h4><p>表示索引中使用的字节数，可以通过key_len计算查询中使用的索引长度，在不损失精度的情况下长度越短越好。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp<span class="token punctuation">,</span>dept <span class="token keyword">where</span> emp<span class="token punctuation">.</span>deptno <span class="token operator">=</span> dept<span class="token punctuation">.</span>deptno <span class="token operator">and</span> emp<span class="token punctuation">.</span>deptno <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a><strong>ref</strong></h4><p>显示索引的哪一列被使用了，如果可能的话，是一个常数</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp<span class="token punctuation">,</span>dept <span class="token keyword">where</span> emp<span class="token punctuation">.</span>deptno <span class="token operator">=</span> dept<span class="token punctuation">.</span>deptno <span class="token operator">and</span> emp<span class="token punctuation">.</span>deptno <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="rows"><a href="#rows" class="headerlink" title="rows"></a><strong>rows</strong></h4><p>根据表的统计信息及索引使用情况，大致估算出找出所需记录需要读取的行数，此参数很重要，直接反应的sql找了多少数据，在完成目的的情况下越少越好</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a><strong>filtered</strong></h4><p>某个表经过搜索条件<code>过滤后剩余记录条数</code>的百分比，这个<code>过滤后剩余记录条数</code>，是需要用来对下一张表进行连接的行数。什么意思呢？</p><ul><li>对于单表查询来说，这个filtered列的值没什么意义。</li><li>对于多表联合查询，假设表1扫描的rows是10000行，filteres是20%，那么表示要与表2进行连接的行数是：10000 x 20% &#x3D; 2000条记录。</li></ul><h4 id="extra"><a href="#extra" class="headerlink" title="extra"></a><strong>extra</strong></h4><p>包含额外的信息。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- using filesort :说明mysql无法利用索引进行排序，只能利用排序算法进行排序，会消耗额外的位置</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">order</span> <span class="token keyword">by</span> sal<span class="token punctuation">;</span><span class="token comment">-- using temporary:需要使用临时表来保存中间结果，查询完成之后把临时表删除</span><span class="token keyword">explain</span> <span class="token keyword">select</span> ename<span class="token punctuation">,</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> deptno <span class="token operator">=</span> <span class="token number">10</span> <span class="token keyword">group</span> <span class="token keyword">by</span> ename<span class="token punctuation">;</span><span class="token comment">-- using index: 这个表示当前的查询时覆盖索引的，直接从索引中读取数据，而不用访问数据表。如果同时出现using where 表名索引被用来执行索引键值的查找，如果没有，表面索引被用来读取数据，而不是真的查找</span><span class="token keyword">explain</span> <span class="token keyword">select</span> deptno<span class="token punctuation">,</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> emp <span class="token keyword">group</span> <span class="token keyword">by</span> deptno <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">-- using where:使用where进行条件过滤</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_user <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">-- using join buffer :使用连接缓存，情况没有模拟出来</span><span class="token comment">-- impossible where：where语句的结果总是false</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> empno <span class="token operator">=</span> <span class="token number">7469</span><span class="token punctuation">;</span><span class="token comment">-- using MRR：使用了Multi-Range Read 优化 (MRR)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;资料：打开&lt;/p&gt;
&lt;p&gt;mysql的索引优化，联合索引使用的时候，时间+站点+code， 通过时间筛选之后，数据还比较多，此时效率很低。可以把所以改成：站点+时间+code，这样通过站点筛选之后的数据，就剩下很少了，此时效率很高。&lt;/p&gt;
&lt;p&gt;事务中，行锁是在</summary>
      
    
    
    
    <category term="JAVA" scheme="https://zspcer.gitee.io/categories/JAVA/"/>
    
    <category term="数据库" scheme="https://zspcer.gitee.io/categories/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MYSQL" scheme="https://zspcer.gitee.io/categories/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL/"/>
    
    
    <category term="mysql" scheme="https://zspcer.gitee.io/tags/mysql/"/>
    
    <category term="性能调优" scheme="https://zspcer.gitee.io/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
    <category term="调优" scheme="https://zspcer.gitee.io/tags/%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>mysql的临时表从入门到入土</title>
    <link href="https://zspcer.gitee.io/note/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL/mysql%E7%9A%84%E4%B8%B4%E6%97%B6%E8%A1%A8%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/"/>
    <id>https://zspcer.gitee.io/note/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL/mysql%E7%9A%84%E4%B8%B4%E6%97%B6%E8%A1%A8%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/</id>
    <published>2023-03-15T04:24:10.512Z</published>
    <updated>2023-03-15T04:24:10.512Z</updated>
    
    <content type="html"><![CDATA[<p>mysql临时表的xmind，<a href="">点击下载</a></p><p>#### 临时表相关 </p><ul><li>17 | 如何正确地显示随机消息？ </li><li>34 | 到底可不可以使用join？ </li><li>35 | join语句怎么优化？ </li><li>36 | 为什么临时表可以重名？</li><li>37 | 什么时候会使用内部临时表？</li><li>43 | 要不要使用分区表？</li></ul><hr><p>本文的内容，是mysql中关于sql优化，比较重要的一部分内容，涉及到：</p><ul><li>mysql的排序：就是我们日常sql语句中经常写的 order by</li></ul><p>还涉及到：</p><ul><li>临时文件，为什么会涉及临时文件，因为：排序的时候会有内部排序和外部排序</li><li>排序的记录比较多的时候，就会用到外部排序，外部排序就会用到临时文件，使用归并排序算法</li></ul><p>还涉及到：</p><ul><li>JOIN 语句的优化：就是我们日常开发中 a left join b 等等</li><li>临时表，因为涉及到JOIN的优化</li></ul><p>这些都是很日常的开发工作中，就会用到的部分，所以这篇文章要好好掌握以下，对实战的能力提升很大</p><h2 id="mysql的排序"><a href="#mysql的排序" class="headerlink" title="mysql的排序"></a>mysql的排序</h2><p>这部分在 Mysql的索引从入门到入土 已经介绍过了，这里我再总结一下</p><img src="mysql的临时表从入门到入土.assets/image-20230307144252828.png" alt="image-20230307144252828" style="zoom:80%;" /><p>在日常的开发过程中，经常会使用<code>order by</code>语句，那么排序的原理是什么呢？</p><p>排序分为两种情况</p><ul><li>排序的字段有索引</li><li>排序的字段没有索引</li></ul><p>有索引的排序，会直接使用索引，因为索引是有序的，所以没啥可说的。性能很高</p><p>主要讨论没有索引的排序：没有索引的排序，相对来说复杂一下。</p><p>一个语句是否使用了排序，可以通过：<code>explain</code>命令查看，结果中有 Using filesort ，说明mysql无法利用索引进行排序，只能利用排序算法进行排序，会消耗额外的位置</p><p>MySQL 会给每个线程分配一块<code>内存</code>用于排序，称为<code> sort_buffer</code>。</p><p>sort_buffer既然是内存区域，就不可能无限的扩大，是可以通过参数<code>sort_buffer_size</code>控制的</p><h3 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h3><p>如果要排序的数据量小于 <code>sort_buffer_size</code>，排序就在内存中完成。 </p><p>这叫做：<code>内部排序</code>，有两种算法：快排和优先队列排序(也叫堆排序)</p><h3 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h3><p>如果要排序的数据量 大于 <code>sort_buffer_size</code>，内存放不下，则不得不利用磁盘临时文件辅助排序。</p><p>这叫做：<code>外部排序</code>，算法是归并排序</p><h3 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h3><p>是指将 <strong>排序的字段和要返回的字段</strong>，全部放入内存，这样排序完之后，就不需要回表了。性能比较高</p><p>比如：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> name<span class="token punctuation">,</span>city<span class="token punctuation">,</span>age <span class="token keyword">from</span> t <span class="token keyword">order</span> <span class="token keyword">by</span> name <span class="token keyword">desc</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果内存放得下，就将：name，city，age 全都放入内存，在内存中使用 name 排好序，直接返回。避免了回表</p><h3 id="rowId排序"><a href="#rowId排序" class="headerlink" title="rowId排序"></a>rowId排序</h3><p>如果 MySQL 认为排序的单行长度太大（通过参数：max_length_for_sort_data），就不能将 <strong>排序的字段和要返回的字段</strong> 都放在内存中了</p><p>只能将 <strong>排序的字段和要返回的字段所在记录的id</strong> 放在内存中进行排序</p><p>排序完之后，在通过：<strong>要返回的字段所在记录的id</strong> 进行回表，取出：<strong>要返回的字段</strong></p><p>比如：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> name<span class="token punctuation">,</span>prov<span class="token punctuation">,</span>city<span class="token punctuation">,</span>address<span class="token punctuation">,</span>age <span class="token keyword">from</span> t <span class="token keyword">order</span> <span class="token keyword">by</span> name <span class="token keyword">desc</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要返回的字段：name,prov,city,address,age 太大了，内存放不下，就会将 id 和 name 放在内存中，然后通过name排序</p><p>排序完成之后，在通过 id 回表查找 name,prov,city,address,age 返回给客户端</p><h3 id="全字段排序-VS-rowid-排序"><a href="#全字段排序-VS-rowid-排序" class="headerlink" title="全字段排序 VS rowid 排序"></a>全字段排序 VS rowid 排序</h3><ul><li>MySQL 如果觉得排序内存太小，会影响排序效率，会采用 rowid 排序算法，这样排序过程中一次可以排序更多行，但是需要回表</li><li>MySQL 认为内存足够大，会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，可以减少回表</li></ul><h3 id="排序算法的选择"><a href="#排序算法的选择" class="headerlink" title="排序算法的选择"></a>排序算法的选择</h3><p>判断排序的单行字段大小</p><ul><li>如果 单行长度大小 &lt; max_length_for_sort_data ：全字段排序</li><li>如果 单行长度大小 &gt; max_length_for_sort_data ：rowid排序</li></ul><p>不管是全字段排序，还是rowid排序都受限制于：sort_buffer 的大小</p><ul><li>如果：要排序的总数据量 &lt; sort_buffer_size ： 内部排序，使用快速排序算法</li><li>如果 ：要排序的总数据量 &gt; sort_buffer_size：<ul><li>继续判断结果量级，结果量级大，比如：order by xx limit 10000：外部排序，使用归并排序算法</li><li>结果量级小，比如：order by xx limit 3：内部排序，使用 优化队列算法（堆排序）</li></ul></li></ul><p>表的存储引擎</p><ul><li>要排序的表是InnoDB的： 优先选择：全字段排序，rowid 排序会要求回表多造成磁盘读，因此不会被优先选择</li><li>要排序的是内存的(比如memory)： 优先选择：rowid排序，因为是内存表，不涉及磁盘读，使用rowid可以一次性排更多的数据</li></ul><p>上面我们说过，当排序的记录数比较多，sort_buffer 内存放不下，会使用临时文件辅助排序</p><p>接下老我们就看看：Mysql 中的临时文件</p><h2 id="Mysql的临时文件"><a href="#Mysql的临时文件" class="headerlink" title="Mysql的临时文件"></a>Mysql的临时文件</h2><p>临时文件和临时表是不一样的东西！</p><p>临时文件，一般是在排序过程中，内存放不下，会将数据存在磁盘中，这时，存在磁盘中的文件就是临时文件。排序完成之后，就删除了。</p><p>关于临时文件，这里不过多的解释。</p><p>我们来看看临时表吧</p><h2 id="Mysql的临时表"><a href="#Mysql的临时表" class="headerlink" title="Mysql的临时表"></a>Mysql的临时表</h2><h3 id="什么是临时表"><a href="#什么是临时表" class="headerlink" title="什么是临时表"></a>什么是临时表</h3><p>有的人可能会认为，临时表就是内存表。</p><p>但是，这两个概念可是完全不同的。</p><p>内存表，指的是使用 Memory 引擎的表，建表语法是 create table … engine&#x3D;memory。这种表的数据都保存在内存里，系统重启的时候会被清空，但是表结构还在。除了这两个特性看上去比较“奇怪”外，从其他的特征上看，它就是一个正常的表。</p><p>临时表，可以使用各种引擎类型 。如果是使用 InnoDB 引擎或者 MyISAM 引擎的临时表，写数据的时候是写到磁盘上的。当然，临时表也可以使用 Memory 引擎。</p><h3 id="临时表的特性"><a href="#临时表的特性" class="headerlink" title="临时表的特性"></a>临时表的特性</h3><p>通过一个实例，来了解临时表的特性</p><table><thead><tr><th>session A</th><th>session B</th></tr></thead><tbody><tr><td>create temporary table t (c int) engine&#x3D;myisam;</td><td></td></tr><tr><td></td><td>show create table t;<br/><font color='red'>(Table ‘t’ doesn’t exist)</font></td></tr><tr><td>create table t (id int primary key) engine&#x3D;innodb;</td><td></td></tr><tr><td>show create table t;<br/><font color='green'>&#x2F;&#x2F;create temporary table t (c int) engine&#x3D;myisam;</font></td><td></td></tr><tr><td>show tables;<br/><font color='green'>&#x2F;&#x2F;只显示普通表t</font></td><td></td></tr><tr><td></td><td>insert into t value (1);<br/>select * from t;<br/>&#x2F;&#x2F;返回1</td></tr><tr><td>select * from t;<br/>&#x2F;&#x2F;Empty Set</td><td></td></tr></tbody></table><p>临时表在使用上有以下几个特点：</p><ul><li>建表语法是 create temporary table …</li><li>一个临时表只能被创建它的 session 访问，对其他线程不可见。所以，图中 session A 创建的临时表 t，对于 session B 就是不可见的。</li><li>临时表可以与普通表同名。</li><li>session A 内有同名的临时表和普通表的时候，show create 语句，以及增删改查语句访问的是临时表。</li><li>show tables 命令不显示临时表。</li></ul><img src="mysql的临时表从入门到入土.assets/image-20230307150000571.png" alt="image-20230307150000571" /><h3 id="哪里会用到临时表"><a href="#哪里会用到临时表" class="headerlink" title="哪里会用到临时表"></a>哪里会用到临时表</h3><img src="mysql的临时表从入门到入土.assets/image-20230307145644973.png" alt="image-20230307145644973"  /><h3 id="怎么创建临时表"><a href="#怎么创建临时表" class="headerlink" title="怎么创建临时表"></a>怎么创建临时表</h3><img src="mysql的临时表从入门到入土.assets/image-20230307145631925.png" alt="image-20230307145631925" style="zoom:80%;" /><h3 id="临时表的分类"><a href="#临时表的分类" class="headerlink" title="临时表的分类"></a>临时表的分类</h3><img src="mysql的临时表从入门到入土.assets/image-20230307165554003.png" alt="image-20230307165554003" /><h3 id="临时表的日志"><a href="#临时表的日志" class="headerlink" title="临时表的日志"></a>临时表的日志</h3><img src="mysql的临时表从入门到入土.assets/image-20230307165507644.png" alt="image-20230307165507644" /><h2 id="JOIN语句"><a href="#JOIN语句" class="headerlink" title="JOIN语句"></a>JOIN语句</h2><h3 id="JOIN的基本概念"><a href="#JOIN的基本概念" class="headerlink" title="JOIN的基本概念"></a>JOIN的基本概念</h3><ul><li>笛卡尔积</li><li>隐式内连接<ul><li>等值连接</li><li>非等值连接</li></ul></li><li>自连接</li><li>外连接<ul><li>左外连接</li><li>右外连接</li><li>全外连接</li></ul></li><li>内连接</li><li>交叉连接</li></ul><p>可以参考：mysql的连接查询.md 一文，这里不再赘述</p><h3 id="JOIN语句的分类"><a href="#JOIN语句的分类" class="headerlink" title="JOIN语句的分类"></a>JOIN语句的分类</h3><h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><ul><li>准备 表t1：有索引a，100条记录</li><li>准备 表t2：有索引a，1000条记录</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>t2<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>a<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>b<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>a<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>a<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">procedure</span> idata<span class="token punctuation">;</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">procedure</span> idata<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">begin</span>  <span class="token keyword">declare</span> i <span class="token keyword">int</span><span class="token punctuation">;</span>  <span class="token keyword">set</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token keyword">do</span>    <span class="token keyword">insert</span> <span class="token keyword">into</span> t2 <span class="token keyword">values</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">set</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token keyword">call</span> idata<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">table</span> t1 <span class="token operator">like</span> t2<span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t1 <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t2 <span class="token keyword">where</span> id<span class="token operator">&lt;=</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Index-Nested-Loop-Join（NLJ）"><a href="#Index-Nested-Loop-Join（NLJ）" class="headerlink" title="Index Nested-Loop Join（NLJ）"></a>Index Nested-Loop Join（NLJ）</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 straight_join t2 <span class="token keyword">on</span> <span class="token punctuation">(</span>t1<span class="token punctuation">.</span>a<span class="token operator">=</span>t2<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+---------+------+----------+-------------+</span><span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>  <span class="token operator">|</span> key_len <span class="token operator">|</span> ref     <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra       <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+---------+------+----------+-------------+</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> t1    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> a             <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span>  <span class="token number">100</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> t2    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> ref  <span class="token operator">|</span> a             <span class="token operator">|</span> a    <span class="token operator">|</span> <span class="token number">5</span>       <span class="token operator">|</span> zs<span class="token punctuation">.</span>t1<span class="token punctuation">.</span>a <span class="token operator">|</span>    <span class="token number">1</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>        <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+---------+------+----------+-------------+</span><span class="token number">2</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行过程</p><ul><li>从表 t1 中读入一行数据 R；</li><li>从数据行 R 中，取出 a 字段到表 t2 里去查找；</li><li>取出表 t2 中满足条件的行，跟 R 组成一行，作为结果集的一部分；</li><li>重复执行步骤 1 到 3，直到表 t1 的末尾循环结束。</li></ul><p>这个过程是先遍历表 t1，然后根据从表 t1 中取出的每行数据中的 a 值，去表 t2 中查找满足条件的记录。并且可以用上表t2的索引，所以我们称之为“Index Nested-Loop Join”，简称 NLJ。</p><h4 id="Simple-Nested-Loop-Join（SNL）"><a href="#Simple-Nested-Loop-Join（SNL）" class="headerlink" title="Simple Nested-Loop Join（SNL）"></a>Simple Nested-Loop Join（SNL）</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 straight_join t2 <span class="token keyword">on</span> <span class="token punctuation">(</span>t1<span class="token punctuation">.</span>a<span class="token operator">=</span>t2<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span><span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>  <span class="token operator">|</span> key_len <span class="token operator">|</span> ref  <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra                                              <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> t1    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> a             <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span>  <span class="token number">100</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>                                               <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> t2    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> <span class="token boolean">NULL</span>          <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token number">1000</span> <span class="token operator">|</span>    <span class="token number">10.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span><span class="token punctuation">;</span> <span class="token keyword">Using</span> <span class="token keyword">join</span> buffer <span class="token punctuation">(</span>Block Nested <span class="token keyword">Loop</span><span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span><span class="token number">2</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于表 t2 的字段 b 上没有索引，因此再用图 2 的执行流程时，每次到 t2 去匹配的时候，就要做一次全表扫描。</p><p>你可以先设想一下这个问题，继续使用图 2 的算法，是不是可以得到正确的结果呢？如果只看结果的话，这个算法是正确的，而且这个算法也有一个名字，叫做“Simple Nested-Loop Join”。</p><p>但是，这样算来，这个 SQL 请求就要扫描表 t2 多达 100 次，总共扫描 100*1000&#x3D;10 万行。</p><p>效率极低。</p><p>但是mysql并没有使用这种算法，因为这种算法效率极低，通过执行计划也可以看到：Using where; Using join buffer (Block Nested Loop) </p><p>mysql使用的是 Block Nested Loop</p><h4 id="Block-Nested-Loop-Join（BNL）"><a href="#Block-Nested-Loop-Join（BNL）" class="headerlink" title="Block Nested Loop Join（BNL）"></a>Block Nested Loop Join（BNL）</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 straight_join t2 <span class="token keyword">on</span> <span class="token punctuation">(</span>t1<span class="token punctuation">.</span>a<span class="token operator">=</span>t2<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span><span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>  <span class="token operator">|</span> key_len <span class="token operator">|</span> ref  <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra                                              <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> t1    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> a             <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span>  <span class="token number">100</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>                                               <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> t2    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> <span class="token boolean">NULL</span>          <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token number">1000</span> <span class="token operator">|</span>    <span class="token number">10.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span><span class="token punctuation">;</span> <span class="token keyword">Using</span> <span class="token keyword">join</span> buffer <span class="token punctuation">(</span>Block Nested <span class="token keyword">Loop</span><span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span><span class="token number">2</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当<code>被驱动表</code>无法使用索引的时候，算法的流程是这样的：</p><ul><li><p>把表 t1 的数据读入线程内存 join_buffer 中，由于我们这个语句中写的是 select *，因此是把整个表 t1 放入了内存；</p></li><li><p>扫描表 t2，把表 t2 中的每一行取出来，跟 join_buffer 中的数据做对比，满足 join 条件的，作为结果集的一部分返回。</p></li></ul><p><strong>如果驱动表的数据太多，join_buffer放不下怎么办？</strong></p><p>join_buffer 的大小是由参数 join_buffer_size 设定的，默认值是 256k。</p><p>如果放不下表 t1 的所有数据话，策略很简单，就是分段放。</p><p>执行过程就变成了：</p><ul><li>扫描表 t1，顺序读取数据行放入 join_buffer 中，放完第 88 行 join_buffer 满了，继续第 2 步；</li><li>扫描表 t2，把 t2 中的每一行取出来，跟 join_buffer 中的数据做对比，满足 join 条件的，作为结果集的一部分返回；</li><li>清空 join_buffer；</li><li>继续扫描表 t1，顺序读取第 88 行之后的12 行数据放入 join_buffer 中，继续执行第 2 步。</li></ul><p>这个流程才体现出了这个算法名字中“Block”的由来，表示“分块去 join”</p><h4 id="hash-join（mysql-8-0-）"><a href="#hash-join（mysql-8-0-）" class="headerlink" title="hash join（mysql 8.0 ）"></a>hash join（mysql 8.0 ）</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 straight_join t2 <span class="token keyword">on</span> <span class="token punctuation">(</span>t1<span class="token punctuation">.</span>a<span class="token operator">=</span>t2<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span><span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>  <span class="token operator">|</span> key_len <span class="token operator">|</span> ref  <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra                                      <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> t1    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> a             <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span>  <span class="token number">100</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>                                       <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> t2    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> <span class="token boolean">NULL</span>          <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token number">1000</span> <span class="token operator">|</span>    <span class="token number">10.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span><span class="token punctuation">;</span> <span class="token keyword">Using</span> <span class="token keyword">join</span> buffer <span class="token punctuation">(</span><span class="token keyword">hash</span> <span class="token keyword">join</span><span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span><span class="token number">2</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样的语句，在mysql8.0版本中，就不是使用 BNL了，而是使用 hash join</p><p>hash join 是mysql 8 的优化，在8之前这种语句使用的是：BNL，在8之后是 hash join</p><p>hash join 和 BNL 思路上是一致的</p><ul><li>将 驱动表 加载到内存<ul><li>BNL：所需的字段放在join_buffer中</li><li>hash join： 在 join_buffer中存的是一个hash表，key是将连接字段（join的字段）hash后的结果；value是所需的字段</li></ul></li><li>join_buffer不够用的时候<ul><li>BNL：分块加载</li><li>hash join：存到磁盘上</li></ul></li><li>读取 被驱动表 中记录与内存中的驱动表作比较<ul><li>BNL：遍历内存中的驱动表，时间复杂度是 O(n)</li><li>hash join：被驱动表的记录先hash，然后去内存中的hash表查找，时间复杂度是 O(1)</li></ul></li><li>返回结果集</li></ul><p>个人理解：主要是匹配的过程中，hash比BNL时间复杂度更好，所以更快</p><h4 id="它们之间的区别和联系"><a href="#它们之间的区别和联系" class="headerlink" title="它们之间的区别和联系"></a>它们之间的区别和联系</h4><img src="mysql的临时表从入门到入土.assets/image-20230307214104063.png" alt="image-20230307214104063"  /><h3 id="是否可以使用JOIN语句"><a href="#是否可以使用JOIN语句" class="headerlink" title="是否可以使用JOIN语句"></a>是否可以使用JOIN语句</h3><p>能不能使用 join 语句？</p><ul><li><p>如果可以使用 Index Nested-Loop Join 算法，也就是说可以用上被驱动表上的索引，其实是没问题的；</p></li><li><p>如果使用 Block Nested-Loop Join 算法，扫描行数就会过多。尤其是在大表上的 join 操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源（比较次数多，CPU也会升高）。所以这种 join 尽量不要用。</p></li></ul><p>所以你在判断要不要使用 join 语句时，就是看 explain 结果里面，Extra 字段里面有没有出现“Block Nested Loop”字样。</p><h3 id="驱动表应该怎么选"><a href="#驱动表应该怎么选" class="headerlink" title="驱动表应该怎么选"></a>驱动表应该怎么选</h3><p>先说结论：应该选择小表作为驱动表</p><h4 id="在-NLJ-的情况下"><a href="#在-NLJ-的情况下" class="headerlink" title="在 NLJ 的情况下"></a>在 NLJ 的情况下</h4><p>在 NLJ 的情况下，<code>驱动表</code>走全表扫描，<code>被驱动表</code>走索引树搜索</p><p>假设<code>被驱动表</code>的行数是 M，每次在<code>驱动表</code>查一行数据，要先搜索索引 a，在搜索主键索引。</p><p>每次搜索一棵树近似复杂度是 以2为底的M的对数，记为： log2M</p><p>所以在<code>被驱动表</code>上查一行数据的时间复杂度就是： 2 * log2M（因为走了2次索引，一次普通索引，一次主键索引）</p><p>假设<code>驱动表</code>的行数是 N，执行过程就要扫描驱动表的 N 行，然后对于每一行，都去<code>被驱动表</code>上匹配一次。</p><p>因此整个执行过程，近似复杂度为：N + N * 2 * log2M</p><p>显然，N 对扫描行数的影响更大，因此应该让小表来做驱动表。</p><blockquote><p> 如果你没觉得这个影响有那么“显然”， 可以这么理解：</p><p>N 扩大 1000 倍的话，扫描行数就会扩大 1000 倍；</p><p>而 M 扩大 1000 倍，扫描行数扩大不到 10 倍。</p></blockquote><p>总结：在 NLJ 的情况下，需要选择小表作为驱动表。</p><h4 id="在-BNL-的情况下"><a href="#在-BNL-的情况下" class="headerlink" title="在 BNL 的情况下"></a>在 BNL 的情况下</h4><p>在 BNL 的情况下，<code>驱动表</code>走全表扫描，<code>被驱动表</code>也是走全表扫描</p><p>假设小表的行数是 N，大表的行数是 M</p><p>在 BNL 算法，会首先把 <code>驱动表</code>加载到内存中，然后扫描<code>被驱动表</code>，扫描一行，就和内存中的<code>驱动表</code>做一次匹配，所以是：</p><ul><li>两次全表扫描：M + N</li><li>内存中的判断次数是 M * N</li></ul><p>可以看到，调换这两个算式中的 M 和 N 没差别，因此这时候无论选择哪个表做驱动表，执行耗时是一样的。</p><p><strong>但是！！！</strong>如果驱动表的数据比较多，我们知道此时需要分块join</p><p>此时假设，<code>驱动表</code>的数据行数是 N，需要分 K 段才能完成算法流程，<code>被驱动表</code>的数据行数是 M</p><p>注意，这里的 K 不是常数，N 越大 K 就会越大</p><p>所以：对驱动表的扫描次数是N； 对被驱动表的扫描次数是：K * M，此时：</p><ul><li>总的扫描次数是：N + K * M</li><li>总的内存判断次数是： N * M</li></ul><p>显然，内存判断次数是不受选择哪个表作为驱动表影响的。而考虑到扫描行数，在 M 和 N 大小确定的情况下，K 小一些，也就是分段小一些，整个算式的结果会更小。</p><p>为了让分段更小，有两个办法：</p><ul><li>选择小表作为驱动表</li><li>增大 join_buffer_size</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>如果要使用 join，应该选择大表做驱动表还是选择小表做驱动表？</p><ul><li>如果是 Index Nested-Loop Join 算法，应该选择小表做驱动表；</li><li>如果是 Block Nested-Loop Join 算法：<ul><li>在 join_buffer_size 足够大的时候，是一样的；</li><li>在 join_buffer_size 不够大的时候（这种情况更常见），应该选择小表做驱动表。</li></ul></li></ul><p>所以，这个问题的结论就是，总是应该使用小表做驱动表。</p><h4 id="什么是小表"><a href="#什么是小表" class="headerlink" title="什么是小表"></a>什么是小表</h4><p>这里所说的小表，并不是说表的数据量是多还是少；</p><p>而是作为 join 的数据量的大小。</p><p>比如下面两个语句：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 straight_join t2 <span class="token keyword">on</span> <span class="token punctuation">(</span>t1<span class="token punctuation">.</span>b<span class="token operator">=</span>t2<span class="token punctuation">.</span>b<span class="token punctuation">)</span> <span class="token keyword">where</span> t2<span class="token punctuation">.</span>id<span class="token operator">&lt;=</span><span class="token number">50</span><span class="token punctuation">;</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t2 straight_join t1 <span class="token keyword">on</span> <span class="token punctuation">(</span>t1<span class="token punctuation">.</span>b<span class="token operator">=</span>t2<span class="token punctuation">.</span>b<span class="token punctuation">)</span> <span class="token keyword">where</span> t2<span class="token punctuation">.</span>id<span class="token operator">&lt;=</span><span class="token number">50</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>两个语句使用 b 字段进行 join，所以都用不上索引。</p><p>但如果是用第二个语句的话，join_buffer 只需要放入 t2 的前 50 行，显然是更好的。所以这里，“t2 的前 50 行”是那个相对小的表，也就是“小表”。</p><p>继续看另一个例子</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> t1<span class="token punctuation">.</span>b<span class="token punctuation">,</span>t2<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">from</span>  t1  straight_join t2 <span class="token keyword">on</span> <span class="token punctuation">(</span>t1<span class="token punctuation">.</span>b<span class="token operator">=</span>t2<span class="token punctuation">.</span>b<span class="token punctuation">)</span> <span class="token keyword">where</span> t2<span class="token punctuation">.</span>id<span class="token operator">&lt;=</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">select</span> t1<span class="token punctuation">.</span>b<span class="token punctuation">,</span>t2<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">from</span>  t2  straight_join t1 <span class="token keyword">on</span> <span class="token punctuation">(</span>t1<span class="token punctuation">.</span>b<span class="token operator">=</span>t2<span class="token punctuation">.</span>b<span class="token punctuation">)</span> <span class="token keyword">where</span> t2<span class="token punctuation">.</span>id<span class="token operator">&lt;=</span><span class="token number">100</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>两个语句都是使用 b 字段进行 join，所以都用不上索引。并且 表t1 和 表t2 的数据量都是100行。</p><p>但是，这两条语句每次查询放入 join_buffer 中的数据是不一样的：</p><ul><li>表 t1 只查字段 b，因此如果把 t1 放到 join_buffer 中，则 join_buffer 中只需要放入 b 的值；</li><li>表 t2 需要查所有的字段，因此如果把表 t2 放到 join_buffer 中的话，就需要放入三个字段 id、a 和 b。</li></ul><p>所以这里，我们应该选择表 t1 作为驱动表。也就是说在这个例子里，“只需要一列参与 join 的表 t1”是那个相对小的表。</p><h2 id="JOIN语句的优化"><a href="#JOIN语句的优化" class="headerlink" title="JOIN语句的优化"></a>JOIN语句的优化</h2><p>在上文，我们知道了什么时候可以使用 JOIN 语句，以及 JOIN 语句是怎么的内部执行逻辑，这一节我们来看一下怎么优化 JOIN 语句。</p><h3 id="数据准备-1"><a href="#数据准备-1" class="headerlink" title="数据准备"></a>数据准备</h3><ul><li>表 t1 里，插入了 1000 行数据，每一行的 a&#x3D;1001-id 的值。也就是说，表 t1 中字段 a 是逆序的</li><li>表 t2 中插入了 100 万行数据</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> t1<span class="token punctuation">(</span>id <span class="token keyword">int</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">,</span> a <span class="token keyword">int</span><span class="token punctuation">,</span> b <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">index</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">table</span> t2 <span class="token operator">like</span> t1<span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">procedure</span> idata<span class="token punctuation">;</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">procedure</span> idata<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">begin</span>  <span class="token keyword">declare</span> i <span class="token keyword">int</span><span class="token punctuation">;</span>  <span class="token keyword">set</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token keyword">do</span>    <span class="token keyword">insert</span> <span class="token keyword">into</span> t1 <span class="token keyword">values</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1001</span><span class="token operator">-</span>i<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">set</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span>    <span class="token keyword">set</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token keyword">do</span>    <span class="token keyword">insert</span> <span class="token keyword">into</span> t2 <span class="token keyword">values</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">set</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token keyword">call</span> idata<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Multi-Range-Read-（MRR）优化"><a href="#Multi-Range-Read-（MRR）优化" class="headerlink" title="Multi-Range Read （MRR）优化"></a>Multi-Range Read （MRR）优化</h3><p>什么是MRR优化</p><p>当回表的数据量比较多的时候，将需要回表的主键id先暂存到内存中，然后进行排序，将排序后的id在进行回表，此时id是顺序的，此时回表，近似于磁盘的顺序读。可以提高性能</p><p>MRR优化默认是关闭的，开启：set optimizer_switch&#x3D;”mrr_cost_based&#x3D;off”</p><p>如果使用了 order by 语句，MRR就不生效了</p><h3 id="Batched-Key-Access（BKA）"><a href="#Batched-Key-Access（BKA）" class="headerlink" title="Batched Key Access（BKA）"></a>Batched Key Access（BKA）</h3><p>BKA 算法，其实就是对 NLJ 算法的优化</p><h1 id="——————————"><a href="#——————————" class="headerlink" title="——————————-"></a>——————————-</h1><p>mysql</p><p>临时文件和临时表</p><p>临时表：为什么这里的临时表使用的引擎是memory？ A：tmp_table_size 这个配置限制了内存临时表的大小，默认值是 16M。如果临时表大小超过了 tmp_table_size，那么内存临时表就会转成磁盘临时表；磁盘临时表使用的引擎默认是 InnoDB，是由参数 internal_tmp_disk_storage_engine 控制的。而内存临时表使用的是memory引擎</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 创建表t2，主键索引和字段a的普通索引</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>t2<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>a<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>b<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>a<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>a<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span><span class="token comment">-- 通过存储过程，初始化1000条记录</span><span class="token keyword">drop</span> <span class="token keyword">procedure</span> idata<span class="token punctuation">;</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">procedure</span> idata<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">begin</span>  <span class="token keyword">declare</span> i <span class="token keyword">int</span><span class="token punctuation">;</span>  <span class="token keyword">set</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token keyword">do</span>    <span class="token keyword">insert</span> <span class="token keyword">into</span> t2 <span class="token keyword">values</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">set</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token keyword">call</span> idata<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 创建表t1，主键索引和字段a的普通索引</span><span class="token comment">-- 初始化100条记录</span><span class="token keyword">create</span> <span class="token keyword">table</span> t1 <span class="token operator">like</span> t2<span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t1 <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t2 <span class="token keyword">where</span> id<span class="token operator">&lt;=</span><span class="token number">100</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="驱动表使用索引字段关联；被驱动表使用索引关联；查所有字段"><a href="#驱动表使用索引字段关联；被驱动表使用索引关联；查所有字段" class="headerlink" title="驱动表使用索引字段关联；被驱动表使用索引关联；查所有字段"></a>驱动表使用索引字段关联；被驱动表使用索引关联；查所有字段</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 straight_join t2 <span class="token keyword">on</span> t1<span class="token punctuation">.</span>a <span class="token operator">=</span> t2<span class="token punctuation">.</span>a<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+---------+------+----------+-------------+</span><span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>  <span class="token operator">|</span> key_len <span class="token operator">|</span> ref     <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra       <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+---------+------+----------+-------------+</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> t1    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> a             <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span>  <span class="token number">100</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> t2    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> ref  <span class="token operator">|</span> a             <span class="token operator">|</span> a    <span class="token operator">|</span> <span class="token number">5</span>       <span class="token operator">|</span> zs<span class="token punctuation">.</span>t1<span class="token punctuation">.</span>a <span class="token operator">|</span>    <span class="token number">1</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>        <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+---------+------+----------+-------------+</span><span class="token number">2</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么驱动表的字段a有索引，为啥不走索引呢？</p><ul><li>原因可能是因为没有过滤条件；</li></ul><h4 id="驱动表使用索引字段关联；被驱动表使用索引关联；查所有字段；驱动表添加过滤条件"><a href="#驱动表使用索引字段关联；被驱动表使用索引关联；查所有字段；驱动表添加过滤条件" class="headerlink" title="驱动表使用索引字段关联；被驱动表使用索引关联；查所有字段；驱动表添加过滤条件"></a>驱动表使用索引字段关联；被驱动表使用索引关联；查所有字段；驱动表添加过滤条件</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 straight_join t2 <span class="token keyword">on</span> t1<span class="token punctuation">.</span>a <span class="token operator">=</span> t2<span class="token punctuation">.</span>a <span class="token keyword">where</span> t1<span class="token punctuation">.</span>a <span class="token operator">></span> <span class="token number">50</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+---------+------+----------+-------------+</span><span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>  <span class="token operator">|</span> key_len <span class="token operator">|</span> ref     <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra       <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+---------+------+----------+-------------+</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> t1    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> a             <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span>  <span class="token number">100</span> <span class="token operator">|</span>    <span class="token number">50.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> t2    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> ref  <span class="token operator">|</span> a             <span class="token operator">|</span> a    <span class="token operator">|</span> <span class="token number">5</span>       <span class="token operator">|</span> zs<span class="token punctuation">.</span>t1<span class="token punctuation">.</span>a <span class="token operator">|</span>    <span class="token number">1</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>        <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+---------+------+----------+-------------+</span><span class="token number">2</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么驱动表的字段a有索引，而且添加了过滤条件，还是不走索引呢？</p><ul><li>因为是查询的 * ，即使走了索引 a，还是需要回表，优化器认为还不如直接走全表呢</li><li>因为过滤条件过滤的数据比较少，只过滤了50%，优化器认为全表扫描比走索引更快</li></ul><h4 id="驱动表使用索引字段关联；被驱动表使用索引关联；查驱动表的主键id；驱动表添加过滤条件"><a href="#驱动表使用索引字段关联；被驱动表使用索引关联；查驱动表的主键id；驱动表添加过滤条件" class="headerlink" title="驱动表使用索引字段关联；被驱动表使用索引关联；查驱动表的主键id；驱动表添加过滤条件"></a>驱动表使用索引字段关联；被驱动表使用索引关联；查驱动表的主键id；驱动表添加过滤条件</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">explain</span> <span class="token keyword">select</span> t1<span class="token punctuation">.</span>id <span class="token keyword">from</span> t1 straight_join t2 <span class="token keyword">on</span> t1<span class="token punctuation">.</span>a <span class="token operator">=</span> t2<span class="token punctuation">.</span>a <span class="token keyword">where</span> t1<span class="token punctuation">.</span>a <span class="token operator">></span> <span class="token number">50</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+-------+---------------+------+---------+---------+------+----------+--------------------------+</span><span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span>  <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>  <span class="token operator">|</span> key_len <span class="token operator">|</span> ref     <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra                    <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+-------+---------------+------+---------+---------+------+----------+--------------------------+</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> t1    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> range <span class="token operator">|</span> a             <span class="token operator">|</span> a    <span class="token operator">|</span> <span class="token number">5</span>       <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span>   <span class="token number">50</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span><span class="token punctuation">;</span> <span class="token keyword">Using</span> <span class="token keyword">index</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> t2    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> ref   <span class="token operator">|</span> a             <span class="token operator">|</span> a    <span class="token operator">|</span> <span class="token number">5</span>       <span class="token operator">|</span> zs<span class="token punctuation">.</span>t1<span class="token punctuation">.</span>a <span class="token operator">|</span>    <span class="token number">1</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">index</span>              <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+-------+---------------+------+---------+---------+------+----------+--------------------------+</span><span class="token number">2</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>驱动表的字段a有索引，而且添加了过滤条件，查询驱动表的主键id，会用到覆盖索引，不回表了，所以走了索引；</p><h4 id="驱动表使用索引字段关联；被驱动表使用索引关联；查所有字段；驱动表添加过滤条件，大范围过滤"><a href="#驱动表使用索引字段关联；被驱动表使用索引关联；查所有字段；驱动表添加过滤条件，大范围过滤" class="headerlink" title="驱动表使用索引字段关联；被驱动表使用索引关联；查所有字段；驱动表添加过滤条件，大范围过滤"></a>驱动表使用索引字段关联；被驱动表使用索引关联；查所有字段；驱动表添加过滤条件，大范围过滤</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 straight_join t2 <span class="token keyword">on</span> t1<span class="token punctuation">.</span>a <span class="token operator">=</span> t2<span class="token punctuation">.</span>a <span class="token keyword">where</span> t1<span class="token punctuation">.</span>a <span class="token operator">></span> <span class="token number">90</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+-------+---------------+------+---------+---------+------+----------+-----------------------+</span><span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span>  <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>  <span class="token operator">|</span> key_len <span class="token operator">|</span> ref     <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra                 <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+-------+---------------+------+---------+---------+------+----------+-----------------------+</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> t1    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> range <span class="token operator">|</span> a             <span class="token operator">|</span> a    <span class="token operator">|</span> <span class="token number">5</span>       <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span>   <span class="token number">10</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">index</span> condition <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> t2    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> ref   <span class="token operator">|</span> a             <span class="token operator">|</span> a    <span class="token operator">|</span> <span class="token number">5</span>       <span class="token operator">|</span> zs<span class="token punctuation">.</span>t1<span class="token punctuation">.</span>a <span class="token operator">|</span>    <span class="token number">1</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>                  <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+-------+---------------+------+---------+---------+------+----------+-----------------------+</span><span class="token number">2</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>驱动表的字段a有索引，而且添加了过滤条件，虽然查询的是所有字段，需要回表，但是因为过滤条件过滤90%的数据，优化器因为回表比全表扫描代价低</p><p>以上的情况适用于 t1 的单表查询也是一样的，所以总结下来 join查询其实就是多个单表查询，然后汇总在一起；</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- ALL</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1<span class="token punctuation">;</span><span class="token comment">-- ALL</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> t1<span class="token punctuation">.</span>a <span class="token operator">></span> <span class="token number">50</span><span class="token punctuation">;</span><span class="token comment">-- range</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> t1<span class="token punctuation">.</span>a <span class="token operator">></span> <span class="token number">90</span><span class="token punctuation">;</span><span class="token comment">-- range</span><span class="token keyword">explain</span> <span class="token keyword">select</span> id <span class="token keyword">from</span> t1 <span class="token keyword">where</span> t1<span class="token punctuation">.</span>a <span class="token operator">></span> <span class="token number">50</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>mysql5</p><ul><li>Using where; Using join buffer (Block Nested Loop)</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 straight_join t2 <span class="token keyword">on</span> t1<span class="token punctuation">.</span>a <span class="token operator">=</span> t2<span class="token punctuation">.</span>b<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span><span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>  <span class="token operator">|</span> key_len <span class="token operator">|</span> ref  <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra                                              <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> t1    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> a             <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span>  <span class="token number">100</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>                                               <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> t2    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> <span class="token boolean">NULL</span>          <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token number">1000</span> <span class="token operator">|</span>    <span class="token number">10.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span><span class="token punctuation">;</span> <span class="token keyword">Using</span> <span class="token keyword">join</span> buffer <span class="token punctuation">(</span>Block Nested <span class="token keyword">Loop</span><span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span><span class="token number">2</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.06</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>mysql8</p><ul><li>Using where; Using join buffer (hash join)</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 straight_join t2 <span class="token keyword">on</span> t1<span class="token punctuation">.</span>a <span class="token operator">=</span> t2<span class="token punctuation">.</span>b<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span><span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>  <span class="token operator">|</span> key_len <span class="token operator">|</span> ref  <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra                                      <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> t1    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> a             <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span>  <span class="token number">100</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>                                       <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> t2    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> <span class="token boolean">NULL</span>          <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token number">1000</span> <span class="token operator">|</span>    <span class="token number">10.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span><span class="token punctuation">;</span> <span class="token keyword">Using</span> <span class="token keyword">join</span> buffer <span class="token punctuation">(</span><span class="token keyword">hash</span> <span class="token keyword">join</span><span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span><span class="token number">2</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用order by的话，就不会使用MRR了</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">set</span> optimizer_switch<span class="token operator">=</span><span class="token string">"mrr_cost_based=off"</span><span class="token punctuation">;</span>Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t2 <span class="token keyword">where</span> a <span class="token operator">>=</span> <span class="token number">100</span> <span class="token operator">and</span> a<span class="token operator">&lt;=</span><span class="token number">200</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+----------------------------------+</span><span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span>  <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>  <span class="token operator">|</span> key_len <span class="token operator">|</span> ref  <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra                            <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+----------------------------------+</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> t2    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> range <span class="token operator">|</span> a             <span class="token operator">|</span> a    <span class="token operator">|</span> <span class="token number">5</span>       <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span>  <span class="token number">101</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">index</span> condition<span class="token punctuation">;</span> <span class="token keyword">Using</span> MRR <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+----------------------------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t2 <span class="token keyword">where</span> a <span class="token operator">>=</span> <span class="token number">100</span> <span class="token operator">and</span> a<span class="token operator">&lt;=</span><span class="token number">200</span> <span class="token keyword">order</span> <span class="token keyword">by</span> a <span class="token keyword">asc</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-----------------------+</span><span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span>  <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>  <span class="token operator">|</span> key_len <span class="token operator">|</span> ref  <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra                 <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-----------------------+</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> t2    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> range <span class="token operator">|</span> a             <span class="token operator">|</span> a    <span class="token operator">|</span> <span class="token number">5</span>       <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span>  <span class="token number">101</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">index</span> condition <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-----------------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>mysql的临时表存放位置</p><p>在 5.6 以及之前的版本里，MySQL 会在临时文件目录下创建一个相同前缀、以.ibd 为后缀的文件，用来存放数据文件；</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'tmpdir'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">---------------+-------------------------------------------------+</span><span class="token operator">|</span> Variable_name <span class="token operator">|</span> <span class="token keyword">Value</span>                                           <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">---------------+-------------------------------------------------+</span><span class="token operator">|</span> tmpdir        <span class="token operator">|</span> C:\Windows\SERVIC<span class="token operator">~</span><span class="token number">1</span>\NETWOR<span class="token operator">~</span><span class="token number">1</span>\AppData\<span class="token keyword">Local</span>\<span class="token keyword">Temp</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">---------------+-------------------------------------------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>其中 C:\Windows\SERVIC<del>1\NETWOR</del>1\AppData\Local\Temp  就是临时文件目录，其中的 SERVIC<del>1\NETWOR</del>1 是啥意思，我不知道</li><li>我是win电脑，可以创建一个临时表，然后用everything搜一下，就能找到这个目录</li></ul><p>而从 5.7 版本开始，MySQL 引入了一个临时文件表空间，专门用来存放临时文件的数据。因此，我们就不需要再创建 ibd 文件了。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'innodb_temp_data_file_path'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----------------------------+-----------------------+</span><span class="token operator">|</span> Variable_name              <span class="token operator">|</span> <span class="token keyword">Value</span>                 <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----------------------------+-----------------------+</span><span class="token operator">|</span> innodb_temp_data_file_path <span class="token operator">|</span> ibtmp1:<span class="token number">12</span>M:autoextend <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----------------------------+-----------------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>innodb_temp_data_file_path：定义临时表空间的路径、文件名、初始化大小和最大上限。</li><li>其中<code>ibtmp1</code>就是临时文件表空间，它在windows下是一个文件，不是一个目录。</li></ul><p><img src="/mysql%E7%9A%84%E4%B8%B4%E6%97%B6%E8%A1%A8%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F.assets/image-20230105211938528.png" alt="image-20230105211938528"></p><h1 id="分区表的底层原理"><a href="#分区表的底层原理" class="headerlink" title="分区表的底层原理"></a>分区表的底层原理</h1><p>​分区表由多个相关的底层表实现，这个底层表也是由句柄对象标识，我们可以直接访问各个分区。存储引擎管理分区的各个底层表和管理普通表一样（所有的底层表都必须使用相同的存储引擎），分区表的索引知识在各个底层表上各自加上一个完全相同的索引。从存储引擎的角度来看，底层表和普通表没有任何不同，存储引擎也无须知道这是一个普通表还是一个分区表的一部分。</p><p>​分区表的操作按照以下的操作逻辑进行：</p><p>​<strong>select查询</strong></p><p>​当查询一个分区表的时候，分区层先打开并锁住所有的底层表，优化器先判断是否可以过滤部分分区，然后再调用对应的存储引擎接口访问各个分区的数据</p><p>​<strong>insert操作</strong></p><p>​当写入一条记录的时候，分区层先打开并锁住所有的底层表，然后确定哪个分区接受这条记录，再将记录写入对应底层表</p><p>​<strong>delete操作</strong></p><p>​当删除一条记录时，分区层先打开并锁住所有的底层表，然后确定数据对应的分区，最后对相应底层表进行删除操作</p><p>​<strong>update操作</strong></p><p>​当更新一条记录时，分区层先打开并锁住所有的底层表，mysql先确定需要更新的记录再哪个分区，然后取出数据并更新，再判断更新后的数据应该再哪个分区，最后对底层表进行写入操作，并对源数据所在的底层表进行删除操作</p><p>​有些操作时支持过滤的，例如，当删除一条记录时，MySQL需要先找到这条记录，如果where条件恰好和分区表达式匹配，就可以将所有不包含这条记录的分区都过滤掉，这对update同样有效。如果是insert操作，则本身就是只命中一个分区，其他分区都会被过滤掉。mysql先确定这条记录属于哪个分区，再将记录写入对应得曾分区表，无须对任何其他分区进行操作</p><p>​虽然每个操作都会“先打开并锁住所有的底层表”，但这并不是说分区表在处理过程中是锁住全表的，如果存储引擎能够自己实现行级锁，例如innodb，则会在分区层释放对应表锁。</p><h1 id="范围分区"><a href="#范围分区" class="headerlink" title="范围分区"></a>范围分区</h1><p>​范围分区表的分区方式是：每个分区都包含行数据且分区的表达式在给定的范围内，分区的范围应该是连续的且不能重叠，可以使用values less than运算符来定义。</p><p>​1、创建普通的表</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> employees <span class="token punctuation">(</span>    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    fname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    lname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    hired <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'1970-01-01'</span><span class="token punctuation">,</span>    separated <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'9999-12-31'</span><span class="token punctuation">,</span>    job_code <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    store_id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​2、创建带分区的表，下面建表的语句是按照store_id来进行分区的，指定了4个分区</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> employees <span class="token punctuation">(</span>    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    fname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    lname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    hired <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'1970-01-01'</span><span class="token punctuation">,</span>    separated <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'9999-12-31'</span><span class="token punctuation">,</span>    job_code <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    store_id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token punctuation">(</span>store_id<span class="token punctuation">)</span> <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">--在当前的建表语句中可以看到，store_id的值在1-5的在p0分区，6-10的在p1分区，11-15的在p3分区，16-20的在p4分区，但是如果插入超过20的值就会报错，因为mysql不知道将数据放在哪个分区</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​3、可以使用less than maxvalue来避免此种情况</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> employees <span class="token punctuation">(</span>    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    fname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    lname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    hired <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'1970-01-01'</span><span class="token punctuation">,</span>    separated <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'9999-12-31'</span><span class="token punctuation">,</span>    job_code <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    store_id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token punctuation">(</span>store_id<span class="token punctuation">)</span> <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN MAXVALUE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">--maxvalue表示始终大于等于最大可能整数值的整数值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​4、可以使用相同的方式根据员工的职务代码对表进行分区</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> employees <span class="token punctuation">(</span>    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    fname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    lname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    hired <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'1970-01-01'</span><span class="token punctuation">,</span>    separated <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'9999-12-31'</span><span class="token punctuation">,</span>    job_code <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    store_id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token punctuation">(</span>job_code<span class="token punctuation">)</span> <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​5、可以使用date类型进行分区：如虚妄根据每个员工离开公司的年份进行划分，如year(separated)</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> employees <span class="token punctuation">(</span>    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    fname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    lname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    hired <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'1970-01-01'</span><span class="token punctuation">,</span>    separated <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'9999-12-31'</span><span class="token punctuation">,</span>    job_code <span class="token keyword">INT</span><span class="token punctuation">,</span>    store_id <span class="token keyword">INT</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token punctuation">(</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>separated<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">1991</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">1996</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">2001</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN MAXVALUE<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​6、可以使用函数根据range的值来对表进行分区，如timestampunix_timestamp()</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> quarterly_report_status <span class="token punctuation">(</span>    report_id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    report_status <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    report_updated <span class="token keyword">TIMESTAMP</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span>report_updated<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2008-01-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2008-04-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2008-07-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2008-10-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p4 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2009-01-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p5 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2009-04-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p6 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2009-07-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p7 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2009-10-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p8 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2010-01-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p9 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span>MAXVALUE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">--timestamp不允许使用任何其他涉及值的表达式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基于时间间隔的分区方案，在mysql5.7中，可以基于范围或事件间隔实现分区方案，有两种选择</p><p>1、基于范围的分区，对于分区表达式，可以使用操作函数基于date、time、或者datatime列来返回一个整数值</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> members <span class="token punctuation">(</span>    firstname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    lastname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    username <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    email <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">35</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    joined <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE<span class="token punctuation">(</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>joined<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">1960</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">1970</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">1980</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">1990</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p4 <span class="token keyword">VALUES</span> LESS THAN MAXVALUE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> quarterly_report_status <span class="token punctuation">(</span>    report_id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    report_status <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    report_updated <span class="token keyword">TIMESTAMP</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span>report_updated<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2008-01-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2008-04-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2008-07-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2008-10-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p4 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2009-01-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p5 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2009-04-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p6 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2009-07-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p7 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2009-10-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p8 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2010-01-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p9 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span>MAXVALUE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、基于范围列的分区，使用date或者datatime列作为分区列</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> members <span class="token punctuation">(</span>    firstname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    lastname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    username <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    email <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">35</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    joined <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token keyword">COLUMNS</span><span class="token punctuation">(</span>joined<span class="token punctuation">)</span> <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token string">'1960-01-01'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token string">'1970-01-01'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token string">'1980-01-01'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token string">'1990-01-01'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p4 <span class="token keyword">VALUES</span> LESS THAN MAXVALUE<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="真实案例："><a href="#真实案例：" class="headerlink" title="真实案例："></a>真实案例：</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#不分区的表</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> no_part_tab<span class="token punctuation">(</span>id <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>remark <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>d_date <span class="token keyword">DATE</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token keyword">ENGINE</span><span class="token operator">=</span>MYISAM<span class="token punctuation">;</span><span class="token comment">#分区的表</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> part_tab<span class="token punctuation">(</span>id <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>remark <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>d_date <span class="token keyword">DATE</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token keyword">ENGINE</span><span class="token operator">=</span>MYISAM<span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE<span class="token punctuation">(</span><span class="token keyword">YEAR</span><span class="token punctuation">(</span>d_date<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN<span class="token punctuation">(</span><span class="token number">1995</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN<span class="token punctuation">(</span><span class="token number">1996</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN<span class="token punctuation">(</span><span class="token number">1997</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN<span class="token punctuation">(</span><span class="token number">1998</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">PARTITION</span> p4 <span class="token keyword">VALUES</span> LESS THAN<span class="token punctuation">(</span><span class="token number">1999</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">PARTITION</span> p5 <span class="token keyword">VALUES</span> LESS THAN<span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">PARTITION</span> p6 <span class="token keyword">VALUES</span> LESS THAN<span class="token punctuation">(</span><span class="token number">2001</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">PARTITION</span> p7 <span class="token keyword">VALUES</span> LESS THAN<span class="token punctuation">(</span><span class="token number">2002</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">PARTITION</span> p8 <span class="token keyword">VALUES</span> LESS THAN<span class="token punctuation">(</span><span class="token number">2003</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">PARTITION</span> p9 <span class="token keyword">VALUES</span> LESS THAN<span class="token punctuation">(</span><span class="token number">2004</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">PARTITION</span> p10 <span class="token keyword">VALUES</span> LESS THAN maxvalue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">#插入未分区表记录</span><span class="token keyword">DROP</span> <span class="token keyword">PROCEDURE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> no_load_part<span class="token punctuation">;</span> <span class="token keyword">DELIMITER</span><span class="token comment">//</span><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> no_load_part<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span>    <span class="token keyword">DECLARE</span> i <span class="token keyword">INT</span><span class="token punctuation">;</span>    <span class="token keyword">SET</span> i <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">WHILE</span> i<span class="token operator">&lt;</span><span class="token number">80001</span>    <span class="token keyword">DO</span>    <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> no_part_tab <span class="token keyword">VALUES</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token string">'no'</span><span class="token punctuation">,</span>ADDDATE<span class="token punctuation">(</span><span class="token string">'1995-01-01'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>RAND<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">36520</span><span class="token punctuation">)</span> MOD <span class="token number">3652</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">SET</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">END</span> <span class="token keyword">WHILE</span><span class="token punctuation">;</span><span class="token keyword">END</span><span class="token comment">//</span><span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span> <span class="token keyword">CALL</span> no_load_part<span class="token punctuation">;</span><span class="token comment">#插入分区表记录</span><span class="token keyword">DROP</span> <span class="token keyword">PROCEDURE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> load_part<span class="token punctuation">;</span> <span class="token keyword">DELIMITER</span><span class="token operator">&amp;&amp;</span> <span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> load_part<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span>    <span class="token keyword">DECLARE</span> i <span class="token keyword">INT</span><span class="token punctuation">;</span>    <span class="token keyword">SET</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">WHILE</span> i<span class="token operator">&lt;</span><span class="token number">80001</span>    <span class="token keyword">DO</span>    <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> part_tab <span class="token keyword">VALUES</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token string">'partition'</span><span class="token punctuation">,</span>ADDDATE<span class="token punctuation">(</span><span class="token string">'1995-01-01'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>RAND<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">36520</span><span class="token punctuation">)</span> MOD <span class="token number">3652</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">SET</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">END</span> <span class="token keyword">WHILE</span><span class="token punctuation">;</span><span class="token keyword">END</span><span class="token operator">&amp;&amp;</span><span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span> <span class="token keyword">CALL</span> load_part<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;mysql临时表的xmind，&lt;a href=&quot;&quot;&gt;点击下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;#### 临时表相关 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;17 | 如何正确地显示随机消息？ &lt;/li&gt;
&lt;li&gt;34 | 到底可不可以使用join？ &lt;/li&gt;
&lt;li&gt;35 | join语句怎么</summary>
      
    
    
    
    <category term="JAVA" scheme="https://zspcer.gitee.io/categories/JAVA/"/>
    
    <category term="数据库" scheme="https://zspcer.gitee.io/categories/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MYSQL" scheme="https://zspcer.gitee.io/categories/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL/"/>
    
    
    <category term="mysql" scheme="https://zspcer.gitee.io/tags/mysql/"/>
    
    <category term="join" scheme="https://zspcer.gitee.io/tags/join/"/>
    
    <category term="临时表" scheme="https://zspcer.gitee.io/tags/%E4%B8%B4%E6%97%B6%E8%A1%A8/"/>
    
    <category term="order by" scheme="https://zspcer.gitee.io/tags/order-by/"/>
    
    <category term="分区表" scheme="https://zspcer.gitee.io/tags/%E5%88%86%E5%8C%BA%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>mysql的SQL优化实战</title>
    <link href="https://zspcer.gitee.io/note/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL/mysql%E7%9A%84SQL%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/"/>
    <id>https://zspcer.gitee.io/note/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL/mysql%E7%9A%84SQL%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/</id>
    <published>2023-03-15T04:24:10.502Z</published>
    <updated>2023-03-15T04:24:10.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql的SQL优化实战"><a href="#mysql的SQL优化实战" class="headerlink" title="mysql的SQL优化实战"></a>mysql的SQL优化实战</h1><p>以下是公司实际业务上的SQL调优实战</p><h2 id="金铎项目"><a href="#金铎项目" class="headerlink" title="金铎项目"></a>金铎项目</h2><p>金铎项目是一个异常汇总平台，属于半路接手的项目，其中有很多sql都是比较复杂的，可读性差，维护性差，正好拿来练练手</p><h3 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h3><p>一下是涉及的相关表结构</p><h4 id="amp-event-log"><a href="#amp-event-log" class="headerlink" title="amp_event_log"></a>amp_event_log</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- auto-generated definition</span><span class="token keyword">create</span> <span class="token keyword">table</span> amp_event_log<span class="token punctuation">(</span>    id                         <span class="token keyword">bigint</span> <span class="token keyword">auto_increment</span> <span class="token keyword">comment</span> <span class="token string">'id'</span>        <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">,</span>    event_id                   <span class="token keyword">bigint</span>                             <span class="token operator">not</span> <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'事件ID'</span><span class="token punctuation">,</span>    event_code                 <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span>                       <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'事件代码'</span><span class="token punctuation">,</span>    event_name                 <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span>                       <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'事件名称'</span><span class="token punctuation">,</span>    exception_subject          <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">512</span><span class="token punctuation">)</span>                       <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'异常主体'</span><span class="token punctuation">,</span>    monitor_object_name        <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span>                       <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'监控对象名称'</span><span class="token punctuation">,</span>    process_status             <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span>                       <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'处理状态'</span><span class="token punctuation">,</span>    happen_time                <span class="token keyword">datetime</span>                           <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'发生时间'</span><span class="token punctuation">,</span>    exception_level            <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span>                       <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'异常等级'</span><span class="token punctuation">,</span>    event_detail               <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span>                      <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'事件详情'</span><span class="token punctuation">,</span>    last_event_id              <span class="token keyword">bigint</span>                             <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'上一级事件id'</span><span class="token punctuation">,</span>    timeout                    <span class="token keyword">datetime</span>                           <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'超时时间'</span><span class="token punctuation">,</span>    version                    <span class="token keyword">bigint</span>                             <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'版本'</span><span class="token punctuation">,</span>    push_user                  <span class="token keyword">text</span>                               <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'推送对象'</span><span class="token punctuation">,</span>    is_push                    <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span>                       <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'是否推送'</span><span class="token punctuation">,</span>    process_user               <span class="token keyword">text</span>                               <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'处理对象'</span><span class="token punctuation">,</span>    actual_process_user        <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span>                       <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'实际处理人'</span><span class="token punctuation">,</span>    feedback_duty_organization <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span>                       <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'反馈责任组织'</span><span class="token punctuation">,</span>    feedback_process_results   <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">512</span><span class="token punctuation">)</span>                       <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'反馈处理结果'</span><span class="token punctuation">,</span>    feedback_note              <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span>                      <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'具体原因'</span><span class="token punctuation">,</span>    start_process_time         <span class="token keyword">datetime</span>                           <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'开始处理时间'</span><span class="token punctuation">,</span>    end_process_time           <span class="token keyword">datetime</span>                           <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'结束处理时间'</span><span class="token punctuation">,</span>    reason                     <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span>                       <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'原因'</span><span class="token punctuation">,</span>    create_time                <span class="token keyword">datetime</span>                           <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'创建时间'</span><span class="token punctuation">,</span>    detail_url                 <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">charset</span> utf8mb4       <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'明细路径'</span><span class="token punctuation">,</span>    is_transfer                <span class="token keyword">bigint</span>   <span class="token keyword">default</span> <span class="token number">0</span>                 <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'是否转办 0：否 ，1：是'</span><span class="token punctuation">,</span>    transfer_user              <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span>                       <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'转办人'</span><span class="token punctuation">,</span>    is_approve                 <span class="token keyword">bigint</span>                             <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'是否审批 0:否 1:是'</span><span class="token punctuation">,</span>    process_opinion            <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span>                       <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'处理意见'</span><span class="token punctuation">,</span>    evaluate                   <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span>                      <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'评价'</span><span class="token punctuation">,</span>    approve_status             <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span>                       <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'审批人状态'</span><span class="token punctuation">,</span>    predict_improve_time       <span class="token keyword">datetime</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>                        <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'预计改善时间'</span><span class="token punctuation">,</span>    approve_user               <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span>                       <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'审批人'</span><span class="token punctuation">,</span>    latest_improve_time        <span class="token keyword">datetime</span>                           <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'最晚改善时间'</span><span class="token punctuation">,</span>    update_time                <span class="token keyword">datetime</span> <span class="token keyword">default</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token operator">not</span> <span class="token boolean">null</span> <span class="token keyword">on</span> <span class="token keyword">update</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">comment</span> <span class="token string">'更新时间'</span><span class="token punctuation">,</span>    actual_approve_user        <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span>                       <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'实际审批人'</span><span class="token punctuation">,</span>    person_liable              <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span>                       <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'责任人'</span><span class="token punctuation">,</span>    improve_plan               <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">1500</span><span class="token punctuation">)</span>                      <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'改善方案'</span><span class="token punctuation">,</span>    predict_improve_target     <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>                        <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'预计改善目标'</span><span class="token punctuation">,</span>    prov                       <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>                        <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'省'</span><span class="token punctuation">,</span>    city                       <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>                        <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'城市'</span><span class="token punctuation">,</span>    transfer_time              <span class="token keyword">datetime</span>                           <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'转办时间'</span><span class="token punctuation">,</span>    feedback_process_images    <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span>                       <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'现场处理图片'</span><span class="token punctuation">)</span>    <span class="token keyword">comment</span> <span class="token string">'异常事件记录表'</span> <span class="token keyword">collate</span> <span class="token operator">=</span> utf8mb4_bin<span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">index</span> idx_actualuser_status <span class="token keyword">on</span> amp_event_log <span class="token punctuation">(</span>actual_process_user<span class="token punctuation">,</span> process_status<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">index</span> idx_approve_status_actual_approve_user <span class="token keyword">on</span> amp_event_log <span class="token punctuation">(</span>approve_status<span class="token punctuation">,</span> actual_approve_user<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">index</span> idx_city_happen_time <span class="token keyword">on</span> amp_event_log <span class="token punctuation">(</span>city<span class="token punctuation">,</span> happen_time<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">index</span> idx_event_code <span class="token keyword">on</span> amp_event_log <span class="token punctuation">(</span>event_code<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">index</span> idx_event_id <span class="token keyword">on</span> amp_event_log <span class="token punctuation">(</span>event_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">index</span> idx_exception_subject <span class="token keyword">on</span> amp_event_log <span class="token punctuation">(</span>exception_subject<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">index</span> idx_happendtime <span class="token keyword">on</span> amp_event_log <span class="token punctuation">(</span>happen_time<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="amp-site"><a href="#amp-site" class="headerlink" title="amp_site"></a>amp_site</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- auto-generated definition</span><span class="token keyword">create</span> <span class="token keyword">table</span> amp_site<span class="token punctuation">(</span>    id            <span class="token keyword">bigint</span>       <span class="token operator">not</span> <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'站点id'</span>        <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">,</span>    name          <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'站点名字'</span><span class="token punctuation">,</span>    area          <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token boolean">null</span><span class="token punctuation">,</span>    center_area   <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token boolean">null</span><span class="token punctuation">,</span>    province      <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'站点所属省'</span><span class="token punctuation">,</span>    business_area <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'站点所属的大区（浙北区）'</span><span class="token punctuation">,</span>    city          <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'站点所属城市'</span><span class="token punctuation">,</span>    county        <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'站点所属区'</span><span class="token punctuation">,</span>    sfcode        <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'大网code'</span><span class="token punctuation">,</span>    sf_site       <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>       <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'1是0否'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">index</span> amp_site_name_index <span class="token keyword">on</span> amp_site <span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="amp-event"><a href="#amp-event" class="headerlink" title="amp_event"></a>amp_event</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- auto-generated definition</span><span class="token keyword">create</span> <span class="token keyword">table</span> amp_event<span class="token punctuation">(</span>    id                   <span class="token keyword">bigint</span> <span class="token keyword">auto_increment</span> <span class="token keyword">comment</span> <span class="token string">'id'</span>        <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">,</span>    updator              <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span>                 <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'修改人'</span><span class="token punctuation">,</span>    update_time          <span class="token keyword">datetime</span>                     <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'修改时间'</span><span class="token punctuation">,</span>    create_time          <span class="token keyword">datetime</span>                     <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'创建时间'</span><span class="token punctuation">,</span>    event_code           <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span>                 <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'异常代码'</span><span class="token punctuation">,</span>    event_name           <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span>                 <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'名字'</span><span class="token punctuation">,</span>    monitor_id           <span class="token keyword">bigint</span>                       <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'监控对象id'</span><span class="token punctuation">,</span>    is_external          <span class="token keyword">bigint</span>                       <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'是否外部渠道接入'</span><span class="token punctuation">,</span>    <span class="token keyword">rule</span>                 <span class="token keyword">text</span>                         <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'触发规则'</span><span class="token punctuation">,</span>    message              <span class="token keyword">text</span>                         <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'消息详情'</span><span class="token punctuation">,</span>    upgrade_rule         <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span>                 <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'升级规则'</span><span class="token punctuation">,</span>    exception_level      <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span>                 <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'异常等级'</span><span class="token punctuation">,</span>    reason               <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span>                 <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'原因'</span><span class="token punctuation">,</span>    process_time         <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span>                 <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'处理时效'</span><span class="token punctuation">,</span>    process_cycle        <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span>                 <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'处理周期'</span><span class="token punctuation">,</span>    duty_organization_id <span class="token keyword">bigint</span>                       <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'责任组织id'</span><span class="token punctuation">,</span>    deal_organization_id <span class="token keyword">bigint</span>                       <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'处理组织id'</span><span class="token punctuation">,</span>    valid_time           <span class="token keyword">datetime</span>                     <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'有效时间'</span><span class="token punctuation">,</span>    version              <span class="token keyword">bigint</span> <span class="token keyword">default</span> <span class="token number">1001</span>          <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'版本号'</span><span class="token punctuation">,</span>    is_history           <span class="token keyword">bigint</span> <span class="token keyword">default</span> <span class="token number">0</span>             <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'是否历史版本:0否,1是'</span><span class="token punctuation">,</span>    detail_url           <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">charset</span> utf8mb4 <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'明细路径'</span><span class="token punctuation">,</span>    push_frequency       <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span>                 <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'推送频率 天 ,周，双周，月'</span><span class="token punctuation">,</span>    push_day             <span class="token keyword">bigint</span>                       <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'推送日期'</span><span class="token punctuation">,</span>    latest_improve_day   <span class="token keyword">bigint</span>                       <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'最晚改善时间(天)'</span><span class="token punctuation">,</span>    is_approve           <span class="token keyword">bigint</span>                       <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'是否审批 0:否 1:是'</span><span class="token punctuation">,</span>    approve_user         <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span>                 <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'审批人'</span><span class="token punctuation">,</span>    rule_explain         <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">3072</span><span class="token punctuation">)</span>                <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'规则说明'</span><span class="token punctuation">,</span>    push_job_id          <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span>                 <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'推送岗位ID'</span><span class="token punctuation">,</span>    process_job_id       <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span>                 <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'处理岗位id'</span><span class="token punctuation">,</span>    franchise_fee        <span class="token keyword">decimal</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>               <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'加盟商收入'</span><span class="token punctuation">)</span>    <span class="token keyword">comment</span> <span class="token string">'异常事件表'</span> <span class="token keyword">collate</span> <span class="token operator">=</span> utf8mb4_bin<span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">index</span> idx_dealorganizationid <span class="token keyword">on</span> amp_event <span class="token punctuation">(</span>deal_organization_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">index</span> idx_dutyorganizationid <span class="token keyword">on</span> amp_event <span class="token punctuation">(</span>duty_organization_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">index</span> idx_event_code_version <span class="token keyword">on</span> amp_event <span class="token punctuation">(</span>event_code<span class="token punctuation">,</span> version<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">index</span> idx_monitorid <span class="token keyword">on</span> amp_event <span class="token punctuation">(</span>monitor_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="优化SQL一"><a href="#优化SQL一" class="headerlink" title="优化SQL一"></a>优化SQL一</h3><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span><span class="token keyword">SELECT</span> t1<span class="token punctuation">.</span>process_status <span class="token keyword">AS</span> <span class="token keyword">STATUS</span><span class="token punctuation">,</span>       <span class="token function">count</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span>id<span class="token punctuation">)</span>         cnt<span class="token keyword">FROM</span> amp_event_log t1<span class="token keyword">JOIN</span>     <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> amp_site <span class="token keyword">where</span> sf_site <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span>     t3 <span class="token keyword">ON</span> t3<span class="token punctuation">.</span>NAME <span class="token operator">=</span> t1<span class="token punctuation">.</span>exception_subject<span class="token keyword">JOIN</span> <span class="token punctuation">(</span> <span class="token keyword">SELECT</span> event_code<span class="token punctuation">,</span>deal_organization_id <span class="token keyword">FROM</span> amp_event <span class="token keyword">WHERE</span> is_history <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">AND</span> deal_organization_id <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">)</span>     t2 <span class="token keyword">ON</span> t1<span class="token punctuation">.</span>event_code <span class="token operator">=</span> t2<span class="token punctuation">.</span>event_code<span class="token keyword">where</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">1</span>  <span class="token operator">and</span> t1<span class="token punctuation">.</span>happen_time <span class="token operator">>=</span> <span class="token string">'2022-3-2 20:37:04'</span>  <span class="token operator">and</span> t1<span class="token punctuation">.</span>happen_time <span class="token operator">&lt;=</span> <span class="token string">'2023-3-2 20:37:13'</span>  <span class="token operator">and</span> t1<span class="token punctuation">.</span>prov <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token string">'浙江省'</span><span class="token punctuation">,</span> <span class="token string">'广东省'</span><span class="token punctuation">)</span>  <span class="token operator">and</span> t1<span class="token punctuation">.</span>city <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token string">'杭州市'</span><span class="token punctuation">,</span> <span class="token string">'深圳市'</span><span class="token punctuation">)</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> process_status<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----+-------------+-----------+------------+------+-------------------------------------------------------------------------------------------------+----------------+---------+--------------------------------+-------+----------+------------------------------------------------+</span><span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span>     <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> possible_keys                                                                                   <span class="token operator">|</span> <span class="token keyword">key</span>            <span class="token operator">|</span> key_len <span class="token operator">|</span> ref                            <span class="token operator">|</span> <span class="token keyword">rows</span>  <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra                                          <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-----------+------------+------+-------------------------------------------------------------------------------------------------+----------------+---------+--------------------------------+-------+----------+------------------------------------------------+</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> amp_event <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> idx_dealorganizationid<span class="token punctuation">,</span>idx_event_code_version                                                   <span class="token operator">|</span> <span class="token boolean">NULL</span>           <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span>                           <span class="token operator">|</span>    <span class="token number">15</span> <span class="token operator">|</span>     <span class="token number">8.67</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span><span class="token punctuation">;</span> <span class="token keyword">Using</span> <span class="token keyword">temporary</span><span class="token punctuation">;</span> <span class="token keyword">Using</span> filesort   <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> t1        <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> ref  <span class="token operator">|</span> idx_happendtime<span class="token punctuation">,</span>idx_actualuser_status<span class="token punctuation">,</span>idx_event_code<span class="token punctuation">,</span>idx_city_happen_time<span class="token punctuation">,</span>idx_exception_subject <span class="token operator">|</span> idx_event_code <span class="token operator">|</span> <span class="token number">1003</span>    <span class="token operator">|</span> fnsdmpsit<span class="token punctuation">.</span>amp_event<span class="token punctuation">.</span>event_code <span class="token operator">|</span>    <span class="token number">13</span> <span class="token operator">|</span>     <span class="token number">3.54</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span>                                    <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> amp_site  <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> amp_site_name_index                                                                             <span class="token operator">|</span> <span class="token boolean">NULL</span>           <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span>                           <span class="token operator">|</span> <span class="token number">54023</span> <span class="token operator">|</span>     <span class="token number">1.00</span> <span class="token operator">|</span> Range checked <span class="token keyword">for</span> each record <span class="token punctuation">(</span><span class="token keyword">index</span> map: <span class="token number">0x2</span><span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-----------+------------+------+-------------------------------------------------------------------------------------------------+----------------+---------+--------------------------------+-------+----------+------------------------------------------------+</span><span class="token number">3</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token keyword">warnings</span> <span class="token punctuation">(</span><span class="token number">0.03</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="分析语句"><a href="#分析语句" class="headerlink" title="分析语句"></a>分析语句</h4><p>Using where; Using temporary; Using filesort</p><p>Using where </p><p>Range checked for each record (index map: 0x2)</p><ul><li><p>Using temporary</p><ul><li><code>group by</code> 语句一般会使用内部临时表，因为需要使用内部临时表存储数量；</li><li>一般情况下<code>group by</code>都是会使用临时表的，但是再<code>有些业务场景</code>下，也是可以优化成不用临时表的，所以效率会更高</li><li>【优化点一】：是否可以将这个 group by 语句取消使用内部临时表</li></ul></li><li><p>Using filesort</p><ul><li>group by 分组后默认自然顺序排序，如果不需要排序，可以改成：order by null；（8.0版本group by已经不会排序了）</li><li>所以可以根据具体的业务场景看，是否需要排序</li><li>【优化点二】：group by 语句是否可以不需要排序</li></ul></li><li><p>Using join buffer (Block Nested Loop)</p><ul><li><p>使用了join语句，而且是BNL算法，效率很低，首先看这个语句是否可以不用join</p></li><li><p>【优化点三】：是否可以避免join？从业务代码的角度进行优化？</p></li><li><p>如果join优化不了，是否可以将BNL算法优化成NLJ（BKA算法）</p></li><li><p>【优化点四】：是否可以将BNL算法优化成NLJ（BKA算法）</p></li><li><p>但是呢，即使使用了NLJ（BKA算法），效率还是不如hash-join（mysql8.0支持hash-join，效率高）</p></li><li><p>【优化点五】：是否可以通过业务代码实现hash-join</p></li></ul></li></ul><p>初次分析结论如上，先进行优化一波</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span><span class="token keyword">select</span> log<span class="token punctuation">.</span>process_status <span class="token keyword">as</span> <span class="token keyword">STATUS</span><span class="token punctuation">,</span>       <span class="token function">count</span><span class="token punctuation">(</span>log<span class="token punctuation">.</span>id<span class="token punctuation">)</span>         cnt<span class="token keyword">from</span> amp_event event <span class="token keyword">left</span> <span class="token keyword">join</span> amp_event_log log <span class="token keyword">on</span> event<span class="token punctuation">.</span>event_code<span class="token operator">=</span>log<span class="token punctuation">.</span>event_code<span class="token keyword">where</span> <span class="token number">1</span><span class="token operator">=</span><span class="token number">1</span>  <span class="token operator">and</span> event<span class="token punctuation">.</span>is_history<span class="token operator">=</span><span class="token number">0</span>  <span class="token operator">and</span> event<span class="token punctuation">.</span>deal_organization_id<span class="token operator">=</span><span class="token number">1024</span>  <span class="token operator">and</span> log<span class="token punctuation">.</span>prov <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token string">'浙江省'</span><span class="token punctuation">,</span> <span class="token string">'广东省'</span><span class="token punctuation">)</span>  <span class="token operator">and</span> log<span class="token punctuation">.</span>city <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token string">'杭州市'</span><span class="token punctuation">,</span> <span class="token string">'深圳市'</span><span class="token punctuation">)</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> log<span class="token punctuation">.</span>process_status <span class="token keyword">order</span> <span class="token keyword">by</span> <span class="token boolean">null</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+----------------------------------------------------------------------------------------+----------------+---------+----------------------------+------+----------+------------------------------+</span><span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> possible_keys                                                                          <span class="token operator">|</span> <span class="token keyword">key</span>            <span class="token operator">|</span> key_len <span class="token operator">|</span> ref                        <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra                        <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+----------------------------------------------------------------------------------------+----------------+---------+----------------------------+------+----------+------------------------------+</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> event <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> idx_dealorganizationid<span class="token punctuation">,</span>idx_event_code_version                                          <span class="token operator">|</span> <span class="token boolean">NULL</span>           <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span>                       <span class="token operator">|</span>   <span class="token number">15</span> <span class="token operator">|</span>     <span class="token number">8.67</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span><span class="token punctuation">;</span> <span class="token keyword">Using</span> <span class="token keyword">temporary</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> log   <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> ref  <span class="token operator">|</span> idx_actualuser_status<span class="token punctuation">,</span>idx_event_code<span class="token punctuation">,</span>amp_event_log_city_index<span class="token punctuation">,</span>amp_event_log_prov_index <span class="token operator">|</span> idx_event_code <span class="token operator">|</span> <span class="token number">1003</span>    <span class="token operator">|</span> fnsdmpsit<span class="token punctuation">.</span>event<span class="token punctuation">.</span>event_code <span class="token operator">|</span>   <span class="token number">13</span> <span class="token operator">|</span>    <span class="token number">12.43</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span>                  <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+----------------------------------------------------------------------------------------+----------------+---------+----------------------------+------+----------+------------------------------+</span><span class="token number">2</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.04</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span><span class="token keyword">SELECT</span> t1<span class="token punctuation">.</span>event_code<span class="token punctuation">,</span>       t2<span class="token punctuation">.</span>event_name     <span class="token keyword">AS</span> name<span class="token punctuation">,</span>       t1<span class="token punctuation">.</span>process_status <span class="token keyword">AS</span> <span class="token keyword">STATUS</span><span class="token punctuation">,</span>       t1<span class="token punctuation">.</span>cnt<span class="token keyword">FROM</span> <span class="token punctuation">(</span>         <span class="token keyword">SELECT</span> t<span class="token punctuation">.</span>event_code<span class="token punctuation">,</span>                t<span class="token punctuation">.</span>process_status<span class="token punctuation">,</span>                t<span class="token punctuation">.</span>exception_subject<span class="token punctuation">,</span>                <span class="token function">count</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>id<span class="token punctuation">)</span> cnt         <span class="token keyword">FROM</span> amp_event_log t                  <span class="token keyword">JOIN</span>              <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span>               <span class="token keyword">from</span> amp_site              <span class="token punctuation">)</span> t3              <span class="token keyword">ON</span> t3<span class="token punctuation">.</span>NAME <span class="token operator">=</span> t<span class="token punctuation">.</span>exception_subject         <span class="token keyword">where</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">1</span>           <span class="token operator">and</span> t<span class="token punctuation">.</span>happen_time <span class="token operator">>=</span> <span class="token string">'2022-3-2 20:37:04'</span>           <span class="token operator">and</span> t<span class="token punctuation">.</span>happen_time <span class="token operator">&lt;=</span> <span class="token string">'2023-3-2 20:37:13'</span>           <span class="token operator">and</span> t<span class="token punctuation">.</span>prov <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token string">'浙江省'</span><span class="token punctuation">,</span> <span class="token string">'广东省'</span><span class="token punctuation">)</span>           <span class="token operator">and</span> t<span class="token punctuation">.</span>city <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token string">'杭州市'</span><span class="token punctuation">,</span> <span class="token string">'深圳市'</span><span class="token punctuation">)</span>         <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> t<span class="token punctuation">.</span>event_code<span class="token punctuation">,</span> t<span class="token punctuation">.</span>process_status     <span class="token punctuation">)</span> t1         <span class="token keyword">JOIN</span> <span class="token punctuation">(</span>    <span class="token keyword">SELECT</span> event_code<span class="token punctuation">,</span>           event_name<span class="token punctuation">,</span>           deal_organization_id    <span class="token keyword">FROM</span> amp_event    <span class="token keyword">WHERE</span> is_history <span class="token operator">=</span> <span class="token number">0</span>      <span class="token operator">AND</span> deal_organization_id <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">)</span> t2 <span class="token keyword">ON</span> t1<span class="token punctuation">.</span>event_code <span class="token operator">=</span> t2<span class="token punctuation">.</span>event_code<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----+-------------+------------+------------+------+-------------------------------------------------------------------+------+---------+------+-------+----------+----------------------------------------------------+</span><span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span>      <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> possible_keys                                                     <span class="token operator">|</span> <span class="token keyword">key</span>  <span class="token operator">|</span> key_len <span class="token operator">|</span> ref  <span class="token operator">|</span> <span class="token keyword">rows</span>  <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra                                              <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+------------+------------+------+-------------------------------------------------------------------+------+---------+------+-------+----------+----------------------------------------------------+</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">PRIMARY</span>     <span class="token operator">|</span> amp_event  <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> idx_dealorganizationid<span class="token punctuation">,</span>idx_event_code_version                     <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span>    <span class="token number">15</span> <span class="token operator">|</span>     <span class="token number">8.67</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span>                                        <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">PRIMARY</span>     <span class="token operator">|</span> <span class="token operator">&lt;</span>derived2<span class="token operator">></span> <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> <span class="token boolean">NULL</span>                                                              <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token number">30879</span> <span class="token operator">|</span>    <span class="token number">10.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span><span class="token punctuation">;</span> <span class="token keyword">Using</span> <span class="token keyword">join</span> buffer <span class="token punctuation">(</span>Block Nested <span class="token keyword">Loop</span><span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">2</span> <span class="token operator">|</span> DERIVED     <span class="token operator">|</span> t          <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> idx_happendtime<span class="token punctuation">,</span>amp_event_log_city_index<span class="token punctuation">,</span>amp_event_log_prov_index <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span>    <span class="token number">52</span> <span class="token operator">|</span>    <span class="token number">10.99</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span><span class="token punctuation">;</span> <span class="token keyword">Using</span> <span class="token keyword">temporary</span><span class="token punctuation">;</span> <span class="token keyword">Using</span> filesort       <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">2</span> <span class="token operator">|</span> DERIVED     <span class="token operator">|</span> amp_site   <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> amp_site_name_index                                               <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token number">54023</span> <span class="token operator">|</span>    <span class="token number">10.00</span> <span class="token operator">|</span> Range checked <span class="token keyword">for</span> each record <span class="token punctuation">(</span><span class="token keyword">index</span> map: <span class="token number">0x2</span><span class="token punctuation">)</span>     <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+------------+------------+------+-------------------------------------------------------------------+------+---------+------+-------+----------+----------------------------------------------------+</span><span class="token number">4</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token keyword">warnings</span> <span class="token punctuation">(</span><span class="token number">1.18</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span><span class="token keyword">select</span> t2<span class="token punctuation">.</span>event_code <span class="token keyword">as</span> event_code<span class="token punctuation">,</span> t1<span class="token punctuation">.</span>event_name <span class="token keyword">as</span> name<span class="token punctuation">,</span> t2<span class="token punctuation">.</span>process_status <span class="token keyword">as</span> <span class="token keyword">status</span><span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>t2<span class="token punctuation">.</span>id<span class="token punctuation">)</span> <span class="token keyword">as</span> cnt<span class="token keyword">from</span> amp_event t1         <span class="token keyword">left</span> <span class="token keyword">join</span> amp_event_log t2 <span class="token keyword">on</span> t1<span class="token punctuation">.</span>event_code <span class="token operator">=</span> t2<span class="token punctuation">.</span>event_code<span class="token keyword">where</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">1</span>  <span class="token operator">and</span> t2<span class="token punctuation">.</span>happen_time <span class="token operator">>=</span> <span class="token string">'2022-3-2 20:37:04'</span>  <span class="token operator">and</span> t2<span class="token punctuation">.</span>happen_time <span class="token operator">&lt;=</span> <span class="token string">'2023-3-2 20:37:13'</span>  <span class="token operator">and</span> t2<span class="token punctuation">.</span>prov <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token string">'浙江省'</span><span class="token punctuation">,</span> <span class="token string">'广东省'</span><span class="token punctuation">)</span>  <span class="token operator">and</span> t2<span class="token punctuation">.</span>city <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token string">'杭州市'</span><span class="token punctuation">,</span> <span class="token string">'深圳市'</span><span class="token punctuation">)</span>  <span class="token operator">and</span> t1<span class="token punctuation">.</span>is_history <span class="token operator">=</span> <span class="token number">0</span>  <span class="token operator">and</span> t1<span class="token punctuation">.</span>deal_organization_id <span class="token operator">=</span> <span class="token number">1024</span><span class="token keyword">group</span> <span class="token keyword">by</span> t2<span class="token punctuation">.</span>event_code<span class="token punctuation">,</span> t2<span class="token punctuation">.</span>process_status<span class="token keyword">order</span> <span class="token keyword">by</span> <span class="token boolean">null</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+----------------------------------------------------------------------------------+----------------+---------+-------------------------+------+----------+------------------------------+</span><span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> possible_keys                                                                    <span class="token operator">|</span> <span class="token keyword">key</span>            <span class="token operator">|</span> key_len <span class="token operator">|</span> ref                     <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra                        <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+----------------------------------------------------------------------------------+----------------+---------+-------------------------+------+----------+------------------------------+</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> t1    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> idx_dealorganizationid<span class="token punctuation">,</span>idx_event_code_version                                    <span class="token operator">|</span> <span class="token boolean">NULL</span>           <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span>                    <span class="token operator">|</span>   <span class="token number">15</span> <span class="token operator">|</span>     <span class="token number">8.67</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span><span class="token punctuation">;</span> <span class="token keyword">Using</span> <span class="token keyword">temporary</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> t2    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> ref  <span class="token operator">|</span> idx_happendtime<span class="token punctuation">,</span>idx_event_code<span class="token punctuation">,</span>amp_event_log_city_index<span class="token punctuation">,</span>amp_event_log_prov_index <span class="token operator">|</span> idx_event_code <span class="token operator">|</span> <span class="token number">1003</span>    <span class="token operator">|</span> fnsdmpsit<span class="token punctuation">.</span>t1<span class="token punctuation">.</span>event_code <span class="token operator">|</span>   <span class="token number">13</span> <span class="token operator">|</span>    <span class="token number">10.99</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span>                  <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+----------------------------------------------------------------------------------+----------------+---------+-------------------------+------+----------+------------------------------+</span><span class="token number">2</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.04</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mysql的SQL优化实战&quot;&gt;&lt;a href=&quot;#mysql的SQL优化实战&quot; class=&quot;headerlink&quot; title=&quot;mysql的SQL优化实战&quot;&gt;&lt;/a&gt;mysql的SQL优化实战&lt;/h1&gt;&lt;p&gt;以下是公司实际业务上的SQL调优实战&lt;/p&gt;
&lt;h2</summary>
      
    
    
    
    <category term="JAVA" scheme="https://zspcer.gitee.io/categories/JAVA/"/>
    
    <category term="数据库" scheme="https://zspcer.gitee.io/categories/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MYSQL" scheme="https://zspcer.gitee.io/categories/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL/"/>
    
    
    <category term="mysql" scheme="https://zspcer.gitee.io/tags/mysql/"/>
    
    <category term="SQL优化" scheme="https://zspcer.gitee.io/tags/SQL%E4%BC%98%E5%8C%96/"/>
    
    <category term="性能调优" scheme="https://zspcer.gitee.io/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
    <category term="调优" scheme="https://zspcer.gitee.io/tags/%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>mysql的连接查询</title>
    <link href="https://zspcer.gitee.io/note/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL/MySql%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/"/>
    <id>https://zspcer.gitee.io/note/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL/MySql%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/</id>
    <published>2023-03-15T04:24:10.501Z</published>
    <updated>2023-03-15T04:24:10.501Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mysql的连接查询"><a href="#mysql的连接查询" class="headerlink" title="mysql的连接查询"></a>mysql的连接查询</h2><h3 id="笛卡尔集"><a href="#笛卡尔集" class="headerlink" title="笛卡尔集"></a>笛卡尔集</h3><p>对于两张表的连接，会造成笛卡尔乘积现象：</p><p>假设表a有m行，表b有n行：则结果是m*n行。</p><img src="mysql的连接查询.assets/image-20220831204520815-16671893143504.png" alt="image-20220831204520815" style="zoom:80%;" /><p>对于上面的两张表，如果直接查询：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select name,boyName from beauty,boys; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>则结果是：12 * 4 &#x3D; 48行</p><p>很显然不是我们想要的结果！</p><p>那么怎么解决笛卡尔集呢</p><p>通过添加连接条件，可以过滤掉笛卡尔集</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select name,boyName from beauty,boys where beauty.boyfriend_id &#x3D; boys.id;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="隐式内连接-等值连接"><a href="#隐式内连接-等值连接" class="headerlink" title="隐式内连接-等值连接"></a>隐式内连接-等值连接</h3><p>mysql的隐式内连接：在 SQL 语句中使用两个或多个表，通过 WHERE 条件筛选满足条件的行进行连接。此时，并没有使用 INNER JOIN 或 JOIN 等显式的连接操作符，因此也被称为隐式连接。虽然隐式连接在某些情况下可以简化 SQL 的编写，但是在实际使用中，建议使用显式连接方式，因为显式连接更加清晰易懂，同时对于复杂的连接查询有更好的可读性和可维护性。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">-- 语法SELECT 字段1, 字段2... FROM 表1,表2... WHERE 表1.xxx &#x3D; 表2.xxx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>原理：</p><ul><li>先从表1中拿出第一行的数据,然后匹配表2中的每一行记录，进行WHERE后面的判断</li><li>满足判断：找到结果</li><li>不满足判断：过滤掉，继续下一个</li></ul><p>特点</p><ul><li>等值连接，可以进行分组</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">,</span>city <span class="token keyword">from</span> departments d<span class="token punctuation">,</span> location l <span class="token keyword">WHERE</span> d<span class="token punctuation">.</span>location_id <span class="token operator">=</span> l<span class="token punctuation">.</span>id <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> city<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="隐式内连接-非等值连接"><a href="#隐式内连接-非等值连接" class="headerlink" title="隐式内连接-非等值连接"></a>隐式内连接-非等值连接</h3><p>mysql的隐式内连接：在 SQL 语句中使用两个或多个表，通过 WHERE 条件筛选满足条件的行进行连接。此时，并没有使用 INNER JOIN 或 JOIN 等显式的连接操作符，因此也被称为隐式连接。虽然隐式连接在某些情况下可以简化 SQL 的编写，但是在实际使用中，建议使用显式连接方式，因为显式连接更加清晰易懂，同时对于复杂的连接查询有更好的可读性和可维护性。</p><p>与等值连接的不同之处在于</p><ul><li><p>等值连接的WEHER中是使用 &#x3D; 进行判断</p></li><li><p>非等值连接，就是不使用 &#x3D; 进行判断，比如 xxx &gt; xxx，或者 xxx BETWEEN xxx and xxx</p></li></ul><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">-- 语法SELECT 字段1, 字段2 ... FROM 表1,表2... WHERE 判断条件-- 例子select 员工表.员工工资, 工资等级表.工资等级 from 员工表, 工资等级表 WHERE 员工表.员工工资 BETWEEN 工资等级表.最低工资 AND 工资等级表.最高工资;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>原理：</p><ul><li>就是拿到员工表的中的每一个员工的工资，去工资登记表中进行判断，是否满足WHERE条件后的判断：</li><li>满足判断：找到结果</li><li>不满足判断：过滤掉，继续下一个</li></ul><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p>自连接，简单地说，就是一张表，自己与自己进行连接.</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT a.name AS &#39;部门名&#39;, b.name AS &#39;上级部门&#39; FROM sys_department a ,sys_department b WHERE a.parent_id &#x3D; b.id;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="外连接-左外连接-LEFT-JOIN"><a href="#外连接-左外连接-LEFT-JOIN" class="headerlink" title="外连接-左外连接(LEFT  JOIN)"></a>外连接-左外连接(LEFT  JOIN)</h3><ul><li>LEFT JOIN</li><li>LEFT OUTER JOIN</li><li>只有形式不一样。left join 是 left outer join 的简写，两者含义一样的。</li><li>左外连接 &#x3D; 左表全部记录 + 右表相关联记录</li></ul><h3 id="外连接-右外连接-RIGHT-JOIN"><a href="#外连接-右外连接-RIGHT-JOIN" class="headerlink" title="外连接-右外连接(RIGHT JOIN)"></a>外连接-右外连接(RIGHT JOIN)</h3><ul><li>RIGHT JOIN</li><li>RIGHT OUTER JOIN</li><li>有形式不一样。left join 是 left outer join 的简写，两者含义一样的。</li><li>右外连接 &#x3D; 右表全部记录 + 左表相关联记录</li></ul><h3 id="外连接-全外连接-不支持"><a href="#外连接-全外连接-不支持" class="headerlink" title="外连接-全外连接(不支持)"></a>外连接-全外连接(不支持)</h3><ul><li>mysql不支持全外连接。</li><li>全外连接 &#x3D; 【左有右没有的记录】 + 【右有左没有的记录】 + 【两张表的交集记录】</li></ul><h3 id="内连接-JOIN-x2F-INNER-JOIN"><a href="#内连接-JOIN-x2F-INNER-JOIN" class="headerlink" title="内连接(JOIN &#x2F; INNER JOIN)"></a>内连接(JOIN &#x2F; INNER JOIN)</h3><ul><li>JOIN</li><li>INNER JOIN</li><li>join 是 inner join 的缩写</li><li>内连接 &#x3D; 两张表的交集记录</li></ul><h3 id="交叉连接-CROSS-JOIN"><a href="#交叉连接-CROSS-JOIN" class="headerlink" title="交叉连接(CROSS JOIN)"></a>交叉连接(CROSS JOIN)</h3><ul><li>CROSS JOIN</li><li>交叉连接 &#x3D; 笛卡尔积</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><img src="mysql的连接查询.assets/image-20220831210715528-16671893143505.png" alt="image-20220831210715528" style="zoom:50%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;mysql的连接查询&quot;&gt;&lt;a href=&quot;#mysql的连接查询&quot; class=&quot;headerlink&quot; title=&quot;mysql的连接查询&quot;&gt;&lt;/a&gt;mysql的连接查询&lt;/h2&gt;&lt;h3 id=&quot;笛卡尔集&quot;&gt;&lt;a href=&quot;#笛卡尔集&quot; class=&quot;head</summary>
      
    
    
    
    <category term="JAVA" scheme="https://zspcer.gitee.io/categories/JAVA/"/>
    
    <category term="数据库" scheme="https://zspcer.gitee.io/categories/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MYSQL" scheme="https://zspcer.gitee.io/categories/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL/"/>
    
    
    <category term="mysql" scheme="https://zspcer.gitee.io/tags/mysql/"/>
    
    <category term="join" scheme="https://zspcer.gitee.io/tags/join/"/>
    
  </entry>
  
  <entry>
    <title>hexo+butterfly更新mermaid版本</title>
    <link href="https://zspcer.gitee.io/note/TOOLS/hexo/hexo+butterfly%E6%9B%B4%E6%96%B0mermaid%E7%89%88%E6%9C%AC/"/>
    <id>https://zspcer.gitee.io/note/TOOLS/hexo/hexo+butterfly%E6%9B%B4%E6%96%B0mermaid%E7%89%88%E6%9C%AC/</id>
    <published>2023-02-23T13:45:00.944Z</published>
    <updated>2023-02-23T13:45:00.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo-butterfly更新mermaid版本"><a href="#hexo-butterfly更新mermaid版本" class="headerlink" title="hexo+butterfly更新mermaid版本"></a>hexo+butterfly更新mermaid版本</h1><p>怎么使用的mermaid，可以参考butterfly的官网：<a href="https://butterfly.js.org/posts/4aa8abbe/#mermaid">https://butterfly.js.org/posts/4aa8abbe/#mermaid</a></p><p>最近在本地重新编辑一篇文章之后，部署起来，发现有一个<code>mermaid</code>图表不支持了。</p><p>原因是因为：我的 <code>hexo</code> 引用的 <code>butterfly</code> 主题默认使用的 <code>mermaid</code> 版本是 <code>8.13.8</code></p><p>而我本地是使用 <code>typora</code> 编辑的，<code>typora</code> 版本是 <code>1.5.8</code>，引用的 mermaid 版本是 <code>9.2.0</code></p><p>所以我是用了 新版本的特性之后，在低版本中就无法渲染了。</p><img src="hexo+butterfly更新mermaid版本.assets/image-20230217231526333.png" alt="image-20230217231526333" style="zoom:50%;" /><p><strong>解决办法</strong></p><p>更新 hexo+butterfly 的 mermaid 版本</p><p>mermaid 版本是主题引入的，其实就是主题引入了一个js</p><p>我们找到这个 js ，给它升级了就完事了</p><p>找到主题目录</p><blockquote><p>…&#x2F;你的主题目录&#x2F;hexo-theme-butterfly&#x2F;layout&#x2F;includes&#x2F;footer.pug</p></blockquote><img src="hexo+butterfly更新mermaid版本.assets/image-20230217230355932.png" alt="image-20230217230355932" style="zoom:50%;" /><p>打开<code>footer.pug</code>文件，将引入的低版本mermaid直接升级就可以了</p><img src="hexo+butterfly更新mermaid版本.assets/image-20230217230516681.png" alt="image-20230217230516681" style="zoom: 33%;" /><p>然后重新部署一遍就可以了。</p><img src="hexo+butterfly更新mermaid版本.assets/image-20230217231546566.png" alt="image-20230217231546566" style="zoom:50%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hexo-butterfly更新mermaid版本&quot;&gt;&lt;a href=&quot;#hexo-butterfly更新mermaid版本&quot; class=&quot;headerlink&quot; title=&quot;hexo+butterfly更新mermaid版本&quot;&gt;&lt;/a&gt;hexo+butter</summary>
      
    
    
    
    <category term="TOOLS" scheme="https://zspcer.gitee.io/categories/TOOLS/"/>
    
    <category term="hexo" scheme="https://zspcer.gitee.io/categories/TOOLS/hexo/"/>
    
    
    <category term="hexo" scheme="https://zspcer.gitee.io/tags/hexo/"/>
    
    <category term="butterfly" scheme="https://zspcer.gitee.io/tags/butterfly/"/>
    
    <category term="mermaid" scheme="https://zspcer.gitee.io/tags/mermaid/"/>
    
  </entry>
  
  <entry>
    <title>docker+hexo+gitee部署完美个人博客</title>
    <link href="https://zspcer.gitee.io/note/TOOLS/hexo/docker+hexo+gitee%E9%83%A8%E7%BD%B2%E5%AE%8C%E7%BE%8E%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://zspcer.gitee.io/note/TOOLS/hexo/docker+hexo+gitee%E9%83%A8%E7%BD%B2%E5%AE%8C%E7%BE%8E%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2023-02-23T13:45:00.939Z</published>
    <updated>2023-02-23T13:45:00.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>因为引用的文章在下面都说到了，可以先看看</p><p><a href="https://zhuanlan.zhihu.com/p/372398281">Docker + Git 部署Hexo发布</a></p><p><a href="https://www.cnblogs.com/moshuying/p/15801437.html">【hexo指南】hexo配置ER图流程图时序图插件</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本文仅适用：x86_64架构</strong></p><p>因为平时使用typora写文章，除了基本的MD语法之外，还使用了</p><ul><li>本地图片</li><li>mermaid</li></ul><p>就是上面两点，导致部署hexo比较麻烦，特别是第一点。</p><p>为什么呢？</p><p>hexo新版本不是支持了本地图片吗？</p><p>但是支持的前提是：图片的文件夹和MD文件名一致，像下面这样</p><ul><li>xxxxx.md （MD文件）</li><li>xxxxx （图片文件夹）</li></ul><p>而我的图片存储方式是：</p><ul><li>xxxxx.md（MD文件）</li><li>xxxxx.assets（图片文件夹）</li></ul><p>对应typora的设置就是：</p><img src="docker+hexo+gitee部署完美个人博客.assets/image-20221030220722156.png" alt="image-20221030220722156" style="zoom:50%;" /><p>所以hexo就不支持了，我就很难受</p><h2 id="第一步：准备hexo文件"><a href="#第一步：准备hexo文件" class="headerlink" title="第一步：准备hexo文件"></a>第一步：准备hexo文件</h2><p>你需要准备你的所有笔记文件：比如我的是放在gitee的，大致有下面这些笔记</p><img src="docker+hexo+gitee部署完美个人博客.assets/image-20221030220831563.png" alt="image-20221030220831563" style="zoom:50%;" /><p>然后需要准备一个hexo的主题，我推荐是 butterfly，把主题下载下来</p><p>然后需要准备hexo的配置文件_config.yml，配置好你所需要的所有内容</p><p>然后准备下面的脚本，命名为：hexo-img-move.js</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs-extra'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//note/xxx/xx.assets  2020/10/30/xxx/xx.assets</span><span class="token keyword">function</span> <span class="token function">copy</span><span class="token punctuation">(</span><span class="token parameter">dir<span class="token punctuation">,</span>dest</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>fs<span class="token punctuation">.</span><span class="token function">pathExists</span><span class="token punctuation">(</span>dir<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> exists</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>exists<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fs<span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span>dir<span class="token punctuation">,</span> dest<span class="token punctuation">,</span> <span class="token parameter">err</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>   <span class="token keyword">return</span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'success!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//遍历递归public文件夹，将</span><span class="token keyword">function</span> <span class="token function">readFileList</span><span class="token punctuation">(</span><span class="token parameter">path<span class="token punctuation">,</span> filesList</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> files <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readdirSync</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>    files<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">itm<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">var</span> stat <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">statSync</span><span class="token punctuation">(</span>path <span class="token operator">+</span> itm<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>stat<span class="token punctuation">.</span><span class="token function">isDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//递归读取文件</span>            <span class="token function">readFileList</span><span class="token punctuation">(</span>path <span class="token operator">+</span> itm <span class="token operator">+</span> <span class="token string">"/"</span><span class="token punctuation">,</span> filesList<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//定义一个对象存放文件的路径和名字</span>            obj<span class="token punctuation">.</span>path <span class="token operator">=</span> path<span class="token punctuation">;</span><span class="token comment">//路径</span>            obj<span class="token punctuation">.</span>filename <span class="token operator">=</span> itm<span class="token comment">//名字</span>            filesList<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> getFiles <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//获取文件夹下的所有文件</span>    <span class="token function-variable function">getFileList</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">path</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">var</span> filesList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">readFileList</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> filesList<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> filesList<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>getFiles<span class="token punctuation">.</span><span class="token function">getFileList</span><span class="token punctuation">(</span><span class="token string">'/var/www/hexo/public/'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">// console.log(obj.path);</span><span class="token comment">// var paths = obj.path.split('public/');</span><span class="token comment">// var dir_part = paths[1];</span><span class="token comment">// var dir_full = '/var/www/hexo/source/_posts/'+dir_part;</span><span class="token comment">// var dir = dir_full.substring(0,dir_full.length-1)+'.assets';</span><span class="token keyword">var</span> dir_part <span class="token operator">=</span> obj<span class="token punctuation">.</span>path<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'note'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> dir_full <span class="token operator">=</span> <span class="token string">'/var/www/hexo/source/_posts/note'</span><span class="token operator">+</span>dir_part<span class="token punctuation">;</span><span class="token keyword">var</span> dir <span class="token operator">=</span> dir_full<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>dir_full<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">'.assets'</span><span class="token punctuation">;</span><span class="token comment">//第一种：复制到 dir 的下一级目录下</span><span class="token keyword">var</span> dirs <span class="token operator">=</span> dir<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> aessets_name <span class="token operator">=</span> dirs<span class="token punctuation">[</span>dirs<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">var</span> dest1 <span class="token operator">=</span> obj<span class="token punctuation">.</span>path<span class="token operator">+</span>aessets_name<span class="token punctuation">;</span><span class="token comment">// 第二种：复制到 dir 同级目录下</span><span class="token comment">// var dest2 = obj.path.substring(0,obj.path.length-1)+'.assets';</span><span class="token comment">//第三种：复制到 public 下</span><span class="token keyword">var</span> dirs <span class="token operator">=</span> dir<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> forder_name <span class="token operator">=</span> dirs<span class="token punctuation">[</span>dirs<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'.assets'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> dest_full <span class="token operator">=</span> obj<span class="token punctuation">.</span>path<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>obj<span class="token punctuation">.</span>path<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">'.assets'</span><span class="token punctuation">;</span><span class="token keyword">var</span> dests <span class="token operator">=</span> dest_full<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> dest3 <span class="token operator">=</span> <span class="token string">'/var/www/hexo/public/'</span><span class="token operator">+</span>dests<span class="token punctuation">[</span>dests<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//</span><span class="token comment">///var/www/hexo/public/2022/10/30/note/JAVA/数据库/MYSQL/mysql的日志从入门到入土/</span><span class="token comment">// console.log(dir)</span><span class="token function">copy</span><span class="token punctuation">(</span>dir<span class="token punctuation">,</span>dest1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">copy</span><span class="token punctuation">(</span>dir<span class="token punctuation">,</span>dest3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="docker+hexo+gitee部署完美个人博客.assets/image-20221030221220970.png" alt="image-20221030221220970" style="zoom:80%;" /><h2 id="第二步：准备dockerfile"><a href="#第二步：准备dockerfile" class="headerlink" title="第二步：准备dockerfile"></a>第二步：准备dockerfile</h2><p>将下面的文件 命名为：Dockerfile  没有后缀名</p><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> node:14-alpine</span><span class="token instruction"><span class="token keyword">WORKDIR</span> /var/www/hexo</span><span class="token instruction"><span class="token keyword">RUN</span> echo <span class="token string">"Asia/Shanghai"</span> > /etc/timezone <span class="token operator">\</span>    &amp;&amp; echo <span class="token string">"https://mirrors.aliyun.com/alpine/v3.9/main/"</span> > /etc/apk/repositories  <span class="token operator">\</span>    &amp;&amp; npm config set registry https://registry.npm.taobao.org <span class="token operator">\</span>    &amp;&amp; apk add --no-cache git <span class="token operator">\</span>    &amp;&amp; apk add --no-cache openssh-client <span class="token operator">\</span>    &amp;&amp; npm install hexo-cli -g <span class="token operator">\</span>    &amp;&amp; hexo init <span class="token operator">\</span>    &amp;&amp; npm install hexo-renderer-swig <span class="token operator">\</span>    &amp;&amp; npm install <span class="token operator">\</span>    &amp;&amp; npm install fs-extra --save </span>    &amp;&amp; npm install hexo-deployer-git --save \    &amp;&amp; npm install hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive --save \    &amp;&amp; npm install hexo-filter-mermaid-diagrams --save \    &amp;&amp; npm install hexo-blog-encrypt --save \    &amp;&amp; npm install hexo-generator-search --save \    &amp;&amp; git config --global user.email "zhuansunpengcheng@qq.com" \    &amp;&amp; git config --global user.name "zhuansun" \    &amp;&amp; ssh-keygen -t RSA -C "zhuansunpengcheng@qq.com" -P "" -N "" -f /root/.ssh/id_rsa \    &amp;&amp; echo "StrictHostKeyChecking no" >> /etc/ssh/ssh_config \    &amp;&amp; cat /root/.ssh/id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>我们使用alpine作为基本镜像，因为够小，对于hexo来说，足够了</li><li>设置工作目录是 &#x2F;var&#x2F;www&#x2F;hexo</li><li>下面就是安装git，ssh，hexo</li><li>npm install fs-extra –save ：安装fs-extra的依赖，是为了我们的 hexo-img-move.js能正常运行</li><li>安装了一些hexo的插件<ul><li>hexo-deployer-git：让hexo支持直接部署到git上</li><li>hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive：这些是为了butterfly主题支持用的</li><li>hexo-filter-mermaid-diagrams：让hexo支持mermaid流程图（解决了我的第二个痛点）：<a href="https://www.cnblogs.com/moshuying/p/15801437.html">https://www.cnblogs.com/moshuying/p/15801437.html</a></li><li>hexo-blog-encrypt：加密文章，使用方法见github：<a href="https://github.com/rdou/hexo-blog-encrypt">https://github.com/rdou/hexo-blog-encrypt</a><ul><li>说明：在http环境下不支持加密，这是因为脚本中的使用的crypto对象，有一个subtle属性只能在https环境下获取到。</li><li><img src="docker+hexo+gitee部署完美个人博客.assets/image-20221031001047545.png" alt="image-20221031001047545" style="zoom: 30%;float:left" /></li><li><img src="docker+hexo+gitee部署完美个人博客.assets/image-20221031001405503.png" alt="image-20221031001405503" style="zoom:33%;float:left" /></li></ul></li></ul></li><li>hexo-generator-search：实现本地搜索，hexo本地搜索的实现原理是在 public 目录下，生成一个 search.xml 文件</li><li>设置git的邮箱和用户名，填自己的就行</li><li>设置ssh公钥，是为了让git提交的时候不用每次都输入密码，直接用公钥提交</li><li>echo “StrictHostKeyChecking no” &gt;&gt; &#x2F;etc&#x2F;ssh&#x2F;ssh_config \： 这一步很重要，是为了容器启动的时候，跳过ssh公钥的检查，避免手动输入yes</li><li>cat &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub：打印公钥</li></ul><h2 id="第三步：构建docker镜像"><a href="#第三步：构建docker镜像" class="headerlink" title="第三步：构建docker镜像"></a>第三步：构建docker镜像</h2><p>在Dockerfile的目录下，运行下面的命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> build <span class="token parameter variable">-t</span> zhuansun/hexo:v1.0 <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>-t：表示指定镜像的名字和标签</li><li>zhuansun&#x2F;hexo:v1.0 : 表示镜像的名字，v1.0是标签</li><li>. ：这个点，不知道啥意思，写上</li></ul><p>查看构建的镜像</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ash-4.3<span class="token comment"># docker image ls</span>REPOSITORY                                          TAG                       IMAGE ID       CREATED         SIZEzhuansun/hexo                                       v1.0                      71b6e1b7ea19   <span class="token number">4</span> minutes ago   249MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="第四步：运行容器"><a href="#第四步：运行容器" class="headerlink" title="第四步：运行容器"></a>第四步：运行容器</h2><p>我用的是群辉的docker，挂载了四个目录，和一个端口</p><img src="docker+hexo+gitee部署完美个人博客.assets/image-20221030222106418.png" alt="image-20221030222106418" style="zoom: 80%;" /><img src="docker+hexo+gitee部署完美个人博客.assets/image-20221030222129007.png" alt="image-20221030222129007" style="zoom:50%;" /><p>其他的都是默认。然后启动</p><p>注意：</p><p>挂载的文件夹里面，要有内容哦。按照第一步，该放的都放好。</p><h2 id="第五步：启动容器"><a href="#第五步：启动容器" class="headerlink" title="第五步：启动容器"></a>第五步：启动容器</h2><img src="docker+hexo+gitee部署完美个人博客.assets/image-20221030222250742.png" alt="image-20221030222250742" style="zoom:80%;" /><h2 id="第六步：使用容器"><a href="#第六步：使用容器" class="headerlink" title="第六步：使用容器"></a>第六步：使用容器</h2><p>先开启群辉的ssh，然后进入到容器里面</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> xxxxxxx <span class="token function">sh</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进来之后，默认就是我们设置的：&#x2F;var&#x2F;www&#x2F;hexo</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ash-4.3<span class="token comment"># docker exec -it fb29ef2559ef sh</span>/var/www/hexo <span class="token comment"># ls</span>_config.landscape.yml  db.json                package-lock.json      public                 shell                  themes_config.yml            node_modules           package.json           scaffolds              <span class="token builtin class-name">source</span>                 yarn.lock/var/www/hexo <span class="token comment"># hexo clean</span>INFO  Validating configINFO  Deleted database.INFO  Deleted public folder./var/www/hexo <span class="token comment"># hexo g</span>INFO  Validating configINFO  Start processingINFO  Generated: note/JAVA/数据库/MYSQL/mysql中的交集差集并集/index.htmlINFO  Generated: note/JAVA/GIT/git批量删除分支/index.htmlINFO  Generated: note/PROJECT/时效项目/index.htmlINFO  <span class="token number">73</span> files generated <span class="token keyword">in</span> <span class="token number">7.03</span> s/var/www/hexo <span class="token comment"># node shell/hexo-img-move.js </span>success<span class="token operator">!</span>success<span class="token operator">!</span>success<span class="token operator">!</span>/var/www/hexo <span class="token comment"># hexo server -d</span>INFO  Validating configINFO  <span class="token punctuation">[</span>Browsersync<span class="token punctuation">]</span> Access URLs: ----------------------------------          UI: http://localhost:3001 ---------------------------------- UI External: http://localhost:3001 ----------------------------------INFO  Start processingINFO  Hexo is running at http://localhost:4000/ <span class="token builtin class-name">.</span> Press Ctrl+C to stop.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>说一下 node shell&#x2F;hexo-img-move.js  这一步，hexo生成静态文件之后，只有html，并没有图片的</li><li>如果你用的是图床，那么完全啥问题都没有</li><li>如果是本地图片，我们就需要把本地图片移动到指定的文件夹中</li><li>然后hexo server启动后，html才可以找到图片（具体怎么移动的可以看上面的代码）</li></ul><h2 id="第七步：本地验证hexo服务"><a href="#第七步：本地验证hexo服务" class="headerlink" title="第七步：本地验证hexo服务"></a>第七步：本地验证hexo服务</h2><p>图片可以正常显示</p><img src="docker+hexo+gitee部署完美个人博客.assets/image-20221030222950902.png" alt="image-20221030222950902" style="zoom:80%;" /><p>代码可以正常显示</p><img src="docker+hexo+gitee部署完美个人博客.assets/image-20221030223012143.png" alt="image-20221030223012143" style="zoom:80%;" /><p>时序图可以正常显示</p><img src="docker+hexo+gitee部署完美个人博客.assets/image-20221030223026695.png" alt="image-20221030223026695" style="zoom:80%;" /><h2 id="第八步：部署到gitee"><a href="#第八步：部署到gitee" class="headerlink" title="第八步：部署到gitee"></a>第八步：部署到gitee</h2><p>首先需要配置上面的公钥到gitee上，百度很简单</p><p>然后再hexo中：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/var/www/hexo <span class="token comment"># hexo d</span>INFO  Validating configINFO  Deploying: <span class="token function">git</span>INFO  Clearing .deploy_git folder<span class="token punctuation">..</span>.INFO  Copying files from public folder<span class="token punctuation">..</span>.INFO  Copying files from extend dirs<span class="token punctuation">..</span>.<span class="token punctuation">[</span>master c3fe339<span class="token punctuation">]</span> Site updated: <span class="token number">2022</span>-10-30 <span class="token number">14</span>:31:27Enumerating objects: <span class="token number">308</span>, done.Counting objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">308</span>/308<span class="token punctuation">)</span>, done.Delta compression using up to <span class="token number">4</span> threadsCompressing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">247</span>/247<span class="token punctuation">)</span>, done.Writing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">284</span>/284<span class="token punctuation">)</span>, <span class="token number">22.02</span> MiB <span class="token operator">|</span> <span class="token number">1.09</span> MiB/s, done.Total <span class="token number">284</span> <span class="token punctuation">(</span>delta <span class="token number">51</span><span class="token punctuation">)</span>, reused <span class="token number">0</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>remote: Resolving deltas: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">51</span>/51<span class="token punctuation">)</span>, completed with <span class="token number">3</span> <span class="token builtin class-name">local</span> objects.remote: Powered by GITEE.COM <span class="token punctuation">[</span>GNK-6.4<span class="token punctuation">]</span>To gitee.com:zhuansunpengcheng/zhuansunpengcheng.git   e4984bb<span class="token punctuation">..</span>c3fe339  HEAD -<span class="token operator">></span> masterBranch <span class="token string">'master'</span> <span class="token builtin class-name">set</span> up to track remote branch <span class="token string">'master'</span> from <span class="token string">'git@gitee.com:zhuansunpengcheng/zhuansunpengcheng.git'</span><span class="token builtin class-name">.</span>INFO  Deploy done: <span class="token function">git</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>提交成功之后，到gitee上，开始gitee page服务</p><img src="docker+hexo+gitee部署完美个人博客.assets/image-20221030223331923.png" alt="image-20221030223331923" style="zoom:50%;" /><p>然后就可以使用了</p><img src="docker+hexo+gitee部署完美个人博客.assets/image-20221030223426237.png" alt="image-20221030223426237" style="zoom:80%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h2&gt;&lt;p&gt;因为引用的文章在下面都说到了，可以先看看&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/3723</summary>
      
    
    
    
    <category term="TOOLS" scheme="https://zspcer.gitee.io/categories/TOOLS/"/>
    
    <category term="hexo" scheme="https://zspcer.gitee.io/categories/TOOLS/hexo/"/>
    
    
    <category term="docker" scheme="https://zspcer.gitee.io/tags/docker/"/>
    
    <category term="hexo" scheme="https://zspcer.gitee.io/tags/hexo/"/>
    
    <category term="gitee" scheme="https://zspcer.gitee.io/tags/gitee/"/>
    
  </entry>
  
  <entry>
    <title>kafka从入门到入土</title>
    <link href="https://zspcer.gitee.io/note/JAVA/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/KAFKA/kafka%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/"/>
    <id>https://zspcer.gitee.io/note/JAVA/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/KAFKA/kafka%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/</id>
    <published>2023-02-23T13:45:00.914Z</published>
    <updated>2023-02-23T13:45:00.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kafka从入门到入土"><a href="#kafka从入门到入土" class="headerlink" title="kafka从入门到入土"></a>kafka从入门到入土</h1><hr><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="名词术语"><a href="#名词术语" class="headerlink" title="名词术语"></a>名词术语</h3><p>消息：<code>Record</code>。Kafka 是消息引擎嘛，这里的消息就是指 Kafka 处理的主要对象。</p><p>主题：<code>Topic</code>。Topic 是承载消息的逻辑容器，在实际使用中多用来区分具体的业务。</p><p>分区：<code>Partition</code>。是一个物理概念，可以理解为一个有序不变的消息序列。每个 Topic 下可以有多个 Partition。</p><p>分区位移：<code>Offset</code>。表示 Partition 中每条消息的位置信息，这个值是存在消息中的，是一个单调递增且不变的值。</p><p>副本：<code>Replica</code>。Kafka 中同一条消息能够被拷贝到多个地方以提供数据冗余，这些地方就是所谓的<code>Replica</code>副本。<code>Replica</code>还分为<code>Leader Replica</code>和<code>Follower Replica</code>，各自有不同的角色划分。<code>Replica</code>是在<code>Partition</code>层级下的，即每个<code>Partition</code>可配置多个<code>Replica</code>实现高可用。</p><p>生产者：<code>Producer</code>。向<code>Topic</code>发布新消息的应用程序。</p><p>消费者：<code>Consumer</code>。从<code>Topic</code>订阅新消息的应用程序。</p><p>消费者位移：<code>Consumer Offset</code>。表示<code>Consumer</code>的消费进度，每个<code>Consumer</code>都有自己的<code>Consumer Offset</code>。</p><p>消费者组：<code>Consumer Group</code>。多个<code>Consumer</code>实例共同组成的一个组<code>Group</code>，同时消费多个<code>Partition</code>以实现高吞吐。</p><p>重平衡：<code>Rebalance</code>。<code>Consumer Group</code>内某个<code>Consumer</code>实例挂掉后，其他<code>Consumer</code>实例自动重新分配订阅<code>Topic Partiton</code>的过程。<code>Rebalance</code> 是 Kafka 消费端实现高可用的重要手段。</p><img src="kafka从入门到入土.assets/58c35d3ab0921bf0476e3ba14069d291.jpg" alt="img" style="zoom: 20%;" /><h3 id="三层消息架构"><a href="#三层消息架构" class="headerlink" title="三层消息架构"></a>三层消息架构</h3><ul><li>第一层：主题层<code>Topic</code><ul><li>每个<code>Topic</code>可以配置<code>M</code>的<code>Partition</code>，而每个<code>Partition</code>又可以配置<code>N</code>个<code>Replica</code></li></ul></li><li>第二层：分区层<code>Partition</code><ul><li>每个<code>Partition</code>下的<code>N</code>个<code>Replica</code>中，只能有一个充当<code>Leader Replica</code>，<code>Leader Replica</code>负责对外提供服务；</li><li>剩下的<code>N-1</code>个<code>Replica</code>，都是作为<code>Follower Replica</code>，<code>Follower Replica</code>只是作为数据冗余，不对外提供服务；</li></ul></li><li>第三层：消息层<ul><li>每个<code>Partition</code>中包含若干消息，每个消息的<code>Offset</code>（注意不是<code>Consumer Offset</code>）都是从0开始，依次递增；</li></ul></li></ul><h3 id="数据持久化（Log）"><a href="#数据持久化（Log）" class="headerlink" title="数据持久化（Log）"></a>数据持久化（Log）</h3><p><code>kafka</code>使用消息日志<code>Log</code>来保存数据，一个<code>Log</code>就是磁盘上一个只能追加写消息的物理文件。</p><p>一个<code>Log</code>包含了多个日志段<code>Log Segment</code>，消息其实是被追加写到最新的<code>Log Segment</code>中的；</p><p>当写满一个<code>Log Segment</code>的时候，会自动切分一个新的<code>Log Segment</code>中，老的<code>Log Segment</code>就会被封存；</p><p><code>kafka</code>会有一个定时任务，定期检查老的<code>Log Segment</code>是否能够被删除，从而释放磁盘空间；</p><h3 id="两种消息模型"><a href="#两种消息模型" class="headerlink" title="两种消息模型"></a>两种消息模型</h3><p>点对点<code>peer to peer</code></p><ul><li>同一个消息只能被下游的一个<code>Consumer</code>消费；</li><li>kafka实现点对点，用到的是<code>Consumer Group</code>的概念</li></ul><p>发布订阅模型<code>pub/sub</code></p><ul><li>我们常用到的其实就是这种发布订阅模型</li></ul><h2 id="发展历史和定位"><a href="#发展历史和定位" class="headerlink" title="发展历史和定位"></a>发展历史和定位</h2><p>kakka既是一个消息引擎系统，同时又是一个分布式流处理平台；</p><h3 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h3><ul><li><p>是<code>Linkedln</code>公司内部的孵化项目。</p></li><li><p><code>Linkedln</code>一开始是有 数据强实时性处理方面的需求，用了<code>activeMq</code>，但不理想，所以准备自己搞一套。</p></li><li><p><code>Kafka</code> 自诞生伊始是以<strong>消息引擎系统</strong>的面目出现在大众视野中的。如果翻看 <code>0.10.0.0</code> 之前的官网说明，你会发现 <code>Kafka</code> 社区将其清晰地定位为一个分布式、分区化且带备份功能的提交日志<code>Commit Log</code>服务。</p></li><li><p><code>Kafka</code>在设计之初提供三个方面的特性：</p><ul><li>提供一套 API 实现<code>Producer</code>和<code>Consumer</code>；</li><li>降低网络传输和磁盘存储开销；</li><li>实现高伸缩性架构。</li></ul></li><li><p>后来用的人越来越多，<code>kafka</code>思考引入了流处理；</p></li><li><p><code>Kafka</code> 社区于 <code>0.10.0.0</code> 版本正式推出了流处理组件 <code>Kafka Streams</code>，也正是从这个版本开始，<code>Kafka</code> 正式“变身”为分布式的流处理平台，而不仅仅是消息引擎系统了。</p></li></ul><h3 id="与其他的流处理框架的优点"><a href="#与其他的流处理框架的优点" class="headerlink" title="与其他的流处理框架的优点"></a>与其他的流处理框架的优点</h3><ul><li>第一点是更容易实现端到端的正确性<code>Correctness</code></li><li><code>kafka</code>自己对于流式计算的定位</li></ul><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><ul><li>消息引擎系统</li><li>流处理平台</li><li>分布式存储系统（很少）</li></ul><h2 id="kafka版本"><a href="#kafka版本" class="headerlink" title="kafka版本"></a>kafka版本</h2><h3 id="发行版本"><a href="#发行版本" class="headerlink" title="发行版本"></a>发行版本</h3><p><code>kafka</code>存在多个不同的发行版本，类似<code>linux</code>系统中的<code>centos</code>，<code>redhat</code>，<code>ununtu</code>等；</p><table><thead><tr><th>类型</th><th>描述</th><th>优点</th><th>缺点</th><th>选择</th></tr></thead><tbody><tr><td>apache kafka</td><td>Apache Kafka 是最“正宗”的 Kafka，是我们学习和使用 Kafka 的基础。</td><td>优势在于迭代速度快，社区响应度高，使用它可以让你有更高的把控度</td><td>缺陷在于仅提供基础核心组件，缺失一些高级的特性。</td><td>如果你仅仅需要一个消息引擎系统亦或是简单的流处理应用场景，同时需要对系统有较大把控度，那么我推荐你使用 Apache Kafka。</td></tr><tr><td>Confluent Kafka</td><td>Confluent 公司：2014 年，Kafka 的 3 个创始人 Jay Kreps、Naha Narkhede 和饶军离开 LinkedIn 创办了 Confluent 公司，专注于提供基于 Kafka 的企业级流处理解决方案。Confluent Kafka 提供了一些 Apache Kafka 没有的高级特性，比如跨数据中心备份、Schema 注册中心以及集群监控工具等。</td><td>优势在于集成了很多高级特性且由 Kafka 原班人马打造，质量上有保证；</td><td>缺陷在于相关文档资料不全，普及率较低，没有太多可供参考的范例。</td><td>如果你需要用到 Kafka 的一些高级特性，那么推荐你使用 Confluent Kafka。</td></tr><tr><td>CDH Kafka &#x2F; HDP Kafka</td><td>Cloudera 提供的 CDH 和 Hortonworks 提供的 HDP 是非常著名的大数据平台，里面集成了目前主流的大数据框架，能够帮助用户实现从分布式存储、集群调度、流处理到机器学习、实时数据库等全方位的数据处理，不管是 CDH 还是 HDP 里面都集成了 Apache Kafka，因此我把这两款产品中的 Kafka 称为 CDH Kafka 和 HDP Kafka。</td><td>操作简单，节省运维成本</td><td>把控度低，演进速度较慢。</td><td>如果你需要快速地搭建消息引擎系统，或者你需要搭建的是多框架构成的数据平台且 Kafka 只是其中一个组件，那么我推荐你使用这些大数据云公司提供的 Kafka。</td></tr></tbody></table><h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>在官网上下载 <code>Kafka</code> 时，会看到这样的版本：</p><img src="kafka从入门到入土.assets/c10df9e6f72126e9c721fba38e27ac23.png" alt="img" style="zoom:80%;" /><p>有些人会误将<code>Scala</code>版本看作是<code>Kafka</code>版本，那么就来解释一下这个版本号</p><ul><li><p><code>2.11/2.12</code>：代表着<code>Kafka</code>源代码的<code>Scala</code>编译器版本</p></li><li><p><code>2.3.0</code>：才是Kafka的版本号，<code>2</code>代表着大版本号；<code>3</code>代表着小版本号；<code>0</code>代表着修订版本号或补丁</p></li></ul><p>Kafka目前经历了7个大版本，0.7、0.8、0.9、0.10、0.11、1.0和2.0，其中小版本与Patch版本很多就不一一列举</p><p>在上面的7个大版本中，在哪个版本进行了重大的改进，来好好看一下</p><img src="kafka从入门到入土.assets/Kafka版本变迁.png" alt="img" style="zoom:80%;" /><h4 id="0-7版本"><a href="#0-7版本" class="headerlink" title="0.7版本"></a>0.7版本</h4><p>这是个“上古”版本，只提供了基础的消息队列功能，还没有提供副本机制</p><h4 id="0-8版本"><a href="#0-8版本" class="headerlink" title="0.8版本"></a>0.8版本</h4><p>正式引入了副本机制，能够比较好地做到消息无丢失，新版本Producer API不稳定</p><h4 id="0-9版本"><a href="#0-9版本" class="headerlink" title="0.9版本"></a>0.9版本</h4><p>添加了基础的安全认证&#x2F;权限；新版本Producer API在这个版本中算比较稳定，但是0.9版的Consumer API BUG超多，即使提到社区也不会有人管，所以千万别用！</p><h4 id="0-10版本"><a href="#0-10版本" class="headerlink" title="0.10版本"></a>0.10版本</h4><p>是里程碑式的大版本，因为该版本引入了Kafka Streams，但还不能生产大规模部署使用，自0.10.2.2版本起，新版本Consumer API算是比较稳定了</p><h4 id="0-11版本"><a href="#0-11版本" class="headerlink" title="0.11版本"></a>0.11版本</h4><p>引入了两个重量级的功能变更：一个是提供幂等性Producer API以及事务（Transaction） API；另一个是对Kafka消息格式做了重构</p><p>Producer实现幂等性以及支持事务都是Kafka实现流处理结果正确性的基石，由于刚推出，事务API有一些Bug，另外事务API主要是为Kafka Streams应用服务的，不建议用</p><p>这个版本中各个大功能组件都变得非常稳定了，国内该版本的用户也很多，应该算是目前最主流的版本之一了</p><p>如果你对1.0版本是否适用于线上环境依然感到困惑，那么至少将你的环境升级到0.11.0.3，因为这个版本的消息引擎功能已经非常完善了</p><h4 id="1-0-x2F-2-0版本"><a href="#1-0-x2F-2-0版本" class="headerlink" title="1.0&#x2F;2.0版本"></a>1.0&#x2F;2.0版本</h4><p>合并说下1.0和2.0版本吧，因为这两个大版本主要还是Kafka Streams的各种改进，在消息引擎方面并未引入太多的重大功能特性</p><p>Kafka Streams的确在这两个版本有着非常大的变化，也必须承认Kafka Streams目前依然还在积极地发展着，如果你是Kafka Streams的用户，至少选择2.0.0版本吧</p><h4 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h4><p>不论你用的是哪个版本，都请尽量保持服务器端版本和客户端版本一致，否则你将损失很多Kafka为你提供的性能优化收益</p><h2 id="kafka生产集群部署"><a href="#kafka生产集群部署" class="headerlink" title="kafka生产集群部署"></a>kafka生产集群部署</h2><p>上面了解了kafka的基本概念之后，下面看一下kafka的生产部署，需要怎么部署</p><p>同时在本小节之后，我们会搭建一个简单的kafka集群，用于后续的学习</p><p>kafka的集群搭建需要考虑一下几个因素</p><table><thead><tr><th>因素</th><th>考量点</th><th>建议</th></tr></thead><tbody><tr><td>操作系统</td><td>操作系统的IO模型</td><td>将kafka部署在linux上</td></tr><tr><td>磁盘</td><td>磁盘的IO性能</td><td>普通环境使用机械硬盘，不需要搭建RAID</td></tr><tr><td>磁盘容量</td><td>根据消息数，留存时间预估磁盘容量</td><td>实际使用中磁盘预留20%~30%的空间</td></tr><tr><td>带宽</td><td>根据实际带宽资源和业务SLA预估服务器数量</td><td>对于千兆网络，建议每台服务器按照700Mbps来计算，避免大流量下的丢包</td></tr></tbody></table><h3 id="操作系统的选择"><a href="#操作系统的选择" class="headerlink" title="操作系统的选择"></a>操作系统的选择</h3><p>操作系统：Windows，Linux，MacOs</p><p>选择：Linux</p><p>为什么：</p><ul><li>IO模型的使用</li><li>网络传输效率</li><li>社区支持度</li></ul><h4 id="IO模型的使用"><a href="#IO模型的使用" class="headerlink" title="IO模型的使用"></a>IO模型的使用</h4><ul><li>阻塞IO</li><li>非阻塞IO</li><li>IO多路复用</li><li>信号驱动IO</li><li>异步IO</li></ul><p>每种IO都有自己的典型使用场景，比如：</p><ul><li>Java中的Socket对象的阻塞模式和非阻塞模式就是对应前两种</li><li>Linux系统的select函数就属于IO多路复用</li><li>大名鼎鼎的epoll介入第三种和第四种之间</li><li>第五种模型，目前很少有Linux支持，然而Windos却在操作系统中提供了叫IOCP线程模型属于第五种</li></ul><p>说完了IO模型，再来看kafka与IO模型的关系</p><ul><li>kafka的底层使用的是java的selector<ul><li>java的selector在linux上的实现机制是：epoll</li><li>而在windos上的实现机制是：select（IO多路复用）</li></ul></li><li>所以，将kafka部署在linux机器上，更有优势</li></ul><h4 id="网络传输效率"><a href="#网络传输效率" class="headerlink" title="网络传输效率"></a>网络传输效率</h4><p>kafka的消息是通过网络传输的，而消息又是保存在磁盘中的，所以kafka非常依赖网络和磁盘的性能；</p><p>而linux恰巧有零拷贝（Zero copy）技术，就是当数据在磁盘和网络进行传输的时候，避免昂贵的的内核态数据拷贝从而实现数据的高速传输；</p><p>而windos要到java8的60更新版本才有这个功能；</p><h4 id="社区的支持度"><a href="#社区的支持度" class="headerlink" title="社区的支持度"></a>社区的支持度</h4><p>社区对于windos版的bug不做承诺，基本不会修复；</p><h3 id="磁盘的选择"><a href="#磁盘的选择" class="headerlink" title="磁盘的选择"></a>磁盘的选择</h3><ul><li>选择机械磁盘：kafka多为顺序读写，规避了机械磁盘的弊端，替换成SSD，效益不大</li><li>不用组RAID：kafka在软件层面通过分区副本保证了高可用，基本不需要磁盘组RAID</li></ul><h3 id="磁盘容量的选择"><a href="#磁盘容量的选择" class="headerlink" title="磁盘容量的选择"></a>磁盘容量的选择</h3><ul><li><p>磁盘容量：kafka的日志有保留时间的概念，根据具体的业务量，消息大小，计算好容量；</p><ul><li><p>新增消息量</p></li><li><p>消息留存时间</p></li><li><p>平均消息大小</p></li><li><p>备份数</p></li><li><p>是否启用压缩（压缩比）</p></li></ul></li></ul><h3 id="带宽的选择"><a href="#带宽的选择" class="headerlink" title="带宽的选择"></a>带宽的选择</h3><p>目前公司普遍的带宽配置都是千兆网（每秒处理1G数据），财大气粗的公司会有万兆网（每秒处理10G数据）；</p><p>假设你公司的机房环境是千兆网络，即 1Gbps，现在你有个业务，其业务目标或 SLA 是在 1 小时内处理 1TB 的业务数据。那么问题来了，你到底需要多少台 Kafka 服务器来完成这个业务呢？</p><p>千兆网络下，单台机器，假设kafka占用70%的带宽（总要为其他进程保留一些资源），稍等，这只是它能使用的最大带宽资源，你不能让 Kafka 服务器常规性使用这么多资源，故通常要再额外预留出 2&#x2F;3 的资源，即单台服务器使用带宽 700Mb &#x2F; 3 ≈ 240Mbps。有了 240Mbps，我们就可以计算 1 小时内处理 1TB 数据所需的服务器数量了。根据这个目标，我们每秒需要处理 2336Mb 的数据，除以 240，约等于 10 台服务器。如果消息还需要额外复制两份，那么总的服务器台数还要乘以 3，即 30 台。</p><h2 id="重要的集群参数配置"><a href="#重要的集群参数配置" class="headerlink" title="重要的集群参数配置"></a>重要的集群参数配置</h2><p>参数配置分为四个方面：</p><ul><li>broker端参数配置</li><li>topic的参数配置</li><li>JVM的参数配置</li><li>操作系统的参数配置</li></ul><h3 id="broker端参数（静态参数）"><a href="#broker端参数（静态参数）" class="headerlink" title="broker端参数（静态参数）"></a>broker端参数（静态参数）</h3><p>静态参数是指修改后需要重启才能生效的参数；</p><p>是配置在 kafka安装的这个机器上的。通过静态的配置文件配置的。</p><h4 id="存储信息类参数"><a href="#存储信息类参数" class="headerlink" title="存储信息类参数"></a>存储信息类参数</h4><p>表示 Broker 使用哪些磁盘</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>log.dirs</td><td>【没有默认值的，必须手动指定】指定Broker需要使用的若干个文件目录路径，可配置多个</td></tr><tr><td>log.dir</td><td>【一般不用设置，新版本已经取消了】只能配置一个，用来补充上面参数的</td></tr></tbody></table><h4 id="与ZK相关的参数"><a href="#与ZK相关的参数" class="headerlink" title="与ZK相关的参数"></a>与ZK相关的参数</h4><p>ZK负责协调管理并保存 Kafka 集群的所有元数据信息，比如集群都有哪些 Broker 在运行、创建了哪些 Topic，每个 Topic 都有多少分区以及这些分区的 Leader 副本都在哪些机器上等信息</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>zookeeper.connect</td><td>负责协调管理并保存 Kafka 集群的所有元数据信息</td></tr></tbody></table><h4 id="broker连接相关的参数"><a href="#broker连接相关的参数" class="headerlink" title="broker连接相关的参数"></a>broker连接相关的参数</h4><p>表示客户端程序或其他 Broker 如何与该 Broker 进行通信的设置</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>listeners</td><td>告诉外部连接需要通过什么协议访问指定主机名和端口开放的kafka服务（用于内网访问）</td></tr><tr><td>Advertised.listeners</td><td>表明这组监听器是broker对外发布的（用于外网访问）</td></tr><tr><td>host.name&#x2F;port</td><td>这俩参数是过期参数，忘掉</td></tr></tbody></table><h4 id="topic管理的参数"><a href="#topic管理的参数" class="headerlink" title="topic管理的参数"></a>topic管理的参数</h4><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>auto.create.topics.enable</td><td>是否允许自动创建topic，<br />建议设置成false；</td></tr><tr><td>unclean.leader.election.enable</td><td>是否允许Unclean Leader选举，<br />建议设置为false；<br />kafka的分区有多个副本，并不是所有的副本都有资格竞争Leader，只有保存数据比较多的才有资格；那如果保存数据比较多的副本全都挂了，那还要不要竞选Leader呢？ 就是这个参数控制的；<br />false表示不竞选，后果：分区不可用；<br />true表示竞选；后果：数据不一致；</td></tr><tr><td>auto.leader.rebalance.enable</td><td>是否允许定期进行Leader选举；true表示到达一定条件，kafka会自动把leader换了，注意是换掉，而不是选举；即使原来的leaderA运行的好好地，也会给换成leaderB；换leader的代价很大，建议设置为false；</td></tr></tbody></table><h4 id="数据留存方面的参数"><a href="#数据留存方面的参数" class="headerlink" title="数据留存方面的参数"></a>数据留存方面的参数</h4><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>log.retention.{hour|minutes|ms}</td><td>控制一条消息被保留多长时间</td></tr><tr><td>log.retention.bytes</td><td>Broker为保留消息提供的磁盘容量的大小</td></tr><tr><td>message.max.bytes</td><td>控制Broker能够接收的最大的消息大小</td></tr></tbody></table><h3 id="Topic的参数配置"><a href="#Topic的参数配置" class="headerlink" title="Topic的参数配置"></a>Topic的参数配置</h3><p>topic端的参数配置会覆盖broker端的参数配置</p><p>Topic 端的参数是在创建Topic的时候，手动设置的。<a href="#%E6%80%8E%E4%B9%88%E4%BF%AE%E6%94%B9topic%E7%9A%84%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE">怎么修改topic的参数配置</a></p><h4 id="数据留存方面的参数-1"><a href="#数据留存方面的参数-1" class="headerlink" title="数据留存方面的参数"></a>数据留存方面的参数</h4><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>retention.ms</td><td>规定了该topic下数据的保存时长，默认7天，如果配置了，就会覆盖broker端的配置</td></tr><tr><td>retention.bytes</td><td>规定了要为该topic预留多少磁盘容量空间</td></tr><tr><td>max.message.bytes</td><td>该参数跟 Broker 端的 message.max.bytes 参数的作用是一样的，只不过 max.message.bytes 是作用于某个 topic，而 message.max.bytes 是作用于全局。</td></tr></tbody></table><h4 id="怎么修改topic的参数配置"><a href="#怎么修改topic的参数配置" class="headerlink" title="怎么修改topic的参数配置"></a>怎么修改topic的参数配置</h4><ul><li><p>创建topic的时候设置</p><ul><li><blockquote><p>bin&#x2F;kafka-topics.sh –bootstrap-server localhost:9092 –create –topic transaction –partitions 1 –replication-factor 1 –config retention.ms&#x3D;15552000000 –config max.message.bytes&#x3D;5242880</p></blockquote></li></ul></li><li><p>修改topic的时候设置</p><ul><li><blockquote><p>bin&#x2F;kafka-configs.sh –zookeeper localhost:2181 –entity-type topics –entity-name transaction –alter –add-config max.message.bytes&#x3D;10485760</p></blockquote></li></ul></li></ul><h3 id="JVM的参数配置"><a href="#JVM的参数配置" class="headerlink" title="JVM的参数配置"></a>JVM的参数配置</h3><p>设置kafka的JVM参数，只需要设置环境变量就可以啦。<a href="#%E6%80%8E%E4%B9%88%E5%AF%B9kafka%E8%AE%BE%E7%BD%AEJVM%E5%8F%82%E6%95%B0">怎么对kafka设置JVM参数</a></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>KAFKA_HEAP_OPTS</td><td>JVM堆大小，建议设置为6GB，默认的1GB太小了</td></tr><tr><td>KAFKA_JVM_PERFORMANCE_OPTS</td><td>指定垃圾回收器<br>在java7下：cpu充足，就用CMS；否则使用ParallelGC<br>在java8下：选择G1</td></tr></tbody></table><h4 id="怎么对kafka设置JVM参数"><a href="#怎么对kafka设置JVM参数" class="headerlink" title="怎么对kafka设置JVM参数"></a>怎么对kafka设置JVM参数</h4><p>指定kafka的环境变量即可</p><ul><li>KAFKA_HEAP_OPTS：指定堆大小</li><li>KAFKA_JVM_PERFORMANCE_OPTS：指定垃圾回收器</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$<span class="token operator">></span> <span class="token builtin class-name">export</span> <span class="token assign-left variable">KAFKA_HEAP_OPTS</span><span class="token operator">=</span>--Xms6g  <span class="token parameter variable">--Xmx6g</span>$<span class="token operator">></span> <span class="token builtin class-name">export</span> <span class="token assign-left variable">KAFKA_JVM_PERFORMANCE_OPTS</span><span class="token operator">=</span> <span class="token parameter variable">-server</span> <span class="token parameter variable">-XX:+UseG1GC</span> <span class="token parameter variable">-XX:MaxGCPauseMillis</span><span class="token operator">=</span><span class="token number">20</span> <span class="token parameter variable">-XX:InitiatingHeapOccupancyPercent</span><span class="token operator">=</span><span class="token number">35</span> <span class="token parameter variable">-XX:+ExplicitGCInvokesConcurrent</span> <span class="token parameter variable">-Djava.awt.headless</span><span class="token operator">=</span>true$<span class="token operator">></span> bin/kafka-server-start.sh config/server.properties<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="操作系统的参数配置"><a href="#操作系统的参数配置" class="headerlink" title="操作系统的参数配置"></a>操作系统的参数配置</h3><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>文件描述符限制</td><td>ulimit -n；其实设置这个参数不重要，但是不设置后果很严重，会看到too many open file 的报错；</td></tr><tr><td>文件系统类型</td><td>文件系统类型（ext3，ext4，XFS），XFS的性能强于ext4，ZFS的性能强于XFS（但技术比较新，使用很少）</td></tr><tr><td>Swappiness</td><td>网上很多文章都提到设置其为 0，将 swap 完全禁掉以防止 Kafka 进程使用 swap 空间。我个人反倒觉得还是不要设置成 0 比较好，我们可以设置成一个较小的值。为什么呢？因为一旦设置成 0，当物理内存耗尽时，操作系统会触发 OOM killer 这个组件，它会随机挑选一个进程然后 kill 掉，即根本不给用户任何的预警。但如果设置成一个比较小的值，当开始使用 swap 空间时，你至少能够观测到 Broker 性能开始出现急剧下降，从而给你进一步调优和诊断问题的时间。基于这个考虑，我个人建议将 swappniess 配置成一个接近 0 但不为 0 的值，比如 1。</td></tr><tr><td>提交时间（系统的刷盘时间）</td><td>提交时间或者说是 Flush 落盘时间。向 Kafka 发送数据并不是真要等数据被写入磁盘才会认为成功，而是只要数据被写入到操作系统的页缓存（Page Cache）上就可以了，随后操作系统根据 LRU 算法会定期将页缓存上的“脏”数据落盘到物理磁盘上。这个定期就是由提交时间来确定的，默认是 5 秒。一般情况下我们会认为这个时间太频繁了，可以适当地增加提交间隔来降低物理磁盘的写操作。当然你可能会有这样的疑问：如果在页缓存中的数据在写入到磁盘前机器宕机了，那岂不是数据就丢失了。的确，这种情况数据确实就丢失了，但鉴于 Kafka 在软件层面已经提供了多副本的冗余机制，因此这里稍微拉大提交间隔去换取性能还是一个合理的做法。</td></tr></tbody></table><h2 id="分区机制"><a href="#分区机制" class="headerlink" title="分区机制"></a>分区机制</h2><p>对于那种大批量机器组成的集群环境，每分钟产生的日志量都能以 GB 数，因此如何将这么大的数据量均匀地分配到 Kafka 的各个 Broker 上，就成为一个非常重要的问题。</p><p>我们知道 kafka 的数据，是以 Topic 为概念进行存储的，而<code>topic</code>是一个逻辑概念，真正存放数据的是<code>topic</code>下的<code>partition</code>；<code>partition</code>是物理概念；</p><p>一个消息只会保存在一个<code>topic</code>下的一个<code>partition</code>中，不会保存在多个<code>partition</code>中（<code>Replica</code>除外）</p><p>那么，为了保证大数据量的均匀分布，其实就是保证一个<code>topic</code>下的数据量均匀的分散在各个<code>partition</code>中；</p><p>那么问题来了？</p><h3 id="为什么要分区"><a href="#为什么要分区" class="headerlink" title="为什么要分区"></a>为什么要分区</h3><p>为什么要<code>Partiton</code>，为什么<code>kafka</code>不直接存储数据，而是要分区存储？为什么要使用<code>Partiton</code>，而不是直接使用<code>topic</code>？</p><p>分区的目的是为了<strong>负载均衡</strong>；或者说分区的目的是为了<strong>提高系统的可伸缩性</strong>；</p><ul><li>负载均衡<ul><li>如果没有分区，所有的请求全部在一个<code>topic</code>上，请求量大的时候，只对一个磁盘进行大量的读写（分钟<code>GB</code>级别的数据量），可能直接就崩了；</li></ul></li><li>可伸缩性<ul><li>顺丰的<code>kafka</code>一般是32分区，这样每一个<code>Partition</code>都可以有一个<code>consumer</code>，提升系统的吞吐量；当数据量增长的时候，可以扩<code>Partition</code>，32-&gt;64；提升系统的可伸缩性；</li><li>但是一般不建议直接扩<code>Partition</code>，在顺丰，一般是申请新的<code>topic</code>，然后将消息转发到不同的<code>topic</code>中，变相的实现扩<code>Partition</code>；</li><li>因为<code>Partition</code>过多，<code>kafka</code>管理起来很困难，没必要增加不必要的消耗；</li></ul></li><li><code>Partition</code>可以实现业务上的功能（消息的顺序问题）</li></ul><p>以上说了<code>Partiton</code>存在的必要性</p><p>那么既然存在<code>Partiton</code>，怎么保证每个<code>Partiton</code>的数据量的均匀呢，避免数据倾斜？这就涉及到分区的策略</p><h3 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h3><p>分区策略：就是决定消息被发送到哪个分区</p><table><thead><tr><th>分区策略</th><th>描述</th></tr></thead><tbody><tr><td>轮训</td><td>没有指定<code>partitioner.class</code>这个配置的时候，在没有指定key的时候（消息键保留策略），轮训策略是兜底的</td></tr><tr><td>随机</td><td>使用的很少了，已经被废弃了</td></tr><tr><td>自定义</td><td>需要显示的配置<code>partitioner.class</code>这个配置，同时需要编写代码；</td></tr><tr><td>按消息键保留策略</td><td>按照key的顺序进行存放</td></tr></tbody></table><p>默认分区策略：如果指定了key，按照key分发；没有指定key，按照轮训；</p><h3 id="怎么设置分区策略"><a href="#怎么设置分区策略" class="headerlink" title="怎么设置分区策略"></a>怎么设置分区策略</h3><p><strong>轮训</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">不需要配置，默认的就是这个。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>随机</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PartitionInfo</span><span class="token punctuation">></span></span> partitions <span class="token operator">=</span> cluster<span class="token punctuation">.</span><span class="token function">partitionsForTopic</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token class-name">ThreadLocalRandom</span><span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>partitions<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>按消息键保序策略</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PartitionInfo</span><span class="token punctuation">></span></span> partitions <span class="token operator">=</span> cluster<span class="token punctuation">.</span><span class="token function">partitionsForTopic</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> partitions<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>自定义</strong></p><p>比如我想实现：根据 <code>Broker</code> 所在的 <code>IP</code> 地址判断是南方还是北方，实现定制化的分区策略</p><ul><li>编写一个具体的类实现<code>org.apache.kafka.clients.producer.Partitioner</code>接口</li><li>实现其中的两个方法：<code>partition()</code>和<code>close()</code></li><li>显式地配置生产者端的参数<code>partitioner.class</code>为你自己实现类的 <code>Full Qualified Name</code></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PartitionInfo</span><span class="token punctuation">></span></span> partitions <span class="token operator">=</span> cluster<span class="token punctuation">.</span><span class="token function">partitionsForTopic</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> partitions<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>p <span class="token operator">-></span> <span class="token function">isSouth</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">leader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">host</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">PartitionInfo</span><span class="token operator">::</span><span class="token function">partition</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findAny</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="消息压缩（消息格式）"><a href="#消息压缩（消息格式）" class="headerlink" title="消息压缩（消息格式）"></a>消息压缩（消息格式）</h2><h3 id="为什么要压缩？"><a href="#为什么要压缩？" class="headerlink" title="为什么要压缩？"></a>为什么要压缩？</h3><p>说起压缩<code>compression</code>，我相信你一定不会感到陌生。它秉承了用时间去换空间的经典 <code>trade-off</code> 思想，具体来说就是用 CPU 时间去换磁盘空间或网络 I&#x2F;O 传输量，希望以较小的 CPU 开销带来更少的磁盘占用或更少的网络 I&#x2F;O 传输。在 <code>Kafka</code> 中，压缩也是用来做这件事的。</p><h3 id="kafka的消息格式"><a href="#kafka的消息格式" class="headerlink" title="kafka的消息格式"></a>kafka的消息格式</h3><p>kafka有两大类消息格式，一类是在<code>0.11.0.0</code>版本之前的消息格式（称作V1版本），一个是<code>0.11.0.0</code>版本之后的格式（称作V2版本）；</p><p>不管是哪个版本，kafka消息层次都是分为两层：</p><table><thead><tr><th>V1版本</th><th>V2版本</th></tr></thead><tbody><tr><td>消息集合（message set） + 消息（message）</td><td>消息集合（record batch） + 消息（record）</td></tr></tbody></table><p>一个消息集合中包含若干个日志项<code>record item</code>，日志项<code>record item</code>才是真正封装消息的地方；（注意这里不要和日志段（<code>Log Segment</code>）混为一谈）</p><p>V2版本对V1版本进行了优化，将日志项<code>record item</code>中一些通用的字段抽出来，放在了消息集合中；</p><p>V2版本对V1版本还有一个关于压缩方面的优化</p><h3 id="怎么压缩"><a href="#怎么压缩" class="headerlink" title="怎么压缩"></a>怎么压缩</h3><p>V2 版本对 V1 版本还有一个关于压缩方面的优化</p><p>V1 版本：是把多条消息进行压缩，然后将压缩后的内容放在外层消息的消息体字段中； </p><p>V2 版本：是对整个消息集合进行压缩，显然V2版本的压缩效率应该更高；</p><p>压缩使用到的是压缩算法：<a href="#%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%89%E6%8B%A9">压缩算法的选择</a></p><h3 id="何时压缩"><a href="#何时压缩" class="headerlink" title="何时压缩"></a>何时压缩</h3><p>在 <code>kafka</code> 中，压缩可能发生在：<code>Producer</code>端和<code>Broker</code>端</p><ul><li><p><code>Producer</code>端【一般都是<code>Producer</code>端做压缩】</p><ul><li>在<code>Producer</code>程序中添加一个配置：<code>compression.type</code> 参数</li><li>compression.type&#x3D;gzip 表示开启gzip压缩</li></ul></li><li><p><code>Broker</code>端</p><ul><li>一般<code>Broker</code>端不会对<code>Producer</code>发出来的消息进行修改；</li><li>有两个例外情况，会让<code>Broker</code>对消息重新压缩<ul><li><code>Broker</code>端和<code>Producer</code>端指定的消息压缩算法不一致（不一致的时候，<code>broker</code>端会对<code>producer</code>端发出来的消息解压然后重新压缩）</li><li><code>Broker</code>端发生了消息格式转换：新老版本消息格式（V1版本和V2版本）兼容的问题</li></ul></li></ul></li></ul><h3 id="何时解压缩"><a href="#何时解压缩" class="headerlink" title="何时解压缩"></a>何时解压缩</h3><ul><li><code>consumer</code>端消费到消息的时候，进行解压缩<ul><li>解压缩的时候，压缩算法是在消息中，用一个字段标识的，所以<code>consumer</code>可以拿到消息之后在解压缩</li></ul></li><li><code>broker</code>端收到<code>producer</code>发出的消息之后，也会解压缩一次，进行消息的校验；</li></ul><h3 id="压缩的时机"><a href="#压缩的时机" class="headerlink" title="压缩的时机"></a>压缩的时机</h3><p>记住这句话：<code>Producer</code>端压缩，<code>Broker</code>端保持，<code>Consumer</code>端解压缩</p><h3 id="压缩算法的选择"><a href="#压缩算法的选择" class="headerlink" title="压缩算法的选择"></a>压缩算法的选择</h3><p>一般看两个指标：压缩比 和 压缩&#x2F;解压缩的吞吐量</p><p>GZIP</p><p>Snappy</p><p>LZ4</p><p>zstd</p><h2 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h2><p><code>kafka</code>只对 已提交成功 的消息做有限度的持久化保证；</p><h3 id="什么是消息丢失"><a href="#什么是消息丢失" class="headerlink" title="什么是消息丢失"></a>什么是消息丢失</h3><p>对于<code>Producer</code>来说：消息发不出去，就是丢失；</p><p>对于<code>Consumer</code>来说：消息消费不到，就是丢失；</p><p>对于<code>Broker</code>来说：不存在丢失，<code>Broker</code>会对 已提交成功 的消息，做有限度的持久化；</p><h3 id="什么时候会消息丢失"><a href="#什么时候会消息丢失" class="headerlink" title="什么时候会消息丢失"></a>什么时候会消息丢失</h3><ul><li><code>Producer</code>丢失消息<ul><li><code>producer.send(msg) </code>因为是异步，<code>fire and forget</code> 所以可能会丢消息</li><li>网络抖动、消息不合法被<code>broker</code>拒收（比如：消息体太大）等都会导致消息发送不成功</li></ul></li><li><code>Consumer</code>丢失消息<ul><li>消费的消息不存在了。一般只有先提交<code>offset</code>在消费的场景下会发生；</li><li>多线程处理消息的时候，某一个线程消费失败了，但是<code>offset</code>自动提交了；</li></ul></li></ul><h3 id="怎么保证消息不丢失"><a href="#怎么保证消息不丢失" class="headerlink" title="怎么保证消息不丢失"></a>怎么保证消息不丢失</h3><p>上面几种丢失消息的场景，怎么避免？</p><ul><li>【<code>Producer</code>端】：不要使用 <code>producer.send(msg)</code>，而要使用 <code>producer.send(msg, callback)</code>。一定要使用带有回调通知的 <code>send </code>方法。</li><li>【<code>Producer</code>端】：设置 <code>acks</code> &#x3D; <code>all</code>。是个动态值（如果原来有<code>3</code>个<code>Replica</code>，就要写入<code>3</code>个，如果有<code>1</code>个挂了，那就只需要写入<code>2</code>个），表明所有<code>Replica</code>都要接收到消息，该消息才算是“已提交”。这是最高等级的“已提交”定义。</li><li>【<code>Producer</code>端】：设置 <code>retries</code> 为一个较大的值。 表示<code>Producer </code>自动重试。当出现网络的瞬时抖动时，消息发送可能会失败，这里开启自动重试，避免消息丢失。（重试会导致消息乱序吗：会）</li><li>【Broker端】：设置 <code>unclean.leader.election.enable</code> &#x3D; <code>false</code>。它控制的是哪些 <code>Replica </code>有资格竞选分区的 <code>Leader</code>。如果一个 <code>Replica </code> 落后原先的 <code>Leader </code>太多，就不要让它竞选，即不允许这种情况的发生。</li><li>【Broker端】：设置<code> replication.factor</code> &gt;&#x3D; <code>3</code>。表示某个分区的<code>Replica</code>总数，最好将消息多保存几份，毕竟目前防止消息丢失的主要机制就是冗余</li><li>【Broker端】：设置 <code>min.insync.replicas</code> &gt; 1。表示至少写入多少个<code>Replica</code>才算是“已提交”。设置成大于 1 可以提升消息持久性。在实际环境中千万不要使用默认值 1。</li><li>【Broker端】：确保<code> replication.factor</code> &gt; <code>min.insync.replicas</code>。如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成。推荐设置成 <code>replication.factor</code> &#x3D; <code>min.insync.replicas</code> + <code>1</code>。</li><li>【<code>Consumer</code>端】：设置<code>enable.auto.commit</code>&#x3D; <code>false</code>，采用手动提交位移的方式。就像前面说的，这对于单 <code>Consumer </code>多线程处理的场景而言是至关重要的。</li></ul><p>举个例子：</p><p>比如<code>Replica</code>&#x3D;<code>3</code>，设置<code>min.insync.replicas</code>&#x3D;<code>2</code>，<code>acks</code>&#x3D;<code>all</code></p><p>如果<code>Replica</code>都正常工作：此时<code>acks</code>&#x3D;<code>all</code>的约束就是写入<code>3</code>个<code>Replica</code>，才算提交成功，此时满足<code>min.insync.replicas</code>&#x3D;<code>2</code>约束。</p><p>如果<code>Replica</code>挂了<code>1</code>个，此时<code>acks</code>&#x3D;<code>all</code>的约束就是写入<code>2</code>个<code>Replica</code>即可，此时满足<code>min.insync.replicas</code>&#x3D;<code>2</code>约束。</p><p>如果<code>Replica</code>挂了<code>2</code>个，此时<code>acks</code>&#x3D;<code>all</code>的约束就是写入<code>1</code>个<code>Replica</code>即可，此时不满足<code>min.insync.replicas</code>&#x3D;<code>2</code>这个下限约束，写入失败。</p><p>补充：</p><blockquote><p>设置 ack &#x3D; all，其实就是需要保证 ISR 集合中所有的 Replica 都写入成功才能返回</p></blockquote><p>公司的生产者的设置</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">KafkaProducer24</span><span class="token punctuation">(</span><span class="token class-name">String</span> brokers<span class="token punctuation">,</span> <span class="token class-name">ProduceOptionalConfig</span> extraConfig<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>extraConfig <span class="token operator">=</span> extraConfig <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token class-name">ProduceOptionalConfig</span><span class="token punctuation">.</span>defaultConfig <span class="token operator">:</span> extraConfig<span class="token punctuation">;</span>    <span class="token class-name">Properties</span> props <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"bootstrap.servers"</span><span class="token punctuation">,</span> brokers<span class="token punctuation">)</span><span class="token punctuation">;</span>    props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"key.serializer"</span><span class="token punctuation">,</span> <span class="token string">"org.apache.kafka.common.serialization.StringSerializer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"value.serializer"</span><span class="token punctuation">,</span> <span class="token string">"org.apache.kafka.common.serialization.ByteArraySerializer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"acks"</span><span class="token punctuation">,</span> <span class="token string">"默认是Leader Replica收到就行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"request.timeout.ms"</span><span class="token punctuation">,</span> <span class="token string">"默认是30000"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"compression.type"</span><span class="token punctuation">,</span> <span class="token string">"snappy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"batch.size"</span><span class="token punctuation">,</span> <span class="token string">"默认是16384"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"linger.ms"</span><span class="token punctuation">,</span> <span class="token string">"默认是5"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">KafkaProducer</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>Kafka 拦截器自<code> 0.10.0.0</code> 版本被引入后并未得到太多的实际应用，我也从未在任何 Kafka 技术峰会上看到有公司分享其使用拦截器的成功案例。</p><p>拦截器是一个小众功能。</p><p>Kafka 拦截器分为生产者拦截器和消费者拦截器</p><h3 id="生产者拦截器"><a href="#生产者拦截器" class="headerlink" title="生产者拦截器"></a>生产者拦截器</h3><p>开发：实现<code>org.apache.kafka.clients.producer.ProducerInterceptor</code>这个接口，这个接口有俩方法</p><ul><li><code>onSend</code>：消息真正发给broker之前</li><li><code>onAcknowledgement</code>：消息提交成功之后，在<code>callback</code>之前</li></ul><h3 id="消费者拦截器"><a href="#消费者拦截器" class="headerlink" title="消费者拦截器"></a>消费者拦截器</h3><p>开发：实现<code>org.apache.kafka.clients.consumer.ConsumerInterceptor</code>这个接口，这个接口有俩方法</p><ul><li><code>onConsume</code>：在消费者真正处理消息之前</li><li><code>onCommit</code>：消费者处理完消息，提交offset之后</li></ul><h3 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a>配置拦截器</h3><p>拦截器开发完成了，怎么让它生效呢？</p><p>当前 Kafka 拦截器的设置方法是通过参数配置完成的</p><p>生产者和消费者两端有一个相同的参数，名字叫 interceptor.classes，它指定的是一组类的列表</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Properties</span> props <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> interceptors <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>interceptors<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"com.yourcompany.kafkaproject.interceptors.AddTimestampInterceptor"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拦截器1</span>interceptors<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"com.yourcompany.kafkaproject.interceptors.UpdateCounterInterceptor"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拦截器2</span>props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">ProducerConfig</span><span class="token punctuation">.</span><span class="token constant">INTERCEPTOR_CLASSES_CONFIG</span><span class="token punctuation">,</span> interceptors<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="生产者与TCP连接"><a href="#生产者与TCP连接" class="headerlink" title="生产者与TCP连接"></a>生产者与TCP连接</h2><h3 id="为什么采用TCP作为底层传输协议"><a href="#为什么采用TCP作为底层传输协议" class="headerlink" title="为什么采用TCP作为底层传输协议"></a>为什么采用TCP作为底层传输协议</h3><p>TCP 拥有一些高级功能，如多路复用请求和同时轮询多个连接的能力。</p><p>多路复用请求：multiplexing request，是将两个或多个数据合并到底层—物理连接中的过程。TCP 的多路复用请求会在一条物理连接上创建若干个虚拟连接，每个虚拟连接负责流转各自对应的数据流。严格讲：TCP 并不能多路复用，只是提供可靠的消息交付语义保证，如自动重传丢失的报文。</p><h3 id="生产者是什么时候创建TCP连接的"><a href="#生产者是什么时候创建TCP连接的" class="headerlink" title="生产者是什么时候创建TCP连接的"></a>生产者是什么时候创建TCP连接的</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Properties</span> props <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>“参数<span class="token number">1</span>”<span class="token punctuation">,</span> “参数<span class="token number">1</span>的值”<span class="token punctuation">)</span>；props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>“参数<span class="token number">2</span>”<span class="token punctuation">,</span> “参数<span class="token number">2</span>的值”<span class="token punctuation">)</span>；……<span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">Producer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">KafkaProducer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ProducerRecord</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>……<span class="token punctuation">)</span><span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>  ……<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>针对上面的代码，能创建TCP连接的只有两个地方，一是 Producer 实例化的时候；一是 producer.send 的时候；</p><ul><li><strong>Kafka 是在 Producer 实例化的时候与 Broker 建立的 TCP 连接</strong></li><li>所以，当 producer.send 的时候，其实已经有TCP连接了</li></ul><p>扩展：除了在 Producer 实例化的时候与 Broker 建立的 TCP 连接之外，还有没有其他情况？</p><ul><li>有，有两个情况，也会创建TCP连接</li><li><strong>元数据更新时，会与元数据中没有连接的 Broker 建立 TCP 连接；</strong><ul><li>每隔5分钟， Producer 会定期从 Broker 中获取元数据信息</li><li>Producer 尝试给一个不存在的 Topic 发送消息时，Broker 会说这个 Topic 不存在，然后 Producer 会请求 Broker 更新元数据信息</li></ul></li><li><strong>在消息发送时，如果 Producer 发现与要发送消息的 Topic 所在的 Broker 没有 TCP 连接，就会创建连接；</strong></li></ul><h3 id="是怎么创建TCP连接的"><a href="#是怎么创建TCP连接的" class="headerlink" title="是怎么创建TCP连接的"></a>是怎么创建TCP连接的</h3><p>在创建 KafkaProducer 实例时，生产者应用会在后台创建并启动一个名为 Sender 的线程，该 Sender 线程开始运行时首先会创建与 Broker 的TCP连接。</p><p>Broker有1000个，bootstrap.servers 要配置1000个嘛？ 不需要，因为 Producer 一旦连接到集群中的任一台 Broker，就能拿到整个集群的 Broker 信息。</p><h3 id="TCP连接是什么时候被关闭的"><a href="#TCP连接是什么时候被关闭的" class="headerlink" title="TCP连接是什么时候被关闭的"></a>TCP连接是什么时候被关闭的</h3><ul><li>用户主动关闭，调用 producer.close</li><li>Kafka自动关闭（虽然是producer端设置的参数，但实际上，是broker关闭的TCP连接）：与 Producer 端参数 connections.max.idle.ms 的值有关。默认情况下该参数值是 9 分钟，即如果在 9 分钟内没有任何请求“流过”某个 TCP 连接，那么 Kafka 会主动帮你把该 TCP 连接关闭。用户可以在 Producer 端设置 connections.max.idle.ms&#x3D;-1 禁掉这种机制。一旦被设置成 -1，TCP 连接将成为永久长连接。</li></ul><h3 id="会存在的一些问题"><a href="#会存在的一些问题" class="headerlink" title="会存在的一些问题"></a>会存在的一些问题</h3><ul><li>producer每5分钟获取一些元数据，然后与元数据中没有连接的broker建立TCP连接，然后9分钟后，broker会中断空闲的连接，然后5分钟后，在此建立连接；9分钟后，再次中断连接；</li></ul><h2 id="消费者与TCP连接"><a href="#消费者与TCP连接" class="headerlink" title="消费者与TCP连接"></a>消费者与TCP连接</h2><h3 id="消费者是什么时候创建TCP连接的"><a href="#消费者是什么时候创建TCP连接的" class="headerlink" title="消费者是什么时候创建TCP连接的"></a>消费者是什么时候创建TCP连接的</h3><ul><li>生产者是在new KakfaProducer的时候，后台开启一个Sender的线程用来创建TCP连接的；</li><li>消费者<strong>不是</strong>在实例化的时候创建的，而是在开始消费消息的时候（consumer.poll）才主动创建TCP连接，准确的说有三个时机<ul><li>发起 FindCoordinator 请求时（连接的brokerId是-1，因为不知道连哪一个）</li><li>连接协调者的时候（连接的brokerId是 <code>Interger.Max - 协调者所在broker的Id号</code> ，为什么这么设计，为了防止连接重用）</li><li>真正消费消息的时候（连接某个topic的某个分区的leader副本所在的broker）</li></ul></li></ul><h3 id="创建多少个TCP连接"><a href="#创建多少个TCP连接" class="headerlink" title="创建多少个TCP连接"></a>创建多少个TCP连接</h3><p>会创建三类TCP连接</p><ul><li>FindCoordinator 请求与任意一个 Broker 的 TCP 连接</li><li>与 Coordinator 的连接，此时消费者才能真正的开始工作</li><li>与 Partition 所在leader副本的TCP连接，拉取消息，真正开始处理</li></ul><p>其中第一类（FIndCoordinator请求与任意一个Broker的连接）会在消费者真正开始处理消息的时候，也就是后面两类TCP连接建立好之后，第一类连接会被关闭掉；</p><h3 id="消费者是什么时候关闭TCP连接的"><a href="#消费者是什么时候关闭TCP连接的" class="headerlink" title="消费者是什么时候关闭TCP连接的"></a>消费者是什么时候关闭TCP连接的</h3><p>上面说的三类连接，其中第一类连接会在二，三类连接创建好之后，被关闭掉；</p><p>二，三类连接的关闭场景有两种：</p><ul><li>主动关闭，这个不说了</li><li>kafka自动关闭，由 消费者端参数connection.max.idle.ms控制。当超过指定时间，该消费者没有消息消费时，就会被关闭连接（但是如果我们的消费逻辑是while循环的情况，则永远不会被关闭，因为一直与broker保持通信，实现了“长链接”的效果）</li></ul><h3 id="可能存在的问题"><a href="#可能存在的问题" class="headerlink" title="可能存在的问题"></a>可能存在的问题</h3><p>第一类 TCP 连接仅仅是为了首次获取元数据而创建的，后面就会被废弃掉。最根本的原因是，消费者在启动时还不知道 Kafka 集群的信息，只能使用“-1” 去注册，即使消费者获取了真实的 Broker ID，它依旧无法区分这个“-1”对应的是哪台 Broker，因此也就无法重用这个 Socket 连接，只能再重新创建一个新的连接。</p><p>为什么会出现这种情况呢？主要是因为目前 Kafka 仅仅使用 ID 这一个维度的数据来表征 Socket 连接信息。这点信息明显不足以确定连接的是哪台 Broker，也许在未来，社区应该考虑使用 &lt; 主机名、端口、ID&gt; 三元组的方式来定位 Socket 资源，这样或许能够让消费者程序少创建一些 TCP 连接。</p><p>也许你会问，反正 Kafka 有定时关闭机制，这算多大点事呢？其实，在实际场景中，我见过很多将 connection.max.idle.ms 设置成 -1，即禁用定时关闭的案例，如果是这样的话，这些 TCP 连接将不会被定期清除，只会成为永久的“僵尸”连接。基于这个原因，社区应该考虑更好的解决方案。</p><h2 id="幂等和事务生产者"><a href="#幂等和事务生产者" class="headerlink" title="幂等和事务生产者"></a>幂等和事务生产者</h2><h3 id="消息交付可靠性"><a href="#消息交付可靠性" class="headerlink" title="消息交付可靠性"></a>消息交付可靠性</h3><p>所谓的消息交付可靠性，是指<code>kafka</code>对<code>Producer</code>和<code>Consumer</code>要处理的消息，提供什么样的承诺：</p><ul><li><p><code>最多一次</code>：消息只会被发送一次，可能会丢失，绝不会重复</p></li><li><p><code>至少一次</code>（默认）：发送消息的时候，至少要有一次broker明确告知已经提交的callback，消息可能重复，但不会丢失</p></li><li><p><code>精确一次</code>：消息不会丢失，也不会重复</p></li></ul><h3 id="幂等和事务的概念"><a href="#幂等和事务的概念" class="headerlink" title="幂等和事务的概念"></a>幂等和事务的概念</h3><p>略</p><h3 id="幂等生产者"><a href="#幂等生产者" class="headerlink" title="幂等生产者"></a>幂等生产者</h3><p>在 Kafka 中，<code>Producer </code>默认不是幂等性的，但我们可以创建幂等性 <code>Producer</code>。</p><p>在没有幂等之前，<code>Producer</code>向一个<code>Partition</code>发送消息，可能会出现同一条消息被多次发送的情况，导致消息重复</p><p>在有了幂等之后，<code>Producer</code>向一个<code>Partition</code>发送消息，发送一次和发送多次，由于幂等存在，在当前这一个<code>Partition</code>内消息不会重复</p><h4 id="幂等生产者的使用方式"><a href="#幂等生产者的使用方式" class="headerlink" title="幂等生产者的使用方式"></a>幂等生产者的使用方式</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>“enable<span class="token punctuation">.</span>idempotence”<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>或props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">ProducerConfig</span><span class="token punctuation">.</span><span class="token constant">ENABLE_IDEMPOTENCE_CONFIG</span>， <span class="token boolean">true</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>设置 <code>enable.idempotence = true</code> 后，<code>Producer </code>自动升级成幂等性 <code>Producer</code></p><p>如果把 <code>enable.idempotence = true</code> ，则一定要设置<code>ack = all</code>，否则会报错：Must set acks to all in order to use the idempotent producer. Otherwise we cannot guarantee idempotence</p><p>其他所有的代码逻辑都不需要改变。</p><p>Kafka 自动做消息的重复去重</p><p>公司并没有使用幂等生产者，以下是公司的代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">KafkaProducer24</span><span class="token punctuation">(</span><span class="token class-name">String</span> brokers<span class="token punctuation">,</span> <span class="token class-name">ProduceOptionalConfig</span> extraConfig<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>extraConfig <span class="token operator">=</span> extraConfig <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token class-name">ProduceOptionalConfig</span><span class="token punctuation">.</span>defaultConfig <span class="token operator">:</span> extraConfig<span class="token punctuation">;</span>    <span class="token class-name">Properties</span> props <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"bootstrap.servers"</span><span class="token punctuation">,</span> brokers<span class="token punctuation">)</span><span class="token punctuation">;</span>    props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"key.serializer"</span><span class="token punctuation">,</span> <span class="token string">"org.apache.kafka.common.serialization.StringSerializer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"value.serializer"</span><span class="token punctuation">,</span> <span class="token string">"org.apache.kafka.common.serialization.ByteArraySerializer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"acks"</span><span class="token punctuation">,</span> <span class="token string">"默认是Leader Replica收到就行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"request.timeout.ms"</span><span class="token punctuation">,</span> <span class="token string">"默认是30000"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"compression.type"</span><span class="token punctuation">,</span> <span class="token string">"snappy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"batch.size"</span><span class="token punctuation">,</span> <span class="token string">"默认是16384"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"linger.ms"</span><span class="token punctuation">,</span> <span class="token string">"默认是5"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">KafkaProducer</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="幂等生产者的实现原理"><a href="#幂等生产者的实现原理" class="headerlink" title="幂等生产者的实现原理"></a>幂等生产者的实现原理</h4><ul><li>Producer 在每次启动后，都会向 Broker 申请一个全局一个唯一的 pid ，用来标识本次会话</li><li>V2版本的消息格式增加了 sequence number 字段， producer 每发一批消息， seq 就加1</li><li>broker 在内存中会维护 &lt;pid, topic, partition, seq&gt; 映射，收到消息后检查 seq ，如果：<ul><li>new_seq &#x3D; old_seq + 1 ：正常消息</li><li>new_seq &lt;&#x3D; old_seq ：重复消息</li><li>new_seq &gt; old_seq + 1 ： 消息丢失</li></ul></li></ul><h4 id="幂等生产者的作用范围"><a href="#幂等生产者的作用范围" class="headerlink" title="幂等生产者的作用范围"></a>幂等生产者的作用范围</h4><p>只能实现单Session上的幂等性</p><ul><li>因为<code>Producer</code>的每次重启，都会向<code>Broker</code>申请一个新的全局唯一的<code>pid</code>，用来标识本次会话</li><li><code>Producer</code>在不同<code>Session</code>上的<code>pid</code>不一样，是幂等不能跨<code>Session</code>的主要原因。</li></ul><p>只能保证单分区上的幂等性</p><ul><li>因为<code>Broker</code>端维护的映射是<code>Partiton</code>粒度的，所以只能保证单分区上的幂等性</li></ul><p>那么你可能会问，如果我想实现多分区以及多会话上的消息无重复，应该怎么做呢？答案就是事务（transaction）或者依赖事务型 Producer。</p><h3 id="事务生产者"><a href="#事务生产者" class="headerlink" title="事务生产者"></a>事务生产者</h3><p>如果我想实现多分区以及多会话上的消息无重复，应该怎么做呢？答案就是事务（transaction）或者依赖事务型 Producer。</p><p>这也是幂等性 Producer 和事务型 Producer 的最大区别！</p><p>在 Kafka 中，<code>Producer </code>默认不是幂等性的，同时默认也不是事务的。</p><p>Kafka 自 0.11 版本开始也提供了对事务的支持，它能保证多条消息原子性地写入到目标分区，同时也能保证 Consumer 只能看到事务成功提交的消息。</p><h4 id="事务生产者的使用方式"><a href="#事务生产者的使用方式" class="headerlink" title="事务生产者的使用方式"></a>事务生产者的使用方式</h4><p>要想使用kafka的事务，需要同时设置<code>Producer</code>和<code>Consumer</code></p><p><strong>设置Producer</strong></p><p>设置事务型 Producer 的方法也很简单，满足两个要求即可：</p><ul><li>和幂等性 Producer 一样，开启 <code>enable.idempotence = true</code></li><li>设置 Producer 端参数<code> transactional.id</code>。最好为其设置一个有意义的名字。</li><li>在发送消息的时候，需要显示的开启<code>beginTransaction</code>和提交<code>commitTransaction</code>事务</li><li>消息1和消息2，要么全部成功，要么全部失败</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//创建事务生产者</span>props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>“enable<span class="token punctuation">.</span>idempotence”<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>“transactional<span class="token punctuation">.</span>id”<span class="token punctuation">,</span> <span class="token string">"my-transcation-id-zs"</span><span class="token punctuation">)</span>producer<span class="token punctuation">.</span><span class="token function">initTransactions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化事务</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    producer<span class="token punctuation">.</span><span class="token function">beginTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//开启事务</span>    producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>record1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//发送消息1</span>    producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>record2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//发送消息2</span>    producer<span class="token punctuation">.</span><span class="token function">commitTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//提交事务</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">KafkaException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    producer<span class="token punctuation">.</span><span class="token function">abortTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//终止事务</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>设置Consumer</strong></p><ul><li>为什么要设置，因为事务型<code>Producer</code>即使发送失败了，也会写到kakfa日志中，会被<code>Consumer</code>消费到；</li><li>设置<code>Consumer</code>的 <code>isolation.level</code>参数<ul><li><code>read_uncommitted</code>：读未提交，这是默认值，表明 Consumer 能够读取到 Kafka 写入的任何消息，不论事务型 Producer 提交事务还是终止事务，其写入的消息都可以读取。</li><li><code>read_committed</code>：读已提交，表明 Consumer 只会读取事务型 Producer 成功提交事务写入的消息。当然了，它也能看到非事务型 Producer 写入的所有消息。</li></ul></li></ul><h4 id="事务生产者的实现原理"><a href="#事务生产者的实现原理" class="headerlink" title="事务生产者的实现原理"></a>事务生产者的实现原理</h4><p>待补充</p><h2 id="消费者组和独立消费者"><a href="#消费者组和独立消费者" class="headerlink" title="消费者组和独立消费者"></a>消费者组和独立消费者</h2><p>Kafka 为了实现点对点（同一个消息只能被下游的一个 Consumer 消费），使用了<code>Consumer Group</code>的概念；</p><p>那么什么是<code>Consumer Group</code>呢，我们具体看一下</p><p><code>Consumer Group</code>：多个 Consumer 实例组成一组消费某一个 Topic，这个 Topic 下的一条消息只能被组中的一个 Consumer 实例消费；</p><h3 id="什么是消费者组"><a href="#什么是消费者组" class="headerlink" title="什么是消费者组"></a>什么是消费者组</h3><p><code>Consumer Group</code> 是 Kafka 提供的可扩展且具有容错性的消费者机制。</p><p>组内有多个消费者实例（Consumer Instance），它们共享一个公共的 Group ID。</p><p>组内的所有消费者实例（Consumer Instance）一起消费订阅的主题（Subscribed Topics）的所有分区（Partition）。</p><p>当然，该 Topic 的每个 Partition 只能由同一个消费者组内的一个 Consumer 实例来消费。</p><h3 id="为什么要引入消费者组"><a href="#为什么要引入消费者组" class="headerlink" title="为什么要引入消费者组"></a>为什么要引入消费者组</h3><p>为了提升吞吐量，假设 Topic 的消息的生产速率不变，增加消费者实例，就可以提升吞吐量；</p><h3 id="消费者的重平衡"><a href="#消费者的重平衡" class="headerlink" title="消费者的重平衡"></a>消费者的重平衡</h3><p>当组内的某一个消费者实例挂了，kafka会自动重平衡；将这个死亡的消费者实例原先消费的分区，转移给存活的消费者实例；</p><p>后面会详细介绍：<a href="#%E9%87%8D%E5%B9%B3%E8%A1%A1">重平衡</a></p><h3 id="消费者组的特性是什么"><a href="#消费者组的特性是什么" class="headerlink" title="消费者组的特性是什么"></a>消费者组的特性是什么</h3><ul><li><code>Consumer Group</code> 下可以有一个或多个 Consumer 实例。这里的实例可以是一个单独的进程，也可以是同一进程下的线程。在实际场景中，使用进程更为常见一些。</li><li><code>Group ID</code> 是一个字符串，在一个 Kafka 集群中，它标识唯一的一个 Consumer Group。</li><li><code>Consumer Group</code>所订阅的 Topic ，该 Topic 下的某<strong>一个</strong> Partition ，只能分配给组内的某<strong>一个</strong> Consumer 实例消费。当然，这个 Partition 也可以被其他的 Group 消费。</li></ul><h3 id="传统的消息引擎模型"><a href="#传统的消息引擎模型" class="headerlink" title="传统的消息引擎模型"></a>传统的消息引擎模型</h3><ul><li>点对点：一个消息只能被一个消费者消费到</li><li>发布订阅：一个 Topic 下的消息，可以被订阅该 Topic 的所有消费者都消费到</li><li>kafka使用消费者组，实现了两种消息引擎模型； <ul><li>如果所有的消费者属于一个消费者组，那就是点对点</li><li>如果所有的消费者属于不同的消费者组，那就是发布订阅</li></ul></li></ul><h3 id="消费者组的使用方式"><a href="#消费者组的使用方式" class="headerlink" title="消费者组的使用方式"></a>消费者组的使用方式</h3><p>待补充，补充一个代码</p><h3 id="消费者组是如何维护offset的"><a href="#消费者组是如何维护offset的" class="headerlink" title="消费者组是如何维护offset的"></a>消费者组是如何维护offset的</h3><p>对于一个单独的消费者来说，offset就是一个数值；</p><p>但是对于一个消费者组来说，因为组内有多个消费者，那么消费者组维护offset是通过一个map来维护的，这个map简单的可以理解为是：Map&lt;TopicPartition,Long&gt;</p><p>对于老版本的kafka来说，offset是保存在zk中的，但是后来kafka的开发者发现，offset的更新太过于频繁，频繁的封信会拖慢zk的性能，所以在新版本的kafka中，offset是保存在broker内部的一个特殊的topic中的(__consumer_offset)。</p><p>下面我们来看看这个特殊的 Topic：位移主题（__consumer_offset）</p><h3 id="独立消费者"><a href="#独立消费者" class="headerlink" title="独立消费者"></a>独立消费者</h3><p>在 Kafka 中，消费消息除了使用 消费者组 Consumer Group 外，还有一种消费者会被使用，但是在业务场景中，使用的不多，一般是从在 Kafka 的流处理中。</p><p>它是：独立消费者 Standalone Consumer</p><p>1、请问Standalone Consumer 的独立消费者一般什么情况会用到 </p><ul><li>很多流处理框架的Kafka connector都没有使用consumer group，而是直接使用standalone consumer，因为group机制不好把控</li></ul><p>2、Standalone Consumer 的独立消费者 使用跟普通消费者组有什么区别的。</p><ul><li>standalone consumer没有rebalance，也没有group提供的负载均衡，你需要自己实现。其他方面（比如位移提交）和group没有太大的不同</li></ul><p>3、如果使用 Standalone Consumer，是不是也不会发生 rebalance 了？</p><ul><li>standalone consumer就没有rebalance一说了。 它的特点主要是灵活。虽然社区一直在改进rebalance的性能，但大数据量下consumer group机制依然有很多弊病（比如rebalance太慢等），所以很多大数据框架(Spark &#x2F;Flink)的kafka connector并不使用group机制，而是使用standalone consumer</li></ul><h2 id="位移和位移主题"><a href="#位移和位移主题" class="headerlink" title="位移和位移主题"></a>位移和位移主题</h2><p>位移在 Kafka 中是一个很重要的概念，分为：消费者位移（Consumer Offset）和分区位移（Offset）：<a href="#%E5%90%8D%E8%AF%8D%E6%9C%AF%E8%AF%AD">名词术语</a></p><h3 id="消费者位移和分区位移"><a href="#消费者位移和分区位移" class="headerlink" title="消费者位移和分区位移"></a>消费者位移和分区位移</h3><p>消费者位移（Consumer Offset）：消费者位移是随时变化的，毕竟它是消费者消费进度的指示器嘛。</p><p>分区位移（Offset）：表示的是分区内的消息位置，它是不变的，即一旦消息被成功写入到一个分区上，它的位移值就是固定的了。</p><p>举个例子：</p><p>一个消息发送到kafka集群，kafka就会给这个消息并一个编号，这个编号就是“分区位移”；而且这个“分区位移”是固定不变的；</p><p>当有消费者消费的时候，消费者会记录我自己消费到了哪里，这个就是消费者位移；（消息者位移其实并不是记录在消费者端的，而是记录在zk或者kafka中的）；</p><p>分区位移是一个常量，在消息写入到 Partition 中之后，就不变了。所以分区位移没什么好研究的。</p><p>我们主要看一看：消费者位移</p><h3 id="消费者位移"><a href="#消费者位移" class="headerlink" title="消费者位移"></a>消费者位移</h3><p>之前介绍过，消费者组是怎么维护 消费者位移（Consumer Offset） 的，在低版本中，Consumer Offset 是维护在 ZK 中的，在后续版本中，是记录在 Broker 中的一个特殊的 Topic 中，这个 Topic 叫做：位移主题（__consumer_offset）</p><p>__consumer_offsets 在 Kafka 源码中有个更为正式的名字，叫位移主题，即 Offsets Topic。</p><h3 id="位移主题"><a href="#位移主题" class="headerlink" title="位移主题"></a>位移主题</h3><h4 id="为什么会有位移主题"><a href="#为什么会有位移主题" class="headerlink" title="为什么会有位移主题"></a>为什么会有位移主题</h4><p>对于老版本的 Kafka 来说，Consumer Offset 是保存在 ZK 中的，但是后来 Kafka 的开发者发现，Consumer Offset 的更新太过于频繁，频繁的更新会拖慢 ZK 的性能，所以在新版本的 Kafka 中，Consumer Offset 是保存在 Broker 内部的一个特殊的 Topic 中的：__consumer_offset</p><h4 id="位移主题是什么"><a href="#位移主题是什么" class="headerlink" title="位移主题是什么"></a>位移主题是什么</h4><p>是 Kafka 中的一个内部 Topic</p><p>这个 Topic 的主要作用是用来管理 Consumer Offset</p><p>Consumer Offset 管理机制其实很简单，就是将 Consumer 的位移数据作为一条条普通的 Kafka 消息，发送到 __consumer_offsets 中。</p><p>可以这么说，__consumer_offsets 的主要作用是保存 Kafka 消费者的位移信息。</p><h4 id="位移主题什么时候创建"><a href="#位移主题什么时候创建" class="headerlink" title="位移主题什么时候创建"></a>位移主题什么时候创建</h4><p>当 Kafka 集群中的第一个 Consumer 程序启动时，Kafka 会自动创建位移主题。</p><h4 id="位移主题的分区和副本"><a href="#位移主题的分区和副本" class="headerlink" title="位移主题的分区和副本"></a>位移主题的分区和副本</h4><p>我们知道 __consumer_offset 虽然是内部 Topic，但是它仍然是一个 Topic ，既然是 Topic ，那么它的分区数和副本是多少呢？</p><ul><li>分区数：50；由Broker 端参数 offsets.topic.num.partitions指定</li><li>副本数：3；由Broker 端参数 offsets.topic.replication.factor指定</li></ul><h4 id="位移主题中存了什么"><a href="#位移主题中存了什么" class="headerlink" title="位移主题中存了什么"></a>位移主题中存了什么</h4><p>存了三类消息</p><ul><li>位移消息：表示当前消费者组消费的位移信息</li><li>用于保存 Consumer Group 信息的消息：比较神秘，几乎无法在搜索引擎中搜到。不过，你只需要记住它是用来注册 Consumer Group 的就可以了。</li><li>用于删除 Group 过期位移甚至是删除 Group 的消息：tombstone 消息，即墓碑消息，也称 delete mark</li></ul><p><strong>位移消息</strong></p><p>之前说过，Kafka 中有两种消息格式，<a href="#kafka%E7%9A%84%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F">kafka的消息格式</a>，那么位移主题的消息格式，其实是 Kafka 自定义的特殊消息格式。</p><p>既然是自定义的消息格式，也就说明：开发者不能随意的向这个主题发送消息，因为一旦你写入的消息不满足 Kafka 规定的格式，那么 Kafka 内部无法成功解析，就会造成 Broker 的崩溃。</p><p>那么这个主题存的到底是什么格式的消息呢？</p><p>事实上， Kafka 自定义的位移主题消息格式，其实是一个 KV 结构</p><p>K：保存 3 部分内容：&lt;Group ID，主题名，分区号&gt;  （即使是单个消费者（Standalone Consumer），也是会有groupid的）</p><p>V：Offset</p><p><strong>墓碑消息</strong></p><p>墓碑消息只出现在源码中而不暴露给你。</p><p>它的主要特点是它的消息体是 null，即空消息体。</p><p>那么，何时会写入这类消息呢？</p><p>一旦某个 Consumer Group 下的所有 Consumer 实例都停止了，而且它们的 Consumer Offset 数据都已被删除时，Kafka 会向位移主题的对应分区写入 tombstone 消息，表明要彻底删除这个 Consumer Group 的信息。</p><h4 id="怎么提交offset到位移主题"><a href="#怎么提交offset到位移主题" class="headerlink" title="怎么提交offset到位移主题"></a>怎么提交offset到位移主题</h4><p>Kafka Consumer 提交 Offset 时会写入  __consumer_offset 这个 Topic</p><p>那 Consumer 是怎么提交位移的呢？</p><p>目前 Kafka Consumer 提交位移的方式有两种：自动提交位移和手动提交位移。</p><h5 id="自动提交位移"><a href="#自动提交位移" class="headerlink" title="自动提交位移"></a>自动提交位移</h5><ul><li>设置 Consumer 端参数：enable.auto.commit</li><li>设置 Consumer 端参数：auto.commit.interval.ms</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Properties</span> props <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"bootstrap.servers"</span><span class="token punctuation">,</span> <span class="token string">"localhost:9092"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"group.id"</span><span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"enable.auto.commit"</span><span class="token punctuation">,</span> <span class="token string">"true"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"auto.commit.interval.ms"</span><span class="token punctuation">,</span> <span class="token string">"2000"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"key.deserializer"</span><span class="token punctuation">,</span> <span class="token string">"org.apache.kafka.common.serialization.StringDeserializer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"value.deserializer"</span><span class="token punctuation">,</span> <span class="token string">"org.apache.kafka.common.serialization.StringDeserializer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token class-name">KafkaConsumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">KafkaConsumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>     consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token string">"bar"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token class-name">ConsumerRecords</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> records <span class="token operator">=</span> consumer<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">ConsumerRecord</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> record <span class="token operator">:</span> records<span class="token punctuation">)</span>             <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"offset = %d, key = %s, value = %s%n"</span><span class="token punctuation">,</span> record<span class="token punctuation">.</span><span class="token function">offset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> record<span class="token punctuation">.</span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> record<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="手动提交位移"><a href="#手动提交位移" class="headerlink" title="手动提交位移"></a>手动提交位移</h5><ul><li>设置 Consumer 端参数：enable.auto.commit</li><li>然后我们就需要手动提交位移了，手动提交位移，Kafka提供了两种方式：同步提交方式和异步提交方式</li></ul><h6 id="同步提交方式"><a href="#同步提交方式" class="headerlink" title="同步提交方式"></a>同步提交方式</h6><ul><li>KafkaConsumer#commitSync()</li><li>提交失败了，会自动重试，再次提交，所以会影响消费性能</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">ConsumerRecords</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> records <span class="token operator">=</span> consumer<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofSeconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">process</span><span class="token punctuation">(</span>records<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 处理消息</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        consumer<span class="token punctuation">.</span><span class="token function">commitSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CommitFailedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">handle</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 处理提交失败异常</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="异步提交方式"><a href="#异步提交方式" class="headerlink" title="异步提交方式"></a>异步提交方式</h6><ul><li>KafkaConsumer#commitAsync()</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">ConsumerRecords</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> records <span class="token operator">=</span> consumer<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofSeconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">process</span><span class="token punctuation">(</span>records<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 处理消息</span>    consumer<span class="token punctuation">.</span><span class="token function">commitAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span>offsets<span class="token punctuation">,</span> exception<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>exception <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token function">handle</span><span class="token punctuation">(</span>exception<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="同步提交方式-异步提交方式"><a href="#同步提交方式-异步提交方式" class="headerlink" title="同步提交方式+异步提交方式"></a>同步提交方式+异步提交方式</h6><ul><li>同步会出现的问题：是阻塞的，会降低 Consumer 的 TPS ；好处是会自动重试，提交不成功的话，不会拉取新的消息；</li><li>异步会出现的问题：提交异常的话，不会重试；会导致消息重复消费</li><li>怎么办呢？结合两者，先使用异步提交一次，如果失败了，finally里使用同步方式</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ConsumerRecords</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> records <span class="token operator">=</span> consumer<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofSeconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">process</span><span class="token punctuation">(</span>records<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 处理消息</span>        <span class="token function">commitAysnc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用异步提交规避阻塞</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">handle</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 处理异常</span><span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        consumer<span class="token punctuation">.</span><span class="token function">commitSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 最后一次提交使用同步阻塞式提交</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        consumer<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="公司内部使用"><a href="#公司内部使用" class="headerlink" title="公司内部使用"></a>公司内部使用</h5><p>在公司内部默认是使用：手动提交位移</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>optionalConfig<span class="token punctuation">.</span><span class="token function">isTransactional</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    properties<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"enable.auto.commit"</span><span class="token punctuation">,</span> <span class="token string">"false"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    properties<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"enable.auto.commit"</span><span class="token punctuation">,</span> <span class="token string">"true"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConsumeOptionalConfig</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//....</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> transactional <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment">//....</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>既然公司内部使用的手动提交，那么在哪里提交的位移呢？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">commitInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//公司是为：每一个Consumer开了一个线程，后台手动提交位移</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>commitOffsetThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TransactionalConsumer<span class="token punctuation">.</span>CommitOffsetThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>commitOffsetThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//这是线程真正提交位移的方式，提交到 ZK 的</span><span class="token keyword">long</span> nextOffset <span class="token operator">=</span> currentOffset <span class="token operator">+</span> <span class="token number">1L</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ZookeeperConsumerConnector</span><span class="token punctuation">)</span><span class="token class-name">TransactionalConsumer</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>connector<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">commitOffsetToZooKeeper</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TopicAndPartition</span><span class="token punctuation">(</span><span class="token class-name">TransactionalConsumer</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>topic<span class="token punctuation">,</span> partition<span class="token punctuation">)</span><span class="token punctuation">,</span> nextOffset<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"commit offset: topic:%s, partition:%d, nextOffset: %s"</span><span class="token punctuation">,</span> <span class="token class-name">TransactionalConsumer</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>topic<span class="token punctuation">,</span> partition<span class="token punctuation">,</span> nextOffset<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="Offset提交导致的问题"><a href="#Offset提交导致的问题" class="headerlink" title="Offset提交导致的问题"></a>Offset提交导致的问题</h5><p>上面说了 Offset 的提交，有两种方式：自动提交和手动提交，手动提交又分为：同步提交和异步提交</p><p>那么它们会导致什么问题呢？会不会导致消息的丢失消费和消息的重复消费？</p><p><strong>自动提交</strong></p><ul><li>自动提交会导致消息的丢失</li><li>自动提交会导致消息的重复消费</li></ul><p>为什么会导致丢失？是因为消息消费的流程是：Concumer 先 Pull 一部分消息到内存中，然后开始消费，但是需要提交给 Broker 的 Offset 是Pull下来的最大的Offset，由于提交 Offset 是自动的，有可能 Pull 下来的消息还没有消费完，Offset 已经提交了；然后如果从内存中消费出现了问题，那么会导致内存中剩余没消费就永远不会在消费了。</p><p>为什么会导致重复？是因为自动提交，默认周期是5秒，如果在第3秒的时候，Broker发生了 Rebalance，那么 Offset 就提交不上去，当 Rebalance 完成之后，这部分数据，还会被在消费一次。</p><p><strong>手动提交</strong></p><ul><li>手动提交方式，可以解决消息的重复消费和丢失问题，因为我消费一个，提交一次Offset</li><li>同步提交方式，会影响消费端的性能</li><li>异步提交方式，解决了性能问题，但是消费成功之后，位移提交失败，不会自动重试提交，如果我们在 callback 中手动重试，又有可能导致提交上去的是一个老的 Offset</li><li>异步+同步方式：每次提交Offset都是异步的，然后在 finally 中同步提交一次，可以完美避免以上问题</li></ul><p>怎么避免的呢？消费者 poll 方法内部有维护一个不可见的指针，commitAysnc 方法异步提交不管是否成功，poll 仍然能根据自己维护的指针位移消费数据，最后在finally内用同步方法， 同步最新的 Offset。 这样提交上去的就不是老的 Offset</p><p>如果你选择的是自动提交位移，那么就可能存在一个问题：只要 Consumer 一直启动着，它就会无限期地向位移主题写入消息。导致磁盘爆满；因为自动提交位移是后台定时提交的（auto.commit.interval.ms默认是5s）；</p><p>那么满了怎么办？满了就删除，怎么删除呢？</p><h4 id="位移主题中的过期数据（过期位移）"><a href="#位移主题中的过期数据（过期位移）" class="headerlink" title="位移主题中的过期数据（过期位移）"></a>位移主题中的过期数据（过期位移）</h4><p>我们知道所有的位移数据都是保存在 位移主题 中的，如果不删除的话，位移主题就会无限的膨胀</p><p>为了避免该主题无限期膨胀。Kafka 会定期的清理位移主题中的数据。</p><p><strong>那么什么样的数据被称为过期数据呢？</strong></p><p>我们知道位移主题中存了三类消息，这里以 位移消息 为例；</p><p>位移消息的消息格式是Map格式，key是 groupid+topic+partition ；value是位移数据</p><p>举个例子说：</p><p>一个消费者组（假设groupid为：consumer_group_1），这个消费者组消费一个 Topic（假设消费：topic_a）；然后这个 Topic 有3个 Partition；</p><p>生产者 源源不断的向 Topic 中写数据，消费者组不停地消费数据，消费一个数据，就向 位移主题 中发一个位移消息；</p><p>那么这里的位移消息可能就是下面这样的：</p><p>consumer_group_1+topic_a+partition_1  ：  2345</p><p>consumer_group_1+topic_a+partition_1  ：  2346</p><p>consumer_group_1+topic_a+partition_1  ：  2347</p><p>。。。。。</p><p>最终，我们就会发现，同一个key就会存在很多数据，而且只有最后一条数据，才是有效的。那么之前的数据，都<strong>被称为过期数据</strong>；</p><p>再次之外，还有一种情况：</p><p>在 Broker 端有一个参数：<code>offsets.retention.minutes</code>,这个参数表明了 offset 的保留时间，什么意思呢？</p><p>就是说：我们提交到 位移主题 中的消息，并不会永远的保存，在超过了这个配置时间后，Kafka后台有一个线程，就会把这个Offset删掉</p><p>这个值一般是 7 天。</p><p>也就是说：如果你的消费者7天都没有上线了，或者7天都没有提交 offset 了，Kafka就会把这个消费者组的 位移数据 判定为过期数据。并删除</p><h4 id="位移主题中的过期数据（过期位移）清理"><a href="#位移主题中的过期数据（过期位移）清理" class="headerlink" title="位移主题中的过期数据（过期位移）清理"></a>位移主题中的过期数据（过期位移）清理</h4><p>在上面我们知道了 位移主题 中的过期数据有两类：</p><ul><li>一类是：同一个<code>key</code>的过期数据</li><li>一类是：超过了<code>offsets.retention.minutes</code>的过期数据</li></ul><p><strong>第一类过期数据，Kafka是怎么清理的呢？</strong></p><p>答案就是 Compaction。</p><p>国内很多文献都将其翻译成压缩，我个人是有一点保留意见的。</p><p>在英语中，压缩的专有术语是 Compression，它的原理和 Compaction 很不相同，我更倾向于翻译成压实，或干脆采用 JVM 垃圾回收中的术语：整理。</p><p>它的原理很简单：就是将：同一个 &lt;Group ID，主题名，分区号&gt; 的 Offset 进行压实整理，只保留最新的</p><img src="kafka从入门到入土.assets/image-20220828155424662.png" alt="image-20220828155424662" style="zoom: 50%;" /><p>图中位移为 0、2 和 3 的消息的 Key 都是 K1。Compact 之后，分区只需要保存位移为 3 的消息，因为它是最新发送的。</p><p>Kafka 提供了专门的后台线程定期地巡检待 Compact 的主题，看看是否存在满足条件的可压缩数据。这个后台线程叫 Log Cleaner。</p><p><strong>第二类过期数据，Kafka是怎么清理的呢？</strong></p><p>上面说到，Kafka有一个后台线程：Log Cleaner。</p><p>这个线程除了会清理第一类过期数据之外，还会清理第二类过期数据。</p><p>很多实际生产环境中都出现过位移主题无限膨胀占用过多磁盘空间的问题，如果你的环境中也有这个问题，我建议你去检查一下 Log Cleaner 线程的状态，通常都是这个线程挂掉了导致的。</p><p>Kafka 定期自动删除过期位移的条件就是，组要处于 Empty 状态（消费者组的状态机）。因此，如果你的消费者组停掉了很长时间（超过 7 天），那么 Kafka 很可能就把该组的位移数据删除了</p><h4 id="位移提交失败怎么办"><a href="#位移提交失败怎么办" class="headerlink" title="位移提交失败怎么办"></a>位移提交失败怎么办</h4><p>一般的失败，API会自动重试；</p><p>但是有一个异常叫做 CommitFailedException，这个异常抛出，说明位移的提交出现了大问题，需要人工介入了</p><p>那么这个异常是啥意思呢？什么时候会产生呢？产生了之后要怎么处理呢？</p><p><strong>什么是 CommitFailedException</strong></p><blockquote><p>Commit cannot be completed since the group has already rebalanced and assigned the partitions to another member. </p><p>This means that the time between subsequent calls to poll() was longer than the configured max.poll.interval.ms, which typically implies that the poll loop is spending too much time message processing. </p><p>You can address this either by increasing max.poll.interval.ms or by reducing the maximum size of batches returned in poll() with max.poll.records.</p></blockquote><p>翻译过来就是：</p><blockquote><p>本次提交位移失败了，原因是消费者组已经开启了 Rebalance 过程，并且将要提交位移的分区分配给了另一个消费者实例。</p><p>出现这个情况的原因是：你的消费者实例连续两次调用 poll 方法的时间间隔超过了期望的 max.poll.interval.ms 参数值。这通常表明，你的消费者实例花费了太长的时间进行消息处理，耽误了调用 poll 方法。</p><p>你可以通过：增加期望的时间间隔 max.poll.interval.ms 参数值 或者 减少 poll 方法一次性返回的消息数量，即减少 max.poll.records 参数值。</p></blockquote><p><strong>那么什么时候会抛出这个异常呢？</strong></p><p>从源代码方面来说，CommitFailedException 异常通常发生在手动提交位移时，即用户显式调用 KafkaConsumer.commitSync() 方法时。</p><p>从使用场景来说，有两种典型的场景可能遭遇该异常。</p><p>场景一</p><ul><li><p>当消息处理的总时间超过预设的 max.poll.interval.ms 参数值时，Kafka Consumer 端会抛出 CommitFailedException 异常。</p></li><li><p>模拟异常产生：</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">…<span class="token class-name">Properties</span> props <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>…props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"max.poll.interval.ms"</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"test-topic"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">ConsumerRecords</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> records <span class="token operator">=</span>     consumer<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofSeconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 使用Thread.sleep模拟真实的消息处理逻辑</span>    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">6000L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    consumer<span class="token punctuation">.</span><span class="token function">commitSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>场景二</p><ul><li>消费者组 Consumer Group  和 独立消费者 Standalone Consumer 拥有了相同的 group.id，当独立消费者程序手动提交位移时，Kafka 就会立即抛出 CommitFailedException 异常，因为 Kafka 无法识别这个具有相同 group.id 的消费者实例，于是就向它返回一个错误，表明它不是消费者组内合法的成员。</li><li>这种情况一般出现在很多部门消费同一个 Kafka 集群导致的，各个部门的消费者命名重复了，导致相同的 group.id</li></ul><p><strong>当前当异常出现了，我们应该怎么办呢？</strong></p><p>怎么解决问题，要先知道问题是怎么出现的。</p><p>比如在 场景一 中，我们知道产生问题的原因是：两次 poll() 方法调用的间隔超过了 max.poll.interval.ms</p><p>那么就简单了，针对 场景一 ，我们可以：</p><ul><li><strong>调大 max.poll.interval.ms 这个间隔时间</strong>，默认时间是 5分钟</li><li><strong>减少每次 poll() 拉取的消息数量</strong>：我们知道一次 poll() 方法，默认拉 500 条，因为拉取的太多了，消费的慢，所以导致两次 poll() 时间间隔太长</li><li>接第二条，‘消费的慢’，那我们就提到消息速率，<strong>优化代码，减少每条消息的处理时间</strong>，提高TPS</li><li>除了优化代码，提交消费速度，还可以<strong>使用多线程，提高消费速度</strong>，但是要注意多线程下的位移提交问题</li></ul><p>针对场景二呢，上面四个办法就不能用了，不过一般大公司下，消费者都是需要申请的，如果重复了，一般是申请不了的。</p><h2 id="多线程消费"><a href="#多线程消费" class="headerlink" title="多线程消费"></a>多线程消费</h2><h3 id="Kafka-Java-Consumer-的单线程设计"><a href="#Kafka-Java-Consumer-的单线程设计" class="headerlink" title="Kafka Java Consumer 的单线程设计"></a>Kafka Java Consumer 的单线程设计</h3><p>为什么 Kafka Java Consumer 要设计成单线程，看一下发展历史就明白了了</p><p>在目前的 KafkaConsumer 的API出现之前，有一个 Scala 版本的 Consumer 的API，这组 Scale 的API 被称为老版本 Consumer</p><p>在老版本 Consumer 中，Consumer 的设计是多线程的架构：</p><ul><li>每个 Consumer 实例在内部为所有订阅的 Topic 分区，创建对应的消息获取线程（就是一个分区一个线程），称为 Fetcher 线程</li><li>老版本的 Consumer 同时也是阻塞的，Consumer 实例启动后，内部会创建阻塞式的消息获取迭代器</li></ul><p>那么为什么后来变成单线程的了呢？</p><ul><li>主要是因为老版本的 Consumer 是阻塞的</li><li>而在大部分业务场景下，比如对数据的过滤，连接，分组，就不能是阻塞式的。</li><li>所以在新版的 Consumer 下，Kafka 设计了 单线程+轮训 的机制</li></ul><p>采用单线程还有另外一个考虑</p><ul><li>就是单线程可以简化 Consumer 的设计，在任何编程语言中，单线程都比多线程更方便维护</li></ul><p>不过，虽然 Consumer 的设计是单线程的，但是并不意味着我们就不能多线程了。</p><p>虽然 KafkaConsumer 的类的设计是单线程的，而且<strong>不是线程安全</strong>的。但是只是说明 拉取消息 的逻辑是单线程的</p><p>但是消息拉取之后，怎么处理消息，完全是由开发者决定的，此时可以<strong>手动开发多线程</strong>进行消费</p><h3 id="多线程方案"><a href="#多线程方案" class="headerlink" title="多线程方案"></a>多线程方案</h3><p>总体来说有两种方案。</p><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a><strong>方案一</strong></h4><p>消费者程序启动多个线程，每个线程维护专属的 KafkaConsumer 实例，负责完整的消息获取、消息处理流程。</p><p>简单地说：一个线程负责一个分区</p><img src="kafka从入门到入土.assets/image-20230214112054515.png" alt="image-20230214112054515" style="zoom: 33%;" /><h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a><strong>方案二</strong></h4><p>消费者程序使用单或多线程获取消息，同时创建多个消费线程执行消息处理逻辑</p><p>简单的说：一个或多个线程负责拉取消息，多个线程负责处理消息</p><img src="kafka从入门到入土.assets/image-20230214112223276.png" alt="image-20230214112223276" style="zoom:33%;" /><h4 id="方案对比"><a href="#方案对比" class="headerlink" title="方案对比"></a><strong>方案对比</strong></h4><table><thead><tr><th>方案</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>方案一</td><td>方便实现</td><td>占用更多的系统资源</td></tr><tr><td>方案一</td><td>速度快，没有线程间的交互开销</td><td>线程数受限于 Topic 的分区数（最多一个分区一个线程），扩展性差</td></tr><tr><td>方案一</td><td>易于维护分区间的消息顺序</td><td>线程自己拉取消息，自己处理消息，可能导致超时，引发Rebalance</td></tr><tr><td>方案二</td><td>可独立扩展获取消息线程数和处理消息线程数</td><td>实现难度高</td></tr><tr><td>方案二</td><td>伸缩性好</td><td>难以维护分区内的消息消费顺序</td></tr><tr><td>方案二</td><td></td><td>处理链路长，不利于 Offset 的提交管理</td></tr></tbody></table><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h4><p>方案一</p><ul><li>这段代码创建了一个 Runnable 类，表示执行消费获取和消费处理的逻辑。每个 KafkaConsumerRunner 类都会创建一个专属的 KafkaConsumer 实例。在实际应用中，你可以创建多个 KafkaConsumerRunner 实例，并依次执行启动它们，以实现方案 1 的多线程架构。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">KafkaConsumerRunner</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicBoolean</span> closed <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicBoolean</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">KafkaConsumer</span> consumer<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>             consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"topic"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>closed<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">ConsumerRecords</span> records <span class="token operator">=</span>         consumer<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofMillis</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//  执行消息处理逻辑</span>             <span class="token punctuation">&#125;</span>         <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">WakeupException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>             <span class="token comment">// Ignore exception if closing</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>closed<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> e<span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>             consumer<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span>     <span class="token comment">// Shutdown hook which can be called from a separate thread</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         closed<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         consumer<span class="token punctuation">.</span><span class="token function">wakeup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方案二</p><ul><li>这段代码最重要的地方是最后一行：当 Consumer 的 poll 方法返回消息后，由专门的线程池来负责处理具体的消息。调用 poll 方法的主线程不负责消息处理逻辑，这样就实现了方案 2 的多线程架构。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">KafkaConsumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> consumer<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token class-name">ExecutorService</span> executors<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">private</span> <span class="token keyword">int</span> workerNum <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>executors <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>  workerNum<span class="token punctuation">,</span> workerNum<span class="token punctuation">,</span> <span class="token number">0L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">,</span>  <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">,</span>   <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>CallerRunsPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token class-name">ConsumerRecords</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> records <span class="token operator">=</span>     consumer<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofSeconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">ConsumerRecord</span> record <span class="token operator">:</span> records<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    executors<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>record<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="重平衡与协调者"><a href="#重平衡与协调者" class="headerlink" title="重平衡与协调者"></a>重平衡与协调者</h2><h3 id="什么是重平衡"><a href="#什么是重平衡" class="headerlink" title="什么是重平衡"></a>什么是重平衡</h3><p>Rebalance 本质上是一种协议，规定了一个 Consumer Group 下的所有 Consumer 如何达成一致，来分配订阅 Topic 的每个分区。</p><p>比如某个 Group 下有 20 个 Consumer 实例，它订阅了一个具有 100 个分区的 Topic。正常情况下，Kafka 平均会为每个 Consumer 分配 5 个分区。这个分配的过程就叫 Rebalance。</p><h3 id="什么时候会重平衡"><a href="#什么时候会重平衡" class="headerlink" title="什么时候会重平衡"></a>什么时候会重平衡</h3><ul><li>Consumer Group 内 Consumer实例 数量发生变化（新增或减少）；</li><li>Consumer Group 订阅的 Topic 数发生变化；</li><li>Consumer Group 订阅的 Topic 的 Partition 数量发生变化</li></ul><h3 id="重平衡策略"><a href="#重平衡策略" class="headerlink" title="重平衡策略"></a>重平衡策略</h3><ul><li>举例：比如组内有2个消费者，这个组消费 TopicA 和 TopicB ,其中 Consumer-1 消费 TopicA，Consumer-2 消费 TopicB，当该 Consumer Group 新订阅一个 TopicC 的时候，会不会 Consumer-1 消费到 TopicB，Consumer-2 消费到 TopicA</li></ul><p>Kafka 有三种策略保证重平衡后的公平</p><p><strong>Rnage 分配策略</strong></p><p>Range分配策略是面向每个 Topic 的，首先会对同一个 Topic 里面的 Partition 按照序号进行排序，并把消费者线程按照字母顺序进行排序。然后用分区数除以消费者线程数量来判断每个消费者线程消费几个分区。如果除不尽，那么前面几个消费者线程将会多消费一个分区。 </p><p><strong>RoundRobin策略</strong></p><p>RoundRobin策略的原理是将 Consumer Group 内所有 Consumer 以及订阅的所有 Topic 的 Partition 按照字典序排序，然后通过轮询算法逐个将分区以此分配给每个消费者。 使用RoundRobin分配策略时会出现两种情况： </p><ul><li><p>如果同一消费组内，所有的消费者订阅的消息都是相同的，那么 RoundRobin 策略的分区分配会是均匀的。</p></li><li><p>如果同一消费者组内，所订阅的消息是不相同的，那么在执行分区分配的时候，就不是完全的轮询分配，有可能会导致分区分配的不均匀。如果某个消费者没有订阅消费组内的某个 topic，那么在分配分区的时候，此消费者将不会分配到这个 topic 的任何分区。</p></li></ul><p><strong>Sticky分配策略</strong></p><p>Sticky分配策略，这种分配策略是在 Kafka 的 0.11.X 版本才开始引入的，是目前最复杂也是最优秀的分配策略。 Sticky分配策略的原理比较复杂，它的设计主要实现了两个目的： </p><ul><li><p>分区的分配要尽可能的均匀；</p></li><li><p>分区的分配尽可能的与上次分配的保持相同。 如果这两个目的发生了冲突，优先实现第一个目的。</p></li></ul><h3 id="什么是协调者Coordinator"><a href="#什么是协调者Coordinator" class="headerlink" title="什么是协调者Coordinator"></a>什么是协调者Coordinator</h3><p>所谓协调者，在 Kafka 中对应的术语是 Coordinator，它专门为 Consumer Group 服务，负责为 Group 执行 Rebalance 以及提供位移管理和组成员管理等。</p><ul><li><p>协调者 coordinators 是协调管理 Consumer Group 的一个程序，运行在broker上的</p></li><li><p>每一个broker在启动时都会启动 coordinator 组件（coordinator程序），也就是说每个 Broker 都有具备称为 Coordinator 的能力</p></li></ul><p>具体来讲，Consumer 端应用程序在提交位移时，其实是向 Coordinator 所在的 Broker 提交位移。</p><p>同样地，当 Consumer 应用启动时，也是向 Coordinator 所在的 Broker 发送各种请求，然后由 Coordinator 负责执行消费者组的注册、成员管理记录等元数据管理操作。</p><h3 id="消费者组是怎么找到自己的coordinator的"><a href="#消费者组是怎么找到自己的coordinator的" class="headerlink" title="消费者组是怎么找到自己的coordinator的"></a>消费者组是怎么找到自己的coordinator的</h3><p>既然 Coordinator 是运行在 Broker上 的一个程序，那么一个消费者组，是怎么找到自己的 Coordinator 的呢？</p><p>在<a href="#%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8ETCP%E8%BF%9E%E6%8E%A5">消费者与TCP连接</a>这一节中，我们知道消费者在启动的时候，会创建三类 TCP 连接</p><ul><li>第一类：与负载最小的 Broker 创建连接，发送 FIndCoordinator 请求，希望该 Broker 告诉自己谁是我的协调者；</li><li>第二类：与 Coordinator 创建TCP连接，加入组，分配方案，位移获取和提交等</li><li>第三类：与 要消费的分区的副本所在 Broker 创建 TCP 连接，真正开始消费数据</li></ul><p>所以，消费者组找到自己的 Coordinator 是在第一类 TCP 请求中找到的</p><p>那么 具体是怎么找到的呢？是通过之前说过的 __consumer_offset 这个主题来找的</p><p>分为两步</p><ul><li>获取当前 Consumer Group 的 groupid，然后hash得到hash值；</li><li>获取__consumer_offset 的分区数，默认是50</li><li>计算 ：abs ( hash % 50 ) &#x3D; 分区号</li><li>然后，找到这个分区号的 leader 副本所在的 broker ；这个broker就是这个消费者的coordinator</li></ul><h3 id="重平衡的缺点"><a href="#重平衡的缺点" class="headerlink" title="重平衡的缺点"></a>重平衡的缺点</h3><ul><li>会STW（stop the world）：消费者会全部停止消费</li><li>时间太慢了，几百个消费者重平衡一次，要几个小时</li><li>Rebalance 的设计是要求所有 Consumer 实例共同参与，全部重新分配所有分区</li><li>在 Rebalance 过程中，所有 Consumer 实例都要参与，所以在整个过程中都不能消费任何消息，因此它对 Consumer 的 TPS 影响很大</li></ul><h3 id="避免消费者组重平衡"><a href="#避免消费者组重平衡" class="headerlink" title="避免消费者组重平衡"></a>避免消费者组重平衡</h3><p>首先，明确一个概念，目前Rebalance的弊端（慢，STW）这2个弊端，社区是没有办法解决的；</p><p>针对Rebalance的效率低的情况，社区采用了StickyAssignor策略来提升性能；</p><p>既然无法解决，那我们只能尽量避免，怎么避免呢？就要从导致Rebalance发生的三种情况来看</p><ul><li>组成员数量发生变化（99%的Rebalance都是这个原因）</li><li>订阅主题数量发生变化（一般是程序开发者主动操作，无法避免）</li><li>订阅主题的分区数发生变化（一般是程序开发者主动操作，无法避免）</li></ul><p>组成员数量发生变化，变化分为两种，一种是增加，一种是减少</p><ul><li>增加：一般都是程序开发者主动操作，比如为了提升topic的消费速率，无法避免</li><li>减少：如果是主动停掉的，那自不必说，无法避免；</li><li>减少：不是主动停掉的，是被 Coordinator 错误地认为“已停止”从而被“踢出”Group。如果是这个原因导致的 Rebalance，我们就不能不管了。</li></ul><p><strong>什么时候coordinator会认为consumer实例已停止</strong></p><ul><li>Coordinator 没有收到 Consumer 的心跳，就会让 Consumer 离组，重新 Rebalance<ul><li>Consumer 端有个参数，叫 session.timeout.ms，默认10秒；</li><li>Coordinator 在10s内没有收到 Consumer 的心跳，就Rebalance</li><li>心跳是consumer主动给coordinator的，那么多久一次呢？是由参数：heartbeat.interval.ms控制的；</li><li>推荐配置：session.timeout.ms&#x3D;6s，heartbeat.interval.ms&#x3D;2s：要保证 Consumer 实例在被判定为“dead”之前，能够发送至少 3 轮的心跳请求</li></ul></li><li>Consumer 实例在一定时间内消费不完已经 pull() 下来的消息，就会主动离组，重新Rebalance<ul><li>Consumer 端有个参数，max.poll.interval.ms 参数，默认5分钟</li><li>一个consumer在5分钟内，没有消费完拉取的数据，就Rebalance</li></ul></li><li>consumer端的GC情况</li></ul><p>standalone consumer 就没有 rebalance 一说了。 它的特点主要是灵活。</p><p>虽然社区一直在改进rebalance的性能，但大数据量下consumer group机制依然有很多弊病（比如rebalance太慢等）</p><p>所以很多大数据框架(Spark &#x2F;Flink)的kafka connector并不使用group机制，而是使用standalone consumer</p><h3 id="怎么排查生产是否重平衡过多"><a href="#怎么排查生产是否重平衡过多" class="headerlink" title="怎么排查生产是否重平衡过多"></a>怎么排查生产是否重平衡过多</h3><p>主动去排查：去找Coordinator所在的broker日志，如果经常发生rebalance，会有类似于”(Re)join group” 之类的日志</p><p>被动排查：一般 Rebalance 过多，会降低消费者能力，间接的就会出现消息堵，可以配置相关告警</p><h3 id="重平衡核心全流程"><a href="#重平衡核心全流程" class="headerlink" title="重平衡核心全流程"></a>重平衡核心全流程</h3><p>重平衡是怎么做到的？</p><p>在 Kafka 中，每个 Consumer 都会通过<strong>心跳线程</strong>，定期的向 Coordinator 汇报自己的状态；</p><p>同时 Coordinator 也会通过<strong>心跳线程</strong>，告诉 Consumer ：我收到了你的汇报；</p><p>如果 Consumer 超时没有汇报；说明这个 Cnnsumer 有问题了，此时 Coordinator 就会开启重平衡</p><p>Coordinator 会通过<strong>心跳线程</strong>，向这个 Consumner 所在的 Group 下的所有 Consumer，发送消息：<strong>REBALANCE_IN_PROGRESS</strong></p><p>当 Consumer 收到这种消息之后，就知道要开启重平衡了</p><p>而 Coordinator 具体是怎么实现重平衡的呢？</p><p>其实是通过控制 Consumer Group 的状态来完成重平衡的。这是<strong>理解重平衡的基础</strong>。</p><p>下面我们就来看看 消费者组的状态机，这是<strong>理解重平衡的基础</strong>；</p><h4 id="消费者组的状态机"><a href="#消费者组的状态机" class="headerlink" title="消费者组的状态机"></a>消费者组的状态机</h4><p>消费者组的状态主要有以下 五个：</p><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>Empty</td><td>组内没有任何成员，但消费者可能存在已经提交的数据，并且未过期：<a href="#%E4%BD%8D%E7%A7%BB%E4%B8%BB%E9%A2%98%E4%B8%AD%E7%9A%84%E8%BF%87%E6%9C%9F%E6%95%B0%E6%8D%AE%EF%BC%88%E8%BF%87%E6%9C%9F%E4%BD%8D%E7%A7%BB%EF%BC%89">位移主题中的过期数据（过期位移）</a></td></tr><tr><td>Dead</td><td>组内没有任何成员，Coordinator 已经把这个消费者组的元数据信息删除了</td></tr><tr><td>PreparingRebalance</td><td>消费者组准备开启重平衡，此时所有成员都要重新申请加入组</td></tr><tr><td>CompletingRebalance</td><td>消费者组下的所有成员都已经加入，等待Leader分配方案，老版本中这个状态叫：AwatingSync</td></tr><tr><td>Stable</td><td>消费者组的稳定状态，表示重平衡已经完成，可以正常开启消费了</td></tr></tbody></table><pre class="mermaid">stateDiagram    direction LR    Empty-->Dead: 组信息过期被删除    Empty-->PreparingRebalance:准备开启rebalance    PreparingRebalance-->Dead:位移主题分区Leader发生变化    PreparingRebalance-->Empty:组内所有成员离组    PreparingRebalance-->CompletingRebalance:有成员入组    CompletingRebalance-->Dead:位移主题分区Leader发生变化    CompletingRebalance-->PreparingRebalance:成员加入或离开    CompletingRebalance-->Stable:Leader完成分配    Stable-->Dead:位移主题分区Leader发生变化    Stable-->PreparingRebalance:心跳过期/成员离组/新成员加入        %% 给状态添加样式    classDef badBadEvent fill:green,color:white,font-weight:bold,stroke-width:2px,stroke:yellow    class Empty badBadEvent    class PreparingRebalance badBadEvent    class CompletingRebalance badBadEvent    class Stable badBadEvent    class Dead badBadEvent</pre><p>一个消费者组最开始是 Empty 状态</p><p>当重平衡过程开启后，它会被置于 PreparingRebalance 状态等待成员加入</p><p>之后变更到 CompletingRebalance 状态等待分配方案</p><p>最后流转到 Stable 状态完成重平衡</p><p>当有新成员加入或已有成员退出时，消费者组的状态从 Stable 直接跳到 PreparingRebalance 状态，此时，所有现存成员就必须重新申请加入组。</p><p>当所有成员都退出组后，消费者组状态变更为 Empty</p><h4 id="重平衡流程"><a href="#重平衡流程" class="headerlink" title="重平衡流程"></a>重平衡流程</h4><h5 id="场景一：新成员入组"><a href="#场景一：新成员入组" class="headerlink" title="场景一：新成员入组"></a>场景一：新成员入组</h5><pre class="mermaid">sequenceDiagram    成员1->>协调者: 心跳请求：你好协调者，我是组内的成员1，我还活着    协调者-->>成员1: 心跳响应：你好成员1，已收到    成员2->>协调者: joinGroup请求：你好协调者，我请求加入组，我要消费的是主题是 B    成员1->>协调者: 心跳请求：你好协调者，我是组内的成员1，我还活着    协调者-->>成员1: 心跳响应：你好成员1，REBALANCE_IN_PROGRESS,重平衡，你需要重新入组    成员1->>协调者: joinGroup请求：你好协调者，我请求加入组，我要消费的是主题是 A    协调者-->>成员2: joinGroup响应：你好成员2，你已成功入组，你是这组的Leader<br/>这组的订阅信息有：{成员1->主题A，成员2->主题B}    协调者-->>成员1: joinGroup响应：你好成员1，你已成功入组，当前组的Leader是成员2，请等待分配方案    成员1->>协调者: syncGroup请求：你好协调者，我是成员1，等待分配方案    成员2->>协调者: syncGroup请求：你好协调者，我是成员2，也是这个组的Leader<br/>以下是我的分配方案：{成员1->主题A分区0，成员2->主题B分区0}    协调者-->>成员1: syncGroup响应：你好成员1，你负责消费主题A的0分区    协调者-->>成员2: syncGroup响应：你好成员2，你负责消费主题B的0分区    成员1->>协调者: 心跳请求：你好协调者，我是组内的成员1，我还活着    协调者-->>成员1: 心跳响应：你好成员1，已收到    成员2->>协调者: 心跳请求：你好协调者，我是组内的成员2，我还活着    协调者-->>成员2: 心跳响应：你好成员2，已收到</pre><h5 id="场景二：组成员主动离组"><a href="#场景二：组成员主动离组" class="headerlink" title="场景二：组成员主动离组"></a>场景二：组成员主动离组</h5><pre class="mermaid">sequenceDiagram    成员1->>协调者: 心跳请求：你好协调者，我是组内的成员1，我还活着    协调者-->>成员1: 心跳响应：你好成员1，已收到    成员2->>协调者: 心跳请求：你好协调者，我是组内的成员2，我还活着    协调者-->>成员2: 心跳响应：你好成员2，已收到    成员1->>协调者: leaveGroup请求：你好协调者，我是组内的成员1，申请主动离组    协调者-->>成员1: leaveGroup响应：你好成员1，已收到    成员2->>协调者: 心跳请求：你好协调者，我是组内的成员2，我还活着    协调者-->>成员2: 心跳响应：你好成员2，REBALANCE_IN_PROGRESS,重平衡，你需要重新入组    成员2->>协调者: joinGroup请求：你好协调者，我请求加入组，我要消费的是主题是 B    协调者-->>成员2: joinGroup响应：你好成员2，你已成功入组，你是这组的Leader<br/>这组的订阅信息有：{成员2->主题B}    成员2->>协调者: syncGroup请求：你好协调者，我是成员2，也是这个组的Leader<br/>以下是我的分配方案：{成员2->主题B分区0}    协调者-->>成员2: syncGroup响应：你好成员2，你负责消费主题B的0分区    成员2->>协调者: 心跳请求：你好协调者，我是组内的成员2，我还活着    协调者-->>成员2: 心跳响应：你好成员2，已收到</pre><h5 id="场景三：组成员崩溃离组"><a href="#场景三：组成员崩溃离组" class="headerlink" title="场景三：组成员崩溃离组"></a>场景三：组成员崩溃离组</h5><pre class="mermaid">sequenceDiagram    成员1->>协调者: 心跳请求：你好协调者，我是组内的成员1，我还活着    协调者-->>成员1: 心跳响应：你好成员1，已收到    成员2->>协调者: 心跳请求：你好协调者，我是组内的成员2，我还活着    协调者-->>成员2: 心跳响应：你好成员2，已收到    note left of 成员2: 成员2此时已离线    协调者->>协调者: 发现成员2已经很长时间没有汇报了    成员1->>协调者: 心跳请求：你好协调者，我是组内的成员1，我还活着    协调者-->>成员1: 心跳响应：你好成员1，REBALANCE_IN_PROGRESS,重平衡，你需要重新入组    成员1->>协调者: joinGroup请求：你好协调者，我请求加入组，我要消费的是主题是 A    协调者-->>成员1: joinGroup响应：你好成员1，你已成功入组，你是这组的Leader<br/>这组的订阅信息有：{成员1->主题A}    成员1->>协调者: syncGroup请求：你好协调者，我是成员1，也是这个组的Leader<br/>以下是我的分配方案：{成员1->主题A分区0}    协调者-->>成员1: syncGroup响应：你好成员1，你负责消费主题A的0分区    成员1->>协调者: 心跳请求：你好协调者，我是组内的成员1，我还活着    协调者-->>成员1: 心跳响应：你好成员1，已收到</pre><h5 id="场景四：重平衡时协调者对组内成员提交位移的处理"><a href="#场景四：重平衡时协调者对组内成员提交位移的处理" class="headerlink" title="场景四：重平衡时协调者对组内成员提交位移的处理"></a>场景四：重平衡时协调者对组内成员提交位移的处理</h5><pre class="mermaid">sequenceDiagram    成员1->>协调者: 心跳请求：你好协调者，我是组内的成员1，我还活着      协调者-->>成员1: 心跳响应：你好成员1，已收到      协调者->>协调者: 此时发现需要重平衡    成员1->>协调者: 心跳请求：你好协调者，我是组内的成员1，我还活着    协调者->>成员1: 心跳响应：你好成员1，REBALANCE_IN_PROGRESS,重平衡，你需要重新入组    成员1->>成员1: 必须赶在超时时间内提交位移    note right of 成员1 : 赶在超时时间内提交位移    成员1->>协调者: 提交位移请求：你好协调者，我要提交的位移是：{....}    协调者->>成员1: 提交位移响应：你好成员1，位移数据已收到    note right of 成员1 : 如果提交失败了，这部分数据在重平衡之后就会被重新消费</pre><h4 id="重平衡的一些问题"><a href="#重平衡的一些问题" class="headerlink" title="重平衡的一些问题"></a>重平衡的一些问题</h4><p>joingroup时等待所有消费者上报订阅信息，协调者通过什么判断所有消费者都已经上报了？</p><ul><li>join group时也是有一个总的超时时间的（取所有member最大的rebalance超时时间），靠这个作为判断是否进入到下一阶段的阈值。</li><li>如果在这次 Rebalance 期间，有 消费者 超时没有上报信息，那么这个消费者会被排除在这轮 Rebalance 之外</li></ul><p>如果在超时时间之后，排除在外的 消费者 此时上报了信息，怎么办？</p><ul><li>相当于 新成员入组，重新 Rebalance</li></ul><h2 id="副本机制"><a href="#副本机制" class="headerlink" title="副本机制"></a>副本机制</h2><p>我们之前谈到过，Kafka 是有 Topic 概念的，而每个 Topic 又进一步划分成若干个 Partition。</p><p>每个 Partition 配置有若干个 Replica，Replica 的概念实际上是在 Partition 层级下定义的</p><h3 id="什么是副本"><a href="#什么是副本" class="headerlink" title="什么是副本"></a>什么是副本</h3><p>所谓副本（Replica），本质就是一个只能追加写消息的提交日志。</p><p>同一个 Partition 下的所有 Replica 保存有相同的消息序列，这些 Replica 分散保存在不同的 Broker 上，从而能够对抗部分 Broker 宕机带来的数据不可用。</p><p>在实际生产环境中，每台 Broker 都可能保存有各个 Topic 下不同 Partition 的不同 Replica，因此，单个 Broker 上存有成百上千个 Replica 的现象是非常正常的。</p><p>下图展示的是一个有 3 台 Broker 的 Kafka 集群上的副本分布情况。</p><p>从这张图中，我们可以看到，主题 1 分区 0 的 3 个副本分散在 3 台 Broker 上，其他主题分区的副本也都散落在不同的 Broker 上，从而实现数据冗余。</p><img src="kafka从入门到入土.assets/image-20230214160607518.png" alt="image-20230214160607518" style="zoom:33%;" /><h3 id="副本之间数据是怎么同步的"><a href="#副本之间数据是怎么同步的" class="headerlink" title="副本之间数据是怎么同步的"></a>副本之间数据是怎么同步的</h3><p>我们知道 Replica 是用来冗余数据的，同一个 Partiton 下的所有 Replica 的数据都应该是一模一样的，顺序都是一样的</p><p>那么这么多的 Replica，是怎么进行 Replica 之间的数据同步的呢？</p><p>Kafka使用的解决方案：就是采用<strong>基于领导者（Leader-based）的副本机制</strong></p><img src="kafka从入门到入土.assets/image-20230214161048286.png" alt="image-20230214161048286" style="zoom:33%;" /><ul><li>在 Kafka 中，副本分成两类：领导者副本（Leader Replica）和追随者副本（Follower Replica）。每个分区在创建时都要选举一个 Leader Replica，剩余的是 Follower Replica</li><li>Kafka 的副本机制比其他分布式系统要更严格一些。在 Kafka 中，Follower Replica 是不对外提供服务的。所有的读写请求都必须由 Leader Replica所在的 Broker负责处理。而 Follower 的任务只有一个：就是从 Leader 异步拉取消息，并写入到自己的提交日志中，从而实现与 Leader 的同步。</li><li>当 Leader Replica 挂掉了，或者说 Leader Replica 所在的 Broker 宕机时，Kafka 依托于 ZK 进行新的 Leader Replica 的选举</li></ul><p>你一定要特别注意上面的第二点，即追随者副本是不对外提供服务的。</p><p>原因归咎于两点：方便 Read-your-writes ，同时方便实现单调读（Monotonic Reads）</p><h3 id="Follower不提供服务的优点"><a href="#Follower不提供服务的优点" class="headerlink" title="Follower不提供服务的优点"></a>Follower不提供服务的优点</h3><p>有两个好处</p><h4 id="方便实现“Read-your-writes”"><a href="#方便实现“Read-your-writes”" class="headerlink" title="方便实现“Read-your-writes”"></a>方便实现“Read-your-writes”</h4><p>所谓 Read-your-writes，顾名思义就是，当你使用生产者 API 向 Kafka 成功写入消息后，马上使用消费者 API 去读取刚才生产的消息。</p><p>举个例子，比如你平时发微博时，你发完一条微博，肯定是希望能立即看到的，这就是典型的 Read-your-writes 场景。如果允许追随者副本对外提供服务，由于副本同步是异步的，因此有可能出现追随者副本还没有从领导者副本那里拉取到最新的消息，从而使得客户端看不到最新写入的消息。</p><h4 id="方便实现单调读（Monotonic-Reads）"><a href="#方便实现单调读（Monotonic-Reads）" class="headerlink" title="方便实现单调读（Monotonic Reads）"></a>方便实现单调读（Monotonic Reads）</h4><p>什么是单调读呢？就是对于一个消费者用户而言，在多次消费消息时，它不会看到某条消息一会儿存在一会儿不存在。</p><p>如果允许追随者副本提供读服务，那么假设当前有 2 个追随者副本 F1 和 F2，它们异步地拉取领导者副本数据。倘若 F1 拉取了 Leader 的最新消息而 F2 还未及时拉取，那么，此时如果有一个消费者先从 F1 读取消息之后又从 F2 拉取消息，它可能会看到这样的现象：第一次消费时看到的最新消息在第二次消费时不见了，这就不是单调读一致性。但是，如果所有的读请求都是由 Leader 来处理，那么 Kafka 就很容易实现单调读一致性。</p><p>现在我们知道了 Replica 的同步机制，和 Follower Replica 不对外提供服务的原因，接下来还有两个问题，我们一一来看：</p><p>Kafka 是怎么保证 Replica 的数据一致性的</p><p>当 Leader Replica 挂掉之后，Kafka 是怎么进行选举新的 Leader Replica 的</p><h3 id="怎么保证-副本数据一致性"><a href="#怎么保证-副本数据一致性" class="headerlink" title="怎么保证 副本数据一致性"></a>怎么保证 副本数据一致性</h3><p>我们知道 Kafka 的 Partition 有很多个 Replica</p><p>Replica 分为 Leader Replica 和 Follower Replica</p><p>Leader Replica 对外提供读写服务，Follower Replica 只是从 Leader Replica 异步同步数据，不对外提供任何服务；</p><p>那么，Kakfa是怎么保证这些 Replica 内的数据是一致的呢？</p><h4 id="In-Sync-Replicas（ISR）"><a href="#In-Sync-Replicas（ISR）" class="headerlink" title="In-Sync Replicas（ISR）"></a><strong>In-Sync Replicas（ISR）</strong></h4><p>既然 Follower Replica 是异步的方式，从Leader Replica 同步数据的，那么就一定会存在延迟；</p><p>就像 Mysql 的主从一样，主要涉及到数据同步，就一定会有延迟，无外乎：延迟的大小是多少。</p><p>Kafka 知道这个延迟是无法避免的，所以，Kafka 维护了一个集合，这个集合中保存的是：与Leader同步的Follower；</p><p>什么是与Leader同步的Follower？有同步的Follower，难道还有不同步的Follower？</p><ul><li>是的，有同步的，就有不同步的。</li><li>Kafka 有自己一套判定条件，只要 Follower Replica 满足了这个判定条件，Kafka 就认为这个 Follower 是同步的。就会放进 ISR 集合；</li><li>这个条件就是：replica.lag.time.max.ms，表示 Follower 副本能够落后 Leader 副本的最长时间间隔，默认是10S</li><li>也就是说：当 Follower 与 Leader 的同步时间差，在10秒内，Kafka就认为这个 Follower 是同步的。否则就是不同步的</li><li>ISR 集合有什么用的，主要是用来选举新的 Leader Replica 的，后面会说</li></ul><p>ISR 是一个动态调整的集合，当 Follower 落后于 Leader ，并且落后时间大于<code>replica.lag.time.max.ms</code>，Kafka 就会将这个 Follower 踢出 ISR；</p><p>同样的，当一个落后的 Follower 最终追上了 Leader ，Kafka 会将这个 Follower 在加入 ISR；</p><h4 id="ISR是怎么变化的"><a href="#ISR是怎么变化的" class="headerlink" title="ISR是怎么变化的"></a>ISR是怎么变化的</h4><p>Kafka 在启动的时候会开启两个任务</p><p>一个任务用来定期地检查是否需要调整 ISR 集合，这个周期是replica.lag.time.max.ms的一半，默认5秒；</p><p>当检测到 ISR 集合中有失效副本时，就会收缩 ISR 集合，当检查到有 Follower 的 HighWatermark （高水位）追赶上 Leader 时，就会扩充ISR。 </p><p>除此之外，当 ISR 集合发生变更的时候。还会将变更后的记录缓存到 isrChangeSet 中</p><p>另一个任务会周期性地检查 isrChangeSet，如果发现这个 isrChangeSet 有新的变更记录，那么它会在 ZK 中持久化一个节点。</p><p>然后因为 Controller（Kafka 控制器） 在这个 ZK 节点的路径上注册了一个Watcher，所以它就能够感知到 ISR 的变化，并向它所管理的broker发送更新元数据的请求。最后删除该ZK节点。 </p><p>Leader 副本天然就在 ISR 中</p><p>极端的情况：ISR 包含全部的 Replica，也有可能 ISR 中一个 Replica 都没有，如果一个都没有的话，说明 Leader 都挂了，此时就需要选举新的 Leader了。</p><h3 id="怎么进行选举新的-Leader-Replica"><a href="#怎么进行选举新的-Leader-Replica" class="headerlink" title="怎么进行选举新的 Leader Replica"></a>怎么进行选举新的 Leader Replica</h3><p>选举的时候，是通过 Controller（Kafka控制器）来处理的。 Coordinator（协调者）只是消费者组用来重平衡的；这两个不是一个概念；</p><p>当 ISR 不为空的时候，则选择其中一个作为新Leader，新的ISR则包含当前 ISR 中所有幸存的 Replica。</p><p>当 ISR 为空的时候，此时幸存的 Replica 都是非同步副本，也就是说：都是和 老的 Leader Replica 差距比较大的 Replica，如果此时从这些 非同步副本 中选举一个作为 Leader 的话，就会有消息丢失的风险；如果不选举，那就是 Kafka 服务不可用了。</p><p>当 ISR 为空的时候，如果进行选举，则这个选举叫做： Unclean 领导者选举，Broker 端参数 unclean.leader.election.enable 控制是否允许 Unclean 领导者选举</p><p>如果开启了  Unclean 领导者选举 ，相当于选择了可用性，牺牲了一致性；如果不选举，相当于选择了一致性，牺牲了可用性</p><p>建议不要开启，毕竟我们还可以通过其他的方式来提升高可用性。如果为了这点儿高可用性的改善，牺牲了数据一致性，那就非常不值当了。</p><h2 id="请求是怎么被处理的"><a href="#请求是怎么被处理的" class="headerlink" title="请求是怎么被处理的"></a>请求是怎么被处理的</h2><h3 id="kafka的请求分类"><a href="#kafka的请求分类" class="headerlink" title="kafka的请求分类"></a>kafka的请求分类</h3><p>之前，我们了解到 Kafka 是使用 TCP 进行通信，在TCP的基础上，Kafka定义了属于自己的请求协议：</p><p>比如常见的 PRODUCE 请求是用于生产消息的，FETCH 请求是用于消费消息的，METADATA 请求是用于请求 Kafka 集群元数据信息的等等</p><p>截止到 2.3 版本，总共有 45 种，在这 45 种请求中，可以分为两类：</p><p><strong>数据类请求</strong>：Kafka 社区把 PRODUCE 和 FETCH 这类请求称为数据类请求。</p><p><strong>控制类请求</strong>：Kafka 社区把 LeaderAndIsr、StopReplica 这类请求称为控制类请求。</p><h3 id="处理请求的方式"><a href="#处理请求的方式" class="headerlink" title="处理请求的方式"></a>处理请求的方式</h3><p>在传统的开发设计中，对一个请求的处理，很自然的就可以想到下面两种方式</p><h4 id="同步处理"><a href="#同步处理" class="headerlink" title="同步处理"></a>同步处理</h4><p>服务端收到一个消息，立即开始处理，处理完成后返回</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//伪代码</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Request</span> request <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>connection<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">handle</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法实现简单，但是有个致命的缺陷，那就是吞吐量太差。由于只能顺序处理每个请求，因此，每个请求都必须等待前一个请求处理完毕才能得到处理。这种方式只适用于请求发送非常不频繁的系统。</p><h4 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h4><p>既然同步的方式效率差， 那就用异步的方式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//伪代码</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Request</span> <span class="token operator">=</span> request <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>connection<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>        <span class="token function">handle</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法反其道而行之，完全采用异步的方式。系统会为每个入站请求都创建单独的线程来处理。这个方法的好处是，它是完全异步的，每个请求的处理都不会阻塞下一个请求。但缺陷也同样明显。为每个请求都创建线程的做法开销极大，在某些场景下甚至会压垮整个服务。</p><h3 id="Kafka-是如何处理请求的"><a href="#Kafka-是如何处理请求的" class="headerlink" title="Kafka 是如何处理请求的"></a>Kafka 是如何处理请求的</h3><p>Kafka 使用 Reactor 模式来处理请求</p><h4 id="什么是Reactor模式"><a href="#什么是Reactor模式" class="headerlink" title="什么是Reactor模式"></a>什么是Reactor模式</h4><p>Reactor 模式是 JUC 包的作者 Doug Lea 的作品，真不愧是大神。</p><p>简单来说，Reactor 模式是事件驱动架构的一种实现方式，特别适合应用于处理多个客户端并发向服务器端发送请求的场景。</p><p>Reactor 模式的架构如下图所示，图来自 Doug Lea 的PPT：<a href="#https://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">https://gee.cs.oswego.edu/dl/cpjslides/nio.pdf</a>：</p><img src="kafka从入门到入土.assets/image-20230215172615962.png" alt="image-20230215172615962" style="zoom: 33%;" /><p>多个 Client 客户端会发送请求给到 Reactor。</p><p>Reactor 有个请求分发线程 Dispatcher ，也就是图中的 Acceptor 线程，它会将不同的请求下发到多个工作线程中处理。</p><p>Dispatcher 是 Reactor 模式的一个概念，它的实现是：Acceptor 线程，所以它俩是指同一个东西。</p><p>Acceptor 线程只是用于请求分发，不涉及具体的逻辑处理，非常得轻量级，因此有很高的吞吐量表现。</p><p>而工作线程可以根据实际业务处理需要任意增减，从而动态调节系统负载能力。</p><h4 id="Kafka-的Reactor模式"><a href="#Kafka-的Reactor模式" class="headerlink" title="Kafka 的Reactor模式"></a>Kafka 的Reactor模式</h4><img src="kafka从入门到入土.assets/image-20230215173456675.png" alt="image-20230215173456675" style="zoom:33%;" /><p>Kafka 的 Broker 端有个 SocketServer 组件，类似于 Reactor 模式中的 Dispatcher。</p><p>它也有对应的 Acceptor 线程和一个工作线程池，只不过在 Kafka 中，这个工作线程池有个专属的名字，叫网络线程池。</p><p>Kafka 提供了 Broker 端参数 num.network.threads，用于调整该网络线程池的线程数。</p><p>num.network.threads 的默认值是 3，表示每台 Broker 启动时会创建 3 个网络线程，专门处理客户端发送的请求。</p><h5 id="在Reactor模式下怎么处理请求"><a href="#在Reactor模式下怎么处理请求" class="headerlink" title="在Reactor模式下怎么处理请求"></a>在Reactor模式下怎么处理请求</h5><img src="kafka从入门到入土.assets/image-20230215192742666.png" alt="image-20230215192742666" style="zoom:50%;" /><p>上图，其中 1-7 步骤是处理请求， 7-10 是响应请求</p><p>1、客户端或者其他Broker发起请求，这里的请求可能是 数据类请求，也可能是 控制类请求</p><p>2、请求发送到 Broker，会由 SocketServer 组件开始处理</p><p>3、SocketServer 组件（Acceptor线程）开始处理</p><p>4、SocketServer 组件（Acceptor线程）会将请求分发到网络线程池，这是一个很轻量级的工作</p><p>5、网络线程池中的某个线程接收到请求，但是这个线程并不会开始处理，而是将当前请求发送到共享请求队列</p><p>6、Broker 端还有一个IO线程池，会不停的从共享请求队列中获取请求，这才是真正的开始处理请求</p><ul><li>Broker 端参数 num.io.threads 控制了这个线程池中的线程数。</li><li>目前该参数默认值是 8，表示每台 Broker 启动后自动创建 8 个 IO 线程处理请求</li><li>你可以根据实际硬件条件设置此线程池的个数</li></ul><p>7、这个请求如果是 PRODUCE 请求，就写入日志；如果是 FETCH 请求，就从磁盘或者页缓存中读取数据</p><h5 id="在Reactor模式下怎么响应请求"><a href="#在Reactor模式下怎么响应请求" class="headerlink" title="在Reactor模式下怎么响应请求"></a>在Reactor模式下怎么响应请求</h5><img src="kafka从入门到入土.assets/image-20230215192742666.png" alt="image-20230215192742666" style="zoom:50%;" /><p>上图，其中 1-7 步骤是处理请求， 7-10 是响应请求</p><p>7、这个请求如果是 PRODUCE 请求，就写入日志；如果是 FETCH 请求，就从磁盘或者页缓存中读取数据</p><p>8、如果当前这个请求<strong>可以直接返回</strong>，就会找到当时发送这个请求的线程，然后返回到这个线程的响应队列中</p><ul><li><p>什么是可以直接返回的请求？ </p></li><li><blockquote><p>再讲什么是可以直接返回的请求之前，先了解一个什么是不可以直接返回的请求？</p><p>不可以直接返回的请求，比如设置了 acks&#x3D;all 的 PRODUCE 请求</p><p>一旦设置了 acks&#x3D;all，那么该请求就必须等待 ISR 中所有副本都接收了消息后才能返回</p><p>此时处理该请求的 IO 线程就必须等待其他 Broker 的写入结果</p><p>这就是不能直接返回的请求。</p><p>相反的，就是可以直接返回的请求</p></blockquote></li><li><p>响应队列是网络线程池中每个线程专属的吗？</p></li><li><blockquote><p>是的。</p><p>请求队列是所有网络线程共享的，而响应队列则是每个网络线程专属的。</p><p>这么设计的原因就在于，Dispatcher 只是用于请求分发而不负责响应回传，因此只能让每个网络线程自己发送 Response 给客户端，所以这些 Response 也就没必要放在一个公共的地方。</p></blockquote></li><li><p>怎么找到当时发送这个请求的线程呢？</p></li><li><blockquote><p>在源码中，有这部分代码逻辑：RequestChannel 类的 sendResponse 方法</p><p>&#x2F;&#x2F; 找出response对应的Processor线程，即request当初是由哪个Processor线程处理的 </p><p>val processor &#x3D; processors.get(response.processor) </p><p>&#x2F;&#x2F; 将response对象放置到对应Processor线程的Response队列中 </p><p>if (processor !&#x3D; null) { </p><p>  processor.enqueueResponse(response) </p><p>}</p></blockquote></li></ul><p>8、如果当前这个请求是<strong>不可以直接返回的</strong>，就会将当前这个请求暂存到 Purgatory</p><ul><li><p>什么是不可以直接返回的请求？ </p></li><li><blockquote><p>不可以直接返回的请求，比如设置了 acks&#x3D;all 的 PRODUCE 请求</p><p>一旦设置了 acks&#x3D;all，那么该请求就必须等待 ISR 中所有副本都接收了消息后才能返回</p><p>此时处理该请求的 IO 线程就必须等待其他 Broker 的写入结果</p><p>这就是不能直接返回的请求。</p><p>相反的，就是可以直接返回的请求</p></blockquote></li><li><p>Purgatory 是什么？</p></li><li><blockquote><p>Purgatory 的组件，这是 Kafka 中著名的“炼狱”组件。</p><p>它是用来缓存延时请求（Delayed Request）的。</p><p>所谓延时请求，就是那些一时未满足条件，不能立刻处理的请求。</p></blockquote></li></ul><p>9、等 Purgatory 中暂存的请求，可以返回的时候，会找到当时发送这个请求的线程，返回到这个线程的响应队列中</p><ul><li><p>怎么知道是可以返回的时候？</p></li><li><blockquote><p>举个例子：比如设置了 acks&#x3D;all 的 PRODUCE 请求</p><p>一旦设置了 acks&#x3D;all，那么该请求就必须等待 ISR 中所有副本都接收了消息后才能返回</p><p>此时处理该请求的 IO 线程就必须等待其他 Broker 的写入结果</p><p>此时才可以返回</p></blockquote></li></ul><p>10、网络线程池的线程，会将自己响应队列中的响应数据，通过网络传输回去。</p><h3 id="控制类和数据类请求分离"><a href="#控制类和数据类请求分离" class="headerlink" title="控制类和数据类请求分离"></a>控制类和数据类请求分离</h3><p>在本小节开头，就介绍过：Kafka 的请求分类两类</p><p><strong>数据类请求</strong>：Kafka 社区把 PRODUCE 和 FETCH 这类请求称为数据类请求。</p><p><strong>控制类请求</strong>：Kafka 社区把 LeaderAndIsr、StopReplica 这类请求称为控制类请求。</p><p>在了解了 Kafka 是怎么处理请求的流程之后，思考这么一个问题：</p><p>如果当前 共享请求队列 中，已经积压了很多的数据，IO线程正在马不停蹄的处理，此时我们发送一个请求：要求一个 Replica 下线。</p><p>此时：这个要求 Replica 下线的请求是优先处理，还是顺序处理？</p><p>如果是优先处理，那共享请求队列中积压的数据，怎么办？</p><p>如果是顺序处理，如果等待的时间很长很长，Replica 一直无法下线怎么办？</p><p>所以我们需要把 控制类请求 和 数据类请求 <strong>分开处理</strong>。</p><p>这就是 控制类和数据类请求分离</p><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>举一个具体的场景：</p><p>假设我们有个主题只有 1 个分区，该分区配置了 2 个副本</p><p>其中 Leader 副本保存在 Broker 0 上，Follower 副本保存在 Broker 1 上</p><p>假设 Broker 0 这台机器积压了很多的 PRODUCE 请求</p><p>此时你如果使用 Kafka 命令强制将该主题分区的 Leader、Follower 角色互换</p><p>那么 Kafka 内部的控制器组件（Controller）会发送 LeaderAndIsr 请求给 Broker 0，显式地告诉它，当前它不再是 Leader，而是 Follower 了</p><p>而 Broker 1 上的 Follower 副本因为被选为新的 Leader，因此停止向 Broker 0 拉取消息</p><h4 id="不分离的现象"><a href="#不分离的现象" class="headerlink" title="不分离的现象"></a>不分离的现象</h4><p>如果 控制类请求 和 数据类请求 不分离</p><p>LeaderAndIsr 请求（ Leader、Follower 角色互换）就会放在 共享请求队列 的后面</p><p>如果 共享请求队列 积压了很多，我们就要等很长很长时间，才能处理到这个 控制类请求</p><p>很显然，这不是我们想要的结果</p><h4 id="分离的现象"><a href="#分离的现象" class="headerlink" title="分离的现象"></a>分离的现象</h4><p>如果 控制类请求 和 数据类请求 分离</p><p>那么在 LeaderAndIsr 发送之前积压的 PRODUCE 请求就都无法正常完成了。</p><p>这是我们想要的结果吗？</p><p>我不知道这是不是我们想要的结果，但这是目前 Kafka 的处理方式</p><p>Kafka 会优先处理 LeaderAndIsr 请求，Broker 0 就会立刻抛出 NOT_LEADER_FOR_PARTITION 异常，快速地标识这些积压 PRODUCE 请求已失败</p><h4 id="怎么设计分离"><a href="#怎么设计分离" class="headerlink" title="怎么设计分离"></a>怎么设计分离</h4><p>现在我们知道 Kafka 会优先处理 控制类请求，如果是你来设计，你会怎么让 Kafka 优先处理 控制类请求呢？</p><p>方案一：</p><p>在 Broker 中实现一个优先级队列，并赋予控制类请求更高的优先级。</p><p>这是很自然的想法，所以我本以为社区也会这么实现的，但后来我这个方案被清晰地记录在“已拒绝方案”列表中。</p><p>拒绝的原因在于，它无法处理请求队列已满的情形。当请求队列已经无法容纳任何新的请求时，纵然有优先级之分，它也无法处理新的控制类请求了</p><p>方案二：</p><p>直接将 控制类请求 替换 共享请求队列中 的最前面的数据，这样就可以优先处理控制类请求了，处理完控制类请求，再将这个数据类请求插队到队头；</p><p>这个方案是网友分享的，当然，Kafka 社区也没有采用这个方案</p><p>那么 Kafka 是怎么做的呢？</p><h4 id="Kafka是怎么分离的"><a href="#Kafka是怎么分离的" class="headerlink" title="Kafka是怎么分离的"></a>Kafka是怎么分离的</h4><p>那么，社区是如何解决的呢？</p><p>很简单，Kafka 社区实现了两套一模一样的 Reactor模型</p><p>一个用来处理 数据类型请求，一个用来处理 控制类请求；实现了两类请求的分离。</p><p>也就是说，Kafka Broker 启动后，会在后台分别创建两套网络线程池和 IO 线程池的组合，它们分别处理数据类请求和控制类请求。</p><p>至于所用的 Socket 端口，自然是使用不同的端口了，你需要提供不同的 listeners 配置，显式地指定哪套端口用于处理哪类请求。</p><h2 id="kafka控制器"><a href="#kafka控制器" class="headerlink" title="kafka控制器"></a>kafka控制器</h2><h3 id="什么是控制器组件"><a href="#什么是控制器组件" class="headerlink" title="什么是控制器组件"></a>什么是控制器组件</h3><p>控制器组件（Controller），是 Apache Kafka 的核心组件</p><p>它的主要作用是在 ZK 的帮助下管理和协调整个 Kafka 集群</p><p>集群中任意一台 Broker 都能充当控制器的角色，只能有一个 Broker 成为控制器</p><p>每个正常运转的 Kafka 集群，在任意时刻都有且只有一个控制器</p><p>控制器是重度依赖 ZK 的，因此，我们有必要花一些时间学习下 ZK 是做什么的。</p><h3 id="Kafka依赖ZK"><a href="#Kafka依赖ZK" class="headerlink" title="Kafka依赖ZK"></a>Kafka依赖ZK</h3><h4 id="什么是ZK"><a href="#什么是ZK" class="headerlink" title="什么是ZK"></a>什么是ZK</h4><p>ZK 是一个分布式协调服务框架，它使用的数据模型类似于文件系统的树形结构，根目录也是以“&#x2F;”开始</p><p>ZK结构上的每个节点被称为 znode，用来保存一些元数据协调信息，可分为持久性 znode 和临时 znode</p><ul><li><p>持久性 znode 不会因为 ZooKeeper 集群重启而消失</p></li><li><p>临时 znode 则与创建该 znode 的 ZooKeeper 会话绑定，一旦会话结束，该节点会被自动删除</p></li></ul><p>ZK 赋予客户端监控 znode 变更的能力，即所谓的 Watch 通知功能。</p><ul><li>一旦 znode 节点被创建、删除，子节点数量发生变化，或是 znode 所存的数据本身变更</li><li>ZK 会通过节点变更监听器 (ChangeHandler) 的方式显式通知客户端。</li></ul><h4 id="Kafka使用ZK做了什么"><a href="#Kafka使用ZK做了什么" class="headerlink" title="Kafka使用ZK做了什么"></a>Kafka使用ZK做了什么</h4><p>Kafka 大量使用了 ZK 的 Watch 机制对集群进行管理，如下图</p><p>不用了解每个 znode 的作用，但可以大致体会下 Kafka 对 ZooKeeper 的依赖。</p><pre class="mermaid">graph LR;     Kafka的ZK节点 --> /consumers     /consumers --> consumer_group_name     consumer_group_name --> offsets     consumer_group_name --> ids     consumer_group_name --> owners    Kafka的ZK节点 --> /controller_epoch    Kafka的ZK节点 --> /brokers/ids    Kafka的ZK节点 --> /controller    Kafka的ZK节点 --> /admin/delete_topics    Kafka的ZK节点 --> /admin/preferred_replica_election    Kafka的ZK节点 --> /brokers/seqid    Kafka的ZK节点 --> /isr_change_notifaction    Kafka的ZK节点 --> /config    /config --> clients    /config --> changes    /config --> topics    Kafka的ZK节点 --> /config/changes    Kafka的ZK节点 --> /brokers/topics    Kafka的ZK节点 --> /admin/reassign_partitions    Kafka的ZK节点 --> /admin    /admin --> delete_topics</pre><p>在之前我们说过，每个 Broker 都有成为 控制器（Controller）的能力，但是控制器有且只有一个，那么控制器是怎么被选出来的</p><h3 id="控制器是怎么选出来的"><a href="#控制器是怎么选出来的" class="headerlink" title="控制器是怎么选出来的"></a>控制器是怎么选出来的</h3><p>在之前我们说过，每个 Broker 都有成为 控制器（Controller）的能力</p><p>但是控制器有且只有一个，那么控制器是怎么被选出来的</p><p>实际上，Broker 在启动时，会尝试去 ZK 中创建 &#x2F;controller 节点</p><p>Kafka 当前选举控制器的规则是：第一个成功创建 &#x2F;controller 节点的 Broker 会被指定为控制器。</p><h3 id="控制器用来做什么的"><a href="#控制器用来做什么的" class="headerlink" title="控制器用来做什么的"></a>控制器用来做什么的</h3><p>之前说过，控制器（Controller）起到了管理整个集群的作用，那么它具体都做了什么呢？</p><pre class="mermaid">graph LR;    Kafka控制器 --> 主题管理    Kafka控制器 --> 分区重分配    Kafka控制器 --> Preferred领导者选举    Kafka控制器 --> 集群成员管理    Kafka控制器 --> 数据服务</pre><h3 id="控制器中存了什么数据"><a href="#控制器中存了什么数据" class="headerlink" title="控制器中存了什么数据"></a>控制器中存了什么数据</h3><p>接下来，我们就详细看看，控制器中到底保存了哪些数据</p><p>控制器既然作为整个 Kafka 集群的管理者，里面主要存了三部分数据</p><ul><li>所有 Topic 信息<ul><li>某个 Topic 下的所有副本</li><li>某个 Topic 的所有分区</li><li>所有的 Topic 列表</li><li>移除某个 Topic 的所有信息</li></ul></li><li>所有 Broker 信息<ul><li>该 Broker 下的所有分区</li><li>某组 Broker 的所有副本</li><li>正在关闭的 Broker 列表</li><li>当前存活的 Broker 列表</li></ul></li><li>所有涉及运维的 Partiton 信息<ul><li>当前存活的所有 Partiton 副本</li><li>正在进行重分配的 Partiton 列表</li><li>某组 Partiton 下的所有副本</li><li>正在进行 preferred leader 选举的Partition</li><li>分配给每个 Partition 的副本列表</li><li>每个 Partition 的 Leader 和 ISR 信息</li></ul></li></ul><pre class="mermaid">graph LR;    控制器数据 --> 所有Topic信息    所有Topic信息 --> 某个Topic下的所有副本    所有Topic信息 --> 某个Topic的所有分区    所有Topic信息 --> 所有的Topic列表    所有Topic信息 --> 移除某个Topic的所有信息    控制器数据 --> 所有Broker信息    所有Broker信息 --> 该Broker下的所有分区    所有Broker信息 --> 某组Broker的所有副本    所有Broker信息 --> 正在关闭的Broker列表    所有Broker信息 --> 当前存活的Broker列表    控制器数据 --> 所有涉及运维的Partiton信息    所有涉及运维的Partiton信息 --> 当前存活的所有Partiton副本    所有涉及运维的Partiton信息 --> 正在进行重分配的Partiton列表    所有涉及运维的Partiton信息 --> 某组Partiton下的所有副本    所有涉及运维的Partiton信息 --> 正在进行preferredleader选举的Partition    所有涉及运维的Partiton信息 --> 分配给每个Partition的副本列表    所有涉及运维的Partiton信息 --> 每个Partition的Leader和ISR信息</pre><p>值得注意的是，这些数据其实在 ZooKeeper 中也保存了一份</p><p>每当控制器初始化时，它都会从 ZooKeeper 上读取对应的元数据并填充到自己的缓存中</p><h3 id="控制器故障转移"><a href="#控制器故障转移" class="headerlink" title="控制器故障转移"></a>控制器故障转移</h3><p>我们在前面强调过，在 Kafka 集群运行过程中，只能有一台 Broker 充当控制器的角色</p><p>那么这就存在单点失效（Single Point of Failure）的风险</p><p>Kafka 是如何应对单点失效的呢？</p><p>当运行中的控制器突然宕机或意外终止时，Kafka 能够快速地感知到，并立即启用备用控制器来代替之前失败的控制器</p><img src="kafka从入门到入土.assets/image-20230218120514451.png" alt="image-20230218120514451" style="zoom: 23%;" /><p>最开始时，Broker 0 是控制器。</p><p>当 Broker 0 宕机后，此时 ZK 就会通过 Watch 机制感知到并删除了 &#x2F;controller 临时节点。</p><p>之后所有存活的 Broker 就会收到通知，此时所有存活的 Broker 开始竞选新的控制器身份。</p><p>Broker 3 最终赢得了选举，成功地在 ZK 上重建了 &#x2F;controller 节点。</p><p>之后，Broker 3 会从 ZK 中读取集群元数据信息，并初始化到自己的缓存中。</p><p>至此，控制器的 Failover 完成，可以行使正常的工作职责了。</p><h3 id="控制器内部设计原理"><a href="#控制器内部设计原理" class="headerlink" title="控制器内部设计原理"></a>控制器内部设计原理</h3><p><font color='red'><strong>这部分只是根据部分文章，自己总结出来的，有些逻辑点说不通，后续还需要通过看 Kafka 的源码再补充完善这部分</strong></font></p><p><font color='red'><strong>这部分只是根据部分文章，自己总结出来的，有些逻辑点说不通，后续还需要通过看 Kafka 的源码再补充完善这部分</strong></font></p><p><font color='red'><strong>这部分只是根据部分文章，自己总结出来的，有些逻辑点说不通，后续还需要通过看 Kafka 的源码再补充完善这部分</strong></font></p><h4 id="老版本多线程设计"><a href="#老版本多线程设计" class="headerlink" title="老版本多线程设计"></a>老版本多线程设计</h4><p>在 Kafka 0.11 版本之前，Kafka 控制器是一个<strong>模拟状态机的多线程控制器</strong>。 </p><img src="kafka从入门到入土.assets/image-20230219143821049.png" alt="image-20230219143821049" style="zoom:50%;" /><p>它以下列方式工作：</p><p>既然是模拟状态机，那么都有哪些状态呢？</p><p><strong>需要维持的状态</strong>：这些状态是存储在 <font color='purple'><strong>Controller Context</strong></font> 中的</p><ul><li>每台机器上的分区副本。</li><li>分区的领导者。</li></ul><p><strong>什么会导致这些状态变化呢（状态变化源）</strong></p><ul><li><font color='#FFF2CC'>注册到 Zookeeper 的监听器线程。</font><ul><li><font color='#FFF2CC'>AddPartitionsListener</font>&gt;</li><li><font color='#FFF2CC'>BrokerChangeListener</font></li><li><font color='#FFF2CC'>DeleteTopicListener</font></li><li><font color='#FFF2CC'>PartitionReassignedListener（admin）</font></li><li><font color='#FFF2CC'>PreferredReplicaElectionListener（admin）</font></li><li><font color='#FFF2CC'>ReassignedPartitionsIsrChangeListener</font></li><li><font color='#FFF2CC'>TopicChangeListener</font></li></ul></li><li><font color='#FFF2CC'>controller与broker之间的socket连接 (controlled shutdown)</font></li><li><font color='#FFE6CC'>内部定时任务 <strong>Schedule Task</strong>线程（比如：preferred leader 选举）</font></li></ul><p><strong>状态是怎么变化的呢</strong></p><ul><li>ZK的监听线程，Kafka的API线程，内部定时任务的线程 都会<strong>同时</strong>改变状态</li><li>就是这些线程会同时修改 <font color='purple'><strong>Controller Context</strong></font></li></ul><p><strong>状态是怎么传播的</strong></p><ul><li>通过controller与broker之间的socket连接，进行状态的传输</li><li>通过controller与broker之间的消息队列</li><li>发送给broker的异步消息</li><li>不需要回调的消息（主题删除的除外）</li></ul><p><strong>故障转移</strong></p><ul><li>基于 Zookeeper 的领导者选举</li><li>Zookeeper 作为容错的持久状态存储。</li></ul><p><strong>这个设计的缺陷</strong></p><p>控制器是多线程的设计，会在内部创建很多个线程。比如：</p><ul><li>控制器需要为每个 Broker 都创建一个对应的 Socket 连接</li><li>控制器向这些 Broker 发送特定请求，会创建专属的列表</li><li>控制器连接 ZooKeeper 的会话，也会创建单独的线程来处理 Watch 机制的通知回调</li><li>控制器还会为主题删除创建额外的 I&#x2F;O 线程</li><li>多线程访问共享可变数据（控制器缓存）是维持线程安全最大的难题</li><li>为了保护数据安全性，控制器不得不在代码中大量使用 ReentrantLock 同步机制，这就进一步拖慢了整个控制器的处理速度</li></ul><h4 id="新版本单线程加时间队列设计"><a href="#新版本单线程加时间队列设计" class="headerlink" title="新版本单线程加时间队列设计"></a>新版本单线程加时间队列设计</h4><p>kafka 设计原文：<a href="https://cwiki.apache.org/confluence/display/kafka/kafka+controller+redesign">https://cwiki.apache.org/confluence/display/kafka/kafka+controller+redesign</a></p><p>鉴于这些原因，社区于 0.11 版本重构了控制器的底层设计，主要改进了两点</p><ul><li>把多线程的方案改成了单线程加事件队列的方案。</li><li>将 Broker 与 Zookeeper 的连接从同步改成了异步</li></ul><img src="kafka从入门到入土.assets/image-20230219144633226.png" alt="image-20230219144633226" style="zoom:35%;" /><p>将之前的 <strong>状态变化源</strong> 所涉及到的线程，抽象成 一个一个的<strong>事件 Event</strong></p><p>之前状态的变化，是通过线程直接操作控制器缓存</p><p>现在状态发生了变化，会将这个变化抽象成事件，放在事件队列中</p><p>由一个 <font color='green'>Event Execotor Thread</font> 单独处理，并操作 <font color='purple'><strong>Controller Context</strong></font> </p><p>此时的 zk 线程只负责 <font color='purple'><strong>Controller Context</strong></font> 更新而不负责事件 Event 执行。</p><p>针对控制器的第二个改进就是，将之前同步操作 ZooKeeper 全部改为异步操作。</p><p>ZooKeeper 本身的 API 提供了同步写和异步写两种方式。</p><p>之前控制器操作 ZooKeeper 使用的是同步的 API，性能很差，集中表现为，当有大量主题分区发生变更时，ZooKeeper 容易成为系统的瓶颈。</p><p>新版本 Kafka 修改了这部分设计，完全摒弃了之前的同步 API 调用，转而采用异步 API 写入 ZooKeeper，性能有了很大的提升。</p><p>根据社区的测试，改成异步之后，ZooKeeper 写入提升了 10 倍！</p><h3 id="如何处理脑裂"><a href="#如何处理脑裂" class="headerlink" title="如何处理脑裂"></a>如何处理脑裂</h3><p>如果 Controller 挂掉了，Kafka集群必须找到可以替代的 controller，否则集群将不能正常运转。</p><p>这里面存在一个问题，很难确定 Broker 是挂掉了，还是仅仅只是短暂性的故障。</p><p>但是，不管是哪种情况，集群为了正常运转，必须选出新的controller。</p><p>但是如果老的 controller 又正常了，他并不知道自己已经被取代了，那么此时集群中会出现两台controller。</p><h4 id="什么是脑裂"><a href="#什么是脑裂" class="headerlink" title="什么是脑裂"></a>什么是脑裂</h4><p>比如，某个 controlle r由于 GC 时间比较久，而被认为已经挂掉，并选择了一个新的controller。</p><p>在 GC 的情况下，在老的 Controller眼中，并没有改变任何东西，该 Broker 甚至不知道它已经暂停了。</p><p>因此，它将继续充当当前 Controller，但是此时系统中已经选择了另外一个新的 Controller</p><p>对于当前 Kafka 集群来说，就有了两个 Controller，有了两个大脑，就是脑裂了。</p><p>这是分布式系统中的常见情况，称为脑裂。</p><h4 id="如何解决脑裂"><a href="#如何解决脑裂" class="headerlink" title="如何解决脑裂"></a>如何解决脑裂</h4><p>Kafka是通过使用<strong>epoch number</strong>（纪元编号，也称为隔离令牌）来完成的。</p><p>epoch number只是单调递增的数字，第一次选出Controller时，epoch number值为1</p><p>如果再次选出新的Controller，则epoch number将为2，依次单调递增</p><p>简单的说，就是老的 controller 复活之后，它的 epoch 还是老的值，它所下发的命令携带的 epoch 还是老的值</p><p>当它的命令到达 broker 端之后，broker 发现有另一个 controller 发来的消息的epoch是新的值</p><p>就不会执行老的 controller 的命令。</p><h2 id="关于高水位和Leader-Epoch的讨论"><a href="#关于高水位和Leader-Epoch的讨论" class="headerlink" title="关于高水位和Leader Epoch的讨论"></a>关于高水位和Leader Epoch的讨论</h2><p>高水位和低水位分别是什么</p><p>HW</p><p>LEO（Log End Offet）</p><p>LSO（Log Stable Offset）：事务生产者</p><p>每个 Replica 都有自己的 HW 和 LEO；</p><p>Partiton 的 HW 就是 Leader Replica 的HW；</p><p>Leader Replica 所在的 Broker 除了保存当前 Replica 的 HW 和 LEO 之外，还保存了 它的 Follower Replica 的 HW 和 LEO</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>为什么kafka不像mysql那样允许追随者副本（follower replica）对外提供只读服务？</p><p>kafka是怎么做到 提供一套 API 实现生产者和消费者？</p><p>kafka是怎么做到 降低网络传输和磁盘存储开销；</p><p>kafka是怎么做到 实现高伸缩性架构。</p><p>kafka为什么快，为什么高吞吐？</p><ul><li>消息日志（Log）只能追加写，避免了随机IO，改成了顺序IO，大大提高了写能力；</li></ul><p>你觉得 Kafka 未来的演进路线是怎么样的？如果你是 Kafka 社区的“掌舵人”，你准备带领整个社区奔向什么方向呢？</p><p>想你是一家创业公司的架构师，公司最近准备改造现有系统，引入 Kafka 作为消息中间件衔接上下游业务。作为架构师的你会怎么选择合适的 Kafka 发行版呢</p><p>kafka每天 1 亿条 1KB 大小的消息，保存两份且留存两周的时间，需要多大的磁盘空间？</p><p>如果需要kafka1小时内处理1TB的业务数据，在千兆网络下，需要多少台kafka机器？</p><p>kafka怎么实现的故障转移？</p><p>kafka是怎么保障大数据量均匀的分布在各个Broker上的？</p><p>kafka的零拷贝技术是什么？</p><ul><li><a href="https://blog.csdn.net/ljheee/article/details/99652448">https://blog.csdn.net/ljheee/article/details/99652448</a></li><li><a href="https://www.jianshu.com/p/835ec2d4c170">https://www.jianshu.com/p/835ec2d4c170</a></li></ul><p>broker端收到消息也会解压缩，进行消息校验，那么零拷贝还有用嘛？</p><p>consumer可以先提交offset，在处理消息嘛？</p><p>kafka的producer是在producer实例化的时候，创建的TCP连接，那么这个时候，producer都不知道要往那个topic发消息，那么就不知道要连接到哪个broker？kafka是怎么做的呢？</p><p>kafka在建立TCP连接的步骤中，有没有可以优化的地方，目前社区做的不好的地方？</p><p>丰网的kafka的消费者重复注册是怎么做的？是同一个消费者实例的多个线程，还是同一个消费者类，注册了多个bean；</p><p>重试机制会导致消息乱序吗？</p><ul><li>重试机制不会重新计算Partition信息</li><li>重试机制会导致消息乱序，但是可以通过 max.in.flight.requests.per.connection&#x3D;1 来避免，但是会导致吞吐量下降</li><li>max.in.flight.requests.per.connection：表示限制客户端在单个连接上能够发送的未响应请求的个数；</li><li>设置为 1 表示：broker收到一个请求之后，在响应之前，是不会接收别的请求的</li></ul><p>消息的分区位移是什么时候写入的？</p><p>如果一个消息写入失败了，Producer 有重试，它的Offset是新的，还是老的？</p><p>Consumer设置自动提交位移，有一个提交频率，具体的流程是怎么提交的，如果消费到了Producer重试的消息，Offset会怎么样？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;kafka从入门到入土&quot;&gt;&lt;a href=&quot;#kafka从入门到入土&quot; class=&quot;headerlink&quot; title=&quot;kafka从入门到入土&quot;&gt;&lt;/a&gt;kafka从入门到入土&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; cl</summary>
      
    
    
    
    <category term="JAVA" scheme="https://zspcer.gitee.io/categories/JAVA/"/>
    
    <category term="消息中间件" scheme="https://zspcer.gitee.io/categories/JAVA/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="KAFKA" scheme="https://zspcer.gitee.io/categories/JAVA/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/KAFKA/"/>
    
    
    <category term="kafka" scheme="https://zspcer.gitee.io/tags/kafka/"/>
    
    <category term="生产者" scheme="https://zspcer.gitee.io/tags/%E7%94%9F%E4%BA%A7%E8%80%85/"/>
    
    <category term="消费者" scheme="https://zspcer.gitee.io/tags/%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    
    <category term="消息" scheme="https://zspcer.gitee.io/tags/%E6%B6%88%E6%81%AF/"/>
    
    <category term="中间件" scheme="https://zspcer.gitee.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
</feed>
