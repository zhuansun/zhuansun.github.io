<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZSPCR</title>
  
  
  <link href="https://zspcer.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://zspcer.gitee.io/"/>
  <updated>2023-05-11T15:42:17.078Z</updated>
  <id>https://zspcer.gitee.io/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大厂面试之Java基础篇</title>
    <link href="https://zspcer.gitee.io/note/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BJava%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>https://zspcer.gitee.io/note/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BJava%E5%9F%BA%E7%A1%80%E7%AF%87/</id>
    <published>2023-05-11T16:37:58.000Z</published>
    <updated>2023-05-11T15:42:17.078Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Java的特点"><a href="#1-Java的特点" class="headerlink" title="1.Java的特点"></a>1.Java的特点</h2><p><strong>Java是一门面向对象的编程语言</strong>。面向对象和面向过程的区别参考下一个问题。</p><p><strong>Java具有平台独立性和移植性</strong>。</p><ul><li>Java有一句口号：<code>Write once, run anywhere</code>，一次编写、到处运行。这也是Java的魅力所在。而实现这种特性的正是Java虚拟机JVM。已编译的Java程序可以在任何带有JVM的平台上运行。你可以在windows平台编写代码，然后拿到linux上运行。只要你在编写完代码后，将代码编译成.class文件，再把class文件打成Java包，这个jar包就可以在不同的平台上运行了。</li></ul><p><strong>Java具有稳健性</strong>。</p><ul><li><p>Java是一个强类型语言，它允许扩展编译时检查潜在类型不匹配问题的功能。Java要求显式的方法声明，它不支持C风格的隐式声明。这些严格的要求保证编译程序能捕捉调用错误，这就导致更可靠的程序。</p></li><li><p>异常处理是Java中使得程序更稳健的另一个特征。异常是某种类似于错误的异常条件出现的信号。使用<code>try/catch/finally</code>语句，程序员可以找到出错的处理代码，这就简化了出错处理和恢复的任务。</p></li></ul><h2 id="2-Java-与-C-的区别"><a href="#2-Java-与-C-的区别" class="headerlink" title="2.Java 与 C++ 的区别"></a>2.Java 与 C++ 的区别</h2><p>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 兼容 C ，不但支持面向对象也支持面向过程。</p><p>Java 通过虚拟机从而实现跨平台特性， C++ 依赖于特定的平台。</p><p>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</p><p>Java 支持自动垃圾回收，而 C++ 需要手动回收。</p><p>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</p><h2 id="3-面向对象和面向过程的区别？"><a href="#3-面向对象和面向过程的区别？" class="headerlink" title="3.面向对象和面向过程的区别？"></a>3.面向对象和面向过程的区别？</h2><p>面向对象和面向过程是一种软件开发思想。</p><ul><li><p>面向过程就是分析出解决问题所需要的步骤，然后用函数按这些步骤实现，使用的时候依次调用就可以了。</p></li><li><p>面向对象是把构成问题事务分解成各个对象，分别设计这些对象，然后将他们组装成有完整功能的系统。面向过程只用函数实现，面向对象是用类实现各个功能模块。</p></li></ul><p>以五子棋为例，面向过程的设计思路就是首先分析问题的步骤：</p><p>1、开始游戏，2、黑子先走，3、绘制画面，4、判断输赢，5、轮到白子，6、绘制画面，7、判断输赢，8、返回步骤2，9、输出最后结果。 把上面每个步骤用分别的函数来实现，问题就解决了。</p><p>而面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为：</p><p>1、黑白双方</p><p>2、棋盘系统，负责绘制画面</p><p>3、规则系统，负责判定诸如犯规、输赢等。</p><p>黑白双方负责接受用户的输入，并告知棋盘系统棋子布局发生变化，棋盘系统接收到了棋子的变化的信息就负责在屏幕上面显示出这种变化，同时利用规则系统来对棋局进行判定。</p><h2 id="4-JDK-x2F-JRE-x2F-JVM三者的关系"><a href="#4-JDK-x2F-JRE-x2F-JVM三者的关系" class="headerlink" title="4.JDK&#x2F;JRE&#x2F;JVM三者的关系"></a>4.JDK&#x2F;JRE&#x2F;JVM三者的关系</h2><p><strong>JVM</strong></p><p>英文名称（Java Virtual Machine），就是我们耳熟能详的 Java 虚拟机。Java 能够跨平台运行的核心在于 JVM 。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BJava%E5%9F%BA%E7%A1%80%E7%AF%87.assets/1676356804547-8a9b7154-388f-4023-ab0e-85288c1a2d6c.webp" alt="img"></p><p>所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行。也就是说class文件并不直接与机器的操作系统交互，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。</p><p>针对不同的系统有不同的 jvm 实现，有 Linux 版本的 jvm 实现，也有Windows 版本的 jvm 实现，但是同一段代码在编译后的字节码是一样的。这就是Java能够跨平台，实现一次编写，多处运行的原因所在。</p><p><strong>JRE</strong></p><p>英文名称（Java Runtime Environment），就是Java 运行时环境。我们编写的Java程序必须要在JRE才能运行。它主要包含两个部分，JVM 和 Java 核心类库。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BJava%E5%9F%BA%E7%A1%80%E7%AF%87.assets/1676356806545-747ebc8f-f2a9-4dce-a34f-7a75c22fbbf1.png" alt="img"></p><p>JRE是Java的运行环境，并不是一个开发环境，所以没有包含任何开发工具，如编译器和调试器等。</p><p>如果你只是想运行Java程序，而不是开发Java程序的话，那么你只需要安装JRE即可。</p><p><strong>JDK</strong></p><p>英文名称（Java Development Kit），就是 Java 开发工具包</p><p>学过Java的同学，都应该安装过JDK。当我们安装完JDK之后，目录结构是这样的</p><p>可以看到，JDK目录下有个JRE，也就是JDK中已经集成了 JRE，不用单独安装JRE。</p><p>另外，JDK中还有一些好用的工具，如jinfo，jps，jstack等。</p><p>最后，总结一下JDK&#x2F;JRE&#x2F;JVM，他们三者的关系</p><p><strong>JRE &#x3D; JVM + Java 核心类库</strong></p><p><strong>JDK &#x3D; JRE + Java工具 + 编译器 + 调试器</strong></p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BJava%E5%9F%BA%E7%A1%80%E7%AF%87.assets/1676356808527-9378b532-29c7-474c-9e91-76eb2dad0a56.png" alt="img"></p><h2 id="5-面向对象有哪些特性？"><a href="#5-面向对象有哪些特性？" class="headerlink" title="5.面向对象有哪些特性？"></a>5.面向对象有哪些特性？</h2><p>面向对象四大特性：封装，继承，多态，抽象</p><p>1、封装就是将类的信息隐藏在类内部，不允许外部程序直接访问，而是通过该类的方法实现对隐藏信息的操作和访问。 良好的封装能够减少耦合。</p><p>2、继承是从已有的类中派生出新的类，新的类继承父类的属性和行为，并能扩展新的能力，大大增加程序的重用性和易维护性。在Java中是单继承的，也就是说一个子类只有一个父类。</p><p>3、多态是同一个行为具有多个不同表现形式的能力。在不修改程序代码的情况下改变程序运行时绑定的代码。实现多态的三要素：继承、重写、父类引用指向子类对象。</p><ul><li><p>静态多态性：通过重载实现，相同的方法有不同的參数列表，可以根据参数的不同，做出不同的处理。</p></li><li><p>动态多态性：在子类中重写父类的方法。运行期间判断所引用对象的实际类型，根据其实际类型调用相应的方法。</p></li></ul><p>4、抽象。把客观事物用代码抽象出来。</p><h2 id="6-Java的基本数据类型有哪些？"><a href="#6-Java的基本数据类型有哪些？" class="headerlink" title="6.Java的基本数据类型有哪些？"></a>6.Java的基本数据类型有哪些？</h2><ul><li><p>byte，8bit</p></li><li><p>char，16bit</p></li><li><p>short，16bit</p></li><li><p>int，32bit</p></li><li><p>float，32bit</p></li><li><p>long，64bit</p></li><li><p>double，64bit</p></li><li><p>boolean，只有两个值：true、false，可以使⽤用 1 bit 来存储</p></li></ul><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BJava%E5%9F%BA%E7%A1%80%E7%AF%87.assets/1676356813264-e1ca0046-0a52-416a-822a-d6a167fc36e7.png" alt="img"></p><p>在Java规范中，没有明确指出boolean的大小。在《Java虚拟机规范》给出了单个boolean占4个字节，和boolean数组1个字节的定义，具体 <strong>还要看虚拟机实现是否按照规范来</strong>，因此boolean占用1个字节或者4个字节都是有可能的。</p><h2 id="7-为什么不能用浮点型表示金额？"><a href="#7-为什么不能用浮点型表示金额？" class="headerlink" title="7.为什么不能用浮点型表示金额？"></a>7.为什么不能用浮点型表示金额？</h2><p>由于计算机中保存的小数其实是十进制的小数的近似值，并不是准确值，所以，千万不要在代码中使用浮点数来表示金额等重要的指标。</p><p>建议使用BigDecimal或者Long来表示金额。</p><h2 id="8-什么是值传递和引用传递？"><a href="#8-什么是值传递和引用传递？" class="headerlink" title="8.什么是值传递和引用传递？"></a>8.什么是值传递和引用传递？</h2><p>值传递是对基本型变量而言的，传递的是该变量的一个副本，改变副本不影响原变量。</p><p>引用传递一般是对于对象型变量而言的，传递的是该对象地址的一个副本，并不是原对象本身，两者指向同一片内存空间。所以对引用对象进行操作会同时改变原对象。</p><p><strong>java中不存在引用传递，只有值传递</strong>。即不存在变量a指向变量b，变量b指向对象的这种情况。</p><h2 id="9-了解Java的包装类型吗？为什么需要包装类？"><a href="#9-了解Java的包装类型吗？为什么需要包装类？" class="headerlink" title="9.了解Java的包装类型吗？为什么需要包装类？"></a>9.了解Java的包装类型吗？为什么需要包装类？</h2><p>Java 是一种面向对象语言，很多地方都需要使用对象而不是基本数据类型。比如，在集合类中，我们是无法将 int 、double 等类型放进去的。因为集合的容器要求元素是 Object 类型。</p><p>为了让基本类型也具有对象的特征，就出现了包装类型。相当于将基本类型包装起来，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。</p><h2 id="10-自动装箱和拆箱"><a href="#10-自动装箱和拆箱" class="headerlink" title="10.自动装箱和拆箱"></a>10.自动装箱和拆箱</h2><p>Java中基础数据类型与它们对应的包装类见下表：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BJava%E5%9F%BA%E7%A1%80%E7%AF%87.assets/1676356815969-603b452c-c881-45bd-a48c-56f7a21838c7.png" alt="img"></p><p>装箱：将基础类型转化为包装类型。</p><p>拆箱：将包装类型转化为基础类型。</p><p>当基础类型与它们的包装类有如下几种情况时，编译器会<strong>自动</strong>帮我们进行装箱或拆箱：</p><ul><li><p>赋值操作（装箱或拆箱）</p></li><li><p>进行加减乘除混合运算 （拆箱）</p></li><li><p>进行&gt;,&lt;,&#x3D;&#x3D;比较运算（拆箱）</p></li><li><p>调用equals进行比较（装箱）</p></li><li><p>ArrayList、HashMap等集合类添加基础类型数据时（装箱）</p></li></ul><p>示例代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 装箱 调⽤ Integer.valueOf(1)</span><span class="token keyword">int</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// 拆箱 调⽤了 X.intValue()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下面看一道常见的面试题：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> c <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> d <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c <span class="token operator">==</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token boolean">true</span><span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>为什么第三个输出是false？看看 Integer 类的源码就知道啦。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Integer</span> <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>low <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>high<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>low<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Integer c = 200;</code> 会调用 调⽤<code>Integer.valueOf(200)</code>。而从Integer的valueOf()源码可以看到，这里的实现并不是简单的new Integer，而是用IntegerCache做一个cache。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">IntegerCache</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> high<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Integer</span> cache<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// high value may be configured by property</span>        <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> integerCacheHighPropValue <span class="token operator">=</span>            sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span><span class="token constant">VM</span><span class="token punctuation">.</span><span class="token function">getSavedProperty</span><span class="token punctuation">(</span><span class="token string">"java.lang.Integer.IntegerCache.high"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>integerCacheHighPropValue <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>integerCacheHighPropValue<span class="token punctuation">)</span><span class="token punctuation">;</span>                i <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// Maximum array size is Integer.MAX_VALUE</span>                h <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token operator">-</span>low<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span><span class="token punctuation">(</span> <span class="token class-name">NumberFormatException</span> nfe<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// If the property cannot be parsed into an int, ignore it.</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        high <span class="token operator">=</span> h<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是IntegerCache静态代码块中的一段，默认Integer cache 的下限是-128，上限默认127。当赋值100给Integer时，刚好在这个范围内，所以从cache中取对应的Integer并返回，所以a和b返回的是同一个对象，所以比较是相等的，当赋值200给Integer时，不在cache 的范围内，所以会new Integer并返回，当然比较的结果是不相等的。</p><h2 id="11-String-为什么不可变？"><a href="#11-String-为什么不可变？" class="headerlink" title="11.String 为什么不可变？"></a>11.String 为什么不可变？</h2><p>先看看什么是不可变的对象。</p><p>如果一个对象，在它创建完成之后，不能再改变它的状态，那么这个对象就是不可变的。不能改变状态的意思是，不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。</p><p>接着来看Java8 String类的源码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span>    <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">,</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">,</span> <span class="token class-name">CharSequence</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/** The value is used for character storage. */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">/** Cache the hash code for the string */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span> <span class="token comment">// Default to 0</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从源码可以看出，String对象其实在内部就是一个个字符，存储在这个value数组里面的。</p><p>value数组用final修饰，final 修饰的变量，值不能被修改。因此value不可以指向其他对象。</p><p>String类内部所有的字段都是私有的，也就是被private修饰。而且String没有对外提供修改内部状态的方法，因此value数组不能改变。</p><p>所以，String是不可变的。</p><p>那为什么String要设计成不可变的？</p><p>主要有以下几点原因：</p><p>1、<strong>线程安全</strong>。同一个字符串实例可以被多个线程共享，因为字符串不可变，本身就是线程安全的。</p><p>2、<strong>支持hash映射和缓存。</strong>因为String的hash值经常会使用到，比如作为 Map 的键，不可变的特性使得 hash 值也不会变，不需要重新计算。</p><p>3、<strong>出于安全考虑</strong>。网络地址URL、文件路径path、密码通常情况下都是以String类型保存，假若String不是固定不变的，将会引起各种安全隐患。比如将密码用String的类型保存，那么它将一直留在内存中，直到垃圾收集器把它清除。假如String类不是固定不变的，那么这个密码可能会被改变，导致出现安全隐患。</p><p>4、<strong>字符串常量池优化</strong>。String对象创建之后，会缓存到字符串常量池中，下次需要创建同样的对象时，可以直接返回缓存的引用。</p><p>既然我们的String是不可变的，它内部还有很多substring， replace， replaceAll这些操作的方法。这些方法好像会改变String对象？怎么解释呢？</p><p>其实不是的，我们每次调用replace等方法，其实会在堆内存中创建了一个新的对象。然后其value数组引用指向不同的对象。</p><h2 id="12-String-StringBuffer-和-StringBuilder区别"><a href="#12-String-StringBuffer-和-StringBuilder区别" class="headerlink" title="12.String, StringBuffer 和 StringBuilder区别"></a>12.String, StringBuffer 和 StringBuilder区别</h2><p><strong>1. 可变性</strong></p><ul><li><p>String 不可变</p></li><li><p>StringBuffer 和 StringBuilder 可变</p></li></ul><p><strong>2. 线程安全</strong></p><ul><li><p>String 不可变，因此是线程安全的</p></li><li><p>StringBuilder 不是线程安全的</p></li><li><p>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</p></li></ul><h2 id="13-什么是StringJoiner？"><a href="#13-什么是StringJoiner？" class="headerlink" title="13.什么是StringJoiner？"></a>13.什么是StringJoiner？</h2><p>StringJoiner是 Java 8 新增的一个 API，它基于 StringBuilder 实现，用于实现对字符串之间通过分隔符拼接的场景。</p><p>StringJoiner 有两个构造方法，第一个构造要求依次传入分隔符、前缀和后缀。第二个构造则只要求传入分隔符即可（前缀和后缀默认为空字符串）。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">StringJoiner</span><span class="token punctuation">(</span><span class="token class-name">CharSequence</span> delimiter<span class="token punctuation">,</span> <span class="token class-name">CharSequence</span> prefix<span class="token punctuation">,</span> <span class="token class-name">CharSequence</span> suffix<span class="token punctuation">)</span><span class="token class-name">StringJoiner</span><span class="token punctuation">(</span><span class="token class-name">CharSequence</span> delimiter<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>有些字符串拼接场景，使用 StringBuffer 或 StringBuilder 则显得比较繁琐。</p><p>比如下面的例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> values <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">"("</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> values<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> values<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">")"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而通过StringJoiner来实现拼接List的各个元素，代码看起来更加简洁。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> values <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">StringJoiner</span> sj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringJoiner</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">,</span> <span class="token string">"("</span><span class="token punctuation">,</span> <span class="token string">")"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span> value <span class="token operator">:</span> values<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>sj<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外，像平时经常使用的Collectors.joining(“,”)，底层就是通过StringJoiner实现的。</p><p>源码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Collector</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">CharSequence</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">joining</span><span class="token punctuation">(</span>    <span class="token class-name">CharSequence</span> delimiter<span class="token punctuation">,</span><span class="token class-name">CharSequence</span> prefix<span class="token punctuation">,</span><span class="token class-name">CharSequence</span> suffix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CollectorImpl</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>            <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">new</span> <span class="token class-name">StringJoiner</span><span class="token punctuation">(</span>delimiter<span class="token punctuation">,</span> prefix<span class="token punctuation">,</span> suffix<span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token class-name">StringJoiner</span><span class="token operator">::</span><span class="token function">add</span><span class="token punctuation">,</span> <span class="token class-name">StringJoiner</span><span class="token operator">::</span><span class="token function">merge</span><span class="token punctuation">,</span>            <span class="token class-name">StringJoiner</span><span class="token operator">::</span><span class="token function">toString</span><span class="token punctuation">,</span> <span class="token constant">CH_NOID</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="14-String-类的常用方法有哪些？"><a href="#14-String-类的常用方法有哪些？" class="headerlink" title="14.String 类的常用方法有哪些？"></a>14.String 类的常用方法有哪些？</h2><p>1、indexOf()：返回指定字符的索引。</p><p>2、charAt()：返回指定索引处的字符。</p><p>3、replace()：字符串替换。</p><p>4、trim()：去除字符串两端空白。</p><p>5、split()：分割字符串，返回一个分割后的字符串数组。</p><p>6、getBytes()：返回字符串的 byte 类型数组。</p><p>7、length()：返回字符串长度。</p><p>8、toLowerCase()：将字符串转成小写字母。</p><p>9、toUpperCase()：将字符串转成大写字符。</p><p>10、substring()：截取字符串。</p><p>11、equals()：字符串比较。</p><h2 id="15-new-String-“dabin”-会创建几个对象？"><a href="#15-new-String-“dabin”-会创建几个对象？" class="headerlink" title="15.new String(“dabin”)会创建几个对象？"></a>15.new String(“dabin”)会创建几个对象？</h2><p>使用这种方式会创建两个字符串对象（前提是字符串常量池中没有 “dabin” 这个字符串对象）。</p><ul><li><p>“dabin” 属于字符串字面量，因此编译时期会在字符串常量池中创建一个字符串对象，指向这个 “dabin” 字符串字面量；</p></li><li><p>使用 new 的方式会在堆中创建一个字符串对象。</p></li></ul><h2 id="16-什么是字符串常量池？"><a href="#16-什么是字符串常量池？" class="headerlink" title="16.什么是字符串常量池？"></a>16.什么是字符串常量池？</h2><p>字符串常量池（String Pool）保存着所有字符串字面量，这些字面量在编译时期就确定。字符串常量池位于堆内存中，专门用来存储字符串常量。在创建字符串时，JVM首先会检查字符串常量池，如果该字符串已经存在池中，则返回其引用，如果不存在，则创建此字符串并放入池中，并返回其引用。</p><h2 id="17-Object常用方法有哪些？"><a href="#17-Object常用方法有哪些？" class="headerlink" title="17.Object常用方法有哪些？"></a>17.Object常用方法有哪些？</h2><p>Java面试经常会出现的一道题目，Object的常用方法。下面给大家整理一下。</p><p>Object常用方法有：<code>toString()</code>、<code>equals()</code>、<code>hashCode()</code>、<code>clone()</code>等。</p><p><strong>toString</strong></p><p>默认输出对象地址。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">"程序员小官"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//output</span>    <span class="token comment">//me.tyson.java.core.Person@4554617c</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以重写toString方法，按照重写逻辑输出对象值。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> name <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> age<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">"程序员小官"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//output</span>    <span class="token comment">//程序员小官:18</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>equals</strong></p><p>默认比较两个引用变量是否指向同一个对象（内存地址）。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">"程序员小官"</span><span class="token punctuation">;</span>        <span class="token class-name">Person</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Person</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//output</span>    <span class="token comment">//false</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以重写equals方法，按照age和name是否相等来判断：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Person</span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">)</span> o<span class="token punctuation">;</span>            <span class="token keyword">return</span> age <span class="token operator">==</span> p<span class="token punctuation">.</span>age <span class="token operator">&amp;&amp;</span> name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">"程序员小官"</span><span class="token punctuation">;</span>        <span class="token class-name">Person</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Person</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//output</span>    <span class="token comment">//true</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>hashCode</strong></p><p>将与对象相关的信息映射成一个哈希值，默认的实现hashCode值是根据内存地址换算出来。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//out</span>    <span class="token comment">//1349277854</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>clone</strong></p><p>Java赋值是复制对象引用，如果我们想要得到一个对象的副本，使用赋值操作是无法达到目的的。Object对象有个clone()方法，实现了对</p><p>象中各个属性的复制，但它的可见范围是protected的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">native</span> <span class="token class-name">Object</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>所以实体类使用克隆的前提是：</p><ul><li><p>实现Cloneable接口，这是一个标记接口，自身没有方法，这应该是一种约定。调用clone方法时，会判断有没有实现Cloneable接口，没有实现Cloneable的话会抛异常CloneNotSupportedException。</p></li><li><p>覆盖clone()方法，可见性提升为public。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token class-name">Object</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Cat</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"程序员小官"</span><span class="token punctuation">;</span>        <span class="token class-name">Cat</span> cloneCat <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Cat</span><span class="token punctuation">)</span> c<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"小官"</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cloneCat<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//output</span>    <span class="token comment">//程序员小官</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>getClass</strong></p><p>返回此 Object 的运行时类，常用于java反射机制。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Person</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"程序员小官"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Class</span> clz <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>clz<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//获取类名</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>clz<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * class com.tyson.basic.Person     * com.tyson.basic.Person     */</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>wait</strong></p><p>当前线程调用对象的wait()方法之后，当前线程会释放对象锁，进入等待状态。等待其他线程调用此对象的notify()&#x2F;notifyAll()唤醒或者等待超时时间wait(long timeout)自动唤醒。线程需要获取obj对象锁之后才能调用 obj.wait()。</p><p><strong>notify</strong></p><p>obj.notify()唤醒在此对象上等待的单个线程，选择是任意性的。notifyAll()唤醒在此对象上等待的所有线程。</p><h2 id="18-讲讲深拷贝和浅拷贝？"><a href="#18-讲讲深拷贝和浅拷贝？" class="headerlink" title="18.讲讲深拷贝和浅拷贝？"></a>18.讲讲深拷贝和浅拷贝？</h2><p><strong>浅拷贝</strong>：拷⻉对象和原始对象的引⽤类型引用同⼀个对象。</p><p>以下例子，Cat对象里面有个Person对象，调用clone之后，克隆对象和原对象的Person引用的是同一个对象，这就是浅拷贝。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Person</span> owner<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token class-name">Object</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Cat</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Person</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">"程序员小官"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token punctuation">.</span>owner <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token class-name">Cat</span> cloneCat <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Cat</span><span class="token punctuation">)</span> c<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"小官"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cloneCat<span class="token punctuation">.</span>owner<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//output</span>    <span class="token comment">//小官</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>深拷贝</strong>：拷贝对象和原始对象的引用类型引用不同的对象。</p><p>以下例子，在clone函数中不仅调用了super.clone，而且调用Person对象的clone方法（Person也要实现Cloneable接口并重写clone方法），从而实现了深拷贝。可以看到，拷贝对象的值不会受到原对象的影响。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Person</span> owner<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token class-name">Object</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Cat</span> c <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Cat</span><span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token punctuation">.</span>owner <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">)</span> owner<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//拷贝Person对象</span>        <span class="token keyword">return</span> c<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Cat</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Person</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">"程序员小官"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token punctuation">.</span>owner <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token class-name">Cat</span> cloneCat <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Cat</span><span class="token punctuation">)</span> c<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"小官"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cloneCat<span class="token punctuation">.</span>owner<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//output</span>    <span class="token comment">//程序员小官</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="19-两个对象的hashCode-相同，则-equals-是否也一定为-true？"><a href="#19-两个对象的hashCode-相同，则-equals-是否也一定为-true？" class="headerlink" title="19.两个对象的hashCode()相同，则 equals()是否也一定为 true？"></a>19.两个对象的hashCode()相同，则 equals()是否也一定为 true？</h2><p>equals与hashcode的关系：</p><p>1、如果两个对象调用equals比较返回true，那么它们的hashCode值一定要相同；</p><p>2、如果两个对象的hashCode相同，它们并不一定相同。</p><p>hashcode方法主要是用来<strong>提升对象比较的效率</strong>，先进行hashcode()的比较，如果不相同，那就不必在进行equals的比较，这样就大大减少了equals比较的次数，当比较对象的数量很大的时候能提升效率。</p><p>之所以重写<code>equals()</code>要重写<code>hashcode()</code>，是为了保证<code>equals()</code>方法返回true的情况下hashcode值也要一致，如果重写了<code>equals()</code>没有重写<code>hashcode()</code>，就会出现两个对象相等但<code>hashcode()</code>不相等的情况。这样，当用其中的一个对象作为键保存到hashMap、hashTable或hashSet中，再以另一个对象作为键值去查找他们的时候，则会查找不到。</p><h2 id="20-Java创建对象有几种方式？"><a href="#20-Java创建对象有几种方式？" class="headerlink" title="20.Java创建对象有几种方式？"></a>20.Java创建对象有几种方式？</h2><p>Java创建对象有以下几种方式：</p><ul><li><p>用new语句创建对象。</p></li><li><p>使用反射，使用Class.newInstance()创建对象。</p></li><li><p>调用对象的clone()方法。</p></li><li><p>运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法。</p></li></ul><h2 id="21-说说类实例化的顺序"><a href="#21-说说类实例化的顺序" class="headerlink" title="21.说说类实例化的顺序"></a>21.说说类实例化的顺序</h2><p>Java中类实例化顺序：</p><p>1、静态属性，静态代码块。</p><p>2、普通属性，普通代码块。</p><p>3、构造方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LifeCycle</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 静态属性</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">String</span> staticField <span class="token operator">=</span> <span class="token function">getStaticField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 静态代码块</span>    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>staticField<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"静态代码块初始化"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 普通属性</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> field <span class="token operator">=</span> <span class="token function">getField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 普通代码块</span>    <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>field<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"普通代码块初始化"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 构造方法</span>    <span class="token keyword">public</span> <span class="token class-name">LifeCycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"构造方法初始化"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 静态方法</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">getStaticField</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> statiFiled <span class="token operator">=</span> <span class="token string">"静态属性初始化"</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> statiFiled<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 普通方法</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getField</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> filed <span class="token operator">=</span> <span class="token string">"普通属性初始化"</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> filed<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> argc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">new</span> <span class="token class-name">LifeCycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     *      静态属性初始化     *      静态代码块初始化     *      普通属性初始化     *      普通代码块初始化     *      构造方法初始化     */</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="22-equals和-x3D-x3D-有什么区别？"><a href="#22-equals和-x3D-x3D-有什么区别？" class="headerlink" title="22.equals和&#x3D;&#x3D;有什么区别？"></a>22.equals和&#x3D;&#x3D;有什么区别？</h2><ul><li><p>对于基本数据类型，&#x3D;&#x3D;比较的是他们的值。基本数据类型没有equal方法；</p></li><li><p>对于复合数据类型，&#x3D;&#x3D;比较的是它们的存放地址(是否是同一个对象)。<code>equals()</code>默认比较地址值，重写的话按照重写逻辑去比较。</p></li></ul><h2 id="23-常见的关键字有哪些？"><a href="#23-常见的关键字有哪些？" class="headerlink" title="23.常见的关键字有哪些？"></a>23.常见的关键字有哪些？</h2><p><strong>static</strong></p><p>static可以用来修饰类的成员方法、类的成员变量。</p><p>static变量也称作<strong>静态变量</strong>，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</p><p>以下例子，age为非静态变量，则p1打印结果是：<code>Name:zhangsan, Age:10</code>；若age使用static修饰，则p1打印结果是：<code>Name:zhangsan, Age:12</code>，因为static变量在内存只有一个副本。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">"Name:"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">", Age:"</span> <span class="token operator">+</span> age<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Person</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"zhangsan"</span><span class="token punctuation">;</span>        p1<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token class-name">Person</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p2<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"lisi"</span><span class="token punctuation">;</span>        p2<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**Output     * Name:zhangsan, Age:10     * Name:lisi, Age:12     */</span><span class="token operator">/</span><span class="token operator">/</span><span class="token operator">~</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>static方法一般称作<strong>静态方法</strong>。静态方法不依赖于任何对象就可以进行访问，通过类名即可调用静态方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Utils</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello world: "</span> <span class="token operator">+</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Utils</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"程序员小官"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>静态代码块</strong>只会在类加载的时候执行一次。以下例子，startDate和endDate在类加载的时候进行赋值。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Person</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Date</span> birthDate<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Date</span> startDate<span class="token punctuation">,</span> endDate<span class="token punctuation">;</span>    <span class="token keyword">static</span><span class="token punctuation">&#123;</span>        startDate <span class="token operator">=</span> <span class="token class-name">Date</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token string">"2008"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        endDate <span class="token operator">=</span> <span class="token class-name">Date</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token string">"2021"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">Date</span> birthDate<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>birthDate <span class="token operator">=</span> birthDate<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>静态内部类</strong></p><p><strong>在静态方法里</strong>，使用⾮静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。⽽静态内部类不需要。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OuterClass</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">class</span> <span class="token class-name">InnerClass</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">StaticInnerClass</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 在静态方法里，不能直接使用OuterClass.this去创建InnerClass的实例</span>        <span class="token comment">// 需要先创建OuterClass的实例o，然后通过o创建InnerClass的实例</span>        <span class="token comment">// InnerClass innerClass = new InnerClass();</span>        <span class="token class-name">OuterClass</span> outerClass <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OuterClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">InnerClass</span> innerClass <span class="token operator">=</span> outerClass<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">InnerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">StaticInnerClass</span> staticInnerClass <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StaticInnerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        outerClass<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">nonStaticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">InnerClass</span> innerClass <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InnerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"nonStaticMethod..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>final</strong></p><p>1、<strong>基本数据</strong>类型用final修饰，则不能修改，是常量；<strong>对象引用</strong>用final修饰，则引用只能指向该对象，不能指向别的对象，但是对象本身可以修改。</p><p>2、final修饰的方法不能被子类重写</p><p>3、final修饰的类不能被继承。</p><p><strong>this</strong></p><p><code>this.属性名称</code>指访问类中的成员变量，可以用来区分成员变量和局部变量。如下代码所示，<code>this.name</code>访问类Person当前实例的变量。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * @description: * @author: 程序员小官 * @time: 2021-08-17 00:29 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>this.方法名称</code>用来访问本类的方法。以下代码中，<code>this.born()</code>调用类 Person 的当前实例的方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * @description: * @author: 程序员小官 * @time: 2021-08-17 00:29 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">born</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">born</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>super</strong></p><p>super 关键字用于在子类中访问父类的变量和方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">"小官"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"父类:"</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">super</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">B</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        b<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 小官     * 父类:小官     */</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在子类B中，我们重写了父类的<code>getName()</code>方法，如果在重写的<code>getName()</code>方法中我们要调用父类的相同方法，必须要通过super关键字显式指出。</p><h2 id="24-final-finally-finalize-的区别"><a href="#24-final-finally-finalize-的区别" class="headerlink" title="24.final, finally, finalize 的区别"></a>24.final, finally, finalize 的区别</h2><p>final 用于修饰属性、方法和类, 分别表示属性不能被重新赋值，方法不可被覆盖，类不可被继承。</p><p>finally 是异常处理语句结构的一部分，一般以<code>try-catch-finally</code>出现，<code>finally</code>代码块表示总是被执行。</p><p>finalize 是Object类的一个方法，该方法一般由垃圾回收器来调用，当我们调用<code>System.gc()</code>方法的时候，由垃圾回收器调用<code>finalize()</code>方法，回收垃圾，JVM并不保证此方法总被调用。</p><h2 id="25-final关键字的作用？"><a href="#25-final关键字的作用？" class="headerlink" title="25.final关键字的作用？"></a>25.final关键字的作用？</h2><p>final 修饰的类不能被继承。</p><p>final 修饰的方法不能被重写。</p><p>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</p><h2 id="26-方法重载和重写的区别？"><a href="#26-方法重载和重写的区别？" class="headerlink" title="26.方法重载和重写的区别？"></a>26.方法重载和重写的区别？</h2><p><strong>同个类中的多个方法可以有相同的方法名称，但是有不同的参数列表，这就称为方法重载。</strong>参数列表又叫参数签名，包括参数的类型、参数的个数、参数的顺序，只要有一个不同就叫做参数列表不同。</p><p>重载是面向对象的一个基本特性。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OverrideTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">setPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span>        <span class="token keyword">void</span> <span class="token function">setPerson</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//set name</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">void</span> <span class="token function">setPerson</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//set name and age</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>方法的重写描述的是父类和子类之间的。当父类的功能无法满足子类的需求，可以在子类对方法进行重写。</strong>方法重写时， 方法名与形参列表必须一致。</p><p>如下代码，Person为父类，Student为子类，在Student中重写了dailyTask方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dailyTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"work eat sleep"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dailyTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"study eat sleep"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="27-接口与抽象类区别？"><a href="#27-接口与抽象类区别？" class="headerlink" title="27.接口与抽象类区别？"></a>27.接口与抽象类区别？</h2><p>1、<strong>语法层面</strong>上的区别</p><ul><li><p>抽象类可以有方法实现，而接口的方法中只能是抽象方法（Java 8 开始接口方法可以有默认实现）；</p></li><li><p>抽象类中的成员变量可以是各种类型的，接口中的成员变量只能是public static final类型；</p></li><li><p>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</p></li><li><p>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p></li></ul><p>2、<strong>设计层面</strong>上的区别</p><ul><li><p>抽象层次不同。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口只是对类行为进行抽象。继承抽象类是一种”是不是”的关系，而接口实现则是 “有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是具备不具备的关系，比如鸟是否能飞。</p></li><li><p>继承抽象类的是具有相似特点的类，而实现接口的却可以不同的类。</p></li></ul><p>门和警报的例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">AlarmDoor</span> <span class="token keyword">extends</span> <span class="token class-name">Door</span> <span class="token keyword">implements</span> <span class="token class-name">Alarm</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//code</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">BMWCar</span> <span class="token keyword">extends</span> <span class="token class-name">Car</span> <span class="token keyword">implements</span> <span class="token class-name">Alarm</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//code</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="28-常见的Exception有哪些？"><a href="#28-常见的Exception有哪些？" class="headerlink" title="28.常见的Exception有哪些？"></a>28.常见的Exception有哪些？</h2><p><strong>常见的RuntimeException</strong>：</p><p>1、<code>ClassCastException</code> &#x2F;&#x2F;类型转换异常</p><p>2、<code>IndexOutOfBoundsException</code> &#x2F;&#x2F;数组越界异常</p><p>3、<code>NullPointerException</code> &#x2F;&#x2F;空指针</p><p>4、<code>ArrayStoreException</code> &#x2F;&#x2F;数组存储异常</p><p>5、<code>NumberFormatException</code> &#x2F;&#x2F;数字格式化异常</p><p>6、<code>ArithmeticException</code> &#x2F;&#x2F;数学运算异常</p><p><strong>unchecked Exception</strong>：</p><p>1、<code>NoSuchFieldException</code> &#x2F;&#x2F;反射异常，没有对应的字段</p><p>2、<code>ClassNotFoundException</code> &#x2F;&#x2F;类没有找到异常</p><p>3、<code>IllegalAccessException</code> &#x2F;&#x2F;安全权限异常，可能是反射时调用了private方法</p><h2 id="29-Error和Exception的区别？"><a href="#29-Error和Exception的区别？" class="headerlink" title="29.Error和Exception的区别？"></a>29.Error和Exception的区别？</h2><p><strong>Error</strong>：JVM 无法解决的严重问题，如栈溢出<code>StackOverflowError</code>、内存溢出<code>OOM</code>等。程序无法处理的错误。</p><p><strong>Exception</strong>：其它因编程错误或偶然的外在因素导致的一般性问题。可以在代码中进行处理。如：空指针异常、数组下标越界等。</p><h2 id="30-运行时异常和非运行时异常（checked）的区别？"><a href="#30-运行时异常和非运行时异常（checked）的区别？" class="headerlink" title="30.运行时异常和非运行时异常（checked）的区别？"></a>30.运行时异常和非运行时异常（checked）的区别？</h2><p><code>unchecked exception</code>包括<code>RuntimeException</code>和<code>Error</code>类，其他所有异常称为检查（checked）异常。</p><ol><li><p><code>RuntimeException</code>由程序错误导致，应该修正程序避免这类异常发生。</p></li><li><p><code>checked Exception</code>由具体的环境（读取的文件不存在或文件为空或sql异常）导致的异常。必须进行处理，不然编译不通过，可以catch或者throws。</p></li></ol><h2 id="31-throw和throws的区别？"><a href="#31-throw和throws的区别？" class="headerlink" title="31.throw和throws的区别？"></a>31.throw和throws的区别？</h2><p><strong>throw</strong>：用于抛出一个具体的异常对象。</p><p><strong>throws</strong>：用在方法签名中，用于声明该方法可能抛出的异常。子类方法抛出的异常范围更加小，或者根本不抛异常。</p><h2 id="32-通过故事讲清楚NIO"><a href="#32-通过故事讲清楚NIO" class="headerlink" title="32.通过故事讲清楚NIO"></a>32.通过故事讲清楚NIO</h2><p>下面通过一个例子来讲解下。</p><p>假设某银行只有10个职员。该银行的业务流程分为以下4个步骤：</p><p>1） 顾客填申请表（5分钟）；</p><p>2） 职员审核（1分钟）；</p><p>3） 职员叫保安去金库取钱（3分钟）；</p><p>4） 职员打印票据，并将钱和票据返回给顾客（1分钟）。</p><p>下面我们看看银行不同的工作方式对其工作效率到底有何影响。</p><p>首先是BIO方式。</p><p>每来一个顾客，马上由一位职员来接待处理，并且这个职员需要负责以上4个完整流程。当超过10个顾客时，剩余的顾客需要排队等候。</p><p>一个职员处理一个顾客需要10分钟（5+1+3+1）时间。一个小时（60分钟）能处理6个顾客，一共10个职员，那就是只能处理60个顾客。</p><p>可以看到银行职员的工作状态并不饱和，比如在第1步，其实是处于等待中。</p><p>这种工作其实就是BIO，每次来一个请求（顾客），就分配到线程池中由一个线程（职员）处理，如果超出了线程池的最大上限（10个），就扔到队列等待 。</p><p>那么如何提高银行的吞吐量呢？</p><p>思路就是：<strong>分而治之</strong>，将任务拆分开来，由专门的人负责专门的任务。</p><p>具体来讲，银行专门指派一名职员A，A的工作就是每当有顾客到银行，他就递上表格让顾客填写。每当有顾客填好表后，A就将其随机指派给剩余的9名职员完成后续步骤。</p><p>这种方式下，假设顾客非常多，职员A的工作处于饱和中，他不断的将填好表的顾客带到柜台处理。</p><p>柜台一个职员5分钟能处理完一个顾客，一个小时9名职员能处理：9*（60&#x2F;5）&#x3D;108。</p><p>可见工作方式的转变能带来效率的极大提升。</p><p>这种工作方式其实就NIO的思路。</p><p>下图是非常经典的NIO说明图，<code>mainReactor</code>线程负责监听server socket，接收新连接，并将建立的socket分派给<code>subReactor</code></p><p><code>subReactor</code>可以是一个线程，也可以是线程池，负责多路分离已连接的socket，读写网络数据。这里的读写网络数据可类比顾客填表这一耗时动作，对具体的业务处理功能，其扔给worker线程池完成</p><p>可以看到典型NIO有三类线程，分别是<code>mainReactor</code>线程、<code>subReactor</code>线程、<code>work</code>线程。</p><p>不同的线程干专业的事情，最终每个线程都没空着，系统的吞吐量自然就上去了。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BJava%E5%9F%BA%E7%A1%80%E7%AF%87.assets/1676356829100-94d92ec1-934b-4b5c-8403-8a3ec43089f4.png" alt="img"></p><p><strong>那这个流程还有没有什么可以提高的地方呢？</strong></p><p>可以看到，在这个业务流程里边第3个步骤，职员叫保安去金库取钱（3分钟）。这3分钟柜台职员是在等待中度过的，可以把这3分钟利用起来。</p><p>还是分而治之的思路，指派1个职员B来专门负责第3步骤。</p><p>每当柜台员工完成第2步时，就通知职员B来负责与保安沟通取钱。这时候柜台员工可以继续处理下一个顾客。</p><p>当职员B拿到钱之后，通知顾客钱已经到柜台了，让顾客重新排队处理，当柜台职员再次服务该顾客时，发现该顾客前3步已经完成，直接执行第4步即可。</p><p>在当今web服务中，经常需要通过RPC或者Http等方式调用第三方服务，这里对应的就是第3步，如果这步耗时较长，通过异步方式将能极大降低资源使用率。</p><p>NIO+异步的方式能让少量的线程做大量的事情。这适用于很多应用场景，比如代理服务、api服务、长连接服务等等。这些应用如果用同步方式将耗费大量机器资源。</p><p>不过虽然NIO+异步能提高系统吞吐量，但其并不能让一个请求的等待时间下降，相反可能会增加等待时间。</p><p>最后，NIO基本思想总结起来就是：<strong>分而治之，将任务拆分开来，由专门的人负责专门的任务</strong></p><h2 id="33-BIO-x2F-NIO-x2F-AIO区别的区别？"><a href="#33-BIO-x2F-NIO-x2F-AIO区别的区别？" class="headerlink" title="33.BIO&#x2F;NIO&#x2F;AIO区别的区别？"></a>33.BIO&#x2F;NIO&#x2F;AIO区别的区别？</h2><p><strong>同步阻塞IO</strong> : 用户进程发起一个IO操作以后，必须等待IO操作的真正完成后，才能继续运行。</p><p><strong>同步非阻塞IO</strong>: 客户端与服务器通过Channel连接，采用多路复用器轮询注册的<code>Channel</code>。提高吞吐量和可靠性。用户进程发起一个IO操作以后，可做其它事情，但用户进程需要轮询IO操作是否完成，这样造成不必要的CPU资源浪费。</p><p><strong>异步非阻塞IO</strong>: 非阻塞异步通信模式，NIO的升级版，采用异步通道实现异步通信，其read和write方法均是异步方法。用户进程发起一个IO操作，然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知。类似Future模式。</p><h2 id="34-守护线程是什么？"><a href="#34-守护线程是什么？" class="headerlink" title="34.守护线程是什么？"></a>34.守护线程是什么？</h2><p>守护线程是运行在后台的一种特殊进程。</p><p>它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。</p><p>在 Java 中垃圾回收线程就是特殊的守护线程。</p><h2 id="35-Java支持多继承吗？"><a href="#35-Java支持多继承吗？" class="headerlink" title="35.Java支持多继承吗？"></a>35.Java支持多继承吗？</h2><p>java中，<strong>类不支持</strong>多继承。<strong>接口才支持</strong>多继承。接口的作用是拓展对象功能。当一个子接口继承了多个父接口时，说明子接口拓展了多个功能。当一个类实现该接口时，就拓展了多个的功能。</p><p>Java不支持多继承的原因：</p><ul><li><p>出于安全性的考虑，如果子类继承的多个父类里面有相同的方法或者属性，子类将不知道具体要继承哪个。</p></li><li><p>Java提供了接口和内部类以达到实现多继承功能，弥补单继承的缺陷。</p></li></ul><h2 id="36-如何实现对象克隆？"><a href="#36-如何实现对象克隆？" class="headerlink" title="36.如何实现对象克隆？"></a>36.如何实现对象克隆？</h2><p>实现<code>Cloneable</code>接口，重写 <code>clone()</code> 方法。这种方式是浅拷贝，即如果类中属性有自定义引用类型，只拷贝引用，不拷贝引用指向的对象。如果对象的属性的Class也实现 <code>Cloneable</code> 接口，那么在克隆对象时也会克隆属性，即深拷贝。</p><p>结合序列化，深拷贝。</p><p>通过<code>org.apache.commons</code>中的工具类<code>BeanUtils</code>和<code>PropertyUtils</code>进行对象复制。</p><h2 id="37-同步和异步的区别？"><a href="#37-同步和异步的区别？" class="headerlink" title="37.同步和异步的区别？"></a>37.同步和异步的区别？</h2><p>同步：发出一个调用时，在没有得到结果之前，该调用就不返回。</p><p>异步：在调用发出后，被调用者返回结果之后会通知调用者，或通过回调函数处理这个调用。</p><h2 id="38-阻塞和非阻塞的区别？"><a href="#38-阻塞和非阻塞的区别？" class="headerlink" title="38.阻塞和非阻塞的区别？"></a>38.阻塞和非阻塞的区别？</h2><p>阻塞和非阻塞关注的是线程的状态。</p><p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会恢复运行。</p><p>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p><p>举个例子，理解下同步、阻塞、异步、非阻塞的区别：</p><p>同步就是烧开水，要自己来看开没开；异步就是水开了，然后水壶响了通知你水开了（回调通知）。阻塞是烧开水的过程中，你不能干其他事情，必须在旁边等着；非阻塞是烧开水的过程里可以干其他事情。</p><h2 id="39-Java8的新特性有哪些？"><a href="#39-Java8的新特性有哪些？" class="headerlink" title="39.Java8的新特性有哪些？"></a>39.Java8的新特性有哪些？</h2><p>Lambda 表达式：Lambda允许把函数作为一个方法的参数</p><p>Stream API ：新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中</p><p>默认方法：默认方法就是一个在接口里面有了一个实现的方法。</p><p>Optional 类 ：Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</p><p>Date Time API ：加强对日期与时间的处理。</p><h2 id="40-什么是序列化和反序列化？"><a href="#40-什么是序列化和反序列化？" class="headerlink" title="40.什么是序列化和反序列化？"></a>40.什么是序列化和反序列化？</h2><p>序列化：把内存中的对象转换为字节序列的过程。</p><p>反序列化：把字节序列恢复为Java对象的过程。</p><h2 id="41-如何实现序列化"><a href="#41-如何实现序列化" class="headerlink" title="41.如何实现序列化"></a>41.如何实现序列化</h2><p>实现<code>Serializable</code>接口即可。序列化的时候（如<code>objectOutputStream.writeObject(user)</code>），会判断user是否实现了<code>Serializable</code>，如果对象没有实现<code>Serializable</code>接口，在序列化的时候会抛出<code>NotSerializableException</code>异常。源码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// remaining cases</span><span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">writeString</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> obj<span class="token punctuation">,</span> unshared<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cl<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">writeArray</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> desc<span class="token punctuation">,</span> unshared<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Enum</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">writeEnum</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Enum</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">)</span> obj<span class="token punctuation">,</span> desc<span class="token punctuation">,</span> unshared<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Serializable</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">writeOrdinaryObject</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> desc<span class="token punctuation">,</span> unshared<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>extendedDebugInfo<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NotSerializableException</span><span class="token punctuation">(</span>            cl<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span> <span class="token operator">+</span> debugInfoStack<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NotSerializableException</span><span class="token punctuation">(</span>cl<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="42-transient关键字的作用？"><a href="#42-transient关键字的作用？" class="headerlink" title="42.transient关键字的作用？"></a>42.transient关键字的作用？</h2><p>Java语言的关键字，变量修饰符，如果用transient声明一个实例变量，当对象存储时，它的值不需要维持。</p><p>也就是说被transient修饰的成员变量，在序列化的时候其值会被忽略，在被反序列化后， transient 变量的值被设为初始值， 如 int 型的是 0，对象型的是 null。</p><h2 id="43-什么是反射？"><a href="#43-什么是反射？" class="headerlink" title="43.什么是反射？"></a>43.什么是反射？</h2><p>动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。</p><p>在运行状态中，对于任意一个类，能够知道这个类的所有属性和方法。对于任意一个对象，能够调用它的任意一个方法和属性。</p><h2 id="44-反射有哪些应用场景呢？"><a href="#44-反射有哪些应用场景呢？" class="headerlink" title="44.反射有哪些应用场景呢？"></a>44.反射有哪些应用场景呢？</h2><p>1、JDBC连接数据库时使用<code>Class.forName()</code>通过反射加载数据库的驱动程序</p><p>2、Eclispe、IDEA等开发工具利用反射动态解析对象的类型与结构，动态提示对象的属性和方法</p><p>3、Web服务器中利用反射调用了Sevlet的<code>service</code>方法</p><p>4、JDK动态代理底层依赖反射实现</p><h2 id="45-讲讲什么是泛型？"><a href="#45-讲讲什么是泛型？" class="headerlink" title="45.讲讲什么是泛型？"></a>45.讲讲什么是泛型？</h2><p>Java泛型是JDK 5中引⼊的⼀个新特性， 允许在定义类和接口的时候使⽤类型参数。声明的类型参数在使⽤时⽤具体的类型来替换。</p><p>泛型最⼤的好处是可以提⾼代码的复⽤性。以List接口为例，我们可以将String、 Integer等类型放⼊List中， 如不⽤泛型， 存放String类型要写⼀个List接口， 存放Integer要写另外⼀个List接口， 泛型可以很好的解决这个问题。</p><h2 id="46-String为什么不可变？"><a href="#46-String为什么不可变？" class="headerlink" title="46.String为什么不可变？"></a>46.String为什么不可变？</h2><p>先看看什么是不可变的对象。</p><p>如果一个对象，在它创建完成之后，不能再改变它的状态，那么这个对象就是不可变的。</p><p>不能改变状态的意思是，不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。</p><p>接着来看Java8 String类的源码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span>    <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">,</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">,</span> <span class="token class-name">CharSequence</span> <span class="token punctuation">&#123;</span>    <span class="token operator">/</span> <span class="token class-name">The</span> value is used <span class="token keyword">for</span> character storage<span class="token punctuation">.</span> <span class="token operator">*</span><span class="token operator">/</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token operator">/</span> <span class="token class-name">Cache</span> the hash code <span class="token keyword">for</span> the string <span class="token operator">*</span><span class="token operator">/</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span> <span class="token comment">// Default to 0</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从源码可以看出，String对象其实在内部就是一个个字符，存储在这个value数组里面的。</p><p>value数组用final修饰，final 修饰的变量，值不能被修改。因此value不可以指向其他对象。</p><p>String类内部所有的字段都是私有的，也就是被private修饰。而且String没有对外提供修改内部状态的方法，因此value数组不能改变。</p><p>所以，String是不可变的。</p><p>那为什么String要设计成不可变的？</p><p>主要有以下几点原因：</p><p>1、线程安全。同一个字符串实例可以被多个线程共享，因为字符串不可变，本身就是线程安全的。</p><p>2、支持hash映射和缓存。因为String的hash值经常会使用到，比如作为 Map 的键，不可变的特性使得 hash 值也不会变，不需要重新计算。</p><p>3、出于安全考虑。网络地址URL、文件路径path、密码通常情况下都是以String类型保存，假若String不是固定不变的，将会引起各种安全隐患。比如将密码用String的类型保存，那么它将一直留在内存中，直到垃圾收集器把它清除。假如String类不是固定不变的，那么这个密码可能会被改变，导致出现安全隐患。</p><p>4、字符串常量池优化。String对象创建之后，会缓存到字符串常量池中，下次需要创建同样的对象时，可以直接返回缓存的引用。</p><p>既然我们的String是不可变的，那它内部还有很多substring， replace， replaceAll这些操作的方法。</p><p>这些方法好像会改变String对象？怎么解释呢？</p><p>其实不是的，我们每次调用replace等方法，其实会在堆内存中创建了一个新的对象。然后其value数组引用指向不同的对象。</p><h2 id="47-如何停止一个正在运行的线程？"><a href="#47-如何停止一个正在运行的线程？" class="headerlink" title="47.如何停止一个正在运行的线程？"></a>47.如何停止一个正在运行的线程？</h2><p>有几种方式。</p><p>1、<strong>使用线程的stop方法</strong>。</p><p>使用stop()方法可以强制终止线程。不过stop是一个被废弃掉的方法，不推荐使用。</p><p>使用Stop方法，会一直向上传播ThreadDeath异常，从而使得目标线程解锁所有锁住的监视器，即释放掉所有的对象锁。使得之前被锁住的对象得不到同步的处理，因此可能会造成数据不一致的问题。</p><p>2、<strong>使用interrupt方法中断线程</strong>，该方法只是告诉线程要终止，但最终何时终止取决于计算机。调用interrupt方法仅仅是在当前线程中打了一个停止的标记，并不是真的停止线程。</p><p>接着调用 Thread.currentThread().isInterrupted()方法，可以用来判断当前线程是否被终止，通过这个判断我们可以做一些业务逻辑处理，通常如果isInterrupted返回true的话，会抛一个中断异常，然后通过try-catch捕获。</p><p>3、<strong>设置标志位</strong></p><p>设置标志位，当标识位为某个值时，使线程正常退出。设置标志位是用到了共享变量的方式，为了保证共享变量在内存中的可见性，可以使用volatile修饰它，这样的话，变量取值始终会从主存中获取最新值。</p><p>但是这种volatile标记共享变量的方式，在线程发生阻塞时是无法完成响应的。比如调用Thread.sleep() 方法之后，线程处于不可运行状态，即便是主线程修改了共享变量的值，该线程此时根本无法检查循环标志，所以也就无法实现线程中断。</p><p>因此，interrupt() 加上手动抛异常的方式是目前中断一个正在运行的线程<strong>最为正确</strong>的方式了。</p><h2 id="48-什么是跨域？"><a href="#48-什么是跨域？" class="headerlink" title="48.什么是跨域？"></a>48.什么是跨域？</h2><p>简单来讲，跨域是指从一个域名的网页去请求另一个域名的资源。由于有<strong>同源策略</strong>的关系，一般是不允许这么直接访问的。但是，很多场景经常会有跨域访问的需求，比如，在前后端分离的模式下，前后端的域名是不一致的，此时就会发生跨域问题。</p><p><strong>那什么是同源策略呢</strong>？</p><p>所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p><p>同源策略限制以下几种行为：</p><pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">1. Cookie、LocalStorage 和 IndexDB 无法读取2. DOM 和 Js对象无法获得3. AJAX 请求不能发送<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>为什么要有同源策略</strong>？</p><p>举个例子，假如你刚刚在网银输入账号密码，查看了自己的余额，然后再去访问其他带颜色的网站，这个网站可以访问刚刚的网银站点，并且获取账号密码，那后果可想而知。因此，从安全的角度来讲，同源策略是有利于保护网站信息的。</p><h2 id="49-跨域问题怎么解决呢？"><a href="#49-跨域问题怎么解决呢？" class="headerlink" title="49.跨域问题怎么解决呢？"></a>49.跨域问题怎么解决呢？</h2><p>嗯，有以下几种方法：</p><p><strong>CORS</strong>，跨域资源共享</p><p>CORS（Cross-origin resource sharing），跨域资源共享。CORS 其实是浏览器制定的一个规范，浏览器会自动进行 CORS 通信，它的实现主要在服务端，通过一些 HTTP Header 来限制可以访问的域，例如页面 A 需要访问 B 服务器上的数据，如果 B 服务器 上声明了允许 A 的域名访问，那么从 A 到 B 的跨域请求就可以完成。</p><p><strong>@CrossOrigin注解</strong></p><p>如果项目使用的是Springboot，可以在Controller类上添加一个 <a href="">@CrossOrigin(origins </a> &#x3D;”*”) 注解就可以实现对当前controller 的跨域访问了，当然这个标签也可以加到方法上，或者直接加到入口类上对所有接口进行跨域处理。注意SpringMVC的版本要在4.2或以上版本才支持@CrossOrigin。 </p><p><strong>nginx反向代理接口跨域</strong></p><p>nginx反向代理跨域原理如下： 首先同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。</p><p>nginx反向代理接口跨域实现思路如下：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// proxy服务器</span>server <span class="token punctuation">&#123;</span>    listen       <span class="token number">81</span><span class="token punctuation">;</span>    server_name  www<span class="token punctuation">.</span>domain1<span class="token punctuation">.</span>com<span class="token punctuation">;</span>    location <span class="token operator">/</span> <span class="token punctuation">&#123;</span>        proxy_pass   http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>domain2<span class="token punctuation">.</span>com<span class="token operator">:</span><span class="token number">8080</span><span class="token punctuation">;</span>  #反向代理        proxy_cookie_domain www<span class="token punctuation">.</span>domain2<span class="token punctuation">.</span>com www<span class="token punctuation">.</span>domain1<span class="token punctuation">.</span>com<span class="token punctuation">;</span> #修改cookie里域名        index  index<span class="token punctuation">.</span>html index<span class="token punctuation">.</span>htm<span class="token punctuation">;</span>                add_header Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Origin http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>domain1<span class="token punctuation">.</span>com<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样我们的前端代理只要访问 http:<a href="http://www.domain1.com:81/*%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BA%86%E3%80%82">www.domain1.com:81/*就可以了。</a></p><p><strong>通过jsonp跨域</strong></p><p>通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，这是浏览器允许的操作，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-Java的特点&quot;&gt;&lt;a href=&quot;#1-Java的特点&quot; class=&quot;headerlink&quot; title=&quot;1.Java的特点&quot;&gt;&lt;/a&gt;1.Java的特点&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Java是一门面向对象的编程语言&lt;/strong&gt;。面向对象和面向过</summary>
      
    
    
    
    <category term="PROJECT" scheme="https://zspcer.gitee.io/categories/PROJECT/"/>
    
    <category term="我要进大厂" scheme="https://zspcer.gitee.io/categories/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/"/>
    
    
    <category term="面试" scheme="https://zspcer.gitee.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="我要进大厂" scheme="https://zspcer.gitee.io/tags/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/"/>
    
    <category term="Java基础" scheme="https://zspcer.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>大厂面试之Mybatis篇</title>
    <link href="https://zspcer.gitee.io/note/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BMybatis%E7%AF%87/"/>
    <id>https://zspcer.gitee.io/note/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BMybatis%E7%AF%87/</id>
    <published>2023-05-11T16:37:37.000Z</published>
    <updated>2023-05-11T15:42:17.139Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-说说什么是MyBatis"><a href="#1-说说什么是MyBatis" class="headerlink" title="1.说说什么是MyBatis?"></a>1.说说什么是MyBatis?</h2><p>Mybatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开发时只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制 sql 执行性能，灵活度高。</p><p>MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO 映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p><p><strong>再说一下缺点</strong></p><p>SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求</p><p>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库</p><p><strong>ORM是什么?</strong></p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BMybatis%E7%AF%87.assets/1676357342716-3056ec46-4f52-4fc3-b582-d792227d1d5b.png" alt="img"></p><p>ORM（Object Relational Mapping），对象关系映射，是一种为了解决关系型数据库数据与简单Java对象（POJO）的映射关系的技术。简单来说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系型数据库中。</p><p><strong>为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</strong></p><p>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。</p><p>而Mybatis在查询关联对象或关联集合对象时，需要手动编写SQL来完成，所以，被称之为半自动ORM映射工具。</p><p><strong>JDBC编程有哪些不足之处，MyBatis是如何解决的？</strong></p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BMybatis%E7%AF%87.assets/1676357344652-277b3cb6-ead5-4a19-91f8-b8b80752d58c.png" alt="img"></p><p>JDBC编程的不足</p><p>1、数据连接创建、释放频繁造成系统资源浪费从而影响系统性能</p><ul><li>解决：在mybatis-config.xml中配置数据链接池，使用连接池统一管理数据库连接。</li></ul><p>2、sql语句写在代码中造成代码不易维护</p><ul><li>解决：将sql语句配置在XXXXmapper.xml文件中与java代码分离。</li></ul><p>3、向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。</p><ul><li>解决：Mybatis自动将java对象映射至sql语句。</li></ul><p>4、对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。</p><ul><li>解决：Mybatis自动将sql执行结果映射至java对象。</li></ul><h2 id="2-Hibernate-和-MyBatis-有什么区别？"><a href="#2-Hibernate-和-MyBatis-有什么区别？" class="headerlink" title="2.Hibernate 和 MyBatis 有什么区别？"></a>2.Hibernate 和 MyBatis 有什么区别？</h2><p>PS:直接用Hibernate的应该不多了吧，毕竟大家都是“敏捷开发”，但架不住面试爱问。</p><p><strong>相同点</strong></p><p>都是对jdbc的封装，都是应用于持久层的框架。</p><p><strong>不同点</strong></p><p>映射关系</p><ul><li><p>MyBatis 是一个半自动映射的框架，配置Java对象与sql语句执行结果的对应关系，多表关联关系配置简单</p></li><li><p>Hibernate 是一个全表映射的框架，配置Java对象与数据库表的对应关系，多表关联关系配置复杂</p></li></ul><p><strong>SQL优化和移植性</strong></p><ul><li><p>Hibernate 对SQL语句封装，提供了日志、缓存、级联（级联比 MyBatis 强大）等特性，此外还提供 HQL（Hibernate Query Language）操作数据库，数据库无关性支持好，但会多消耗性能。如果项目需要支持多种数据库，代码开发量少，但SQL语句优化困难。</p></li><li><p>MyBatis 需要手动编写 SQL，支持动态 SQL、处理列表、动态生成表名、支持存储过程。开发工作量相对大些。直接使用SQL语句操作数据库，不支持数据库无关性，但sql语句优化容易。</p></li></ul><p><strong>MyBatis和Hibernate的适用场景?</strong></p><p>Hibernate 是标准的ORM框架，SQL编写量较少，但不够灵活，适合于需求相对稳定，中小型的软件项目，比如：办公自动化系统</p><p>MyBatis 是半ORM框架，需要编写较多SQL，但是比较灵活，适合于需求变化频繁，快速迭代的项目，比如：电商网站</p><h2 id="3-MyBatis使用过程？生命周期？"><a href="#3-MyBatis使用过程？生命周期？" class="headerlink" title="3.MyBatis使用过程？生命周期？"></a>3.MyBatis使用过程？生命周期？</h2><p>MyBatis基本使用的过程大概可以分为这么几步：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BMybatis%E7%AF%87.assets/1676357347708-cdbed4ee-d6d9-4a1c-a351-7207ee3a6c04.png" alt="img"></p><p>使用步骤</p><p>1、 创建SqlSessionFactory，可以从配置或者直接编码来创建SqlSessionFactory</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> resource <span class="token operator">=</span> <span class="token string">"org/mybatis/example/mybatis-config.xml"</span><span class="token punctuation">;</span><span class="token class-name">InputStream</span> inputStream <span class="token operator">=</span> <span class="token class-name">Resources</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span>resource<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">SqlSessionFactory</span> sqlSessionFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2、 通过SqlSessionFactory创建SqlSession，SqlSession（会话）可以理解为程序和数据库之间的桥梁</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">SqlSession</span> session <span class="token operator">=</span> sqlSessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、 通过sqlsession执行数据库操作，可以通过 SqlSession 实例来直接执行已映射的 SQL 语句：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Blog</span> blog <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Blog</span><span class="token punctuation">)</span>session<span class="token punctuation">.</span><span class="token function">selectOne</span><span class="token punctuation">(</span><span class="token string">"org.mybatis.example.BlogMapper.selectBlog"</span><span class="token punctuation">,</span> <span class="token number">101</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>更常用的方式是先获取Mapper(映射)，然后再执行SQL语句：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">BlogMapper</span> mapper <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span><span class="token class-name">BlogMapper</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Blog</span> blog <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">selectBlog</span><span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>4、 调用session.commit()提交事务；如果是更新、删除语句，我们还需要提交一下事务。</p><p>5、 调用session.close()关闭会话，最后一定要记得关闭会话。</p><p><strong>MyBatis生命周期？</strong></p><p>上面提到了几个MyBatis的组件，一般说的MyBatis生命周期就是这些组件的生命周期。</p><p>SqlSessionFactoryBuilder：一旦创建了 SqlSessionFactory，就不再需要它了。因此 SqlSessionFactoryBuilder 实例的生命周期只存在于方法的内部。</p><p>SqlSessionFactory：SqlSessionFactory 是用来创建SqlSession的，相当于一个数据库连接池，每次创建SqlSessionFactory都会使用数据库资源，多次创建和销毁是对资源的浪费。所以SqlSessionFactory是应用级的生命周期，而且应该是单例的。</p><p>SqlSession：SqlSession相当于JDBC中的Connection，SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的生命周期是一次请求或一个方法。</p><p>Mapper：映射器是一些绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的，它的生命周期在sqlsession事务方法之内，一般会控制在方法级。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BMybatis%E7%AF%87.assets/1676357350234-ce33711c-227a-49a2-bce5-fd7bd89b570d.png" alt="img"></p><p>当然，万物皆可集成Spring，MyBatis通常也是和Spring集成使用，Spring可以帮助我们创建线程安全的、基于事务的 SqlSession 和映射器，并将它们直接注入到我们的 bean 中，我们不需要关心它们的创建过程和生命周期，那就是另外的故事了。</p><h2 id="4-在mapper中如何传递多个参数？"><a href="#4-在mapper中如何传递多个参数？" class="headerlink" title="4.在mapper中如何传递多个参数？"></a>4.在mapper中如何传递多个参数？</h2><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BMybatis%E7%AF%87.assets/1676357352583-7a8662c3-6a95-4e8a-8bc9-7bf18c469aca.png" alt="img"></p><p><strong>方法1：顺序传参法</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">selectUser</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> deptId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span>select id<span class="token operator">=</span><span class="token string">"selectUser"</span> resultMap<span class="token operator">=</span><span class="token string">"UserResultMap"</span><span class="token operator">></span>    select <span class="token operator">*</span> from user    where user_name <span class="token operator">=</span> #<span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span> and dept_id <span class="token operator">=</span> #<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>select<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>#&#123;&#125;</code>里面的数字代表传入参数的顺序。</p><p>这种方法不建议使用，sql层表达不直观，且一旦顺序调整容易出错。</p><p><strong>方法2：@Param注解传参法</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">selectUser</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"userName"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"deptId"</span><span class="token punctuation">)</span> deptId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span>select id<span class="token operator">=</span><span class="token string">"selectUser"</span> resultMap<span class="token operator">=</span><span class="token string">"UserResultMap"</span><span class="token operator">></span>    select <span class="token operator">*</span> from user    where user_name <span class="token operator">=</span> #<span class="token punctuation">&#123;</span>userName<span class="token punctuation">&#125;</span> and dept_id <span class="token operator">=</span> #<span class="token punctuation">&#123;</span>deptId<span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>select<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>#&#123;&#125;</code>里面的名称对应的是注解@Param括号里面修饰的名称。</p><p>这种方法在参数不多的情况还是比较直观的，（推荐使用）。</p><p><strong>方法3：Map传参法</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">selectUser</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> params<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span>select id<span class="token operator">=</span><span class="token string">"selectUser"</span> parameterType<span class="token operator">=</span><span class="token string">"java.util.Map"</span> resultMap<span class="token operator">=</span><span class="token string">"UserResultMap"</span><span class="token operator">></span>    select <span class="token operator">*</span> from user    where user_name <span class="token operator">=</span> #<span class="token punctuation">&#123;</span>userName<span class="token punctuation">&#125;</span> and dept_id <span class="token operator">=</span> #<span class="token punctuation">&#123;</span>deptId<span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>select<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>#&#123;&#125;</code>里面的名称对应的是Map里面的key名称。</p><p>这种方法适合传递多个参数，且参数易变能灵活传递的情况。</p><p><strong>方法4：Java Bean传参法</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">selectUser</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span>select id<span class="token operator">=</span><span class="token string">"selectUser"</span> parameterType<span class="token operator">=</span><span class="token string">"com.jourwon.pojo.User"</span> resultMap<span class="token operator">=</span><span class="token string">"UserResultMap"</span><span class="token operator">></span>    select <span class="token operator">*</span> from user    where user_name <span class="token operator">=</span> #<span class="token punctuation">&#123;</span>userName<span class="token punctuation">&#125;</span> and dept_id <span class="token operator">=</span> #<span class="token punctuation">&#123;</span>deptId<span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>select<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>#&#123;&#125;</code>里面的名称对应的是User类里面的成员属性。</p><p>这种方法直观，需要建一个实体类，扩展不容易，需要加属性，但代码可读性强，业务逻辑处理方便，推荐使用。（推荐使用）。</p><h2 id="5-实体类属性名和表中字段名不一样-，怎么办"><a href="#5-实体类属性名和表中字段名不一样-，怎么办" class="headerlink" title="5.实体类属性名和表中字段名不一样 ，怎么办?"></a>5.实体类属性名和表中字段名不一样 ，怎么办?</h2><p>第1种：通过在查询的SQL语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getOrder<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>int<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.jourwon.pojo.Order<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>       select order_id id, order_no orderno ,order_price price form orders where order_id=#&#123;id&#125;;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>第2种：通过resultMap  中的来映射字段名和实体类属性名的一一对应的关系。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getOrder<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>int<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>orderResultMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> select * from orders where order_id=#&#123;id&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.jourwon.pojo.Order<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>orderResultMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!–用id属性来映射主键字段–</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>order_id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!–用result属性来映射非主键字段，property为实体类属性名，column为数据库表中的属性–</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>orderno<span class="token punctuation">"</span></span> <span class="token attr-name">column</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>order_no<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>price<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>order_price<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>reslutMap</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-Mybatis是否可以映射Enum枚举类？"><a href="#6-Mybatis是否可以映射Enum枚举类？" class="headerlink" title="6.Mybatis是否可以映射Enum枚举类？"></a>6.Mybatis是否可以映射Enum枚举类？</h2><p>Mybatis当然可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。</p><p>TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。</p><h2 id="7-和-的区别"><a href="#7-和-的区别" class="headerlink" title="7.#{}和${}的区别?"></a>7.#{}和${}的区别?</h2><ul><li><p><code>#&#123;&#125;</code>是占位符，预编译处理；<code>$&#123;&#125;</code>是拼接符，字符串替换，没有预编译处理。</p></li><li><p>Mybatis在处理<code>#&#123;&#125;</code>时，<code>#&#123;&#125;</code>传入参数是以字符串传入，会将SQL中的<code>#&#123;&#125;</code>替换为?号，调用PreparedStatement的set方法来赋值。</p></li><li><p><code>#&#123;&#125;</code> 可以有效的防止SQL注入，提高系统安全性；<code>$&#123;&#125;</code> 不能防止SQL 注入</p></li><li><p><code>#&#123;&#125;</code> 的变量替换是在DBMS 中；<code>$&#123;&#125;</code> 的变量替换是在 DBMS 外</p></li></ul><h2 id="8-模糊查询like语句该怎么写"><a href="#8-模糊查询like语句该怎么写" class="headerlink" title="8.模糊查询like语句该怎么写?"></a>8.模糊查询like语句该怎么写?</h2><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BMybatis%E7%AF%87.assets/1676357357394-2529f66c-31e0-40ee-a2ae-8de2ab1c557e.png" alt="img"></p><p>1、 <code>’%$&#123;question&#125;%’</code> 可能引起SQL注入，不推荐</p><p>2、<code>&quot;%&quot;#&#123;question&#125;&quot;%&quot;</code>注意：因为#{…}解析成sql语句时候，会在变量外侧自动加单引号’ ‘，所以这里 % 需要使用双引号” “，不能使用单引号 ’ ‘，不然会查不到任何结果。</p><p>3、 <code>CONCAT(’%’,#&#123;question&#125;,’%’)</code> 使用CONCAT()函数，（推荐✨）</p><p>4、 使用<code>bind</code>标签（不推荐）</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>listUserLikeUsername<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.jourwon.pojo.User<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token entity named-entity" title="&emsp;">&amp;emsp;</span><span class="token entity named-entity" title="&emsp;">&amp;emsp;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bind</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pattern<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">'</span>%' + username + '%'<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token entity named-entity" title="&emsp;">&amp;emsp;</span><span class="token entity named-entity" title="&emsp;">&amp;emsp;</span>select id,sex,age,username,password from person where username LIKE #&#123;pattern&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-Mybatis能执行一对一、一对多的关联查询吗？"><a href="#9-Mybatis能执行一对一、一对多的关联查询吗？" class="headerlink" title="9.Mybatis能执行一对一、一对多的关联查询吗？"></a>9.Mybatis能执行一对一、一对多的关联查询吗？</h2><p>当然可以，不止支持一对一、一对多的关联查询，还支持多对多、多对一的关联查询。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BMybatis%E7%AF%87.assets/1676357359284-434538a4-6424-4527-86f9-afe9977bd2aa.png" alt="img"></p><p><strong>一对一</strong><code>**&lt;association&gt;**</code>：比如订单和支付是一对一的关系，这种关联的实现：</p><p>实体类:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Order</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> orderId<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> orderDesc<span class="token punctuation">;</span>    <span class="token comment">/**     * 支付对象     */</span>    <span class="token keyword">private</span> <span class="token class-name">Pay</span> pay<span class="token punctuation">;</span>    <span class="token comment">//……</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果映射</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 订单resultMap --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>peopleResultMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cn.fighter3.entity.Order<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>orderId<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>order_id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>orderDesc<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>order_desc<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token comment">&lt;!--一对一结果映射--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>association</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pay<span class="token punctuation">"</span></span> <span class="token attr-name">javaType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cn.fighter3.entity.Pay<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>payId<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pay_id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>account<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>account<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>association</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查询就是普通的关联查</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getTeacher<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getTeacherMap<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>int<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    select * from order o      left join pay p on o.order_id=p.order_id    where  o.order_id=#&#123;orderId&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>一对多</strong>：比如商品分类和商品，是一对多的关系。</p><p>查询就是一个普通的关联查询</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 关联查询分类和产品表 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>listCategory<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>categoryBean<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    select c.*, p.* from category_ c left join product_ p on c.id = p.cid<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>实体类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Category</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> categoryId<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> categoryName<span class="token punctuation">;</span>      <span class="token comment">/**    * 商品列表    **/</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Product</span><span class="token punctuation">></span></span> products<span class="token punctuation">;</span>    <span class="token comment">//……</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果映射</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Category<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>categoryBean<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>categoryId<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>category_id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>categoryName<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>category_name<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>         <span class="token comment">&lt;!-- 一对多的关系 --></span>    <span class="token comment">&lt;!-- property: 指的是集合属性的值, ofType：指的是集合中元素的类型 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>collection</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>products<span class="token punctuation">"</span></span> <span class="token attr-name">ofType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Product<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>product_id<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>productId<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>productName<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>productName<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>price<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>price<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>collection</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么多对一、多对多怎么实现呢？还是利用和，篇幅所限，这里就不展开了。</p><h2 id="10-Mybatis是否支持延迟加载？原理？"><a href="#10-Mybatis是否支持延迟加载？原理？" class="headerlink" title="10.Mybatis是否支持延迟加载？原理？"></a>10.Mybatis是否支持延迟加载？原理？</h2><p>Mybatis支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled&#x3D;true|false。</p><p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p><p>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p><h2 id="11-如何获取生成的主键"><a href="#11-如何获取生成的主键" class="headerlink" title="11.如何获取生成的主键?"></a>11.如何获取生成的主键?</h2><p>新增标签中添加：keyProperty&#x3D;” ID “  即可</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>insert<span class="token punctuation">"</span></span> <span class="token attr-name">useGeneratedKeys</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">keyProperty</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userId<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>    insert into user(     user_name, user_password, create_time)     values(#&#123;userName&#125;, #&#123;userPassword&#125; , #&#123;createTime, jdbcType= TIMESTAMP&#125;)<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时候就可以完成回填主键</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">mapper.insert(user);user.getId;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="12-MyBatis支持动态SQL吗？"><a href="#12-MyBatis支持动态SQL吗？" class="headerlink" title="12.MyBatis支持动态SQL吗？"></a>12.MyBatis支持动态SQL吗？</h2><p>MyBatis中有一些支持动态SQL的标签，它们的原理是使用OGNL从SQL参数对象中计算表达式的值，根据表达式的值动态拼接SQL，以此来完成动态SQL的功能。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BMybatis%E7%AF%87.assets/1676357369188-5d4e1cf8-b88d-4163-898f-501ddfed8c29.png" alt="img"></p><p><strong>if</strong>：根据条件来组成where子句</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>findActiveBlogWithTitleLike<span class="token punctuation">"</span></span>     <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Blog<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  SELECT * FROM BLOG  WHERE state = ‘ACTIVE’  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>title != null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    AND title like #&#123;title&#125;  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>**choose (when, otherwise)**：这个和Java 中的 switch 语句有点像</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>findActiveBlogLike<span class="token punctuation">"</span></span>     <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Blog<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  SELECT * FROM BLOG WHERE state = ‘ACTIVE’  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>choose</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>when</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>title != null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      AND title like #&#123;title&#125;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>when</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>when</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>author != null and author.name != null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      AND author_name like #&#123;author.name&#125;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>when</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>otherwise</span><span class="token punctuation">></span></span>      AND featured = 1    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>otherwise</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>choose</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>**trim (where, set)**：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>findActiveBlogLike<span class="token punctuation">"</span></span>     <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Blog<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  SELECT * FROM BLOG  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>where</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>state != null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>         state = #&#123;state&#125;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>title != null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        AND title like #&#123;title&#125;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>author != null and author.name != null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        AND author_name like #&#123;author.name&#125;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>where</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>： 可以用在动态更新的时候</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>update</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>updateAuthorIfNecessary<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  update Author    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>set</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username != null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>username=#&#123;username&#125;,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password != null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>password=#&#123;password&#125;,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>email != null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>email=#&#123;email&#125;,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bio != null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>bio=#&#123;bio&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>set</span><span class="token punctuation">></span></span>  where id=#&#123;id&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>update</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>：可以用在所有的查询条件都是动态的情况</p><p><strong>foreach</strong>：看到名字就知道了，这个是用来循环的，可以对集合进行遍历</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectPostIn<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>domain.blog.Post<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  SELECT *  FROM POST P  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>where</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>foreach</span> <span class="token attr-name">item</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span> <span class="token attr-name">index</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>index<span class="token punctuation">"</span></span> <span class="token attr-name">collection</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>list<span class="token punctuation">"</span></span>        <span class="token attr-name">open</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ID in (<span class="token punctuation">"</span></span> <span class="token attr-name">separator</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>,<span class="token punctuation">"</span></span> <span class="token attr-name">close</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>)<span class="token punctuation">"</span></span> <span class="token attr-name">nullable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>          #&#123;item&#125;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>foreach</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>where</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="13-MyBatis如何执行批量操作？"><a href="#13-MyBatis如何执行批量操作？" class="headerlink" title="13.MyBatis如何执行批量操作？"></a>13.MyBatis如何执行批量操作？</h2><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BMybatis%E7%AF%87.assets/1676357372197-9eddc769-670b-4c3b-97ea-14234d952607.png" alt="img"></p><p><strong>第一种方法：使用foreach标签</strong></p><p>foreach的主要用在构建in条件中，它可以在SQL语句中进行迭代一个集合。foreach标签的属性主要有item，index，collection，open，separator，close。</p><ul><li><p>item： 表示集合中每一个元素进行迭代时的别名，随便起的变量名；</p></li><li><p>index：指定一个名字，用于表示在迭代过程中，每次迭代到的位置，不常用；</p></li><li><p>open：表示该语句以什么开始，常用“(”；</p></li><li><p>separator ：表示在每次进行迭代之间以什么符号作为分隔符，常用“,”；</p></li><li><p>close：表示以什么结束，常用“)”。</p></li></ul><p>在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有以下3种情况：</p><p>1、如果传入的是单参数且参数类型是一个List的时候，collection属性值为list</p><p>2、如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array</p><p>3、如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以封装成map，实际上如果你在传入参数的时候，在MyBatis里面也是会把它封装成一个Map的， map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封装的map里面的key</p><p>看看批量保存的两种用法：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- MySQL下批量保存，可以foreach遍历 mysql支持values(),(),()语法 --></span> //推荐使用<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>addEmpsBatch<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    INSERT INTO emp(ename,gender,email,did)    VALUES    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>foreach</span> <span class="token attr-name">collection</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>emps<span class="token punctuation">"</span></span> <span class="token attr-name">item</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>emp<span class="token punctuation">"</span></span> <span class="token attr-name">separator</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>,<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        (#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>foreach</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 这种方式需要数据库连接属性allowMutiQueries=true的支持 如jdbc.url=jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=true --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>addEmpsBatch<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>foreach</span> <span class="token attr-name">collection</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>emps<span class="token punctuation">"</span></span> <span class="token attr-name">item</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>emp<span class="token punctuation">"</span></span> <span class="token attr-name">separator</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                         INSERT INTO emp(ename,gender,email,did)        VALUES(#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>foreach</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>第二种方法：使用ExecutorType.BATCH</strong></p><p>Mybatis内置的ExecutorType有3种，默认为simple，该模式下它为每个语句的执行创建一个新的预处理语句，单条提交sql；而batch模式重复使用已经预处理的语句，并且批量执行所有更新语句，显然batch性能将更优；但batch模式也有自己的问题，比如在Insert操作时，在事务没有提交之前，是没有办法获取到自增的id，在某些情况下不符合业务的需求。</p><p>具体用法如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//批量保存方法测试</span><span class="token annotation punctuation">@Test</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testBatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">&#123;</span>    <span class="token class-name">SqlSessionFactory</span> sqlSessionFactory <span class="token operator">=</span> <span class="token function">getSqlSessionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//可以执行批量操作的sqlSession</span>    <span class="token class-name">SqlSession</span> openSession <span class="token operator">=</span> sqlSessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token class-name">ExecutorType</span><span class="token punctuation">.</span><span class="token constant">BATCH</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//批量保存执行前时间</span>    <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">EmployeeMapper</span> mapper <span class="token operator">=</span> openSession<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span><span class="token class-name">EmployeeMapper</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            mapper<span class="token punctuation">.</span><span class="token function">addEmp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        openSession<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> end <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//批量保存执行后的时间</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行时长"</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//批量 预编译sql一次==》设置参数==》10000次==》执行1次   677</span>        <span class="token comment">//非批量  （预编译=设置参数=执行 ）==》10000次   1121</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        openSession<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>mapper和mapper.xml如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">EmployeeMapper</span> <span class="token punctuation">&#123;</span>       <span class="token comment">//批量保存员工</span>    <span class="token class-name">Long</span> <span class="token function">addEmp</span><span class="token punctuation">(</span><span class="token class-name">Employee</span> employee<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.jourwon.mapper.EmployeeMapper<span class="token punctuation">"</span></span>     <span class="token attr-name">&lt;!--批量保存员工</span> <span class="token attr-name">--</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>addEmp<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        insert into employee(lastName,email,gender)        values(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;)    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="14-说说Mybatis的一级、二级缓存？"><a href="#14-说说Mybatis的一级、二级缓存？" class="headerlink" title="14.说说Mybatis的一级、二级缓存？"></a>14.说说Mybatis的一级、二级缓存？</h2><p>1、一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为SqlSession，各个SqlSession之间的缓存相互隔离，当 Session flush 或 close 之后，该 SqlSession 中的所有 Cache 就将清空，MyBatis默认打开一级缓存。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BMybatis%E7%AF%87.assets/1676357375860-44815fcb-93c5-4c96-9ad8-6265772ba2e9.png" alt="img"></p><p>2、二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同之处在于其存储作用域为 Mapper(Namespace)，可以在多个SqlSession之间共享，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BMybatis%E7%AF%87.assets/1676357377683-2b9b9e61-6247-4a13-80d9-733a760fd94d.png" alt="img"></p><h2 id="15-能说说MyBatis的工作原理吗？"><a href="#15-能说说MyBatis的工作原理吗？" class="headerlink" title="15.能说说MyBatis的工作原理吗？"></a>15.能说说MyBatis的工作原理吗？</h2><p>我们已经大概知道了MyBatis的工作流程，按工作原理，可以分为两大步：<code>生成会话工厂</code>、<code>会话运行</code>。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BMybatis%E7%AF%87.assets/1676357380006-2186012c-289b-429d-8b26-f06e958832d0.png" alt="img"></p><p>MyBatis是一个成熟的框架，篇幅限制，这里抓大放小，来看看它的主要工作流程。</p><p><strong>构建会话工厂</strong></p><p>构造会话工厂也可以分为两步：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BMybatis%E7%AF%87.assets/1676357382815-f146adc5-c1ad-4952-9ac1-f144d7f16a30.png" alt="img"></p><p><strong>1、获取配置</strong></p><p>获取配置这一步经过了几步转化，最终由生成了一个配置类Configuration实例，这个配置类实例非常重要，主要作用包括：</p><ul><li><p>读取配置文件，包括基础配置文件和映射文件 </p></li><li><p>初始化基础配置，比如MyBatis的别名，还有其它的一些重要的类对象，像插件、映射器、ObjectFactory等等 </p></li><li><p>提供一个单例，作为会话工厂构建的重要参数 </p></li><li><p>它的构建过程也会初始化一些环境变量，比如数据源</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">SqlSessionFactory</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token class-name">Reader</span> reader<span class="token punctuation">,</span> <span class="token class-name">String</span> environment<span class="token punctuation">,</span> <span class="token class-name">Properties</span> properties<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token class-name">SqlSessionFactory</span> var5<span class="token punctuation">;</span>       <span class="token comment">//省略异常处理</span>           <span class="token comment">//xml配置构建器</span>           <span class="token class-name">XMLConfigBuilder</span> parser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLConfigBuilder</span><span class="token punctuation">(</span>reader<span class="token punctuation">,</span> environment<span class="token punctuation">,</span> properties<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">//通过转化的Configuration构建SqlSessionFactory</span>           var5 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>parser<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2、构建SqlSessionFactory</strong></p><p>SqlSessionFactory只是一个接口，构建出来的实际上是它的实现类的实例，一般我们用的都是它的实现类DefaultSqlSessionFactory</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">SqlSessionFactory</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token class-name">Configuration</span> config<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DefaultSqlSessionFactory</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>会话运行</strong></p><p>会话运行是MyBatis最复杂的部分，它的运行离不开四大组件的配合：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BMybatis%E7%AF%87.assets/1676357386735-529aa023-5211-457d-b253-ce67038bcb6d.png" alt="img"></p><p><strong>1、Executor（执行器）</strong></p><p>Executor起到了至关重要的作用，SqlSession只是一个门面，相当于客服，真正干活的是是Executor，就像是默默无闻的工程师。它提供了相应的查询和更新方法，以及事务方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Environment</span> environment <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>configuration<span class="token punctuation">.</span><span class="token function">getEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">TransactionFactory</span> transactionFactory <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getTransactionFactoryFromEnvironment</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span>tx <span class="token operator">=</span> transactionFactory<span class="token punctuation">.</span><span class="token function">newTransaction</span><span class="token punctuation">(</span>environment<span class="token punctuation">.</span><span class="token function">getDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> level<span class="token punctuation">,</span> autoCommit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//通过Configuration创建executor</span><span class="token class-name">Executor</span> executor <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>configuration<span class="token punctuation">.</span><span class="token function">newExecutor</span><span class="token punctuation">(</span>tx<span class="token punctuation">,</span> execType<span class="token punctuation">)</span><span class="token punctuation">;</span>var8 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultSqlSession</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>configuration<span class="token punctuation">,</span> executor<span class="token punctuation">,</span> autoCommit<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2、StatementHandler（数据库会话器）</strong></p><p>StatementHandler，顾名思义，处理数据库会话的。我们以SimpleExecutor为例，看一下它的查询方法，先生成了一个StatementHandler实例，再拿这个handler去执行query。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token function">doQuery</span><span class="token punctuation">(</span><span class="token class-name">MappedStatement</span> ms<span class="token punctuation">,</span> <span class="token class-name">Object</span> parameter<span class="token punctuation">,</span> <span class="token class-name">RowBounds</span> rowBounds<span class="token punctuation">,</span> <span class="token class-name">ResultHandler</span> resultHandler<span class="token punctuation">,</span> <span class="token class-name">BoundSql</span> boundSql<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Statement</span> stmt <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token class-name">List</span> var9<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Configuration</span> configuration <span class="token operator">=</span> ms<span class="token punctuation">.</span><span class="token function">getConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">StatementHandler</span> handler <span class="token operator">=</span> configuration<span class="token punctuation">.</span><span class="token function">newStatementHandler</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>wrapper<span class="token punctuation">,</span> ms<span class="token punctuation">,</span> parameter<span class="token punctuation">,</span> rowBounds<span class="token punctuation">,</span> resultHandler<span class="token punctuation">,</span> boundSql<span class="token punctuation">)</span><span class="token punctuation">;</span>        stmt <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>handler<span class="token punctuation">,</span> ms<span class="token punctuation">.</span><span class="token function">getStatementLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        var9 <span class="token operator">=</span> handler<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span>stmt<span class="token punctuation">,</span> resultHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">closeStatement</span><span class="token punctuation">(</span>stmt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> var9<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再以最常用的PreparedStatementHandler看一下它的query方法，其实在上面的<code>prepareStatement</code>已经对参数进行了预编译处理，到了这里，就直接执行sql，使用ResultHandler处理返回结果。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token class-name">Statement</span> statement<span class="token punctuation">,</span> <span class="token class-name">ResultHandler</span> resultHandler<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">PreparedStatement</span> ps <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">PreparedStatement</span><span class="token punctuation">)</span>statement<span class="token punctuation">;</span>    ps<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>resultSetHandler<span class="token punctuation">.</span><span class="token function">handleResultSets</span><span class="token punctuation">(</span>ps<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3、ParameterHandler （参数处理器）</strong></p><p>PreparedStatementHandler里对sql进行了预编译处理</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">parameterize</span><span class="token punctuation">(</span><span class="token class-name">Statement</span> statement<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>parameterHandler<span class="token punctuation">.</span><span class="token function">setParameters</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">PreparedStatement</span><span class="token punctuation">)</span>statement<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里用的就是ParameterHandler，setParameters的作用就是设置预编译SQL语句的参数。</p><p>里面还会用到typeHandler类型处理器，对类型进行处理。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ParameterHandler</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Object</span> <span class="token function">getParameterObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">setParameters</span><span class="token punctuation">(</span><span class="token class-name">PreparedStatement</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4、ResultSetHandler（结果处理器）</strong></p><p>我们前面也看到了，最后的结果要通过ResultSetHandler来进行处理，handleResultSets这个方法就是用来包装结果集的。Mybatis为我们提供了一个DefaultResultSetHandler，通常都是用这个实现类去进行结果的处理的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ResultSetHandler</span> <span class="token punctuation">&#123;</span>    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token function">handleResultSets</span><span class="token punctuation">(</span><span class="token class-name">Statement</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span><span class="token punctuation">;</span>    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token class-name">Cursor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token function">handleCursorResultSets</span><span class="token punctuation">(</span><span class="token class-name">Statement</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">handleOutputParameters</span><span class="token punctuation">(</span><span class="token class-name">CallableStatement</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它会使用typeHandle处理类型，然后用ObjectFactory提供的规则组装对象，返回给调用者。</p><p>整体上总结一下会话运行：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BMybatis%E7%AF%87.assets/1676357389841-4e99d9e8-50cb-424c-8dbe-fb950c916ad3.png" alt="img"></p><p>PS：以上源码分析比较简单，在真正的源码大佬面前可能过不了关，有条件的建议Debug一下MyBatis的源码。</p><p>我们最后把整个的工作流程串联起来，简单总结一下：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BMybatis%E7%AF%87.assets/1676357391815-8a28eda7-579d-4b2b-aa1f-45837e72004f.png" alt="img"></p><p>1、读取 MyBatis 配置文件——mybatis-config.xml 、加载映射文件——映射文件即 SQL 映射文件，文件中配置了操作数据库的 SQL 语句。最后生成一个配置对象。</p><p>2、构造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。</p><p>3、创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法。</p><p>4、Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。</p><p>5、StatementHandler：数据库会话器，串联起参数映射的处理和运行结果映射的处理。</p><p>6、参数处理：对输入参数的类型进行处理，并预编译。</p><p>7、结果处理：对返回结果的类型进行处理，根据对象映射规则，返回相应的对象。</p><h2 id="16-MyBatis的功能架构是什么样的？"><a href="#16-MyBatis的功能架构是什么样的？" class="headerlink" title="16.MyBatis的功能架构是什么样的？"></a>16.MyBatis的功能架构是什么样的？</h2><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BMybatis%E7%AF%87.assets/1676357394480-99d32015-c33a-4257-8eae-6088e11ce43a.png" alt="img"></p><p>我们一般把Mybatis的功能架构分为三层：</p><p>1、API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。</p><p>2、数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。</p><p>3、基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。</p><h2 id="17-为什么Mapper接口不需要实现类？"><a href="#17-为什么Mapper接口不需要实现类？" class="headerlink" title="17.为什么Mapper接口不需要实现类？"></a>17.为什么Mapper接口不需要实现类？</h2><p>四个字回答：<strong>动态代理</strong>，我们来看一下获取Mapper的过程：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BMybatis%E7%AF%87.assets/1676357396643-40b34777-a89d-486e-8936-ccdcf689727a.png" alt="img"></p><p><strong>获取Mapper</strong></p><p>我们都知道定义的Mapper接口是没有实现类的，Mapper映射其实是通过<strong>动态代理</strong>实现的。</p><pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">BlogMapper mapper = session.getMapper(BlogMapper.class);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>七拐八绕地进去看一下，发现获取Mapper的过程，需要先获取MapperProxyFactory——Mapper代理工厂。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">getMapper</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> type<span class="token punctuation">,</span> <span class="token class-name">SqlSession</span> sqlSession<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">MapperProxyFactory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> mapperProxyFactory <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">MapperProxyFactory</span><span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">.</span>knownMappers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mapperProxyFactory <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BindingException</span><span class="token punctuation">(</span><span class="token string">"Type "</span> <span class="token operator">+</span> type <span class="token operator">+</span> <span class="token string">" is not known to the MapperRegistry."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> mapperProxyFactory<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> var5<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BindingException</span><span class="token punctuation">(</span><span class="token string">"Error getting mapper instance. Cause: "</span> <span class="token operator">+</span> var5<span class="token punctuation">,</span> var5<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MapperProxyFactory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> mapperInterface<span class="token punctuation">;</span>    ……    <span class="token keyword">protected</span> <span class="token class-name">T</span> <span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token class-name">MapperProxy</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> mapperProxy<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mapperInterface<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>mapperInterface<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> mapperProxy<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token class-name">SqlSession</span> sqlSession<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">MapperProxy</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> mapperProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MapperProxy</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mapperInterface<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>methodCache<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>mapperProxy<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里可以看到动态代理对接口的绑定，它的作用就是生成动态代理对象（占位），而代理的方法被放到了MapperProxy中。</p><p>MapperProxy里，通常会生成一个MapperMethod对象，它是通过cachedMapperMethod方法对其进行初始化的，然后执行excute方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getDeclaringClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">cachedInvoker</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>proxy<span class="token punctuation">,</span> method<span class="token punctuation">,</span> args<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>sqlSession<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> var5<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token class-name">ExceptionUtil</span><span class="token punctuation">.</span><span class="token function">unwrapThrowable</span><span class="token punctuation">(</span>var5<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>MapperMethod</strong></p><p>MapperMethod里的excute方法，会真正去执行sql。这里用到了命令模式，其实绕一圈，最终它还是通过SqlSession的实例去运行对象的sql。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">SqlSession</span> sqlSession<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">Object</span> result<span class="token punctuation">;</span>      <span class="token class-name">Object</span> param<span class="token punctuation">;</span>      ……      <span class="token keyword">case</span> <span class="token constant">SELECT</span><span class="token operator">:</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>method<span class="token punctuation">.</span><span class="token function">returnsVoid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>method<span class="token punctuation">.</span><span class="token function">hasResultHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>              <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">executeWithResultHandler</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>              result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>method<span class="token punctuation">.</span><span class="token function">returnsMany</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>              result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">executeForMany</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>method<span class="token punctuation">.</span><span class="token function">returnsMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>              result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">executeForMap</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>method<span class="token punctuation">.</span><span class="token function">returnsCursor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>              result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">executeForCursor</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>              param <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>method<span class="token punctuation">.</span><span class="token function">convertArgsToSqlCommandParam</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>              result <span class="token operator">=</span> sqlSession<span class="token punctuation">.</span><span class="token function">selectOne</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>command<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>method<span class="token punctuation">.</span><span class="token function">returnsOptional</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>method<span class="token punctuation">.</span><span class="token function">getReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                  result <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>         ……  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>MapperProxy</strong></p><p><strong>MapperProxyFactory</strong></p><p>MapperProxyFactory的作用是生成MapperProxy（Mapper代理对象）。</p><h2 id="18-Mybatis都有哪些Executor执行器？"><a href="#18-Mybatis都有哪些Executor执行器？" class="headerlink" title="18.Mybatis都有哪些Executor执行器？"></a>18.Mybatis都有哪些Executor执行器？</h2><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BMybatis%E7%AF%87.assets/1676357400608-ee02532b-8bde-4fb6-8ceb-ddc252c0d35c.png" alt="img"></p><p>Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。</p><p><strong>SimpleExecutor</strong>：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</p><p><strong>ReuseExecutor</strong>：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。</p><p><strong>BatchExecutor</strong>：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</p><p>作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。</p><p><strong>Mybatis中如何指定使用哪一种Executor执行器？</strong></p><p>在Mybatis配置文件中，在设置（settings）可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数，如SqlSession openSession(ExecutorType execType)。</p><p>配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）；BATCH 执行器将重用语句并执行批量更新。</p><h2 id="19-说说Mybatis的插件运行原理，如何编写一个插件？"><a href="#19-说说Mybatis的插件运行原理，如何编写一个插件？" class="headerlink" title="19.说说Mybatis的插件运行原理，如何编写一个插件？"></a>19.说说Mybatis的插件运行原理，如何编写一个插件？</h2><p><strong>插件的运行原理？</strong></p><p>Mybatis会话的运行需要ParameterHandler、ResultSetHandler、StatementHandler、Executor这四大对象的配合，插件的原理就是在这四大对象调度的时候，插入一些我我们自己的代码。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BMybatis%E7%AF%87.assets/1676357402568-5df1cdae-02ae-4299-aab1-4c1d96ac21f8.png" alt="img"></p><p>Mybatis使用JDK的动态代理，为目标对象生成代理对象。它提供了一个工具类<code>Plugin</code>，实现了<code>InvocationHandler</code>接口。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BMybatis%E7%AF%87.assets/1676357405086-4aebdf9c-1c7e-4b50-9c91-697d3516618d.png" alt="img"></p><p>使用<code>Plugin</code>生成代理对象，代理对象在调用方法的时候，就会进入invoke方法，在invoke方法中，如果存在签名的拦截方法，插件的intercept方法就会在这里被我们调用，然后就返回结果。如果不存在签名方法，那么将直接反射调用我们要执行的方法。</p><p><strong>如何编写一个插件？</strong></p><p>我们自己编写MyBatis 插件，只需要实现拦截器接口 Interceptor (org.apache.ibatis. plugin Interceptor ），在实现类中对拦截对象和方法进行处理。</p><p>实现Mybatis的Interceptor接口并重写intercept()方法</p><p>这里我们只是在目标对象执行目标方法的前后进行了打印；</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">Interceptor</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Properties</span> props<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">intercept</span><span class="token punctuation">(</span><span class="token class-name">Invocation</span> invocation<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before……"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//如果当前代理的是一个非代理对象，那么就会调用真实拦截对象的方法</span>        <span class="token comment">// 如果不是它就会调用下个插件代理对象的invoke方法</span>        <span class="token class-name">Object</span> obj<span class="token operator">=</span>invocation<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after……"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> obj<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后再给插件编写注解，确定要拦截的对象，要拦截的方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Intercepts</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token annotation punctuation">@Signature</span><span class="token punctuation">(</span>        type <span class="token operator">=</span> <span class="token class-name">Executor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>  <span class="token comment">//确定要拦截的对象</span>        method <span class="token operator">=</span> <span class="token string">"update"</span><span class="token punctuation">,</span>        <span class="token comment">//确定要拦截的方法</span>        args <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token class-name">MappedStatement</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span>   <span class="token comment">//拦截方法的参数</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">Interceptor</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Properties</span> props<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">intercept</span><span class="token punctuation">(</span><span class="token class-name">Invocation</span> invocation<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before……"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//如果当前代理的是一个非代理对象，那么就会调用真实拦截对象的方法</span>        <span class="token comment">// 如果不是它就会调用下个插件代理对象的invoke方法</span>        <span class="token class-name">Object</span> obj<span class="token operator">=</span>invocation<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after……"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> obj<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，再MyBatis配置文件里面配置插件</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span> <span class="token attr-name">interceptor</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>xxx.MyPlugin<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dbType<span class="token punctuation">"</span></span><span class="token attr-name">,value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="20-MyBatis是如何进行分页的？分页插件的原理是什么？"><a href="#20-MyBatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="20.MyBatis是如何进行分页的？分页插件的原理是什么？"></a>20.MyBatis是如何进行分页的？分页插件的原理是什么？</h2><p><strong>MyBatis是如何分页的？</strong></p><p>MyBatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页。可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p><p><strong>分页插件的原理是什么？</strong></p><p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，拦截Executor的query方法</p><p>在执行查询的时候，拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p><p>举例：select  <em>from student，拦截sql后重写为：select t.</em> from (select * from student) t limit 0, 10</p><p>可以看一下一个大概的MyBatis通用分页拦截器：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BMybatis%E7%AF%87.assets/1676357408088-8ee7d334-a6d9-477b-ad1c-28617b6ba499.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-说说什么是MyBatis&quot;&gt;&lt;a href=&quot;#1-说说什么是MyBatis&quot; class=&quot;headerlink&quot; title=&quot;1.说说什么是MyBatis?&quot;&gt;&lt;/a&gt;1.说说什么是MyBatis?&lt;/h2&gt;&lt;p&gt;Mybatis 是一个半 ORM（对象关</summary>
      
    
    
    
    <category term="PROJECT" scheme="https://zspcer.gitee.io/categories/PROJECT/"/>
    
    <category term="我要进大厂" scheme="https://zspcer.gitee.io/categories/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/"/>
    
    
    <category term="面试" scheme="https://zspcer.gitee.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="我要进大厂" scheme="https://zspcer.gitee.io/tags/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/"/>
    
    <category term="Mybatis" scheme="https://zspcer.gitee.io/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>大厂面试之RabbitMQ篇</title>
    <link href="https://zspcer.gitee.io/note/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRabbitMQ%E7%AF%87/"/>
    <id>https://zspcer.gitee.io/note/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRabbitMQ%E7%AF%87/</id>
    <published>2023-05-11T16:37:37.000Z</published>
    <updated>2023-05-11T15:42:17.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是RabbitMQ？"><a href="#1-什么是RabbitMQ？" class="headerlink" title="1.什么是RabbitMQ？"></a>1.什么是RabbitMQ？</h2><p>RabbitMQ是一个由erlang开发的消息队列。消息队列用于应用间的异步协作。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/295812/1676359129228-38c37375-e0bf-440d-a37c-9745693d0cce.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_16,text_5YWs5LyX5Y-377ya56CB54y_5oqA5pyv5LiT5qCP,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><h2 id="2-RabbitMQ的组件"><a href="#2-RabbitMQ的组件" class="headerlink" title="2.RabbitMQ的组件"></a>2.RabbitMQ的组件</h2><p>Message：由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key、priority、delivery-mode（是否持久性存储）等。</p><p>Publisher：消息的生产者。</p><p>Exchange：接收消息并将消息路由到一个或多个Queue。default exchange 是默认的直连交换机，名字为空字符串，每个新建队列都会自动绑定到默认交换机上，绑定的路由键名称与队列名称相同。</p><p>Binding：通过Binding将Exchange和Queue关联，这样Exchange就知道将消息路由到哪个Queue中。</p><p>Queue：存储消息，队列的特性是先进先出。一个消息可分发到一个或多个队列。</p><p>Virtual host：每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 &#x2F; 。当多个不同的用户使用同一个RabbitMQ server提供的服务时，可以划分出多个vhost，每个用户在自己的vhost创建exchange和queue。</p><p>Broker：消息队列服务器实体。</p><h2 id="3-什么时候使用MQ"><a href="#3-什么时候使用MQ" class="headerlink" title="3.什么时候使用MQ"></a>3.什么时候使用MQ</h2><p>对于一些不需要立即生效的操作，可以拆分出来，异步执行，使用消息队列实现。</p><p>以常见的订单系统为例，用户点击下单按钮之后的业务逻辑可能包括：扣减库存、生成相应单据、发短信通知。这种场景下就可以用 MQ 。将短信通知放到 MQ 异步执行，在下单的主流程（比如扣减库存、生成相应单据）完成之后发送一条消息到 MQ， 让主流程快速完结，而由另外的线程消费MQ的消息。</p><h2 id="4-RabbitMQ的优缺点"><a href="#4-RabbitMQ的优缺点" class="headerlink" title="4.RabbitMQ的优缺点"></a>4.RabbitMQ的优缺点</h2><p>缺点：使用erlang实现，不利于二次开发和维护；性能较kafka差，持久化消息和ACK确认的情况下生产和消费消息单机吞吐量大约在1-2万左右，kafka单机吞吐量在十万级别。</p><p>优点：有管理界面，方便使用；可靠性高；功能丰富，支持消息持久化、消息确认机制、多种消息分发机制。</p><h2 id="5-RabbitMQ-有哪些重要的角色？"><a href="#5-RabbitMQ-有哪些重要的角色？" class="headerlink" title="5.RabbitMQ 有哪些重要的角色？"></a>5.RabbitMQ 有哪些重要的角色？</h2><p>RabbitMQ 中重要的角色有：生产者、消费者和代理。</p><p>1、生产者：消息的创建者，负责创建和推送数据到消息服务器；</p><p>2、消费者：消息的接收方，用于处理数据和确认消息；</p><p>3、代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。</p><h2 id="6-Exchange-类型"><a href="#6-Exchange-类型" class="headerlink" title="6.Exchange 类型"></a>6.Exchange 类型</h2><p>Exchange分发消息时根据类型的不同分发策略不同，目前共四种类型：direct、fanout、topic、headers 。headers 模式根据消息的headers进行路由，此外 headers 交换器和 direct 交换器完全一致，但性能差很多。</p><p>Exchange规则。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRabbitMQ%E7%AF%87.assets/image-20230511170416217.png" alt="image-20230511170416217"></p><p><strong>direct</strong></p><p>direct交换机会将消息路由到binding key 和 routing key完全匹配的队列中。它是完全匹配、单播的模式。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/295812/1676359131990-932cebf1-f203-4fc5-a1b6-546e1bc53c48.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_11,text_5YWs5LyX5Y-377ya56CB54y_5oqA5pyv5LiT5qCP,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><p><strong>fanout</strong></p><p>所有发到 fanout 类型交换机的消息都会路由到所有与该交换机绑定的队列上去。fanout 类型转发消息是最快的。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/295812/1676359134005-ba4421b2-021f-49b5-9006-afc10099d4fc.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_13,text_5YWs5LyX5Y-377ya56CB54y_5oqA5pyv5LiT5qCP,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><p><strong>topic</strong></p><p>topic交换机使用routing key和binding key进行模糊匹配，匹配成功则将消息发送到相应的队列。routing key和binding key都是句点号“. ”分隔的字符串，binding key中可以存在两种特殊字符“<em>”与“##”，用于做模糊匹配，其中“</em>”用于匹配一个单词，“##”用于匹配多个单词。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/295812/1676359135828-892a7f14-5a4a-46a7-bca6-82b74166581a.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_16,text_5YWs5LyX5Y-377ya56CB54y_5oqA5pyv5LiT5qCP,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p><p><strong>headers</strong></p><p>headers交换机是根据发送的消息内容中的headers属性进行路由的。在绑定Queue与Exchange时指定一组键值对；当消息发送到Exchange时，RabbitMQ会取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配Queue与Exchange绑定时指定的键值对；如果完全匹配则消息会路由到该Queue，否则不会路由到该Queue。</p><h2 id="7-消息丢失"><a href="#7-消息丢失" class="headerlink" title="7.消息丢失"></a>7.消息丢失</h2><p>消息丢失场景：生产者生产消息到RabbitMQ Server消息丢失、RabbitMQ Server存储的消息丢失和RabbitMQ Server到消费者消息丢失。</p><p>消息丢失从三个方面来解决：生产者确认机制、消费者手动确认消息和持久化。</p><h3 id="生产者确认机制"><a href="#生产者确认机制" class="headerlink" title="生产者确认机制"></a>生产者确认机制</h3><p>生产者发送消息到队列，无法确保发送的消息成功的到达server。</p><p>解决方法：</p><p>1、事务机制。在一条消息发送之后会使发送端阻塞，等待RabbitMQ的回应，之后才能继续发送下一条消息。性能差。</p><p>2、开启生产者确认机制，只要消息成功发送到交换机之后，RabbitMQ就会发送一个ack给生产者（即使消息没有Queue接收，也会发送ack）。如果消息没有成功发送到交换机，就会发送一条nack消息，提示发送失败。</p><p>在 Springboot 是通过 publisher-confirms 参数来设置 confirm 模式：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>    <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>           <span class="token comment">##开启 confirm 确认机制</span>        <span class="token key atrule">publisher-confirms</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在生产端提供一个回调方法，当服务端确认了一条或者多条消息后，生产者会回调这个方法，根据具体的结果对消息进行后续处理，比如重新发送、记录日志等。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 消息是否成功发送到Exchange</span><span class="token keyword">final</span> <span class="token class-name">RabbitTemplate<span class="token punctuation">.</span>ConfirmCallback</span> confirmCallback <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">CorrelationData</span> correlationData<span class="token punctuation">,</span> <span class="token keyword">boolean</span> ack<span class="token punctuation">,</span> <span class="token class-name">String</span> cause<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"correlationData: "</span> <span class="token operator">+</span> correlationData<span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"ack: "</span> <span class="token operator">+</span> ack<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>ack<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"异常处理...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>rabbitTemplate<span class="token punctuation">.</span><span class="token function">setConfirmCallback</span><span class="token punctuation">(</span>confirmCallback<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="路由不可达消息"><a href="#路由不可达消息" class="headerlink" title="路由不可达消息"></a>路由不可达消息</h3><p>生产者确认机制只确保消息正确到达交换机，对于从交换机路由到Queue失败的消息，会被丢弃掉，导致消息丢失。</p><p>对于不可路由的消息，有两种处理方式：Return消息机制和备份交换机。</p><p><strong>Return消息机制</strong></p><p>Return消息机制提供了回调函数 ReturnCallback，当消息从交换机路由到Queue失败才会回调这个方法。需要将<code>mandatory</code> 设置为 <code>true</code> ，才能监听到路由不可达的消息。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>    <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>        <span class="token comment">##触发ReturnCallback必须设置mandatory=true, 否则Exchange没有找到Queue就会丢弃掉消息, 而不会触发ReturnCallback</span>        <span class="token key atrule">template.mandatory</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过 ReturnCallback 监听路由不可达消息。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">    <span class="token keyword">final</span> <span class="token class-name">RabbitTemplate<span class="token punctuation">.</span>ReturnCallback</span> returnCallback <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Message</span> message<span class="token punctuation">,</span> <span class="token keyword">int</span> replyCode<span class="token punctuation">,</span> <span class="token class-name">String</span> replyText<span class="token punctuation">,</span> <span class="token class-name">String</span> exchange<span class="token punctuation">,</span> <span class="token class-name">String</span> routingKey<span class="token punctuation">)</span> <span class="token operator">-></span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"return exchange: "</span> <span class="token operator">+</span> exchange <span class="token operator">+</span> <span class="token string">", routingKey: "</span>                    <span class="token operator">+</span> routingKey <span class="token operator">+</span> <span class="token string">", replyCode: "</span> <span class="token operator">+</span> replyCode <span class="token operator">+</span> <span class="token string">", replyText: "</span> <span class="token operator">+</span> replyText<span class="token punctuation">)</span><span class="token punctuation">;</span>rabbitTemplate<span class="token punctuation">.</span><span class="token function">setReturnCallback</span><span class="token punctuation">(</span>returnCallback<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当消息从交换机路由到Queue失败时，会返回 <code>return exchange: , routingKey: MAIL, replyCode: 312, replyText: NO_ROUTE</code>。</p><p><strong>备份交换机</strong></p><p>备份交换机alternate-exchange 是一个普通的exchange，当你发送消息到对应的exchange时，没有匹配到queue，就会自动转移到备份交换机对应的queue，这样消息就不会丢失。</p><h3 id="消费者手动消息确认"><a href="#消费者手动消息确认" class="headerlink" title="消费者手动消息确认"></a>消费者手动消息确认</h3><p>有可能消费者收到消息还没来得及处理MQ服务就宕机了，导致消息丢失。因为消息者默认采用自动ack，一旦消费者收到消息后会通知MQ Server这条消息已经处理好了，MQ 就会移除这条消息。</p><p>解决方法：消费者设置为手动确认消息。消费者处理完逻辑之后再给broker回复ack，表示消息已经成功消费，可以从broker中删除。当消息者消费失败的时候，给broker回复nack，根据配置决定重新入队还是从broker移除，或者进入死信队列。只要没收到消费者的 acknowledgment，broker 就会一直保存着这条消息，但不会 requeue，也不会分配给其他 消费者。</p><p>消费者设置手动ack：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">##设置消费端手动 ackspring<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>listener<span class="token punctuation">.</span>simple<span class="token punctuation">.</span>acknowledge<span class="token operator">-</span>mode<span class="token operator">=</span>manual<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>消息处理完，手动确认：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token class-name">RabbitMqConfig</span><span class="token punctuation">.</span><span class="token constant">MAIL_QUEUE</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onMessage</span><span class="token punctuation">(</span><span class="token class-name">Message</span> message<span class="token punctuation">,</span> <span class="token class-name">Channel</span> channel<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">long</span> deliveryTag <span class="token operator">=</span> message<span class="token punctuation">.</span><span class="token function">getMessageProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//手工ack；第二个参数是multiple，设置为true，表示deliveryTag序列号之前（包括自身）的消息都已经收到，设为false则表示收到一条消息</span>    channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>deliveryTag<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"mail listener receive: "</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当消息消费失败时，消费端给broker回复nack，如果consumer设置了requeue为false，则nack后broker会删除消息或者进入死信队列，否则消息会重新入队。</p><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>如果RabbitMQ服务异常导致重启，将会导致消息丢失。RabbitMQ提供了持久化的机制，将内存中的消息持久化到硬盘上，即使重启RabbitMQ，消息也不会丢失。</p><p>消息持久化需要满足以下条件：</p><p>1、消息设置持久化。发布消息前，设置投递模式delivery mode为2，表示消息需要持久化。</p><p>2、Queue设置持久化。</p><p>3、交换机设置持久化。</p><p>当发布一条消息到交换机上时，Rabbit会先把消息写入持久化日志，然后才向生产者发送响应。一旦从队列中消费了一条消息的话并且做了确认，RabbitMQ会在持久化日志中移除这条消息。在消费消息前，如果RabbitMQ重启的话，服务器会自动重建交换机和队列，加载持久化日志中的消息到相应的队列或者交换机上，保证消息不会丢失。</p><h3 id="镜像队列"><a href="#镜像队列" class="headerlink" title="镜像队列"></a>镜像队列</h3><p>当MQ发生故障时，会导致服务不可用。引入RabbitMQ的镜像队列机制，将queue镜像到集群中其他的节点之上。如果集群中的一个节点失效了，能自动地切换到镜像中的另一个节点以保证服务的可用性。</p><p>通常每一个镜像队列都包含一个master和多个slave，分别对应于不同的节点。发送到镜像队列的所有消息总是被直接发送到master和所有的slave之上。除了publish外所有动作都只会向master发送，然后由master将命令执行的结果广播给slave，从镜像队列中的消费操作实际上是在master上执行的。</p><h2 id="8-消息重复消费怎么处理？"><a href="#8-消息重复消费怎么处理？" class="headerlink" title="8.消息重复消费怎么处理？"></a>8.消息重复消费怎么处理？</h2><p>消息重复的原因有两个：1.生产时消息重复，2.消费时消息重复。</p><p>生产者发送消息给MQ，在MQ确认的时候出现了网络波动，生产者没有收到确认，这时候生产者就会重新发送这条消息，导致MQ会接收到重复消息。</p><p>消费者消费成功后，给MQ确认的时候出现了网络波动，MQ没有接收到确认，为了保证消息不丢失，MQ就会继续给消费者投递之前的消息。这时候消费者就接收到了两条一样的消息。由于重复消息是由于网络原因造成的，无法避免。</p><p>解决方法：发送消息时让每个消息携带一个全局的唯一ID，在消费消息时先判断消息是否已经被消费过，保证消息消费逻辑的幂等性。具体消费过程为：</p><p>1、消费者获取到消息后先根据id去查询redis&#x2F;db是否存在该消息</p><p>2、如果不存在，则正常消费，消费完毕后写入redis&#x2F;db</p><p>3、如果存在，则证明消息被消费过，直接丢弃</p><h2 id="9-消费端怎么进行限流？"><a href="#9-消费端怎么进行限流？" class="headerlink" title="9.消费端怎么进行限流？"></a>9.消费端怎么进行限流？</h2><p>当 RabbitMQ 服务器积压大量消息时，队列里的消息会大量涌入消费端，可能导致消费端服务器奔溃。这种情况下需要对消费端限流。</p><p>Spring RabbitMQ 提供参数 prefetch 可以设置单个请求处理的消息个数。如果消费者同时处理的消息到达最大值的时候，则该消费者会阻塞，不会消费新的消息，直到有消息 ack 才会消费新的消息。</p><p>开启消费端限流：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment">##在单个请求中处理的消息个数，unack的最大数量</span><span class="token key attr-name">spring.rabbitmq.listener.simple.prefetch</span><span class="token punctuation">=</span><span class="token value attr-value">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>原生 RabbitMQ 还提供 prefetchSize 和 global 两个参数。Spring RabbitMQ没有这两个参数。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//单条消息大小限制，0代表不限制</span><span class="token comment">//global：限制限流功能是channel级别的还是consumer级别。当设置为false，consumer级别，限流功能生效，设置为true没有了限流功能，因为channel级别尚未实现。</span><span class="token keyword">void</span> <span class="token function">basicQos</span><span class="token punctuation">(</span><span class="token keyword">int</span> prefetchSize<span class="token punctuation">,</span> <span class="token keyword">int</span> prefetchCount<span class="token punctuation">,</span> <span class="token keyword">boolean</span> global<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="10-什么是死信队列？"><a href="#10-什么是死信队列？" class="headerlink" title="10.什么是死信队列？"></a>10.什么是死信队列？</h2><p>消费失败的消息存放的队列。</p><p>消息消费失败的原因：</p><ul><li><p>消息被拒绝并且消息没有重新入队（requeue&#x3D;false）</p></li><li><p>消息超时未消费</p></li><li><p>达到最大队列长度</p></li></ul><p>设置死信队列的 exchange 和 queue，然后进行绑定：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span>   <span class="token keyword">public</span> <span class="token class-name">DirectExchange</span> <span class="token function">dlxExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DirectExchange</span><span class="token punctuation">(</span><span class="token class-name">RabbitMqConfig</span><span class="token punctuation">.</span><span class="token constant">DLX_EXCHANGE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token annotation punctuation">@Bean</span>   <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">dlxQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token class-name">RabbitMqConfig</span><span class="token punctuation">.</span><span class="token constant">DLX_QUEUE</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token annotation punctuation">@Bean</span>   <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">bindingDeadExchange</span><span class="token punctuation">(</span><span class="token class-name">Queue</span> dlxQueue<span class="token punctuation">,</span> <span class="token class-name">DirectExchange</span> deadExchange<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>dlxQueue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span>deadExchange<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token class-name">RabbitMqConfig</span><span class="token punctuation">.</span><span class="token constant">DLX_QUEUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在普通队列加上两个参数，绑定普通队列到死信队列。当消息消费失败时，消息会被路由到死信队列。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">sendSmsQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> arguments <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 绑定该队列到私信交换机</span>    arguments<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-dead-letter-exchange"</span><span class="token punctuation">,</span> <span class="token class-name">RabbitMqConfig</span><span class="token punctuation">.</span><span class="token constant">DLX_EXCHANGE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    arguments<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-dead-letter-routing-key"</span><span class="token punctuation">,</span> <span class="token class-name">RabbitMqConfig</span><span class="token punctuation">.</span><span class="token constant">DLX_QUEUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token class-name">RabbitMqConfig</span><span class="token punctuation">.</span><span class="token constant">MAIL_QUEUE</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>生产者完整代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MQProducer</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token class-name">RabbitTemplate</span> rabbitTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token class-name">RandomUtil</span> randomUtil<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token class-name">UserService</span> userService<span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token class-name">RabbitTemplate<span class="token punctuation">.</span>ConfirmCallback</span> confirmCallback <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">CorrelationData</span> correlationData<span class="token punctuation">,</span> <span class="token keyword">boolean</span> ack<span class="token punctuation">,</span> <span class="token class-name">String</span> cause<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"correlationData: "</span> <span class="token operator">+</span> correlationData<span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"ack: "</span> <span class="token operator">+</span> ack<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>ack<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"异常处理...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token class-name">RabbitTemplate<span class="token punctuation">.</span>ReturnCallback</span> returnCallback <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Message</span> message<span class="token punctuation">,</span> <span class="token keyword">int</span> replyCode<span class="token punctuation">,</span> <span class="token class-name">String</span> replyText<span class="token punctuation">,</span> <span class="token class-name">String</span> exchange<span class="token punctuation">,</span> <span class="token class-name">String</span> routingKey<span class="token punctuation">)</span> <span class="token operator">-></span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"return exchange: "</span> <span class="token operator">+</span> exchange <span class="token operator">+</span> <span class="token string">", routingKey: "</span>                    <span class="token operator">+</span> routingKey <span class="token operator">+</span> <span class="token string">", replyCode: "</span> <span class="token operator">+</span> replyCode <span class="token operator">+</span> <span class="token string">", replyText: "</span> <span class="token operator">+</span> replyText<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMail</span><span class="token punctuation">(</span><span class="token class-name">String</span> mail<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//貌似线程不安全 范围100000 - 999999</span>        <span class="token class-name">Integer</span> random <span class="token operator">=</span> randomUtil<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">100000</span><span class="token punctuation">,</span> <span class="token number">999999</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> code <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"mail"</span><span class="token punctuation">,</span> mail<span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"code"</span><span class="token punctuation">,</span> code<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">MessageProperties</span> mp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//在生产环境中这里不用Message，而是使用 fastJson 等工具将对象转换为 json 格式发送</span>        <span class="token class-name">Message</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"tyson"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mp<span class="token punctuation">)</span><span class="token punctuation">;</span>        msg<span class="token punctuation">.</span><span class="token function">getMessageProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setExpiration</span><span class="token punctuation">(</span><span class="token string">"3000"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//如果消费端要设置为手工 ACK ，那么生产端发送消息的时候一定发送 correlationData ，并且全局唯一，用以唯一标识消息。</span>        <span class="token class-name">CorrelationData</span> correlationData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CorrelationData</span><span class="token punctuation">(</span><span class="token string">"1234567890"</span><span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">setMandatory</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">setConfirmCallback</span><span class="token punctuation">(</span>confirmCallback<span class="token punctuation">)</span><span class="token punctuation">;</span>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">setReturnCallback</span><span class="token punctuation">(</span>returnCallback<span class="token punctuation">)</span><span class="token punctuation">;</span>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token class-name">RabbitMqConfig</span><span class="token punctuation">.</span><span class="token constant">MAIL_QUEUE</span><span class="token punctuation">,</span> msg<span class="token punctuation">,</span> correlationData<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//存入redis</span>        userService<span class="token punctuation">.</span><span class="token function">updateMailSendState</span><span class="token punctuation">(</span>mail<span class="token punctuation">,</span> code<span class="token punctuation">,</span> <span class="token class-name">MailConfig</span><span class="token punctuation">.</span><span class="token constant">MAIL_STATE_WAIT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>消费者完整代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeadListener</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token class-name">RabbitMqConfig</span><span class="token punctuation">.</span><span class="token constant">DLX_QUEUE</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onMessage</span><span class="token punctuation">(</span><span class="token class-name">Message</span> message<span class="token punctuation">,</span> <span class="token class-name">Channel</span> channel<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">long</span> deliveryTag <span class="token operator">=</span> message<span class="token punctuation">.</span><span class="token function">getMessageProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//手工ack</span>        channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>deliveryTag<span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"receive--1: "</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当普通队列中有死信时，RabbitMQ 就会自动的将这个消息重新发布到设置的死信交换机去，然后被路由到死信队列。可以监听死信队列中的消息做相应的处理。</p><h2 id="11-说说pull模式"><a href="#11-说说pull模式" class="headerlink" title="11.说说pull模式"></a>11.说说pull模式</h2><p>pull模式主要是通过channel.basicGet方法来获取消息，示例代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">GetResponse</span> response <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">basicGet</span><span class="token punctuation">(</span><span class="token constant">QUEUE_NAME</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span><span class="token function">getEnvelope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="12-怎么设置消息的过期时间？"><a href="#12-怎么设置消息的过期时间？" class="headerlink" title="12.怎么设置消息的过期时间？"></a>12.怎么设置消息的过期时间？</h2><p>在生产端发送消息的时候可以给消息设置过期时间，单位为毫秒(ms)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Message</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"tyson"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mp<span class="token punctuation">)</span><span class="token punctuation">;</span>msg<span class="token punctuation">.</span><span class="token function">getMessageProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setExpiration</span><span class="token punctuation">(</span><span class="token string">"3000"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>也可以在创建队列的时候指定队列的ttl，从消息入队列开始计算，超过该时间的消息将会被移除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-什么是RabbitMQ？&quot;&gt;&lt;a href=&quot;#1-什么是RabbitMQ？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是RabbitMQ？&quot;&gt;&lt;/a&gt;1.什么是RabbitMQ？&lt;/h2&gt;&lt;p&gt;RabbitMQ是一个由erlang开发的消</summary>
      
    
    
    
    <category term="PROJECT" scheme="https://zspcer.gitee.io/categories/PROJECT/"/>
    
    <category term="我要进大厂" scheme="https://zspcer.gitee.io/categories/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/"/>
    
    
    <category term="面试" scheme="https://zspcer.gitee.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="我要进大厂" scheme="https://zspcer.gitee.io/tags/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/"/>
    
    <category term="RabbitMQ" scheme="https://zspcer.gitee.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>大厂面试之RocketMQ篇</title>
    <link href="https://zspcer.gitee.io/note/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87/"/>
    <id>https://zspcer.gitee.io/note/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87/</id>
    <published>2023-05-11T16:37:37.000Z</published>
    <updated>2023-05-11T15:42:17.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-为什么要使用消息队列呢？"><a href="#1-为什么要使用消息队列呢？" class="headerlink" title="1.为什么要使用消息队列呢？"></a>1.为什么要使用消息队列呢？</h2><p>消息队列主要有三大用途，我们拿一个电商系统的下单举例：</p><p><strong>解耦</strong>：引入消息队列之前，下单完成之后，需要订单服务去调用库存服务减库存，调用营销服务加营销数据……引入消息队列之后，可以把订单完成的消息丢进队列里，下游服务自己去调用就行了，这样就完成了订单服务和其它服务的解耦合。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359151496-1e1c6e3c-dfb8-4062-b64c-c714714e7fad.png" alt="img"></p><p><strong>异步</strong>：订单支付之后，我们要扣减库存、增加积分、发送消息等等，这样一来这个链路就长了，链路一长，响应时间就变长了。引入消息队列，除了<code>更新订单状态</code>，其它的都可以<strong>异步</strong>去做，这样一来就来，就能降低响应时间。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359161106-097b63db-7df5-4fdc-b0c6-93191ccc3dde.png" alt="img"></p><p><strong>削峰</strong>：消息队列合一用来削峰，例如秒杀系统，平时流量很低，但是要做秒杀活动，秒杀的时候流量疯狂怼进来，我们的服务器，Redis，MySQL各自的承受能力都不一样，直接全部流量照单全收肯定有问题啊，严重点可能直接打挂了。</p><p>我们可以把请求扔到队列里面，只放出我们服务能处理的流量，这样就能抗住短时间的大流量了。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359159655-1a873608-2dd7-4a2a-8c86-d83ddeb89fd5.png" alt="img"></p><p>解耦、异步、削峰，是消息队列最主要的三大作用。</p><h2 id="2-为什么要选择RocketMQ"><a href="#2-为什么要选择RocketMQ" class="headerlink" title="2.为什么要选择RocketMQ?"></a>2.为什么要选择RocketMQ?</h2><p>市场上几大消息队列对比如下：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359163640-f4f7256c-6cae-4117-9166-9036456a38a9.png" alt="img"></p><p><strong>总结一下</strong>：</p><p>选择中间件的可以从这些维度来考虑：可靠性，性能，功能，可运维行，可拓展性，社区活跃度。目前常用的几个中间件，ActiveMQ作为“老古董”，市面上用的已经不多，其它几种：</p><p>RabbitMQ：</p><ul><li><p>优点：轻量，迅捷，容易部署和使用，拥有灵活的路由配置 </p></li><li><p>缺点：性能和吞吐量不太理想，不易进行二次开发</p></li></ul><p>RocketMQ：</p><ul><li><p>优点：性能好，高吞吐量，稳定可靠，有活跃的中文社区</p></li><li><p>缺点：兼容性上不是太好</p></li></ul><p>Kafka：</p><ul><li><p>优点：拥有强大的性能及吞吐量，兼容性很好</p></li><li><p>缺点：由于“攒一波再处理”导致延迟比较高</p></li></ul><p>我们的系统是面向用户的C端系统，具有一定的并发量，对性能也有比较高的要求，所以选择了低延迟、吞吐量比较高，可用性比较好的RocketMQ。</p><h2 id="3-RocketMQ有什么优缺点？"><a href="#3-RocketMQ有什么优缺点？" class="headerlink" title="3.RocketMQ有什么优缺点？"></a>3.RocketMQ有什么优缺点？</h2><p>RocketMQ优点：</p><ul><li><p>单机吞吐量：十万级</p></li><li><p>可用性：非常高，分布式架构</p></li><li><p>消息可靠性：经过参数优化配置，消息可以做到0丢失</p></li><li><p>功能支持：MQ功能较为完善，还是分布式的，扩展性好</p></li><li><p>支持10亿级别的消息堆积，不会因为堆积导致性能下降</p></li><li><p>源码是Java，方便结合公司自己的业务二次开发</p></li><li><p>天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况</p></li><li><p><strong>RoketMQ</strong>在稳定性上可能更值得信赖，这些业务场景在阿里双11已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择<strong>RocketMQ</strong></p></li></ul><p>RocketMQ缺点：</p><ul><li><p>支持的客户端语言不多，目前是Java及c++，其中c++不成熟</p></li><li><p>没有在 MQ核心中去实现<strong>JMS</strong>等接口，有些系统要迁移需要修改大量代码</p></li></ul><h2 id="4-消息队列有哪些消息模型？"><a href="#4-消息队列有哪些消息模型？" class="headerlink" title="4.消息队列有哪些消息模型？"></a>4.消息队列有哪些消息模型？</h2><p>消息队列有两种模型：<strong>队列模型</strong>和<strong>发布&#x2F;订阅模型</strong>。</p><p><strong>队列模型</strong></p><p>这是最初的一种消息队列模型，对应着消息队列“发-存-收”的模型。生产者往某个队列里面发送消息，一个队列可以存储多个生产者的消息，一个队列也可以有多个消费者，但是消费者之间是竞争关系，也就是说每条消息只能被一个消费者消费。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359168715-3eeb4345-de3c-4b05-add6-e63ff7113556.png" alt="img"></p><p><strong>发布&#x2F;订阅模型</strong></p><p>如果需要将一份消息数据分发给多个消费者，并且每个消费者都要求收到全量的消息。很显然，队列模型无法满足这个需求。解决的方式就是发布&#x2F;订阅模型。</p><p>在发布 - 订阅模型中，消息的发送方称为发布者（Publisher），消息的接收方称为订阅者（Subscriber），服务端存放消息的容器称为主题（Topic）。发布者将消息发送到主题中，订阅者在接收消息之前需要先“订阅主题”。“订阅”在这里既是一个动作，同时还可以认为是主题在消费时的一个逻辑副本，每份订阅中，订阅者都可以接收到主题的所有消息。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359170351-5586dc22-1e58-45c7-ad55-9248e838a59d.png" alt="img"></p><p>它和 “队列模式” 的异同：生产者就是发布者，队列就是主题，消费者就是订阅者，无本质区别。唯一的不同点在于：一份消息数据是否可以被多次消费。</p><h2 id="5-那RocketMQ的消息模型呢？"><a href="#5-那RocketMQ的消息模型呢？" class="headerlink" title="5.那RocketMQ的消息模型呢？"></a>5.那RocketMQ的消息模型呢？</h2><p>RocketMQ使用的消息模型是标准的发布-订阅模型，在RocketMQ的术语表中，生产者、消费者和主题，与发布-订阅模型中的概念是完全一样的。</p><p>RocketMQ本身的消息是由下面几部分组成：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359172230-39110103-3a6b-43fb-b4d3-4afa03f78741.png" alt="img"></p><p><strong>Message</strong></p><p><strong>Message</strong>（消息）就是要传输的信息。</p><p>一条消息必须有一个主题（Topic），主题可以看做是你的信件要邮寄的地址。</p><p>一条消息也可以拥有一个可选的标签（Tag）和额处的键值对，它们可以用于设置一个业务 Key 并在 Broker 上查找此消息以便在开发期间查找问题。</p><p><strong>Topic</strong></p><p><strong>Topic</strong>（主题）可以看做消息的归类，它是消息的第一级类型。比如一个电商系统可以分为：交易消息、物流消息等，一条消息必须有一个 Topic 。</p><p><strong>Topic</strong> 与生产者和消费者的关系非常松散，一个 Topic 可以有0个、1个、多个生产者向其发送消息，一个生产者也可以同时向不同的 Topic 发送消息。</p><p>一个 Topic 也可以被 0个、1个、多个消费者订阅。</p><p><strong>Tag</strong></p><p><strong>Tag</strong>（标签）可以看作子主题，它是消息的第二级类型，用于为用户提供额外的灵活性。使用标签，同一业务模块不同目的的消息就可以用相同 Topic 而不同的 <strong>Tag</strong> 来标识。比如交易消息又可以分为：交易创建消息、交易完成消息等，一条消息可以没有 <strong>Tag</strong> 。</p><p>标签有助于保持你的代码干净和连贯，并且还可以为 <strong>RocketMQ</strong> 提供的查询系统提供帮助。</p><p><strong>Group</strong></p><p>RocketMQ中，订阅者的概念是通过消费组（Consumer Group）来体现的。每个消费组都消费主题中一份完整的消息，不同消费组之间消费进度彼此不受影响，也就是说，一条消息被Consumer Group1消费过，也会再给Consumer Group2消费。</p><p>消费组中包含多个消费者，同一个组内的消费者是竞争消费的关系，每个消费者负责消费组内的一部分消息。默认情况，如果一条消息被消费者Consumer1消费了，那同组的其他消费者就不会再收到这条消息。</p><p><strong>Message Queue</strong></p><p><strong>Message Queue</strong>（消息队列），一个 Topic 下可以设置多个消息队列，Topic 包括多个 Message Queue ，如果一个 Consumer 需要获取 Topic下所有的消息，就要遍历所有的 Message Queue。</p><p>RocketMQ还有一些其它的Queue——例如ConsumerQueue。</p><p><strong>Offset</strong></p><p>在Topic的消费过程中，由于消息需要被不同的组进行多次消费，所以消费完的消息并不会立即被删除，这就需要RocketMQ为每个消费组在每个队列上维护一个消费位置（Consumer Offset），这个位置之前的消息都被消费过，之后的消息都没有被消费过，每成功消费一条消息，消费位置就加一。</p><p>也可以这么说，<code>Queue</code> 是一个长度无限的数组，<strong>Offset</strong> 就是下标。</p><p>RocketMQ的消息模型中，这些就是比较关键的概念了。画张图总结一下：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359177217-fa688513-1880-45db-9a9a-97f043c5d820.png" alt="img"></p><h2 id="6-消息的消费模式了解吗？"><a href="#6-消息的消费模式了解吗？" class="headerlink" title="6.消息的消费模式了解吗？"></a>6.消息的消费模式了解吗？</h2><p>消息消费模式有两种：<strong>Clustering</strong>（集群消费）和<strong>Broadcasting</strong>（广播消费）。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359178046-5f3b401e-dbfa-4b71-862b-44d241244515.png" alt="img"></p><p>默认情况下就是集群消费，这种模式下<code>一个消费者组共同消费一个主题的多个队列，一个队列只会被一个消费者消费</code>，如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。</p><p>而广播消费消息会发给消费者组中的每一个消费者进行消费。</p><h2 id="7-RoctetMQ基本架构了解吗？"><a href="#7-RoctetMQ基本架构了解吗？" class="headerlink" title="7.RoctetMQ基本架构了解吗？"></a>7.RoctetMQ基本架构了解吗？</h2><p>先看图，RocketMQ的基本架构：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359180377-154268ba-0358-43dd-b33a-f5e115647034.png" alt="img"></p><p>RocketMQ 一共有四个部分组成：NameServer，Broker，Producer 生产者，Consumer 消费者，它们对应了：发现、发、存、收，为了保证高可用，一般每一部分都是集群部署的。</p><h2 id="8-那能介绍一下这四部分吗？"><a href="#8-那能介绍一下这四部分吗？" class="headerlink" title="8.那能介绍一下这四部分吗？"></a>8.那能介绍一下这四部分吗？</h2><p>类比一下我们生活的邮政系统——</p><p>邮政系统要正常运行，离不开下面这四个角色， 一是发信者，二 是收信者， 三是负责暂存传输的邮局， 四是负责协调各个地方邮局的管理机构。对应到 RocketMQ 中，这四个角色就是 Producer、 Consumer、 Broker 、NameServer。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359184359-7dedf125-c589-4aee-9ba0-ee5f8c07ec9e.png" alt="img"></p><h3 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a>NameServer</h3><p>NameServer 是一个无状态的服务器，角色类似于 Kafka使用的 Zookeeper，但比 Zookeeper 更轻量。</p><p><strong>特点</strong>：</p><ul><li><p>每个 NameServer 结点之间是相互独立，彼此没有任何信息交互。</p></li><li><p>Nameserver 被设计成几乎是无状态的，通过部署多个结点来标识自己是一个伪集群，Producer 在发送消息前从 NameServer 中获取 Topic 的路由信息也就是发往哪个 Broker，Consumer 也会定时从 NameServer 获取 Topic 的路由信息，Broker 在启动时会向 NameServer 注册，并定时进行心跳连接，且定时同步维护的 Topic 到 NameServer。</p></li></ul><p><strong>功能主要有两个</strong>：</p><p>1、和Broker 结点保持长连接。</p><p>2、维护 Topic 的路由信息。</p><h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><p>消息存储和中转角色，负责存储和转发消息。</p><p>Broker 内部维护着一个个 Consumer Queue，用来存储消息的索引，真正存储消息的地方是 CommitLog（日志文件）。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359186834-c39aca1d-13e3-49ea-8ab8-98e7b01b12fb.png" alt="img"></p><p>单个 Broker 与所有的 Nameserver 保持着长连接和心跳，并会定时将 Topic 信息同步到 NameServer，和 NameServer 的通信底层是通过 Netty 实现的。</p><h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>消息生产者，业务端负责发送消息，由用户自行实现和分布式部署。</p><p><strong>Producer</strong>由用户进行分布式部署，消息由<strong>Producer</strong>通过多种负载均衡模式发送到<strong>Broker</strong>集群，发送低延时，支持快速失败。</p><p><strong>RocketMQ</strong> 提供了三种方式发送消息：同步、异步和单向</p><ul><li><p><strong>同步发送</strong>：同步发送指消息发送方发出数据后会在收到接收方发回响应之后才发下一个数据包。一般用于重要通知消息，例如重要通知邮件、营销短信。</p></li><li><p><strong>异步发送</strong>：异步发送指发送方发出数据后，不等接收方发回响应，接着发送下个数据包，一般用于可能链路耗时较长而对响应时间敏感的业务场景，例如用户视频上传后通知启动转码服务。</p></li><li><p><strong>单向发送</strong>：单向发送是指只负责发送消息而不等待服务器回应且没有回调函数触发，适用于某些耗时非常短但对可靠性要求并不高的场景，例如日志收集。</p></li></ul><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>消息消费者，负责消费消息，一般是后台系统负责异步消费。</p><p><strong>Consumer</strong>也由用户部署，支持PUSH和PULL两种消费模式，支持<strong>集群消费</strong>和<strong>广播消费</strong>，提供<strong>实时的消息订阅机制</strong>。</p><p><strong>Pull</strong>：拉取型消费者（Pull Consumer）主动从消息服务器拉取信息，只要批量拉取到消息，用户应用就会启动消费过程，所以 Pull 称为主动消费型。</p><p><strong>Push</strong>：推送型消费者（Push Consumer）封装了消息的拉取、消费进度和其他的内部维护工作，将消息到达时执行的回调接口留给用户应用程序来实现。所以 Push  称为被动消费类型，但其实从实现上看还是从消息服务器中拉取消息，不同于 Pull 的是 Push  首先要注册消费监听器，当监听器处触发后才开始消费消息。</p><h2 id="9-如何保证消息的可用性-x2F-可靠性-x2F-不丢失呢？"><a href="#9-如何保证消息的可用性-x2F-可靠性-x2F-不丢失呢？" class="headerlink" title="9.如何保证消息的可用性&#x2F;可靠性&#x2F;不丢失呢？"></a>9.如何保证消息的可用性&#x2F;可靠性&#x2F;不丢失呢？</h2><p>消息可能在哪些阶段丢失呢？可能会在这三个阶段发生丢失：生产阶段、存储阶段、消费阶段。</p><p>所以要从这三个阶段考虑：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359190120-cd05abf5-5cbc-4ff1-9cca-7a1d3ba734a5.png" alt="img"></p><h3 id="生产"><a href="#生产" class="headerlink" title="生产"></a>生产</h3><p>在生产阶段，主要<strong>通过请求确认机制，来保证消息的可靠传递</strong>。</p><p>1、同步发送的时候，要注意处理响应结果和异常。如果返回响应OK，表示消息成功发送到了Broker，如果响应失败，或者发生其它异常，都应该重试。</p><p>2、异步发送的时候，应该在回调方法里检查，如果发送失败或者异常，都应该进行重试。</p><p>3、如果发生超时的情况，也可以通过查询日志的API，来检查是否在Broker存储成功。</p><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>存储阶段，可以通过<strong>配置可靠性优先的 Broker 参数来避免因为宕机丢消息</strong>，简单说就是可靠性优先的场景都应该使用同步。</p><p>1、消息只要持久化到CommitLog（日志文件）中，即使Broker宕机，未消费的消息也能重新恢复再消费。</p><p>2、Broker的刷盘机制：同步刷盘和异步刷盘，不管哪种刷盘都可以保证消息一定存储在pagecache中（内存中），但是同步刷盘更可靠，它是Producer发送消息后等数据持久化到磁盘之后再返回响应给Producer。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359192104-4a1ec703-951a-4b93-ac96-6e4472062522.png" alt="img"></p><p>3、Broker通过主从模式来保证高可用，Broker支持Master和Slave同步复制、Master和Slave异步复制模式，生产者的消息都是发送给Master，但是消费既可以从Master消费，也可以从Slave消费。同步复制模式可以保证即使Master宕机，消息肯定在Slave中有备份，保证了消息不会丢失。</p><h3 id="消费"><a href="#消费" class="headerlink" title="消费"></a>消费</h3><p>从Consumer角度分析，如何保证消息被成功消费？</p><p>Consumer保证消息成功消费的关键在于确认的时机，不要在收到消息后就立即发送消费确认，而是应该在执行完所有消费业务逻辑之后，再发送消费确认。因为消息队列维护了消费的位置，逻辑执行失败了，没有确认，再去队列拉取消息，就还是之前的一条。</p><h2 id="10-如何处理消息重复的问题呢？"><a href="#10-如何处理消息重复的问题呢？" class="headerlink" title="10.如何处理消息重复的问题呢？"></a>10.如何处理消息重复的问题呢？</h2><p>对分布式消息队列来说，同时做到确保一定投递和不重复投递是很难的，就是所谓的“有且仅有一次” 。RocketMQ择了确保一定投递，保证消息不丢失，但有可能造成消息重复。</p><p>处理消息重复问题，主要有业务端自己保证，主要的方式有两种：<strong>业务幂等</strong>和<strong>消息去重</strong>。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359194545-38e2fc62-e242-4714-9dbe-e010f4c514ac.png" alt="img"></p><p><strong>业务幂等</strong>：第一种是保证消费逻辑的幂等性，也就是多次调用和一次调用的效果是一样的。这样一来，不管消息消费多少次，对业务都没有影响。</p><p><strong>消息去重</strong>：第二种是业务端，对重复的消息就不再消费了。这种方法，需要保证每条消息都有一个惟一的编号，通常是业务相关的，比如订单号，消费的记录需要落库，而且需要保证和消息确认这一步的原子性。</p><p>具体做法是可以建立一个消费记录表，拿到这个消息做数据库的insert操作。给这个消息做一个唯一主键（primary key）或者唯一约束，那么就算出现重复消费的情况，就会导致主键冲突，那么就不再处理这条消息。</p><h2 id="11-怎么处理消息积压？"><a href="#11-怎么处理消息积压？" class="headerlink" title="11.怎么处理消息积压？"></a>11.怎么处理消息积压？</h2><p>发生了消息积压，这时候就得想办法赶紧把积压的消息消费完，就得考虑提高消费能力，一般有两种办法：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359196580-c164266a-ce5b-4bbc-97c7-ecce1f7cc35f.png" alt="img"></p><p><strong>消费者扩容</strong>：如果当前Topic的Message Queue的数量大于消费者数量，就可以对消费者进行扩容，增加消费者，来提高消费能力，尽快把积压的消息消费玩。</p><p><strong>消息迁移Queue扩容</strong>：如果当前Topic的Message Queue的数量小于或者等于消费者数量，这种情况，再扩容消费者就没什么用，就得考虑扩容Message Queue。可以新建一个临时的Topic，临时的Topic多设置一些Message Queue，然后先用一些消费者把消费的数据丢到临时的Topic，因为不用业务处理，只是转发一下消息，还是很快的。接下来用扩容的消费者去消费新的Topic里的数据，消费完了之后，恢复原状。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359198415-42dd42e6-bbd8-4b7c-a498-c889219df6f8.png" alt="img"></p><h2 id="12-顺序消息如何实现？"><a href="#12-顺序消息如何实现？" class="headerlink" title="12.顺序消息如何实现？"></a>12.顺序消息如何实现？</h2><p>顺序消息是指消息的消费顺序和产生顺序相同，在有些业务逻辑下，必须保证顺序，比如订单的生成、付款、发货，这个消息必须按顺序处理才行。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359200581-ba4eb743-8950-4666-a61a-523add132754.png" alt="img"></p><p>顺序消息分为全局顺序消息和部分顺序消息，全局顺序消息指某个 Topic 下的所有消息都要保证顺序；</p><p>部分顺序消息只要保证每一组消息被顺序消费即可，比如订单消息，只要保证同一个订单 ID 个消息能按顺序消费即可。</p><h3 id="部分顺序消息"><a href="#部分顺序消息" class="headerlink" title="部分顺序消息"></a>部分顺序消息</h3><p>部分顺序消息相对比较好实现，生产端需要做到把同 ID 的消息发送到同一个 Message Queue ；在消费过程中，要做到从同一个Message Queue读取的消息顺序处理——消费端不能并发处理顺序消息，这样才能达到部分有序。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359202404-12beaa34-9459-40f3-87d6-e068c2563989.png" alt="img"></p><p>发送端使用 MessageQueueSelector 类来控制 把消息发往哪个 Message Queue 。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359205695-4636e123-1762-44e0-8040-2a97c9fdaa75.png" alt="img"></p><p>消费端通过使用 MessageListenerOrderly 来解决单 Message Queue 的消息被并发处理的问题。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359208290-2b33ce57-caee-4580-b37c-dc313add0e3e.png" alt="img"></p><h3 id="全局顺序消息"><a href="#全局顺序消息" class="headerlink" title="全局顺序消息"></a>全局顺序消息</h3><p>RocketMQ 默认情况下不保证顺序，比如创建一个 Topic ，默认八个写队列，八个读队列，这时候一条消息可能被写入任意一个队列里；在数据的读取过程中，可能有多个 Consumer ，每个 Consumer 也可能启动多个线程并行处理，所以消息被哪个 Consumer 消费，被消费的顺序和写人的顺序是否一致是不确定的。</p><p>要保证全局顺序消息， 需要先把 Topic 的读写队列数设置为 一，然后Producer Consumer 的并发设置，也要是一。简单来说，为了保证整个 Topic全局消息有序，只能消除所有的并发处理，各部分都设置成单线程处理 ，这时候就完全牺牲RocketMQ的高并发、高吞吐的特性了。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359212345-344587ec-2e2e-450f-a9fa-3226819dee71.png" alt="img"></p><h2 id="13-如何实现消息过滤？"><a href="#13-如何实现消息过滤？" class="headerlink" title="13.如何实现消息过滤？"></a>13.如何实现消息过滤？</h2><p>有两种方案：</p><p>一种是在 Broker 端按照 Consumer 的去重逻辑进行过滤，这样做的好处是避免了无用的消息传输到 Consumer 端，缺点是加重了 Broker 的负担，实现起来相对复杂。</p><p>另一种是在 Consumer 端过滤，比如按照消息设置的 tag 去重，这样的好处是实现起来简单，缺点是有大量无用的消息到达了 Consumer 端只能丢弃不处理。</p><p>一般采用Cosumer端过滤，如果希望提高吞吐量，可以采用Broker过滤。</p><p>对消息的过滤有三种方式：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359214329-a61e7454-af35-46ab-8320-92766903ea97.png" alt="img"></p><p>根据Tag过滤：这是最常见的一种，用起来高效简单</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">DefaultMQPushConsumer</span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPushConsumer</span><span class="token punctuation">(</span><span class="token string">"CID_EXAMPLE"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"TOPIC"</span><span class="token punctuation">,</span> <span class="token string">"TAGA || TAGB || TAGC"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>SQL 表达式过滤：SQL表达式过滤更加灵活</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">DefaultMQPushConsumer</span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPushConsumer</span><span class="token punctuation">(</span><span class="token string">"please_rename_unique_group_name_4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 只有订阅的消息有这个属性a, a >=0 and a &lt;= 3</span>consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"TopicTest"</span><span class="token punctuation">,</span> <span class="token class-name">MessageSelector</span><span class="token punctuation">.</span><span class="token function">bySql</span><span class="token punctuation">(</span><span class="token string">"a between 0 and 3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>consumer<span class="token punctuation">.</span><span class="token function">registerMessageListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MessageListenerConcurrently</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token class-name">ConsumeConcurrentlyStatus</span> <span class="token function">consumeMessage</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageExt</span><span class="token punctuation">></span></span> msgs<span class="token punctuation">,</span> <span class="token class-name">ConsumeConcurrentlyContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">return</span> <span class="token class-name">ConsumeConcurrentlyStatus</span><span class="token punctuation">.</span><span class="token constant">CONSUME_SUCCESS</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Filter Server 方式：最灵活，也是最复杂的一种方式，允许用户自定义函数进行过滤</p><h2 id="14-延时消息了解吗？"><a href="#14-延时消息了解吗？" class="headerlink" title="14.延时消息了解吗？"></a>14.延时消息了解吗？</h2><p>电商的订单超时自动取消，就是一个典型的利用延时消息的例子，用户提交了一个订单，就可以发送一个延时消息，1h后去检查这个订单的状态，如果还是未付款就取消订单释放库存。</p><p>RocketMQ是支持延时消息的，只需要在生产消息的时候设置消息的延时级别：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 实例化一个生产者来产生延时消息</span><span class="token class-name">DefaultMQProducer</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">"ExampleProducerGroup"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 启动生产者</span>producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> totalMessagesToSend <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> totalMessagesToSend<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Message</span> message <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"TestTopic"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"Hello scheduled message "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 设置延时等级3,这个消息将在10s之后发送(现在只支持固定的几个时间,详看delayTimeLevel)</span>    message<span class="token punctuation">.</span><span class="token function">setDelayTimeLevel</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 发送消息</span>    producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是目前RocketMQ支持的延时级别是有限的：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">String</span> messageDelayLevel <span class="token operator">=</span> <span class="token string">"1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="RocketMQ怎么实现延时消息的？"><a href="#RocketMQ怎么实现延时消息的？" class="headerlink" title="RocketMQ怎么实现延时消息的？"></a>RocketMQ怎么实现延时消息的？</h3><p>简单，八个字：<code>临时存储</code>+<code>定时任务</code>。</p><p>Broker收到延时消息了，会先发送到主题（SCHEDULE_TOPIC_XXXX）的相应时间段的Message Queue中，然后通过一个定时任务轮询这些队列，到期后，把消息投递到目标Topic的队列中，然后消费者就可以正常消费这些消息。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359217644-ab2e499c-fc34-4902-a9ec-7e5375844ffd.png" alt="img"></p><h2 id="15-怎么实现分布式消息事务的？半消息？"><a href="#15-怎么实现分布式消息事务的？半消息？" class="headerlink" title="15.怎么实现分布式消息事务的？半消息？"></a>15.怎么实现分布式消息事务的？半消息？</h2><p>半消息：是指暂时还不能被 Consumer 消费的消息，Producer 成功发送到 Broker 端的消息，但是此消息被标记为 “暂不可投递” 状态，只有等 Producer 端执行完本地事务后经过二次确认了之后，Consumer 才能消费此条消息。</p><p>依赖半消息，可以实现分布式消息事务，其中的关键在于二次确认以及消息回查：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359220511-cea8e30e-d5e8-48c3-9050-a49d5e75654e.png" alt="img"></p><p>1、Producer 向 broker 发送半消息</p><p>2、Producer 端收到响应，消息发送成功，此时消息是半消息，标记为 “不可投递” 状态，Consumer 消费不了。</p><p>3、Producer 端执行本地事务。</p><p>4、正常情况本地事务执行完成，Producer 向 Broker 发送 Commit&#x2F;Rollback，如果是 Commit，Broker 端将半消息标记为正常消息，Consumer 可以消费，如果是 Rollback，Broker 丢弃此消息。</p><p>5、异常情况，Broker 端迟迟等不到二次确认。在一定时间后，会查询所有的半消息，然后到 Producer 端查询半消息的执行情况。</p><p>6、Producer 端查询本地事务的状态</p><p>7、根据事务的状态提交 commit&#x2F;rollback 到 broker 端。（5，6，7 是消息回查）</p><p>8、消费者段消费到消息之后，执行本地事务，执行本地事务。</p><h2 id="16-死信队列知道吗？"><a href="#16-死信队列知道吗？" class="headerlink" title="16.死信队列知道吗？"></a>16.死信队列知道吗？</h2><p>死信队列用于处理无法被正常消费的消息，即死信消息。</p><p>当一条消息初次消费失败，<strong>消息队列 RocketMQ 会自动进行消息重试</strong>；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列 RocketMQ 不会立刻将消息丢弃，而是将其发送到该<strong>消费者对应的特殊队列中</strong>，该特殊队列称为<strong>死信队列</strong>。</p><p><strong>死信消息的特点</strong>：</p><ul><li><p>不会再被消费者正常消费。</p></li><li><p>有效期与正常消息相同，均为 3 天，3 天后会被自动删除。因此，需要在死信消息产生后的 3 天内及时处理。</p></li></ul><p><strong>死信队列的特点</strong>：</p><ul><li><p>一个死信队列对应一个 Group ID， 而不是对应单个消费者实例。</p></li><li><p>如果一个 Group ID 未产生死信消息，消息队列 RocketMQ 不会为其创建相应的死信队列。</p></li><li><p>一个死信队列包含了对应 Group ID 产生的所有死信消息，不论该消息属于哪个 Topic。</p></li></ul><p>RocketMQ 控制台提供对死信消息的查询、导出和重发的功能。</p><h2 id="17-如何保证RocketMQ的高可用？"><a href="#17-如何保证RocketMQ的高可用？" class="headerlink" title="17.如何保证RocketMQ的高可用？"></a>17.如何保证RocketMQ的高可用？</h2><p>NameServer因为是无状态，且不相互通信的，所以只要集群部署就可以保证高可用。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359223269-a8f56974-097e-4cca-9c9a-b72c40ebb7cc.png" alt="img"></p><p>RocketMQ的高可用主要是在体现在Broker的读和写的高可用，Broker的高可用是通过<code>集群</code>和<code>主从</code>实现的。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359224841-e25a59bd-fda2-40d8-ae7a-809ab2197bce.png" alt="img"></p><p>Broker可以配置两种角色：Master和Slave，Master角色的Broker支持读和写，Slave角色的Broker只支持读，Master会向Slave同步消息。</p><p>也就是说Producer只能向Master角色的Broker写入消息，Cosumer可以从Master和Slave角色的Broker读取消息。</p><p>Consumer 的配置文件中，并不需要设置是从 Master 读还是从 Slave读，当 Master 不可用或者繁忙的时候， Consumer 的读请求会被自动切换到从 Slave。有了自动切换 Consumer 这种机制，当一个 Master 角色的机器出现故障后，Consumer 仍然可以从 Slave 读取消息，不影响 Consumer 读取消息，这就实现了读的高可用。</p><p>如何达到发送端写的高可用性呢？在创建 Topic 的时候，把 Topic 的多个Message Queue 创建在多个 Broker 组上（相同 Broker 名称，不同 brokerId机器组成 Broker 组），这样当 Broker 组的 Master 不可用后，其他组Master 仍然可用， Producer 仍然可以发送消息 RocketMQ 目前还不支持把Slave自动转成 Master ，如果机器资源不足，需要把 Slave 转成 Master ，则要手动停止 Slave 色的 Broker ，更改配置文件，用新的配置文件启动 Broker。</p><h2 id="18-说一下RocketMQ的整体工作流程？"><a href="#18-说一下RocketMQ的整体工作流程？" class="headerlink" title="18.说一下RocketMQ的整体工作流程？"></a>18.说一下RocketMQ的整体工作流程？</h2><p>简单来说，RocketMQ是一个分布式消息队列，也就是<code>消息队列</code>+<code>分布式系统</code>。</p><p>作为消息队列，它是<code>发</code>-<code>存</code>-<code>收</code>的一个模型，对应的就是Producer、Broker、Cosumer；作为分布式系统，它要有服务端、客户端、注册中心，对应的就是Broker、Producer&#x2F;Consumer、NameServer</p><p>所以我们看一下它主要的工作流程：RocketMQ由NameServer注册中心集群、Producer生产者集群、Consumer消费者集群和若干Broker（RocketMQ进程）组成：</p><p>1、Broker在启动的时候去向所有的NameServer注册，并保持长连接，每30s发送一次心跳</p><p>2、Producer在发送消息的时候从NameServer获取Broker服务器地址，根据负载均衡算法选择一台服务器来发送消息</p><p>3、Conusmer消费消息的时候同样从NameServer获取Broker地址，然后主动拉取消息来消费</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359227662-0db278bf-ebd6-4d8b-8341-4589d19f9c69.png" alt="img"></p><h2 id="19-为什么RocketMQ不使用Zookeeper作为注册中心呢？"><a href="#19-为什么RocketMQ不使用Zookeeper作为注册中心呢？" class="headerlink" title="19.为什么RocketMQ不使用Zookeeper作为注册中心呢？"></a>19.为什么RocketMQ不使用Zookeeper作为注册中心呢？</h2><p>Kafka我们都知道采用Zookeeper作为注册中心——当然也开始逐渐去Zookeeper，RocketMQ不使用Zookeeper其实主要可能从这几方面来考虑：</p><p>1、基于可用性的考虑，根据CAP理论，同时最多只能满足两个点，而Zookeeper满足的是CP，也就是说Zookeeper并不能保证服务的可用性，Zookeeper在进行选举的时候，整个选举的时间太长，期间整个集群都处于不可用的状态，而这对于一个注册中心来说肯定是不能接受的，作为服务发现来说就应该是为可用性而设计。</p><p>2、基于性能的考虑，NameServer本身的实现非常轻量，而且可以通过增加机器的方式水平扩展，增加集群的抗压能力，而Zookeeper的写是不可扩展的，Zookeeper要解决这个问题只能通过划分领域，划分多个Zookeeper集群来解决，首先操作起来太复杂，其次这样还是又违反了CAP中的A的设计，导致服务之间是不连通的。</p><p>3、持久化的机制来带的问题，ZooKeeper 的 ZAB 协议对每一个写请求，会在每个 ZooKeeper  节点上保持写一个事务日志，同时再加上定期的将内存数据镜像（Snapshot）到磁盘来保证数据的一致性和持久性，而对于一个简单的服务发现的场景来说，这其实没有太大的必要，这个实现方案太重了。而且本身存储的数据应该是高度定制化的。</p><p>4、消息发送应该弱依赖注册中心，而RocketMQ的设计理念也正是基于此，生产者在第一次发送消息的时候从NameServer获取到Broker地址后缓存到本地，如果NameServer整个集群不可用，短时间内对于生产者和消费者并不会产生太大影响。</p><h2 id="20-Broker是怎么保存数据的呢？"><a href="#20-Broker是怎么保存数据的呢？" class="headerlink" title="20.Broker是怎么保存数据的呢？"></a>20.Broker是怎么保存数据的呢？</h2><p>RocketMQ主要的存储文件包括CommitLog文件、ConsumeQueue文件、Indexfile文件。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359230215-486d2245-af30-438d-93db-bd713bfdd630.png" alt="img"></p><p>消息存储的整体的设计：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359231903-b174af69-d891-485a-b3d1-fa4ecfb1db6b.png" alt="img"></p><p><strong>CommitLog</strong>：消息主体以及元数据的存储主体，存储Producer端写入的消息主体内容,消息内容不是定长的。单个文件大小默认1G, 文件名长度为20位，左边补零，剩余为起始偏移量，比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G&#x3D;1073741824；当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是顺序写入日志文件，当文件满了，写入下一个文件。</p><p>CommitLog文件保存于${Rocket_Home}&#x2F;store&#x2F;commitlog目录中，从图中我们可以明显看出来文件名的偏移量，每个文件默认1G，写满后自动生成一个新的文件。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359234946-8ed9b4d6-a493-4e41-b347-86824324c40d.png" alt="img"></p><p><strong>ConsumeQueue</strong>：消息消费队列，引入的目的主要是提高消息消费的性能，由于RocketMQ是基于主题topic的订阅模式，消息消费是针对主题进行的，如果要遍历commitlog文件中根据topic检索消息是非常低效的。</p><p>Consumer即可根据ConsumeQueue来查找待消费的消息。其中，ConsumeQueue（逻辑消费队列）作为消费消息的索引，保存了指定Topic下的队列消息在CommitLog中的起始物理偏移量offset，消息大小size和消息Tag的HashCode值。</p><p>ConsumeQueue文件可以看成是基于Topic的CommitLog索引文件，故ConsumeQueue文件夹的组织方式如下：topic&#x2F;queue&#x2F;file三层组织结构，具体存储路径为：$HOME&#x2F;store&#x2F;consumequeue&#x2F;{topic}&#x2F;{queueId}&#x2F;{fileName}。同样ConsumeQueue文件采取定长设计，每一个条目共20个字节，分别为8字节的CommitLog物理偏移量、4字节的消息长度、8字节tag hashcode，单个文件由30W个条目组成，可以像数组一样随机访问每一个条目，每个ConsumeQueue文件大小约5.72M；</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359236891-39f0b816-a08a-40d1-bb6b-6dcab4a8939f.png" alt="img"></p><p><strong>IndexFile</strong>：IndexFile（索引文件）提供了一种可以通过key或时间区间来查询消息的方法。Index文件的存储位置是：{fileName}，文件名fileName是以创建时的时间戳命名的，固定的单个IndexFile文件大小约为400M，一个IndexFile可以保存 2000W个索引，IndexFile的底层存储设计为在文件系统中实现HashMap结构，故RocketMQ的索引文件其底层实现为hash索引。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359238628-3dd1013d-9938-4e2a-9dbf-c567485913fa.png" alt="img"></p><p>总结一下：RocketMQ采用的是混合型的存储结构，即为Broker单个实例下所有的队列共用一个日志数据文件（即为CommitLog）来存储。</p><p>RocketMQ的混合型存储结构(多个Topic的消息实体内容都存储于一个CommitLog中)针对Producer和Consumer分别采用了数据和索引部分相分离的存储结构，Producer发送消息至Broker端，然后Broker端使用同步或者异步的方式对消息刷盘持久化，保存至CommitLog中。</p><p>只要消息被刷盘持久化至磁盘文件CommitLog中，那么Producer发送的消息就不会丢失。正因为如此，Consumer也就肯定有机会去消费这条消息。当无法拉取到消息后，可以等下一次消息拉取，同时服务端也支持长轮询模式，如果一个消息拉取请求未拉取到消息，Broker允许等待30s的时间，只要这段时间内有新消息到达，将直接返回给消费端。</p><p>这里，RocketMQ的具体做法是，使用Broker端的后台服务线程—ReputMessageService不停地分发请求并异步构建ConsumeQueue（逻辑消费队列）和IndexFile（索引文件）数据。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359241134-f3b4a4e9-c23c-4cff-b6b5-b8fa605949d2.png" alt="img"></p><h2 id="21-说说RocketMQ怎么对文件进行读写的？"><a href="#21-说说RocketMQ怎么对文件进行读写的？" class="headerlink" title="21.说说RocketMQ怎么对文件进行读写的？"></a>21.说说RocketMQ怎么对文件进行读写的？</h2><p>RocketMQ对文件的读写巧妙地利用了操作系统的一些高效文件读写方式——<code>PageCache</code>、<code>顺序读写</code>、<code>零拷贝</code>。</p><p><strong>PageCache、顺序读取</strong></p><p>在RocketMQ中，ConsumeQueue逻辑消费队列存储的数据较少，并且是顺序读取，在page cache机制的预读取作用下，Consume Queue文件的读性能几乎接近读内存，即使在有消息堆积情况下也不会影响性能。而对于CommitLog消息存储的日志数据文件来说，读取消息内容时候会产生较多的随机访问读取，严重影响性能。如果选择合适的系统IO调度算法，比如设置调度算法为“Deadline”（此时块存储采用SSD的话），随机读的性能也会有所提升。</p><p>页缓存（PageCache)是OS对文件的缓存，用于加速对文件的读写。一般来说，程序对文件进行顺序读写的速度几乎接近于内存的读写速度，主要原因就是由于OS使用PageCache机制对读写访问操作进行了性能优化，将一部分的内存用作PageCache。对于数据的写入，OS会先写入至Cache内，随后通过异步的方式由pdflush内核线程将Cache内的数据刷盘至物理磁盘上。对于数据的读取，如果一次读取文件时出现未命中PageCache的情况，OS从物理磁盘上访问读取文件的同时，会顺序对其他相邻块的数据文件进行预读取。</p><p><strong>零拷贝</strong></p><p>另外，RocketMQ主要通过MappedByteBuffer对文件进行读写操作。其中，利用了NIO中的FileChannel模型将磁盘上的物理文件直接映射到用户态的内存地址中（这种Mmap的方式减少了传统IO，将磁盘文件数据在操作系统内核地址空间的缓冲区，和用户应用程序地址空间的缓冲区之间来回进行拷贝的性能开销），将对文件的操作转化为直接对内存地址进行操作，从而极大地提高了文件的读写效率（正因为需要使用内存映射机制，故RocketMQ的文件存储都使用定长结构来存储，方便一次将整个文件映射至内存）。</p><h3 id="说说什么是零拷贝"><a href="#说说什么是零拷贝" class="headerlink" title="说说什么是零拷贝?"></a>说说什么是零拷贝?</h3><p>在操作系统中，使用传统的方式，数据需要经历几次拷贝，还要经历用户态&#x2F;内核态切换。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359243905-a1ba76e4-eef1-4b9b-ba93-e0a6ab26e894.png" alt="img"></p><p>1、从磁盘复制数据到内核态内存；</p><p>2、从内核态内存复制到用户态内存；</p><p>3、然后从用户态内存复制到网络驱动的内核态内存；</p><p>4、最后是从网络驱动的内核态内存复制到网卡中进行传输。</p><p>所以，可以通过零拷贝的方式，<strong>减少用户态与内核态的上下文切换</strong>和<strong>内存拷贝的次数</strong>，用来提升I&#x2F;O的性能。零拷贝比较常见的实现方式是<strong>mmap</strong>，这种机制在Java中是通过MappedByteBuffer实现的。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359245898-8701ce0e-882e-47e4-a3fd-1a16b44779d1.png" alt="img"></p><h2 id="22-消息刷盘怎么实现的呢？"><a href="#22-消息刷盘怎么实现的呢？" class="headerlink" title="22.消息刷盘怎么实现的呢？"></a>22.消息刷盘怎么实现的呢？</h2><p>RocketMQ提供了两种刷盘策略：同步刷盘和异步刷盘</p><ul><li><p>同步刷盘：在消息达到Broker的内存之后，必须刷到commitLog日志文件中才算成功，然后返回Producer数据已经发送成功。</p></li><li><p>异步刷盘：异步刷盘是指消息达到Broker内存后就返回Producer数据已经发送成功，会唤醒一个线程去将数据持久化到CommitLog日志文件中。</p></li></ul><p><strong>Broker</strong> 在消息的存取时直接操作的是内存（内存映射文件），这可以提供系统的吞吐量，但是无法避免机器掉电时数据丢失，所以需要持久化到磁盘中。</p><p>刷盘的最终实现都是使用<strong>NIO</strong>中的 MappedByteBuffer.force() 将映射区的数据写入到磁盘，如果是同步刷盘的话，在<strong>Broker</strong>把消息写到<strong>CommitLog</strong>映射区后，就会等待写入完成。</p><p>异步而言，只是唤醒对应的线程，不保证执行的时机，流程如图所示。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359248522-52a49716-d3c4-41fc-b4b0-4006fc0d3724.png" alt="img"></p><h2 id="22-能说下-RocketMQ-的负载均衡是如何实现的？"><a href="#22-能说下-RocketMQ-的负载均衡是如何实现的？" class="headerlink" title="22.能说下 RocketMQ 的负载均衡是如何实现的？"></a>22.能说下 RocketMQ 的负载均衡是如何实现的？</h2><p>RocketMQ中的负载均衡都在Client端完成，具体来说的话，主要可以分为Producer端发送消息时候的负载均衡和Consumer端订阅消息的负载均衡。</p><h3 id="Producer的负载均衡"><a href="#Producer的负载均衡" class="headerlink" title="Producer的负载均衡"></a>Producer的负载均衡</h3><p>Producer端在发送消息的时候，会先根据Topic找到指定的TopicPublishInfo，在获取了TopicPublishInfo路由信息后，RocketMQ的客户端在默认方式下selectOneMessageQueue()方法会从TopicPublishInfo中的messageQueueList中选择一个队列（MessageQueue）进行发送消息。具这里有一个sendLatencyFaultEnable开关变量，如果开启，在随机递增取模的基础上，再过滤掉not available的Broker代理。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359250717-7c451bff-93c7-44c5-b548-201d2601123e.png" alt="img"></p><p>所谓的”latencyFaultTolerance”，是指对之前失败的，按一定的时间做退避。例如，如果上次请求的latency超过550Lms，就退避3000Lms；超过1000L，就退避60000L；如果关闭，采用随机递增取模的方式选择一个队列（MessageQueue）来发送消息，latencyFaultTolerance机制是实现消息发送高可用的核心关键所在。</p><h3 id="Consumer的负载均衡"><a href="#Consumer的负载均衡" class="headerlink" title="Consumer的负载均衡"></a>Consumer的负载均衡</h3><p>在RocketMQ中，Consumer端的两种消费模式（Push&#x2F;Pull）都是基于拉模式来获取消息的，而在Push模式只是对pull模式的一种封装，其本质实现为消息拉取线程在从服务器拉取到一批消息后，然后提交到消息消费线程池后，又“马不停蹄”的继续向服务器再次尝试拉取消息。如果未拉取到消息，则延迟一下又继续拉取。在两种基于拉模式的消费方式（Push&#x2F;Pull）中，均需要Consumer端知道从Broker端的哪一个消息队列中去获取消息。因此，有必要在Consumer端来做负载均衡，即Broker端中多个MessageQueue分配给同一个ConsumerGroup中的哪些Consumer消费。</p><p><strong>1、Consumer端的心跳包发送</strong></p><p>在Consumer启动后，它就会通过定时任务不断地向RocketMQ集群中的所有Broker实例发送心跳包（其中包含了，消息消费分组名称、订阅关系集合、消息通信模式和客户端id的值等信息）。Broker端在收到Consumer的心跳消息后，会将它维护在ConsumerManager的本地缓存变量—consumerTable，同时并将封装后的客户端网络通道信息保存在本地缓存变量—channelInfoTable中，为之后做Consumer端的负载均衡提供可以依据的元数据信息。</p><p><strong>2、Consumer端实现负载均衡的核心类—RebalanceImpl</strong></p><p>在Consumer实例的启动流程中的启动MQClientInstance实例部分，会完成负载均衡服务线程—RebalanceService的启动（每隔20s执行一次）。</p><p>通过查看源码可以发现，RebalanceService线程的run()方法最终调用的是RebalanceImpl类的rebalanceByTopic()方法，这个方法是实现Consumer端负载均衡的核心。</p><p>rebalanceByTopic()方法会根据消费者通信类型为“广播模式”还是“集群模式”做不同的逻辑处理。这里主要来看下集群模式下的主要处理流程：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359253301-75a66669-1976-4d95-84d2-14241cb6e13e.png" alt="img"></p><p>(1) 从rebalanceImpl实例的本地缓存变量—topicSubscribeInfoTable中，获取该Topic主题下的消息消费队列集合（mqSet）；</p><p>(2) 根据topic和consumerGroup为参数调用mQClientFactory.findConsumerIdList()方法向Broker端发送通信请求，获取该消费组下消费者Id列表；</p><p>(3) 先对Topic下的消息消费队列、消费者Id排序，然后用消息队列分配策略算法（默认为：消息队列的平均分配算法），计算出待拉取的消息队列。这里的平均分配算法，类似于分页的算法，将所有MessageQueue排好序类似于记录，将所有消费端Consumer排好序类似页数，并求出每一页需要包含的平均size和每个页面记录的范围range，最后遍历整个range而计算出当前Consumer端应该分配到的的MessageQueue。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359256179-f339ffb3-f3d9-4b8c-9d4f-2654819fd61a.png" alt="img"></p><p>(4) 然后，调用updateProcessQueueTableInRebalance()方法，具体的做法是，先将分配到的消息队列集合（mqSet）与processQueueTable做一个过滤比对。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359257791-31409212-1308-4f02-90a6-9f0f2d511f90.png" alt="img"></p><p>上图中processQueueTable标注的红色部分，表示与分配到的消息队列集合mqSet互不包含。将这些队列设置Dropped属性为true，然后查看这些队列是否可以移除出processQueueTable缓存变量，这里具体执行removeUnnecessaryMessageQueue()方法，即每隔1s 查看是否可以获取当前消费处理队列的锁，拿到的话返回true。如果等待1s后，仍然拿不到当前消费处理队列的锁则返回false。如果返回true，则从processQueueTable缓存变量中移除对应的Entry；</p><p>上图中processQueueTable的绿色部分，表示与分配到的消息队列集合mqSet的交集。判断该ProcessQueue是否已经过期了，在Pull模式的不用管，如果是Push模式的，设置Dropped属性为true，并且调用removeUnnecessaryMessageQueue()方法，像上面一样尝试移除Entry；</p><p>最后，为过滤后的消息队列集合（mqSet）中的每个MessageQueue创建一个ProcessQueue对象并存入RebalanceImpl的processQueueTable队列中（其中调用RebalanceImpl实例的computePullFromWhere(MessageQueue mq)方法获取该MessageQueue对象的下一个进度消费值offset，随后填充至接下来要创建的pullRequest对象属性中），并创建拉取请求对象—pullRequest添加到拉取列表—pullRequestList中，最后执行dispatchPullRequest()方法，将Pull消息的请求对象PullRequest依次放入PullMessageService服务线程的阻塞队列pullRequestQueue中，待该服务线程取出后向Broker端发起Pull消息的请求。其中，可以重点对比下，RebalancePushImpl和RebalancePullImpl两个实现类的dispatchPullRequest()方法不同，RebalancePullImpl类里面的该方法为空。</p><p>消息消费队列在同一消费组不同消费者之间的负载均衡，其核心设计理念是在一个消息消费队列在同一时间只允许被同一消费组内的一个消费者消费，一个消息消费者能同时消费多个消息队列。</p><h2 id="23-RocketMQ消息长轮询了解吗？"><a href="#23-RocketMQ消息长轮询了解吗？" class="headerlink" title="23.RocketMQ消息长轮询了解吗？"></a>23.RocketMQ消息长轮询了解吗？</h2><p>所谓的长轮询，就是Consumer 拉取消息，如果对应的 Queue 如果没有数据，Broker 不会立即返回，而是把 PullReuqest hold起来，等待 queue 有了消息后，或者长轮询阻塞时间到了，再重新处理该 queue 上的所有 PullRequest。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRocketMQ%E7%AF%87.assets/1676359259857-9f437c03-c4b0-4fa0-9f16-f58dbae2e2be.png" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">PullMessageProcessor#processRequest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//如果没有拉到数据</span><span class="token keyword">case</span> <span class="token class-name">ResponseCode</span><span class="token punctuation">.</span><span class="token constant">PULL_NOT_FOUND</span><span class="token operator">:</span>    <span class="token comment">// broker 和 consumer 都允许 suspend，默认开启</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>brokerAllowSuspend <span class="token operator">&amp;&amp;</span> hasSuspendFlag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">long</span> pollingTimeMills <span class="token operator">=</span> suspendTimeoutMillisLong<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>brokerController<span class="token punctuation">.</span><span class="token function">getBrokerConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isLongPollingEnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            pollingTimeMills <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>brokerController<span class="token punctuation">.</span><span class="token function">getBrokerConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getShortPollingTimeMills</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">String</span> topic <span class="token operator">=</span> requestHeader<span class="token punctuation">.</span><span class="token function">getTopic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> offset <span class="token operator">=</span> requestHeader<span class="token punctuation">.</span><span class="token function">getQueueOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> queueId <span class="token operator">=</span> requestHeader<span class="token punctuation">.</span><span class="token function">getQueueId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//封装一个PullRequest</span>        <span class="token class-name">PullRequest</span> pullRequest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PullRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> channel<span class="token punctuation">,</span> pollingTimeMills<span class="token punctuation">,</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>brokerController<span class="token punctuation">.</span><span class="token function">getMessageStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> offset<span class="token punctuation">,</span> subscriptionData<span class="token punctuation">,</span> messageFilter<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//把PullRequest挂起来</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>brokerController<span class="token punctuation">.</span><span class="token function">getPullRequestHoldService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">suspendPullRequest</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> queueId<span class="token punctuation">,</span> pullRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>        response <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>挂起的请求，有一个服务线程会不停地检查，看queue中是否有数据，或者超时。</p><pre class="line-numbers language-none"><code class="language-none">PullRequestHoldService#run()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125; service started"</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getServiceName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isStopped</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>brokerController<span class="token punctuation">.</span><span class="token function">getBrokerConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isLongPollingEnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">waitForRunning</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">waitForRunning</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>brokerController<span class="token punctuation">.</span><span class="token function">getBrokerConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getShortPollingTimeMills</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">long</span> beginLockTimestamp <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>systemClock<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//检查hold住的请求</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">checkHoldRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">long</span> costTime <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>systemClock<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> beginLockTimestamp<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>costTime <span class="token operator">></span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"[NOTIFYME] check hold request cost &#123;&#125; ms."</span><span class="token punctuation">,</span> costTime<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getServiceName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" service has exception. "</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125; service end"</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getServiceName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-为什么要使用消息队列呢？&quot;&gt;&lt;a href=&quot;#1-为什么要使用消息队列呢？&quot; class=&quot;headerlink&quot; title=&quot;1.为什么要使用消息队列呢？&quot;&gt;&lt;/a&gt;1.为什么要使用消息队列呢？&lt;/h2&gt;&lt;p&gt;消息队列主要有三大用途，我们拿一个电商系统的</summary>
      
    
    
    
    <category term="PROJECT" scheme="https://zspcer.gitee.io/categories/PROJECT/"/>
    
    <category term="我要进大厂" scheme="https://zspcer.gitee.io/categories/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/"/>
    
    
    <category term="面试" scheme="https://zspcer.gitee.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="我要进大厂" scheme="https://zspcer.gitee.io/tags/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/"/>
    
    <category term="RocketMQ" scheme="https://zspcer.gitee.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>大厂面试之Spring篇</title>
    <link href="https://zspcer.gitee.io/note/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87/"/>
    <id>https://zspcer.gitee.io/note/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87/</id>
    <published>2023-05-11T16:37:37.000Z</published>
    <updated>2023-05-11T15:42:17.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Spring是什么？特性？有哪些模块？"><a href="#1-Spring是什么？特性？有哪些模块？" class="headerlink" title="1.Spring是什么？特性？有哪些模块？"></a>1.Spring是什么？特性？有哪些模块？</h2><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357177487-e74a8aab-c1b8-4d91-88f3-eb594d569cb7.jpeg" alt="img"></p><p>一句话概括：<strong>Spring 是一个轻量级、非入侵式的控制反转 (IoC) 和面向切面 (AOP) 的框架。</strong></p><p>2003年，一个音乐家Rod Johnson决定发展一个轻量级的Java开发框架，<code>Spring</code>作为Java战场的龙骑兵渐渐崛起，并淘汰了<code>EJB</code>这个传统的重装骑兵。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357179957-f1f614de-4a6a-43a6-8f8a-a637e5580d6e.png" alt="img"></p><p>到了现在，企业级开发的标配基本就是 <strong>Spring5</strong> + <strong>Spring Boot 2</strong> + <strong>JDK 8</strong></p><p>Spring有哪些特性呢？</p><p>Spring有很多优点：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357181692-9e3bcb90-dbbe-46e5-b637-785b70789212.png" alt="img"></p><p><strong>1、IOC 和 DI 的支持</strong></p><p>Spring 的核心就是一个大的工厂容器，可以维护所有对象的创建和依赖关系，Spring 工厂用于生成 Bean，并且管理 Bean 的生命周期，实现<strong>高内聚低耦合</strong>的设计理念。</p><p><strong>2、AOP 编程的支持</strong></p><p>Spring 提供了<strong>面向切面编程</strong>，可以方便的实现对程序进行权限拦截、运行监控等切面功能。</p><p><strong>3、声明式事务的支持</strong></p><p>支持通过配置就来完成对事务的管理，而不需要通过硬编码的方式，以前重复的一些事务提交、回滚的JDBC代码，都可以不用自己写了。</p><p><strong>4、快捷测试的支持</strong></p><p>Spring 对 Junit 提供支持，可以通过<strong>注解</strong>快捷地测试 Spring 程序。</p><p><strong>5、快速集成功能</strong></p><p>方便集成各种优秀框架，Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis、Quartz 等）的直接支持。</p><p><strong>6、复杂API模板封装</strong></p><p>Spring 对 JavaEE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等）都提供了模板化的封装，这些封装 API 的提供使得应用难度大大降低。</p><h2 id="2-Spring有哪些模块呢？"><a href="#2-Spring有哪些模块呢？" class="headerlink" title="2.Spring有哪些模块呢？"></a>2.Spring有哪些模块呢？</h2><p>Spring 框架是分模块存在，除了最核心的<code>Spring Core Container</code>是必要模块之外，其他模块都是<code>可选</code>，大约有 20 多个模块。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357184035-8ddcdab2-150c-4df8-b3f8-d737f908253f.png" alt="img"></p><p>最主要的七大模块：</p><p>1、<strong>Spring Core</strong>：Spring 核心，它是框架最基础的部分，提供 IOC 和依赖注入 DI 特性。</p><p>2、<strong>Spring Context</strong>：Spring 上下文容器，它是 BeanFactory 功能加强的一个子接口。</p><p>3、<strong>Spring Web</strong>：它提供 Web 应用开发的支持。</p><p>4、<strong>Spring MVC</strong>：它针对 Web 应用中 MVC 思想的实现。</p><p>5、<strong>Spring DAO</strong>：提供对 JDBC 抽象层，简化了 JDBC 编码，同时，编码更具有健壮性。</p><p>6、<strong>Spring ORM</strong>：它支持用于流行的 ORM 框架的整合，比如：Spring + Hibernate、Spring + iBatis、Spring + JDO 的整合等。</p><p>7、<strong>Spring AOP</strong>：即面向切面编程，它提供了与 AOP 联盟兼容的编程实现。</p><h2 id="3-Spring有哪些常用注解呢？"><a href="#3-Spring有哪些常用注解呢？" class="headerlink" title="3.Spring有哪些常用注解呢？"></a>3.Spring有哪些常用注解呢？</h2><p>Spring有很多模块，甚至广义的SpringBoot、SpringCloud也算是Spring的一部分，我们来分模块，按功能来看一下一些常用的注解：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357187738-1abd6ce4-46ba-4794-8470-82c927c1ae0f.png" alt="img"></p><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a><strong>Web</strong></h3><p>@Controller：组合注解（组合了@Component注解），应用在MVC层（控制层）。</p><p>@RestController：该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。</p><p>@RequestMapping：用于映射Web请求，包括访问路径和参数。如果是Restful风格接口，还可以根据请求类型使用不同的注解：</p><ul><li><p><a href="">@GetMapping </a> </p></li><li><p><a href="">@PostMapping </a> </p></li><li><p><a href="">@PutMapping </a> </p></li><li><p><a href="">@DeleteMapping </a></p></li></ul><p>@RequestBody：允许request的参数在request体中，而不是在直接连接在地址后面。</p><p>@PathVariable：用于接收路径参数，比如@RequestMapping(“&#x2F;hello&#x2F;{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。</p><p>@RestController：该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a><strong>容器</strong></h3><p>@Component：表示一个带注释的类是一个“组件”，成为Spring管理的Bean。当使用基于注解的配置和类路径扫描时，这些类被视为自动检测的候选对象。同时@Component还是一个元注解。</p><p>@Service：组合注解（组合了@Component注解），应用在service层（业务逻辑层）。</p><p>@Repository：组合注解（组合了@Component注解），应用在dao层（数据访问层）。</p><p>@Autowired：Spring提供的工具（由Spring的依赖注入工具（BeanPostProcessor、BeanFactoryPostProcessor）自动注入）。</p><p>@Qualifier：该注解通常跟 <a href="">@Autowired </a> 一起使用，当想对注入的过程做更多的控制，<a href="">@Qualifier </a> 可帮助配置，比如两个以上相同类型的 Bean 时 Spring 无法抉择，用到此注解 </p><p>@Configuration：声明当前类是一个配置类（相当于一个Spring配置的xml文件）</p><p>@Value：可用在字段，构造器参数跟方法参数，指定一个默认值，支持 #{} 跟 ${} 两个方式。一般将 SpringbBoot 中的 application.properties 配置的属性值赋值给变量。</p><p>@Bean：注解在方法上，声明当前方法的返回值为一个Bean。返回的Bean对应的类中可以定义init()方法和destroy()方法，然后在@Bean(initMethod&#x3D;”init”,destroyMethod&#x3D;”destroy”)定义，在构造之后执行init，在销毁之前执行destroy。</p><p>@Scope:定义我们采用什么模式去创建Bean（方法上，得有@Bean） 其设置类型包括：Singleton 、Prototype、Request 、 Session、GlobalSession。</p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a><strong>AOP</strong></h3><p>@Aspect:声明一个切面（类上） 使用@After、@Before、@Around定义建言（advice），可直接将拦截规则（切点）作为参数。</p><ul><li><p><code>@After</code> ：在方法执行之后执行（方法上）。</p></li><li><p><code>@Before</code>：在方法执行之前执行（方法上）。</p></li><li><p><code>@Around</code>：在方法执行之前与之后执行（方法上）。</p></li><li><p><code>@PointCut</code>：声明切点 在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持（类上）。</p></li></ul><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a><strong>事务</strong></h3><p>@Transactional：在要开启事务的方法上使用@Transactional注解，即可声明式开启事务。</p><h2 id="4-Spring-中应用了哪些设计模式呢？"><a href="#4-Spring-中应用了哪些设计模式呢？" class="headerlink" title="4.Spring 中应用了哪些设计模式呢？"></a>4.Spring 中应用了哪些设计模式呢？</h2><p>Spring 框架中广泛使用了不同类型的设计模式，下面我们来看看到底有哪些设计模式?</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357192406-64ececfb-ee72-4a54-be04-5c2fe03149f6.png" alt="img"></p><p>1、<strong>工厂模式</strong> : Spring 容器本质是一个大工厂，使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。</p><p>2、<strong>代理模式</strong> : Spring AOP 功能功能就是通过代理模式来实现的，分为动态代理和静态代理。</p><p>3、<strong>单例模式</strong> : Spring 中的 Bean 默认都是单例的，这样有利于容器对Bean的管理。</p><p>4、<strong>模板模式</strong> : Spring 中 JdbcTemplate、RestTemplate 等以 Template结尾的对数据库、网络等等进行操作的模板类，就使用到了模板模式。</p><p>7、<strong>观察者模式</strong>: Spring 事件驱动模型就是观察者模式很经典的一个应用。</p><p>8、<strong>适配器模式</strong> :Spring AOP 的增强或通知 (Advice) 使用到了适配器模式、Spring MVC 中也是用到了适配器模式适配 Controller。</p><p>9、<strong>策略模式</strong>：Spring中有一个Resource接口，它的不同实现类，会根据不同的策略去访问资源。</p><h2 id="5-说一说什么是IOC？什么是DI"><a href="#5-说一说什么是IOC？什么是DI" class="headerlink" title="5.说一说什么是IOC？什么是DI?"></a>5.说一说什么是IOC？什么是DI?</h2><p>Java 是面向对象的编程语言，一个个实例对象相互合作组成了业务逻辑，原来，我们都是在代码里创建对象和对象的依赖。</p><p>所谓的<strong>IOC</strong>（控制反转）：就是由容器来负责控制对象的生命周期和对象间的关系。以前是我们想要什么，就自己创建什么，现在是我们需要什么，容器就给我们送来什么。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357194841-64d29a58-1ab7-4099-a61a-78b2a411729c.png" alt="img"></p><p>也就是说，控制对象生命周期的不再是引用它的对象，而是容器。对具体对象，以前是它控制其它对象，现在所有对象都被容器控制，所以这就叫<strong>控制反转</strong>。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357198913-ca7b165f-37b6-49d3-bf58-06e46eb04c07.png" alt="img"></p><p><strong>DI（依赖注入）</strong>：指的是容器在实例化对象的时候把它依赖的类注入给它。有的说法IOC和DI是一回事，有的说法是IOC是思想，DI是IOC的实现。</p><p><strong>为什么要使用IOC呢？</strong></p><p>最主要的是两个字<strong>解耦</strong>，硬编码会造成对象间的过度耦合，使用IOC之后，我们可以不用关心对象间的依赖，专心开发应用就行。</p><h2 id="6-能简单说一下Spring-IOC的实现机制吗？"><a href="#6-能简单说一下Spring-IOC的实现机制吗？" class="headerlink" title="6.能简单说一下Spring IOC的实现机制吗？"></a>6.能简单说一下Spring IOC的实现机制吗？</h2><p>PS:这道题陈哥在面试中被问到过，问法是“<strong>你有自己实现过简单的Spring吗？</strong>”</p><p>Spring的IOC本质就是一个大工厂，我们想想一个工厂是怎么运行的呢？</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357200807-3f36debf-e563-4119-85ec-0a91d440cffa.png" alt="img"></p><p>1、<strong>生产产品</strong>：一个工厂最核心的功能就是生产产品。在Spring里，不用Bean自己来实例化，而是交给Spring，应该怎么实现呢？——答案毫无疑问，<strong>反射</strong>。</p><p>那么这个厂子的生产管理是怎么做的？你应该也知道——<strong>工厂模式</strong>。</p><p>2、<strong>库存产品</strong>：工厂一般都是有库房的，用来库存产品，毕竟生产的产品不能立马就拉走。Spring我们都知道是一个容器，这个容器里存的就是对象，不能每次来取对象，都得现场来反射创建对象，得把创建出的对象存起来。</p><p>3、<strong>订单处理</strong>：还有最重要的一点，工厂根据什么来提供产品呢？订单。这些订单可能五花八门，有线上签签的、有到工厂签的、还有工厂销售上门签的……最后经过处理，指导工厂的出货。</p><p>在Spring里，也有这样的订单，它就是我们bean的定义和依赖关系，可以是xml形式，也可以是我们最熟悉的注解形式。</p><p>我们简单地实现一个mini版的Spring IOC：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357203134-d7228f43-2e6a-4690-bb9b-1bea0aef147b.png" alt="img"></p><p><strong>Bean定义：</strong></p><p>Bean通过一个配置文件定义，把它解析成一个类型。</p><p><strong>beans.properties</strong></p><p>偷懒，这里直接用了最方便解析的properties，这里直接用一个&lt;key,value&gt;类型的配置来代表Bean的定义，其中key是beanName，value是class</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">userDao<span class="token operator">:</span><span class="token class-name"><span class="token namespace">cn<span class="token punctuation">.</span>fighter3<span class="token punctuation">.</span>bean<span class="token punctuation">.</span></span>UserDao</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>BeanDefinition.java</strong></p><p>bean定义类，配置文件中bean定义对应的实体</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanDefinition</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> beanName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Class</span> beanClass<span class="token punctuation">;</span>     <span class="token comment">//省略getter、setter  </span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>ResourceLoader.java</strong></p><p>资源加载器，用来完成配置文件中配置的加载</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ResourceLoader</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">BeanDefinition</span><span class="token punctuation">></span></span> <span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">BeanDefinition</span><span class="token punctuation">></span></span> beanDefinitionMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Properties</span> properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">InputStream</span> inputStream <span class="token operator">=</span> <span class="token class-name">ResourceLoader</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"/beans.properties"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            properties<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> it <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">stringPropertyNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">String</span> key <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">String</span> className <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">BeanDefinition</span> beanDefinition <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BeanDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                beanDefinition<span class="token punctuation">.</span><span class="token function">setBeanName</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">Class</span> clazz <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span>                beanDefinition<span class="token punctuation">.</span><span class="token function">setBeanClass</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>                beanDefinitionMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> beanDefinition<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            inputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> <span class="token operator">|</span> <span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> beanDefinitionMap<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>BeanRegister.java</strong></p><p>对象注册器，这里用于单例bean的缓存，我们大幅简化，默认所有bean都是单例的。可以看到所谓单例注册，也很简单，不过是往HashMap里存对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanRegister</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//单例Bean缓存</span>    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> singletonMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 获取单例Bean     *     * @param beanName bean名称     * @return     */</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getSingletonBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> singletonMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 注册单例bean     *     * @param beanName     * @param bean     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">registerSingletonBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanName<span class="token punctuation">,</span> <span class="token class-name">Object</span> bean<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        singletonMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> bean<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>BeanFactory.java</strong></p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357206485-ac9fe3ca-909a-4e20-a5ba-9bf6c66d9450.png" alt="img"></p><p>对象工厂，我们最<strong>核心</strong>的一个类，在它初始化的时候，创建了bean注册器，完成了资源的加载。</p><p>获取bean的时候，先从单例缓存中取，如果没有取到，就创建并注册一个bean</p><p>测试：UserDao.java 我们的Bean类，很简单</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserDao</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">queryUserInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A good man."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>单元测试</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ApiTest</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test_BeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//1.创建bean工厂(同时完成了加载资源、创建注册单例bean注册器的操作)</span>        <span class="token class-name">BeanFactory</span> beanFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.第一次获取bean（通过反射创建bean，缓存bean）</span>        <span class="token class-name">UserDao</span> userDao1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">UserDao</span><span class="token punctuation">)</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"userDao"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userDao1<span class="token punctuation">.</span><span class="token function">queryUserInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//3.第二次获取bean（从缓存中获取bean）</span>        <span class="token class-name">UserDao</span> userDao2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">UserDao</span><span class="token punctuation">)</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"userDao"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userDao2<span class="token punctuation">.</span><span class="token function">queryUserInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">A</span> good <span class="token class-name"><span class="token namespace">man<span class="token punctuation">.</span></span>A</span> good man<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>至此，我们一个乞丐+破船版的Spring就完成了，代码也比较完整，有条件的可以跑一下。</p><p>PS:因为时间+篇幅的限制，这个demo比较简陋，没有面向接口、没有解耦、边界检查、异常处理……健壮性、扩展性都有很大的不足</p><h2 id="7-说说BeanFactory和ApplicantContext"><a href="#7-说说BeanFactory和ApplicantContext" class="headerlink" title="7.说说BeanFactory和ApplicantContext?"></a>7.说说BeanFactory和ApplicantContext?</h2><p>可以这么形容，BeanFactory是Spring的“心脏”，ApplicantContext是完整的“身躯”。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357209163-1bd4e4ad-a674-4a7c-9c95-dbec65f210ab.png" alt="img"></p><p>BeanFactory（Bean工厂）是Spring框架的基础设施，面向Spring本身。</p><p>ApplicantContext（应用上下文）建立在BeanFactoty基础上，面向使用Spring框架的开发者。</p><h3 id="BeanFactory-接口"><a href="#BeanFactory-接口" class="headerlink" title="BeanFactory 接口"></a>BeanFactory 接口</h3><p>BeanFactory是类的通用工厂，可以创建并管理各种类的对象。</p><p>Spring为BeanFactory提供了很多种实现，最常用的是XmlBeanFactory，但在Spring 3.2中已被废弃，建议使用XmlBeanDefinitionReader、DefaultListableBeanFactory。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357211173-3c8b206d-0acd-4d4b-8ce2-28eda8c95d2b.png" alt="img"></p><p>BeanFactory接口位于类结构树的顶端，它最主要的方法就是getBean(String var1)，这个方法从容器中返回特定名称的Bean。</p><p>BeanFactory的功能通过其它的接口得到了不断的扩展，比如AbstractAutowireCapableBeanFactory定义了将容器中的Bean按照某种规则（比如按名字匹配、按类型匹配等）进行自动装配的方法。</p><p>这里看一个 XMLBeanFactory（已过期）  获取bean 的例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorldApp</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token class-name">BeanFactory</span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XmlBeanFactory</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ClassPathResource</span><span class="token punctuation">(</span><span class="token string">"beans.xml"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">HelloWorld</span> obj <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">HelloWorld</span><span class="token punctuation">)</span> factory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"helloWorld"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          obj<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ApplicationContext-接口"><a href="#ApplicationContext-接口" class="headerlink" title="ApplicationContext 接口"></a>ApplicationContext 接口</h3><p>ApplicationContext由BeanFactory派生而来，提供了更多面向实际应用的功能。可以这么说，使用BeanFactory就是手动档，使用ApplicationContext就是自动档。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357213686-eebbeffc-7efb-4064-a2a4-1e2a92eb07ca.png" alt="img"></p><p>ApplicationContext 继承了HierachicalBeanFactory和ListableBeanFactory接口，在此基础上，还通过其他的接口扩展了BeanFactory的功能，包括：</p><ul><li><p>Bean instantiation&#x2F;wiring</p></li><li><p>Bean 的实例化&#x2F;串联</p></li><li><p>自动的 BeanPostProcessor 注册</p></li><li><p>自动的 BeanFactoryPostProcessor 注册</p></li><li><p>方便的 MessageSource 访问（i18n）</p></li><li><p>ApplicationEvent 的发布与 BeanFactory 懒加载的方式不同，它是预加载，所以，每一个 bean 都在 ApplicationContext 启动之后实例化</p></li></ul><p>这是 ApplicationContext 的使用例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorldApp</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token class-name">ApplicationContext</span> context<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"beans.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">HelloWorld</span> obj <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">HelloWorld</span><span class="token punctuation">)</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"helloWorld"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          obj<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ApplicationContext 包含 BeanFactory 的所有特性，通常推荐使用前者。</p><h2 id="8-你知道Spring容器启动阶段会干什么吗？"><a href="#8-你知道Spring容器启动阶段会干什么吗？" class="headerlink" title="8.你知道Spring容器启动阶段会干什么吗？"></a>8.你知道Spring容器启动阶段会干什么吗？</h2><p>PS：这道题陈哥面试被问到过</p><p>Spring的IOC容器工作的过程，其实可以划分为两个阶段：<strong>容器启动阶段</strong>和<strong>Bean实例化阶段</strong>。</p><p>其中容器启动阶段主要做的工作是加载和解析配置文件，保存到对应的Bean定义中。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357216480-4a0b6b20-625a-4192-b442-17a0260d7985.png" alt="img"></p><p>容器启动开始，首先会通过某种途径加载Congiguration MetaData，在大部分情况下，容器需要依赖某些工具类（BeanDefinitionReader）对加载的Congiguration MetaData进行解析和分析，并将分析后的信息组为相应的BeanDefinition。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357218674-dec4ad88-d928-4223-bdeb-7fa444528104.png" alt="img"></p><p>最后把这些保存了Bean定义必要信息的BeanDefinition，注册到相应的BeanDefinitionRegistry，这样容器启动就完成了。</p><h2 id="9-能说一下Spring-Bean生命周期吗？"><a href="#9-能说一下Spring-Bean生命周期吗？" class="headerlink" title="9.能说一下Spring Bean生命周期吗？"></a>9.能说一下Spring Bean生命周期吗？</h2><p>在Spring中，基本容器BeanFactory和扩展容器ApplicationContext的实例化时机不太一样，BeanFactory采用的是延迟初始化的方式，也就是只有在第一次getBean()的时候，才会实例化Bean；ApplicationContext启动之后会实例化所有的Bean定义。</p><p>Spring IOC 中Bean的生命周期大致分为四个阶段：<strong>实例化</strong>（Instantiation）、<strong>属性赋值</strong>（Populate）、<strong>初始化</strong>（Initialization）、<strong>销毁</strong>（Destruction）。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357220388-b1afa206-6dd9-414c-af2b-7712cdb46ec5.png" alt="img">Bean生命周期四个阶段</p><p>我们再来看一个稍微详细一些的过程：</p><p>1、<strong>实例化</strong>：第 1 步，实例化一个 Bean 对象</p><p>2、<strong>属性赋值</strong>：第 2 步，为 Bean 设置相关属性和依赖</p><p>3、<strong>初始化</strong>：初始化的阶段的步骤比较多，5、6步是真正的初始化，第 3、4 步为在初始化前执行，第 7 步在初始化后执行，初始化完成之后，Bean就可以被使用了</p><p>4、<strong>销毁</strong>：第 8~10步，第8步其实也可以算到销毁阶段，但不是真正意义上的销毁，而是先在使用前注册了销毁的相关调用接口，为了后面第9、10步真正销毁 Bean 时再执行相应的方法</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357224115-854a5861-a8d6-4791-8191-a056d67e4f8c.png" alt="img"></p><p>简单总结一下，Bean生命周期里初始化的过程相对步骤会多一些，比如前置、后置的处理。</p><p>最后通过一个实例来看一下具体的细节：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357226399-bb2222d7-bb73-4df9-a066-0ef4976f7d80.png" alt="img"></p><p>定义一个<code>PersonBean</code>类，实现<code>DisposableBean</code>,<code>InitializingBean</code>, <code>BeanFactoryAware</code>, <code>BeanNameAware</code>这4个接口，同时还有自定义的<code>init-method</code>和<code>destroy-method</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PersonBean</span> <span class="token keyword">implements</span> <span class="token class-name">InitializingBean</span><span class="token punctuation">,</span> <span class="token class-name">BeanFactoryAware</span><span class="token punctuation">,</span> <span class="token class-name">BeanNameAware</span><span class="token punctuation">,</span> <span class="token class-name">DisposableBean</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 身份证号     */</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> no<span class="token punctuation">;</span>    <span class="token comment">/**     * 姓名     */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">PersonBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1.调用构造方法：我出生了！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">getNo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> no<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setNo</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> no<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>no <span class="token operator">=</span> no<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2.设置属性：我的名字叫"</span><span class="token operator">+</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBeanName</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3.调用BeanNameAware#setBeanName方法:我要上学了，起了个学名"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBeanFactory</span><span class="token punctuation">(</span><span class="token class-name">BeanFactory</span> beanFactory<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"4.调用BeanFactoryAware#setBeanFactory方法：选好学校了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"6.InitializingBean#afterPropertiesSet方法：入学登记"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"7.自定义init方法：努力上学ing"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"9.DisposableBean#destroy方法：平淡的一生落幕了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroyMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"10.自定义destroy方法:睡了，别想叫醒我"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Bean使用中：工作，只有对社会没有用的人才放假。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义一个<code>MyBeanPostProcessor</code>实现<code>BeanPostProcessor</code>接口。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBeanPostProcessor</span> <span class="token keyword">implements</span> <span class="token class-name">BeanPostProcessor</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">postProcessBeforeInitialization</span><span class="token punctuation">(</span><span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"5.BeanPostProcessor.postProcessBeforeInitialization方法：到学校报名啦"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">postProcessAfterInitialization</span><span class="token punctuation">(</span><span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"8.BeanPostProcessor#postProcessAfterInitialization方法：终于毕业，拿到毕业证啦！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置文件，指定<code>init-method</code>和<code>destroy-method</code>属性</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myBeanPostProcessor<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cn.fighter3.spring.life.MyBeanPostProcessor<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>personBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cn.fighter3.spring.life.PersonBean<span class="token punctuation">"</span></span>          <span class="token attr-name">init-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>init<span class="token punctuation">"</span></span> <span class="token attr-name">destroy-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>destroyMethod<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>idNo<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>80669865<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>张铁钢<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ApplicationContext</span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"spring-config.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">PersonBean</span> personBean <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">PersonBean</span><span class="token punctuation">)</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"personBean"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        personBean<span class="token punctuation">.</span><span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">)</span> context<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">1.</span>调用构造方法：我出生了！<span class="token number">2.</span>设置属性：我的名字叫张铁钢<span class="token number">3.</span>调用<span class="token class-name">BeanNameAware</span>#setBeanName方法<span class="token operator">:</span>我要上学了，起了个学名<span class="token number">4.</span>调用<span class="token class-name">BeanFactoryAware</span>#setBeanFactory方法：选好学校了<span class="token number">5.</span>BeanPostProcessor#postProcessBeforeInitialization方法：到学校报名啦<span class="token number">6.</span>InitializingBean#afterPropertiesSet方法：入学登记<span class="token number">7.</span>自定义init方法：努力上学ing<span class="token number">8.</span>BeanPostProcessor#postProcessAfterInitialization方法：终于毕业，拿到毕业证啦！<span class="token class-name">Bean</span>使用中：工作，只有对社会没有用的人才放假。。<span class="token number">9.D</span>isposableBean#destroy方法：平淡的一生落幕了<span class="token number">10.</span>自定义destroy方法<span class="token operator">:</span>睡了，别想叫醒我<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于源码，Bean创建过程可以查看<code>AbstractBeanFactory#doGetBean</code>方法，在这个方法里可以看到Bean的实例化，赋值、初始化的过程，至于最终的销毁，可以看看<code>ConfigurableApplicationContext#close()</code>。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357232253-82469b47-6316-4220-9da1-d98e25974c82.png" alt="img"></p><h2 id="10-Bean定义和依赖定义有哪些方式？"><a href="#10-Bean定义和依赖定义有哪些方式？" class="headerlink" title="10.Bean定义和依赖定义有哪些方式？"></a>10.Bean定义和依赖定义有哪些方式？</h2><p>有三种方式：<strong>直接编码方式</strong>、<strong>配置文件方式</strong>、<strong>注解方式</strong>。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357234145-b7e0e018-10df-40b1-b027-3208a208c7bb.png" alt="img"></p><p>1、直接编码方式：我们一般接触不到直接编码的方式，但其实其它的方式最终都要通过直接编码来实现。</p><p>2、配置文件方式：通过xml、propreties类型的配置文件，配置相应的依赖关系，Spring读取配置文件，完成依赖关系的注入。</p><p>3、注解方式：注解方式应该是我们用的最多的一种方式了，在相应的地方使用注解修饰，Spring会扫描注解，完成依赖关系的注入。</p><h2 id="11-有哪些依赖注入的方法？"><a href="#11-有哪些依赖注入的方法？" class="headerlink" title="11.有哪些依赖注入的方法？"></a>11.有哪些依赖注入的方法？</h2><p>Spring支持<strong>构造方法注入</strong>、<strong>属性注入</strong>、<strong>工厂方法注入</strong>,其中工厂方法注入，又可以分为<strong>静态工厂方法注入</strong>和<strong>非静态工厂方法注入</strong>。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357236092-1cc89e59-ee2d-4690-98de-68f66d2adb54.png" alt="img"></p><p><strong>构造方法注入</strong></p><p>通过调用类的构造方法，将接口实现类通过构造方法变量传入</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">CatDaoImpl</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span> message <span class="token operator">=</span> message<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"CatDaoImpl"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"com.CatDaoImpl"</span><span class="token operator">></span>   <span class="token operator">&lt;</span>constructor<span class="token operator">-</span>arg value<span class="token operator">=</span><span class="token string">" message "</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>constructor<span class="token operator">-</span>arg<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>属性注入</strong></p><p>通过Setter方法完成调用类所需依赖的注入</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Id</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> id<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.id <span class="token punctuation">"</span></span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>123<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>工厂方法注入</strong></p><p><strong>静态工厂注入</strong></p><p>静态工厂顾名思义，就是通过调用静态工厂的方法来获取自己需要的对象，为了让 Spring 管理所有对象，我们不能直接通过”工程类.静态方法()”来获取对象，而是依然通过 Spring 注入的形式获取：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DaoFactory</span> <span class="token punctuation">&#123;</span> <span class="token comment">//静态工厂</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">FactoryDao</span> <span class="token function">getStaticFactoryDaoImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">StaticFacotryDaoImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringAction</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//注入对象</span> <span class="token keyword">private</span> <span class="token class-name">FactoryDao</span> staticFactoryDao<span class="token punctuation">;</span>   <span class="token comment">//注入对象的 set 方法</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setStaticFactoryDao</span><span class="token punctuation">(</span><span class="token class-name">FactoryDao</span> staticFactoryDao<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>staticFactoryDao <span class="token operator">=</span> staticFactoryDao<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">//factory-method="getStaticFactoryDaoImpl"指定调用哪个工厂方法 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>springAction<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span> SpringAction<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>   <span class="token comment">&lt;!--使用静态工厂的方法注入对象,对应下面的配置文件--></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>staticFactoryDao<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>staticFactoryDao<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>  <span class="token comment">&lt;!--此处获取对象的方式是从工厂类中获取静态方法--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>staticFactoryDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>DaoFactory<span class="token punctuation">"</span></span>  <span class="token attr-name">factory-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getStaticFactoryDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>非静态工厂注入</strong></p><p>非静态工厂，也叫实例工厂，意思是工厂方法不是静态的，所以我们需要首先 new 一个工厂实例，再调用普通的实例方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//非静态工厂 </span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DaoFactory</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">FactoryDao</span> <span class="token function">getFactoryDaoImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>     <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FactoryDaoImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringAction</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//注入对象</span>  <span class="token keyword">private</span> <span class="token class-name">FactoryDao</span> factoryDao<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFactoryDao</span><span class="token punctuation">(</span><span class="token class-name">FactoryDao</span> factoryDao<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>factoryDao <span class="token operator">=</span> factoryDao<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>springAction<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>SpringAction<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>   <span class="token comment">&lt;!--使用非静态工厂的方法注入对象,对应下面的配置文件--></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>factoryDao<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>factoryDao<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>  <span class="token comment">&lt;!--此处获取对象的方式是从工厂类中获取实例方法--></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>daoFactory<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.DaoFactory<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>factoryDao<span class="token punctuation">"</span></span> <span class="token attr-name">factory-bean</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>daoFactory<span class="token punctuation">"</span></span> <span class="token attr-name">factory-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getFactoryDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="12-Spring有哪些自动装配的方式？"><a href="#12-Spring有哪些自动装配的方式？" class="headerlink" title="12.Spring有哪些自动装配的方式？"></a>12.Spring有哪些自动装配的方式？</h2><p><strong>什么是自动装配？</strong></p><p>Spring IOC容器知道所有Bean的配置信息，此外，通过Java反射机制还可以获知实现类的结构信息，如构造方法的结构、属性等信息。掌握所有Bean的这些信息后，Spring IOC容器就可以按照某种规则对容器中的Bean进行自动装配，而无须通过显式的方式进行依赖配置。</p><p>Spring提供的这种方式，可以按照某些规则进行Bean的自动装配，元素提供了一个指定自动装配类型的属性：autowire&#x3D;”&lt;自动装配类型&gt;”</p><p><strong>Spring提供了哪几种自动装配类型？</strong></p><p>Spring提供了4种自动装配类型：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357239724-f1d1fcd8-bf11-4588-9c4d-34bf2bc25d81.png" alt="img"></p><p>1、<strong>byName</strong>：根据名称进行自动匹配，假设Boss又一个名为car的属性，如果容器中刚好有一个名为car的bean，Spring就会自动将其装配给Boss的car属性</p><p>2、<strong>byType</strong>：根据类型进行自动匹配，假设Boss有一个Car类型的属性，如果容器中刚好有一个Car类型的Bean，Spring就会自动将其装配给Boss这个属性</p><p>3、<strong>constructor</strong>：与 byType类似， 只不过它是针对构造函数注入而言的。如果Boss有一个构造函数，构造函数包含一个Car类型的入参，如果容器中有一个Car类型的Bean，则Spring将自动把这个Bean作为Boss构造函数的入参；如果容器中没有找到和构造函数入参匹配类型的Bean，则Spring将抛出异常。</p><p>4、<strong>autodetect</strong>：根据Bean的自省机制决定采用byType还是constructor进行自动装配，如果Bean提供了默认的构造函数，则采用byType，否则采用constructor。</p><h2 id="13-Spring-中的-Bean-的作用域有哪些"><a href="#13-Spring-中的-Bean-的作用域有哪些" class="headerlink" title="13.Spring 中的 Bean 的作用域有哪些?"></a>13.Spring 中的 Bean 的作用域有哪些?</h2><p>Spring的Bean主要支持五种作用域：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357242168-af36bc22-b0ab-492c-b488-0409cd0c8dd2.png" alt="img"></p><p><strong>singleton</strong> : 在Spring容器仅存在一个Bean实例，Bean以单实例的方式存在，是Bean默认的作用域。</p><p><strong>prototype</strong> : 每次从容器重调用Bean时，都会返回一个新的实例。</p><p>以下三个作用域于只在Web应用中适用：</p><p>1、<strong>request</strong> : 每一次HTTP请求都会产生一个新的Bean，该Bean仅在当前HTTP Request内有效。</p><p>2、<strong>session</strong> : 同一个HTTP Session共享一个Bean，不同的HTTP Session使用不同的Bean。</p><p>3、<strong>globalSession</strong>：同一个全局Session共享一个Bean，只用于基于Protlet的Web应用，Spring5中已经不存在了。</p><h2 id="14-Spring-中的单例-Bean-会存在线程安全问题吗？"><a href="#14-Spring-中的单例-Bean-会存在线程安全问题吗？" class="headerlink" title="14.Spring 中的单例 Bean 会存在线程安全问题吗？"></a>14.Spring 中的单例 Bean 会存在线程安全问题吗？</h2><p>首先结论在这：Spring中的单例Bean<strong>不是线程安全的</strong>。</p><p>因为单例Bean，是全局只有一个Bean，所有线程共享。如果说单例Bean，是一个无状态的，也就是线程中的操作不会对Bean中的成员变量执行<strong>查询</strong>以外的操作，那么这个单例Bean是线程安全的。比如Spring mvc 的 Controller、Service、Dao等，这些Bean大多是无状态的，只关注于方法本身。</p><p>假如这个Bean是有状态的，也就是会对Bean中的成员变量进行写操作，那么可能就存在线程安全的问题。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357244458-5cd1ac72-9e32-4635-b052-b24b7a390d34.png" alt="img"></p><p><strong>单例Bean线程安全问题怎么解决呢？</strong></p><p>常见的有这么些解决办法：</p><p>1、将Bean定义为多例；这样每一个线程请求过来都会创建一个新的Bean，但是这样容器就不好管理Bean，不能这么办。</p><p>2、在Bean对象中尽量避免定义可变的成员变量；削足适履了属于是，也不能这么干。</p><p>3、将Bean中的成员变量保存在ThreadLocal中⭐；我们知道ThredLoca能保证多线程下变量的隔离，可以在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在ThreadLocal里，这是推荐的一种方式。</p><h2 id="15-说说循环依赖"><a href="#15-说说循环依赖" class="headerlink" title="15.说说循环依赖?"></a>15.说说循环依赖?</h2><p><strong>什么是循环依赖？</strong></p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357246915-7cd478bd-da62-4d9a-9d48-634fee4920e2.png" alt="img"></p><p>Spring 循环依赖：简单说就是自己依赖自己，或者和别的Bean相互依赖。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357249160-f00f7e4c-3a90-4fc8-947a-53219a1f944b.png" alt="img"></p><p>只有单例的Bean才存在循环依赖的情况，<strong>原型</strong>(Prototype)情况下，Spring会直接抛出异常。原因很简单，AB循环依赖，A实例化的时候，发现依赖B，创建B实例，创建B的时候发现需要A，创建A1实例……无限套娃，直接把系统干垮。</p><p><strong>Spring可以解决哪些情况的循环依赖？</strong></p><p>Spring不支持基于构造器注入的循环依赖，但是假如AB循环依赖，如果一个是构造器注入，一个是setter注入呢？</p><p>看看几种情形：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357251677-18313cc5-4bc2-45f1-8be4-1ca24552b2dd.png" alt="img"></p><p>第四种可以而第五种不可以的原因是 Spring 在创建 Bean 时默认会根据自然排序进行创建，所以 A 会先于 B 进行创建。</p><p>所以简单总结，当循环依赖的实例都采用setter方法注入的时候，Spring可以支持，都采用构造器注入的时候，不支持，构造器注入和setter注入同时存在的时候，看天。</p><h2 id="16-那Spring怎么解决循环依赖的呢？"><a href="#16-那Spring怎么解决循环依赖的呢？" class="headerlink" title="16.那Spring怎么解决循环依赖的呢？"></a>16.那Spring怎么解决循环依赖的呢？</h2><p>PS：其实正确答案是开发人员做好设计，别让Bean循环依赖，但是没办法，面试官不想听这个。</p><p>我们都知道，单例Bean初始化完成，要经历三步：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357254691-d06db734-9009-4277-b438-0fc14d38d774.png" alt="img"></p><p>注入就发生在第二步，<strong>属性赋值</strong>，结合这个过程，Spring 通过<strong>三级缓存</strong>解决了循环依赖：</p><p>1、一级缓存 : Map&lt;String,Object&gt; <strong>singletonObjects</strong>，单例池，用于保存实例化、属性赋值（注入）、初始化完成的 bean 实例</p><p>2、二级缓存 : Map&lt;String,Object&gt; <strong>earlySingletonObjects</strong>，早期曝光对象，用于保存实例化完成的 bean 实例</p><p>3、三级缓存 : Map&lt;String,ObjectFactory&lt;?&gt;&gt; <strong>singletonFactories</strong>，早期曝光对象工厂，用于保存 bean 创建工厂，以便于后面扩展有机会创建代理对象。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357256628-90644818-a067-4698-881e-c3c2cb29aebd.png" alt="img"></p><p>我们来看一下三级缓存解决循环依赖的过程：</p><p>当 A、B 两个类发生循环依赖时：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357258545-66367062-cbe9-4c66-a4a7-cc3771718d46.png" alt="img"></p><p>创建A实例，实例化的时候把A对象⼯⼚放⼊三级缓存，表示A开始实例化了，虽然我这个对象还不完整，但是先曝光出来让大家知道</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357260074-2c2657f6-e925-4196-80a6-9b164d2081a1.png" alt="img"></p><p>A注⼊属性时，发现依赖B，此时B还没有被创建出来，所以去实例化B</p><p>同样，B注⼊属性时发现依赖A，它就会从缓存里找A对象。依次从⼀级到三级缓存查询A，从三级缓存通过对象⼯⼚拿到A，发现A虽然不太完善，但是存在，把A放⼊⼆级缓存，同时删除三级缓存中的A，此时，B已经实例化并且初始化完成，把B放入⼀级缓存。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357262074-034cd321-1945-4b39-ad51-632d9da5dfdb.png" alt="img"></p><p>接着A继续属性赋值，顺利从⼀级缓存拿到实例化且初始化完成的B对象，A对象创建也完成，删除⼆级缓存中的A，同时把A放⼊⼀级缓存</p><p>最后，⼀级缓存中保存着实例化、初始化都完成的A、B对象</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357264062-3f230b7f-21c2-480b-bd5f-cbd454943116.png" alt="img"></p><p>所以，我们就知道为什么Spring能解决setter注入的循环依赖了，因为实例化和属性赋值是分开的，所以里面有操作的空间。如果都是构造器注入的化，那么都得在实例化这一步完成注入，所以自然是无法支持了。</p><h2 id="17-为什么要三级缓存？⼆级不⾏吗？"><a href="#17-为什么要三级缓存？⼆级不⾏吗？" class="headerlink" title="17.为什么要三级缓存？⼆级不⾏吗？"></a>17.为什么要三级缓存？⼆级不⾏吗？</h2><p>不行，主要是为了<strong>⽣成代理对象</strong>。如果是没有代理的情况下，使用二级缓存解决循环依赖也是OK的。但是如果存在代理，三级没有问题，二级就不行了。</p><p>因为三级缓存中放的是⽣成具体对象的匿名内部类，获取Object的时候，它可以⽣成代理对象，也可以返回普通对象。使⽤三级缓存主要是为了保证不管什么时候使⽤的都是⼀个对象。</p><p>假设只有⼆级缓存的情况，往⼆级缓存中放的显示⼀个普通的Bean对象，Bean初始化过程中，通过 BeanPostProcessor 去⽣成代理对象之后，覆盖掉⼆级缓存中的普通Bean对象，那么可能就导致取到的Bean对象不一致了。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357266758-d99f7786-468c-4ec4-a0f2-76064e0e1996.png" alt="img"></p><h2 id="18-Autowired的实现原理？"><a href="#18-Autowired的实现原理？" class="headerlink" title="18.@Autowired的实现原理？"></a>18.@Autowired的实现原理？</h2><p>实现@Autowired的关键是：<strong>AutowiredAnnotationBeanPostProcessor</strong></p><p>在Bean的初始化阶段，会通过Bean后置处理器来进行一些前置和后置的处理。</p><p>实现@Autowired的功能，也是通过后置处理器来完成的。这个后置处理器就是AutowiredAnnotationBeanPostProcessor。</p><p>Spring在创建bean的过程中，最终会调用到doCreateBean()方法，在doCreateBean()方法中会调用populateBean()方法，来为bean进行属性填充，完成自动装配等工作。</p><p>在populateBean()方法中一共调用了两次后置处理器，第一次是为了判断是否需要属性填充，如果不需要进行属性填充，那么就会直接进行return，如果需要进行属性填充，那么方法就会继续向下执行，后面会进行第二次后置处理器的调用，这个时候，就会调用到AutowiredAnnotationBeanPostProcessor的postProcessPropertyValues()方法，在该方法中就会进行@Autowired注解的解析，然后实现自动装配。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*** 属性赋值**/</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">populateBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanName<span class="token punctuation">,</span> <span class="token class-name">RootBeanDefinition</span> mbd<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">BeanWrapper</span> bw<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//………… </span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>hasInstAwareBpps<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>pvs <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    pvs <span class="token operator">=</span> mbd<span class="token punctuation">.</span><span class="token function">getPropertyValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token class-name">PropertyValues</span> pvsToUse<span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Iterator</span> var9 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getBeanPostProcessorCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>instantiationAware<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> var9<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> pvs <span class="token operator">=</span> pvsToUse<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">InstantiationAwareBeanPostProcessor</span> bp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">InstantiationAwareBeanPostProcessor</span><span class="token punctuation">)</span>var9<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    pvsToUse <span class="token operator">=</span> bp<span class="token punctuation">.</span><span class="token function">postProcessProperties</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">PropertyValues</span><span class="token punctuation">)</span>pvs<span class="token punctuation">,</span> bw<span class="token punctuation">.</span><span class="token function">getWrappedInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>pvsToUse <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>filteredPds <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            filteredPds <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">filterPropertyDescriptorsForDependencyCheck</span><span class="token punctuation">(</span>bw<span class="token punctuation">,</span> mbd<span class="token punctuation">.</span>allowCaching<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                        <span class="token comment">//执行后处理器，填充属性，完成自动装配</span>                        <span class="token comment">//调用InstantiationAwareBeanPostProcessor的postProcessPropertyValues()方法</span>                        pvsToUse <span class="token operator">=</span> bp<span class="token punctuation">.</span><span class="token function">postProcessPropertyValues</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">PropertyValues</span><span class="token punctuation">)</span>pvs<span class="token punctuation">,</span> filteredPds<span class="token punctuation">,</span> bw<span class="token punctuation">.</span><span class="token function">getWrappedInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>pvsToUse <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            <span class="token keyword">return</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>           <span class="token comment">//…………</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>postProcessorPropertyValues()方法的源码如下，在该方法中，会先调用findAutowiringMetadata()方法解析出bean中带有@Autowired注解、@Inject和@Value注解的属性和方法。然后调用metadata.inject()方法，进行属性填充。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">PropertyValues</span> <span class="token function">postProcessProperties</span><span class="token punctuation">(</span><span class="token class-name">PropertyValues</span> pvs<span class="token punctuation">,</span> <span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//@Autowired注解、@Inject和@Value注解的属性和方法</span>    <span class="token class-name">InjectionMetadata</span> metadata <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">findAutowiringMetadata</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> bean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> pvs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//属性填充</span>        metadata<span class="token punctuation">.</span><span class="token function">inject</span><span class="token punctuation">(</span>bean<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> pvs<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> pvs<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeanCreationException</span> var6<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> var6<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> var7<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanCreationException</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token string">"Injection of autowired dependencies failed"</span><span class="token punctuation">,</span> var7<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="19-说说什么是AOP？"><a href="#19-说说什么是AOP？" class="headerlink" title="19.说说什么是AOP？"></a>19.说说什么是AOP？</h2><p>AOP：面向切面编程。简单说，就是把一些业务逻辑中的相同的代码抽取到一个独立的模块中，让业务逻辑更加清爽。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357269719-73552f31-9453-47e4-8d87-ee8c8273b020.png" alt="img"></p><p>具体来说，假如我现在要crud写一堆业务，可是如何业务代码前后前后进行打印日志和参数的校验呢？</p><p>我们可以把<code>日志记录</code>和<code>数据校验</code>可重用的功能模块分离出来，然后在程序的执行的合适的地方动态地植入这些代码并执行。这样就简化了代码的书写。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357271706-f231fd5d-4f0f-495c-9ea4-6c6b24e47805.png" alt="img"></p><p>业务逻辑代码中没有参和通用逻辑的代码，业务模块更简洁，只包含核心业务代码。实现了业务逻辑和通用逻辑的代码分离，便于维护和升级，降低了业务逻辑和通用逻辑的耦合性。</p><p>AOP 可以将遍布应用各处的功能分离出来形成可重用的组件。在编译期间、装载期间或运行期间实现在不修改源代码的情况下给程序动态添加功能。从而实现对业务逻辑的隔离，提高代码的模块化能力。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357274813-98e34ee4-aed6-44e9-9ec7-e16034a74625.png" alt="img"></p><p>AOP 的核心其实就是<strong>动态代理</strong>，如果是实现了接口的话就会使用 JDK 动态代理，否则使用 CGLIB 代理，主要应用于处理一些具有横切性质的系统级服务，如日志收集、事务管理、安全检查、缓存、对象池管理等。</p><p><strong>AOP有哪些核心概念？</strong></p><ul><li><p><strong>切面</strong>（Aspect）：类是对物体特征的抽象，切面就是对横切关注点的抽象 </p></li><li><p><strong>连接点</strong>（Joinpoint）：被拦截到的点，因为 Spring 只支持方法类型的连接点，所以在 Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器 </p></li><li><p><strong>切点</strong>（Pointcut）：对连接点进行拦截的定位 </p></li><li><p><strong>通知</strong>（Advice）：所谓通知指的就是指拦截到连接点之后要执行的代码，也可以称作<strong>增强</strong> </p></li><li><p><strong>目标对象</strong> （Target）：代理的目标对象 </p></li><li><p><strong>织入</strong>（Weabing）：织入是将增强添加到目标类的具体连接点上的过程。 </p></li><li><ul><li>编译期织入：切面在目标类编译时被织入</li></ul></li><li><ul><li>类加载期织入：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。</li></ul></li><li><ul><li>运行期织入：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。<br>  Spring采用运行期织入，而AspectJ采用编译期织入和类加载器织入。</li></ul></li><li><p><strong>引介</strong>（introduction）：引介是一种特殊的增强，可以动态地为类添加一些属性和方法</p></li></ul><p><strong>AOP有哪些环绕方式？</strong></p><p>AOP 一般有 <strong>5 种</strong>环绕方式：</p><ul><li><p>前置通知 (<a href="">@Before) </a> </p></li><li><p>返回通知 (<a href="">@AfterReturning) </a> </p></li><li><p>异常通知 (<a href="">@AfterThrowing) </a> </p></li><li><p>后置通知 (<a href="">@After) </a> </p></li><li><p>环绕通知 (<a href="">@Around) </a></p></li></ul><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357277036-09d39f8d-ad02-4f8e-96ad-4467bee05de8.png" alt="img"></p><p>多个切面的情况下，可以通过 <a href="">@Order </a> 指定先后顺序，数字越小，优先级越高。 </p><h2 id="20-说说你平时有用到AOP吗？"><a href="#20-说说你平时有用到AOP吗？" class="headerlink" title="20.说说你平时有用到AOP吗？"></a>20.说说你平时有用到AOP吗？</h2><p>PS：这道题陈哥的同事面试候选人的时候问到了，候选人说了一堆AOP原理，同事就势来一句，你能现场写一下AOP的应用吗？结果——场面一度很尴尬。虽然我对面试写这种百度就能出来的东西持保留意见，但是还是加上了这一问，毕竟招人最后都是要撸代码的。</p><p>这里给出一个小例子，SpringBoot项目中，利用AOP打印接口的入参和出参日志，以及执行时间，还是比较快捷的。</p><p>引入依赖：引入AOP依赖</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-aop<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>自定义注解：自定义一个注解作为切点</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">METHOD</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">WebLog</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置AOP切面：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Aspect</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WebLogAspect</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">Logger</span> logger         <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token class-name">WebLogAspect</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 以自定义 @WebLog 注解为切点     **/</span>    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"@annotation(cn.fighter3.spring.aop_demo.WebLog)"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">webLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 在切点之前织入     */</span>    <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"webLog()"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doBefore</span><span class="token punctuation">(</span><span class="token class-name">JoinPoint</span> joinPoint<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 开始打印请求日志</span>        <span class="token class-name">ServletRequestAttributes</span> attributes <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ServletRequestAttributes</span><span class="token punctuation">)</span> <span class="token class-name">RequestContextHolder</span><span class="token punctuation">.</span><span class="token function">getRequestAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">HttpServletRequest</span> request <span class="token operator">=</span> attributes<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 打印请求相关参数</span>        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"========================================== Start =========================================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 打印请求 url</span>        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"URL            : &#123;&#125;"</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span><span class="token function">getRequestURL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 打印 Http method</span>        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"HTTP Method    : &#123;&#125;"</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 打印调用 controller 的全路径以及执行方法</span>        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Class Method   : &#123;&#125;.&#123;&#125;"</span><span class="token punctuation">,</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaringTypeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 打印请求的 IP</span>        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"IP             : &#123;&#125;"</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span><span class="token function">getRemoteAddr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 打印请求入参</span>        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Request Args   : &#123;&#125;"</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>joinPoint<span class="token punctuation">.</span><span class="token function">getArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 在切点之后织入     * @throws Throwable     */</span>    <span class="token annotation punctuation">@After</span><span class="token punctuation">(</span><span class="token string">"webLog()"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAfter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 结束后打个分隔线，方便查看</span>        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"=========================================== End ==========================================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 环绕     */</span>    <span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">"webLog()"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">doAround</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> proceedingJoinPoint<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//开始时间</span>        <span class="token keyword">long</span> startTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span> result <span class="token operator">=</span> proceedingJoinPoint<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 打印出参</span>        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Response Args  : &#123;&#125;"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 执行耗时</span>        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Time-Consuming : &#123;&#125; ms"</span><span class="token punctuation">,</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>@Aspect：标识切面</p><p>@Pointcut：设置切点，这里以自定义注解为切点，定义切点有很多其它种方式，自定义注解是比较常用的一种。</p><p>@Before：在切点之前织入，打印了一些入参信息</p><p>@Around：环绕切点，打印返回参数和接口执行时间</p><p>使用：只需要在接口上加上自定义注解</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@WebLog</span><span class="token punctuation">(</span>desc <span class="token operator">=</span> <span class="token string">"这是一个欢迎接口"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token string">"Hello "</span><span class="token operator">+</span>name<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果：可以看到日志打印了入参、出参和执行时间</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357280598-f0f2fd42-0b9a-4871-b1d9-c40f9cb3e6d4.png" alt="img"></p><h2 id="21-说说JDK-动态代理和-CGLIB-代理-？"><a href="#21-说说JDK-动态代理和-CGLIB-代理-？" class="headerlink" title="21.说说JDK 动态代理和 CGLIB 代理 ？"></a>21.说说JDK 动态代理和 CGLIB 代理 ？</h2><p>Spring的AOP是通过<a href="https://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&mid=2247490507&idx=1&sn=003af1086e53877662621632fa96284d&scene=21#wechat_redirect">动态代理</a>来实现的，动态代理主要有两种方式JDK动态代理和Cglib动态代理，这两种动态代理的使用和原理有些不同。</p><p><strong>JDK 动态代理</strong></p><p>1、<strong>Interface</strong>：对于 JDK 动态代理，目标类需要实现一个Interface。</p><p>2、<strong>InvocationHandler</strong>：InvocationHandler是一个接口，可以通过实现这个接口，定义横切逻辑，再通过反射机制（invoke）调用目标类的代码，在次过程，可能包装逻辑，对目标方法进行前置后置处理。</p><p>3、<strong>Proxy</strong>：Proxy利用InvocationHandler动态创建一个符合目标类实现的接口的实例，生成目标类的代理对象。</p><p><strong>CgLib 动态代理</strong></p><p>1、使用JDK创建代理有一大限制，它只能为接口创建代理实例，而CgLib 动态代理就没有这个限制。</p><p>2、CgLib 动态代理是使用字节码处理框架 <strong>ASM</strong>，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。</p><p>3、<strong>CgLib</strong> 创建的动态代理对象性能比 JDK 创建的动态代理对象的性能高不少，但是 CGLib 在创建代理对象时所花费的时间却比 JDK 多得多，所以对于单例的对象，因为无需频繁创建对象，用 CGLib 合适，反之，使用 JDK 方式要更为合适一些。同时，由于 CGLib 由于是采用动态创建子类的方法，对于 final 方法，无法进行代理。</p><p>我们来看一个常见的小场景，客服中转，解决用户问题：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357283032-1f9e6951-057f-4e7d-8056-fe12729598c4.png" alt="img"></p><p><strong>JDK动态代理实现：</strong></p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357284988-a76cf436-d97e-4dc6-8fa2-a3abaa959063.png" alt="img"></p><p>接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ISolver</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>目标类:需要实现对应接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solver</span> <span class="token keyword">implements</span> <span class="token class-name">ISolver</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"疯狂掉头发解决问题……"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>动态代理工厂:ProxyFactory，直接用反射方式生成一个目标对象的代理对象，这里用了一个匿名内部类方式重写InvocationHandler方法，实现接口重写也差不多</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProxyFactory</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 维护一个目标对象</span>    <span class="token keyword">private</span> <span class="token class-name">Object</span> target<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">ProxyFactory</span><span class="token punctuation">(</span><span class="token class-name">Object</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 为目标对象生成代理对象</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getProxyInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">InvocationHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请问有什么可以帮到您？"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 调用目标对象方法</span>                        <span class="token class-name">Object</span> returnValue <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"问题已经解决啦！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端：Client，生成一个代理对象实例，通过代理对象调用目标对象方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//目标对象:程序员</span>        <span class="token class-name">ISolver</span> developer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//代理：客服小姐姐</span>        <span class="token class-name">ISolver</span> csProxy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ISolver</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">ProxyFactory</span><span class="token punctuation">(</span>developer<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getProxyInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//目标方法：解决问题</span>        csProxy<span class="token punctuation">.</span><span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Cglib动态代理实现：</strong></p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357288624-f32f8d0e-7a76-4c94-b6d8-a9fa7c974046.png" alt="img"></p><p>目标类：Solver，这里目标类不用再实现接口。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solver</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"疯狂掉头发解决问题……"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>动态代理工厂：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProxyFactory</span> <span class="token keyword">implements</span> <span class="token class-name">MethodInterceptor</span> <span class="token punctuation">&#123;</span>   <span class="token comment">//维护一个目标对象</span>    <span class="token keyword">private</span> <span class="token class-name">Object</span> target<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">ProxyFactory</span><span class="token punctuation">(</span><span class="token class-name">Object</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//为目标对象生成代理对象</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getProxyInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//工具类</span>        <span class="token class-name">Enhancer</span> en <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置父类</span>        en<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置回调函数</span>        en<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//创建子类对象代理</span>        <span class="token keyword">return</span> en<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">intercept</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> <span class="token class-name">MethodProxy</span> proxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请问有什么可以帮到您？"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 执行目标对象的方法</span>        <span class="token class-name">Object</span> returnValue <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"问题已经解决啦！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端：Client</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//目标对象:程序员</span>        <span class="token class-name">Solver</span> developer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//代理：客服小姐姐</span>        <span class="token class-name">Solver</span> csProxy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Solver</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">ProxyFactory</span><span class="token punctuation">(</span>developer<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getProxyInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//目标方法：解决问题</span>        csProxy<span class="token punctuation">.</span><span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="22-说说Spring-AOP-和-AspectJ-AOP-区别"><a href="#22-说说Spring-AOP-和-AspectJ-AOP-区别" class="headerlink" title="22.说说Spring AOP 和 AspectJ AOP 区别?"></a>22.说说Spring AOP 和 AspectJ AOP 区别?</h2><p><strong>Spring AOP</strong></p><p>Spring AOP 属于<code>运行时增强</code>，主要具有如下特点：</p><p>1、基于动态代理来实现，默认如果使用接口的，用 JDK 提供的动态代理实现，如果是方法则使用 CGLIB 实现</p><p>2、Spring AOP 需要依赖 IOC 容器来管理，并且只能作用于 Spring 容器，使用纯 Java 代码实现</p><p>3、在性能上，由于 Spring AOP 是基于<strong>动态代理</strong>来实现的，在容器启动时需要生成代理实例，在方法调用上也会增加栈的深度，使得 Spring AOP 的性能不如 AspectJ 的那么好。</p><p>4、Spring AOP 致力于解决企业级开发中最普遍的 AOP(方法织入)。</p><p><strong>AspectJ</strong></p><p>AspectJ 是一个易用的功能强大的 AOP 框架，属于<code>编译时增强</code>，  可以单独使用，也可以整合到其它框架中，是 AOP 编程的完全解决方案。AspectJ 需要用到单独的编译器 ajc。</p><p>AspectJ 属于<strong>静态织入</strong>，通过修改代码来实现，在实际运行之前就完成了织入，所以说它生成的类是没有额外运行时开销的，一般有如下几个织入的时机：</p><p>1、编译期织入（Compile-time weaving）：如类 A 使用 AspectJ 添加了一个属性，类 B 引用了它，这个场景就需要编译期的时候就进行织入，否则没法编译类 B。</p><p>2、编译后织入（Post-compile weaving）：也就是已经生成了 .class 文件，或已经打成 jar 包了，这种情况我们需要增强处理的话，就要用到编译后织入。</p><p>3、类加载后织入（Load-time weaving）：指的是在加载类的时候进行织入，要实现这个时期的织入，有几种常见的方法</p><p>整体对比如下：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357291532-d974c761-3c1c-4b25-9304-b02495ea8e7a.png" alt="img"></p><p>Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，Spring 是无法提供事务功能的。Spring 只提供统一事务管理接口，具体实现都是由各数据库自己实现，数据库事务的提交和回滚是通过数据库自己的事务机制实现。</p><h2 id="23-Spring-事务的种类？"><a href="#23-Spring-事务的种类？" class="headerlink" title="23.Spring 事务的种类？"></a>23.Spring 事务的种类？</h2><p>Spring 支持<code>编程式事务</code>管理和<code>声明式</code>事务管理两种方式：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357293456-647baa4c-0d48-48f8-b32d-688d04798225.png" alt="img"></p><p><strong>1、编程式事务</strong></p><p>编程式事务管理使用 TransactionTemplate，需要显式执行事务。</p><p><strong>2、声明式事务</strong></p><p>声明式事务管理建立在 AOP 之上的。其本质是通过 AOP 功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前启动一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务</p><p>优点是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过 <a href="">@Transactional </a> 注解的方式，便可以将事务规则应用到业务逻辑中，减少业务代码的污染。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。 </p><h2 id="24-Spring-的事务隔离级别？"><a href="#24-Spring-的事务隔离级别？" class="headerlink" title="24.Spring 的事务隔离级别？"></a>24.Spring 的事务隔离级别？</h2><p>Spring的接口TransactionDefinition中定义了表示隔离级别的常量，当然其实主要还是对应数据库的事务隔离级别：</p><p>1、<strong>ISOLATION_DEFAULT</strong>：使用后端数据库默认的隔离界别，MySQL 默认可重复读，Oracle 默认读已提交。</p><p>2、<strong>ISOLATION_READ_UNCOMMITTED</strong>：读未提交</p><p>3、<strong>ISOLATION_READ_COMMITTED</strong>：读已提交</p><p>4、<strong>ISOLATION_REPEATABLE_READ</strong>：可重复读</p><p>5、<strong>ISOLATION_SERIALIZABLE</strong>：串行化</p><h2 id="25-Spring-的事务传播机制？"><a href="#25-Spring-的事务传播机制？" class="headerlink" title="25.Spring 的事务传播机制？"></a>25.Spring 的事务传播机制？</h2><p>Spring 事务的传播机制说的是，当多个事务同时存在的时候——一般指的是多个事务方法相互调用时，Spring 如何处理这些事务的行为。</p><p>事务传播机制是使用简单的 ThreadLocal 实现的，所以，如果调用的方法是在新线程调用的，事务传播实际上是会失效的。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357296072-a398ed12-61f7-41f6-a0de-0235c63da987.png" alt="img"></p><p>Spring默认的事务传播行为是PROPAFATION_REQUIRED，它适合绝大多数情况，如果多个ServiceX#methodX()都工作在事务环境下（均被Spring事务增强），且程序中存在调用链Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()，那么这3个服务类的三个方法通过Spring的事务传播机制都工作在同一个事务中。</p><h2 id="26-声明式事务实现原理了解吗？"><a href="#26-声明式事务实现原理了解吗？" class="headerlink" title="26.声明式事务实现原理了解吗？"></a>26.声明式事务实现原理了解吗？</h2><p>就是通过AOP&#x2F;动态代理。</p><p><strong>在Bean初始化阶段创建代理对象</strong>：Spring容器在初始化每个单例bean的时候，会遍历容器中的所有BeanPostProcessor实现类，并执行其postProcessAfterInitialization方法，在执行AbstractAutoProxyCreator类的postProcessAfterInitialization方法时会遍历容器中所有的切面，查找与当前实例化bean匹配的切面，这里会获取事务属性切面，查找@Transactional注解及其属性值，然后根据得到的切面创建一个代理对象，默认是使用JDK动态代理创建代理，如果目标类是接口，则使用JDK动态代理，否则使用Cglib。</p><p><strong>在执行目标方法时进行事务增强操作</strong>：当通过代理对象调用Bean方法的时候，会触发对应的AOP增强拦截器，声明式事务是一种环绕增强，对应接口为<code>MethodInterceptor</code>，事务增强对该接口的实现为<code>TransactionInterceptor</code>，类图如下：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357298574-10f34fad-606d-40c6-ad90-70cd99503727.png" alt="img"></p><p>事务拦截器<code>TransactionInterceptor</code>在<code>invoke</code>方法中，通过调用父类<code>TransactionAspectSupport</code>的<code>invokeWithinTransaction</code>方法进行事务处理，包括开启事务、事务提交、异常回滚。</p><h2 id="27-声明式事务在哪些情况下会失效？"><a href="#27-声明式事务在哪些情况下会失效？" class="headerlink" title="27.声明式事务在哪些情况下会失效？"></a>27.声明式事务在哪些情况下会失效？</h2><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357300378-f8c8e017-ab58-4a7f-8afe-731f60cd808d.png" alt="img"></p><p><strong>1、</strong><a href=""><strong>@Transactional</strong> </a> <strong>应用在非 public 修饰的方法上</strong> </p><p>如果Transactional注解应用在非 public 修饰的方法上，Transactional将会失效。</p><p>是因为在Spring AOP 代理时，TransactionInterceptor  （事务拦截器）在目标方法执行前后进行拦截，DynamicAdvisedInterceptor（CglibAopProxy  的内部类）的intercept方法 或  JdkDynamicAopProxy的invoke方法会间接调用AbstractFallbackTransactionAttributeSource的 <strong>computeTransactionAttribute</strong>方法，获取Transactional 注解的事务配置信息。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">TransactionAttribute</span> <span class="token function">computeTransactionAttribute</span><span class="token punctuation">(</span><span class="token class-name">Method</span> method<span class="token punctuation">,</span>    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> targetClass<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Don't allow no-public methods as required.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">allowPublicMethodsOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token class-name">Modifier</span><span class="token punctuation">.</span><span class="token function">isPublic</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此方法会检查目标方法的修饰符是否为 public，不是 public则不会获取<a href="">@Transactional </a> 的属性配置信息。 </p><p><strong>2、</strong><a href=""><strong>@Transactional</strong> </a> <strong>注解属性 propagation 设置错误</strong> </p><ul><li><p>TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</p></li><li><p>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</p></li><li><p>TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</p></li></ul><p><strong>3、</strong><a href=""><strong>@Transactional</strong> </a> <strong>注解属性 rollbackFor 设置错误</strong> </p><p>rollbackFor 可以指定能够触发事务回滚的异常类型。Spring默认抛出了未检查unchecked异常（继承自 RuntimeException的异常）或者 Error才回滚事务，其他异常不会触发回滚事务。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357302489-9e7b9f08-a40a-4ca0-9344-5256de1b192f.png" alt="img"></p><p>Spring默认支持的异常回滚</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 希望自定义的异常可以进行回滚</span><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation<span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span><span class="token constant">REQUIRED</span><span class="token punctuation">,</span>rollbackFor<span class="token operator">=</span> <span class="token class-name">MyException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>若在目标方法中抛出的异常是 rollbackFor 指定的异常的子类，事务同样会回滚。</p><p><strong>4、同一个类中方法调用，导致@Transactional失效</strong></p><p>开发中避免不了会对同一个类里面的方法调用，比如有一个类Test，它的一个方法A，A再调用本类的方法B（不论方法B是用public还是private修饰），但方法A没有声明注解事务，而B方法有。则外部调用方法A之后，方法B的事务是不会起作用的。这也是经常犯错误的一个地方。</p><p>那为啥会出现这种情况？其实这还是由于使用Spring AOP代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由Spring生成的代理对象来管理。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//@Transactional</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/test"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">CityInfoDict</span> cityInfoDict <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CityInfoDict</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cityInfoDict<span class="token punctuation">.</span><span class="token function">setCityName</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/**         * B 插入字段为 3的数据         */</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">insertB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">/**        * A 插入字段为 2的数据        */</span>       <span class="token keyword">int</span> insert <span class="token operator">=</span> cityInfoDictMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>cityInfoDict<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> insert<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">insertB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>       <span class="token class-name">CityInfoDict</span> cityInfoDict <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CityInfoDict</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       cityInfoDict<span class="token punctuation">.</span><span class="token function">setCityName</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       cityInfoDict<span class="token punctuation">.</span><span class="token function">setParentCityId</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> cityInfoDictMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>cityInfoDict<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种情况是最常见的一种@Transactional注解失效场景</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token keyword">private</span> <span class="token class-name">Integer</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> insert <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">CityInfoDict</span> cityInfoDict <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CityInfoDict</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cityInfoDict<span class="token punctuation">.</span><span class="token function">setCityName</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cityInfoDict<span class="token punctuation">.</span><span class="token function">setParentCityId</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/**         * A 插入字段为 2的数据         */</span>        insert <span class="token operator">=</span> cityInfoDictMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>cityInfoDict<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/**         * B 插入字段为 3的数据        */</span>        b<span class="token punctuation">.</span><span class="token function">insertB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果B方法内部抛了异常，而A方法此时try catch了B方法的异常，那这个事务就不能正常回滚了，会抛出异常：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>transaction<span class="token punctuation">.</span></span>UnexpectedRollbackException</span><span class="token operator">:</span> <span class="token class-name">Transaction</span> rolled back because it has been marked as rollback<span class="token operator">-</span>only<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="28-Spring-MVC-的核心组件？"><a href="#28-Spring-MVC-的核心组件？" class="headerlink" title="28.Spring MVC 的核心组件？"></a>28.Spring MVC 的核心组件？</h2><p>1、<strong>DispatcherServlet</strong>：前置控制器，是整个流程控制的<strong>核心</strong>，控制其他组件的执行，进行统一调度，降低组件之间的耦合性，相当于总指挥。</p><p>2、<strong>Handler</strong>：处理器，完成具体的业务逻辑，相当于 Servlet 或 Action。</p><p>3、<strong>HandlerMapping</strong>：DispatcherServlet 接收到请求之后，通过 HandlerMapping 将不同的请求映射到不同的 Handler。</p><p>4、<strong>HandlerInterceptor</strong>：处理器拦截器，是一个接口，如果需要完成一些拦截处理，可以实现该接口。</p><p>5、<strong>HandlerExecutionChain</strong>：处理器执行链，包括两部分内容：Handler 和 HandlerInterceptor（系统会有一个默认的 HandlerInterceptor，如果需要额外设置拦截，可以添加拦截器）。</p><p>6、<strong>HandlerAdapter</strong>：处理器适配器，Handler 执行业务方法之前，需要进行一系列的操作，包括表单数据的验证、数据类型的转换、将表单数据封装到 JavaBean 等，这些操作都是由 HandlerApater 来完成，开发者只需将注意力集中业务逻辑的处理上，DispatcherServlet 通过 HandlerAdapter 执行不同的 Handler。</p><p>7、<strong>ModelAndView</strong>：装载了模型数据和视图信息，作为 Handler 的处理结果，返回给 DispatcherServlet。</p><p>8、<strong>ViewResolver</strong>：视图解析器，DispatcheServlet 通过它将逻辑视图解析为物理视图，最终将渲染结果响应给客户端。</p><h2 id="29-Spring-MVC-的工作流程？"><a href="#29-Spring-MVC-的工作流程？" class="headerlink" title="29.Spring MVC 的工作流程？"></a>29.Spring MVC 的工作流程？</h2><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357306536-13ae7de6-1f90-435b-80fc-c2f35c61e4b1.png" alt="img"></p><p>1、客户端向服务端发送一次请求，这个请求会先到前端控制器DispatcherServlet(也叫中央控制器)。</p><p>2、DispatcherServlet接收到请求后会调用HandlerMapping处理器映射器。由此得知，该请求该由哪个Controller来处理（并未调用Controller，只是得知）</p><p>3、DispatcherServlet调用HandlerAdapter处理器适配器，告诉处理器适配器应该要去执行哪个Controller</p><p>4、HandlerAdapter处理器适配器去执行Controller并得到ModelAndView(数据和视图)，并层层返回给DispatcherServlet</p><p>5、DispatcherServlet将ModelAndView交给ViewReslover视图解析器解析，然后返回真正的视图。</p><p>6、DispatcherServlet将模型数据填充到视图中</p><p>7、DispatcherServlet将结果响应给客户端</p><p><strong>Spring MVC</strong> 虽然整体流程复杂，但是实际开发中很简单，大部分的组件不需要开发人员创建和管理，只需要通过配置文件的方式完成配置即可，真正需要开发人员进行处理的只有 <strong>Handler（Controller）</strong> 、<strong>View</strong> 、<strong>Model</strong>。</p><p>当然我们现在大部分的开发都是前后端分离，Restful风格接口，后端只需要返回Json数据就行了。</p><h2 id="30-SpringMVC-Restful风格的接口的流程是什么样的呢？"><a href="#30-SpringMVC-Restful风格的接口的流程是什么样的呢？" class="headerlink" title="30.SpringMVC Restful风格的接口的流程是什么样的呢？"></a>30.SpringMVC Restful风格的接口的流程是什么样的呢？</h2><p>PS:这是一道全新的八股，毕竟ModelAndView这种方式应该没人用了吧？现在都是前后端分离接口，八股也该更新换代了。</p><p>我们都知道Restful接口，响应格式是json，这就用到了一个常用注解：<a href=""><strong>@ResponseBody</strong> </a> </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ResponseBody</span><span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">user</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>加入了这个注解后，整体的流程上和使用ModelAndView大体上相同，但是细节上有一些不同：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357308815-7b096331-16ae-4114-af89-c1c9a759d3d6.png" alt="img"></p><p>1、客户端向服务端发送一次请求，这个请求会先到前端控制器DispatcherServlet</p><p>2、DispatcherServlet接收到请求后会调用HandlerMapping处理器映射器。由此得知，该请求该由哪个Controller来处理</p><p>3、DispatcherServlet调用HandlerAdapter处理器适配器，告诉处理器适配器应该要去执行哪个Controller</p><p>4、Controller被封装成了ServletInvocableHandlerMethod，HandlerAdapter处理器适配器去执行invokeAndHandle方法，完成对Controller的请求处理</p><p>5、HandlerAdapter执行完对Controller的请求，会调用HandlerMethodReturnValueHandler去处理返回值，主要的过程：</p><ul><li><p>调用RequestResponseBodyMethodProcessor，创建ServletServerHttpResponse（Spring对原生ServerHttpResponse的封装）实例 </p></li><li><p>使用HttpMessageConverter的write方法，将返回值写入ServletServerHttpResponse的OutputStream输出流中 </p></li><li><p>在写入的过程中，会使用JsonGenerator（默认使用Jackson框架）对返回值进行Json序列化</p></li></ul><p>6、执行完请求后，返回的ModealAndView为null，ServletServerHttpResponse里也已经写入了响应，所以不用关心View的处理</p><h2 id="31-介绍一下SpringBoot，有哪些优点？"><a href="#31-介绍一下SpringBoot，有哪些优点？" class="headerlink" title="31.介绍一下SpringBoot，有哪些优点？"></a>31.介绍一下SpringBoot，有哪些优点？</h2><p>Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring  框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357312002-31aa115d-ecc1-4811-92ad-c8e5c5b45935.png" alt="img"></p><p>Spring Boot 以<code>约定大于配置</code>核心思想开展工作，相比Spring具有如下优势：</p><p>1、Spring Boot 可以快速创建独立的Spring应用程序。</p><p>2、Spring Boot 内嵌了如Tomcat，Jetty和Undertow这样的容器，也就是说可以直接跑起来，用不着再做部署工作了。</p><p>3、Spring Boot 无需再像Spring一样使用一堆繁琐的xml文件配置。</p><p>4、Spring Boot  可以自动配置(核心)Spring。SpringBoot将原有的XML配置改为Java配置，将bean注入改为使用注解注入的方式(@Autowire)，并将多个xml、properties配置浓缩在一个appliaction.yml配置文件中。</p><p>5、Spring Boot 提供了一些现有的功能，如量度工具，表单数据验证以及一些外部配置这样的一些第三方功能。</p><p>6、Spring Boot 可以快速整合常用依赖（开发库，例如spring-webmvc、jackson-json、validation-api和tomcat等），提供的POM可以简化Maven的配置。当我们引入核心依赖时，SpringBoot会自引入其他依赖。</p><h2 id="32-SpringBoot自动配置原理了解吗？"><a href="#32-SpringBoot自动配置原理了解吗？" class="headerlink" title="32.SpringBoot自动配置原理了解吗？"></a>32.SpringBoot自动配置原理了解吗？</h2><p>SpringBoot开启自动配置的注解是<code>@EnableAutoConfiguration</code> ，启动类上的注解<code>@SpringBootApplication</code>是一个复合注解，包含了@EnableAutoConfiguration：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357314316-9869cb9e-b65e-48f0-afd3-12af224dfbd0.png" alt="img"></p><p><code>EnableAutoConfiguration</code> 只是一个简单的注解，自动装配核心功能的实现实际是通过 <code>AutoConfigurationImportSelector</code>类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@AutoConfigurationPackage</span> <span class="token comment">//将main同级的包下的所有组件注册到容器中</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">AutoConfigurationImportSelector</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token comment">//加载自动装配类 xxxAutoconfiguration</span><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">EnableAutoConfiguration</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> <span class="token constant">ENABLED_OVERRIDE_PROPERTY</span> <span class="token operator">=</span> <span class="token string">"spring.boot.enableautoconfiguration"</span><span class="token punctuation">;</span>    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">exclude</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">excludeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>AutoConfigurationImportSelector</code>实现了<code>ImportSelector</code>接口，这个接口的作用就是收集需要导入的配置类，配合<code>@Import(）</code>就可以将相应的类导入到Spring容器中</p><p>获取注入类的方法是selectImports()，它实际调用的是<code>getAutoConfigurationEntry</code>，这个方法是获取自动装配类的关键，主要流程可以分为这么几步：</p><p>1、获取注解的属性，用于后面的排除</p><p>2、<strong>获取所有需要自动装配的配置类的路径</strong>：这一步是最关键的，从META-INF&#x2F;spring.factories获取自动配置类的路径</p><p>3、去掉重复的配置类和需要排除的重复类，把需要自动加载的配置类的路径存储起来</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">AutoConfigurationImportSelector<span class="token punctuation">.</span>AutoConfigurationEntry</span> <span class="token function">getAutoConfigurationEntry</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> annotationMetadata<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isEnabled</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token constant">EMPTY_ENTRY</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//1.获取到注解的属性</span>        <span class="token class-name">AnnotationAttributes</span> attributes <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getAttributes</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.获取需要自动装配的所有配置类，读取META-INF/spring.factories，获取自动配置类路径</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> configurations <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getCandidateConfigurations</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">,</span> attributes<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//3.1.移除重复的配置</span>        configurations <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">removeDuplicates</span><span class="token punctuation">(</span>configurations<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//3.2.处理需要排除的配置</span>        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> exclusions <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getExclusions</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">,</span> attributes<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">checkExcludedClasses</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>        configurations<span class="token punctuation">.</span><span class="token function">removeAll</span><span class="token punctuation">(</span>exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>        configurations <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getConfigurationClassFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>configurations<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fireAutoConfigurationImportEvents</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AutoConfigurationImportSelector<span class="token punctuation">.</span>AutoConfigurationEntry</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="33-如何自定义一个SpringBoot-Srarter"><a href="#33-如何自定义一个SpringBoot-Srarter" class="headerlink" title="33.如何自定义一个SpringBoot Srarter?"></a>33.如何自定义一个SpringBoot Srarter?</h2><p>知道了自动配置原理，创建一个自定义SpringBoot Starter也很简单。</p><p>1、创建一个项目，命名为demo-spring-boot-starter，引入SpringBoot相关依赖</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-configuration-processor<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、编写配置文件；这里定义了属性配置的前缀</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloProperties</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token comment">//省略getter、setter</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、自动装配；创建自动配置类HelloPropertiesConfigure</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span><span class="token class-name">HelloProperties</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloPropertiesConfigure</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>4、配置自动类；在<code>/resources/META-INF/spring.factories</code>文件中添加自动配置类路径</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span></span>EnableAutoConfiguration</span><span class="token operator">=</span>\  <span class="token class-name"><span class="token namespace">cn<span class="token punctuation">.</span>fighter3<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>starter<span class="token punctuation">.</span>configure<span class="token punctuation">.</span></span>HelloPropertiesConfigure</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>5、测试；至此，随手写的一个自定义SpringBoot-Starter就完成了，虽然比较简单，但是完成了主要的自动装配的能力。</p><p>6、创建一个工程，引入自定义starter依赖</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>cn.fighter3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>demo-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>7、在配置文件里添加配置</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">hello<span class="token punctuation">.</span>name<span class="token operator">=</span>张三<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>8、测试类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span><span class="token class-name">SpringRunner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloTest</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token class-name">HelloProperties</span> helloProperties<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"你好，"</span><span class="token operator">+</span>helloProperties<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>8、运行结果</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357318769-7365d52c-e692-4ed2-a8a4-3c1ac35504dc.png" alt="img"></p><h2 id="34-Springboot-启动原理？"><a href="#34-Springboot-启动原理？" class="headerlink" title="34.Springboot 启动原理？"></a>34.Springboot 启动原理？</h2><p>SpringApplication 这个类主要做了以下四件事情：</p><p>1、推断应用的类型是普通的项目还是 Web 项目</p><p>2、查找并加载所有可用初始化器 ， 设置到 initializers 属性中</p><p>3、找出所有的应用程序监听器，设置到 listeners 属性中</p><p>4、推断并设置 main 方法的定义类，找到运行的主类</p><p>SpringBoot 启动大致流程如下 ：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E7%AF%87.assets/1676357320577-538657c2-d51b-4979-a3bc-05553718715f.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-Spring是什么？特性？有哪些模块？&quot;&gt;&lt;a href=&quot;#1-Spring是什么？特性？有哪些模块？&quot; class=&quot;headerlink&quot; title=&quot;1.Spring是什么？特性？有哪些模块？&quot;&gt;&lt;/a&gt;1.Spring是什么？特性？有哪些模块？&lt;/</summary>
      
    
    
    
    <category term="PROJECT" scheme="https://zspcer.gitee.io/categories/PROJECT/"/>
    
    <category term="我要进大厂" scheme="https://zspcer.gitee.io/categories/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/"/>
    
    
    <category term="面试" scheme="https://zspcer.gitee.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="我要进大厂" scheme="https://zspcer.gitee.io/tags/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/"/>
    
    <category term="Spring" scheme="https://zspcer.gitee.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>大厂面试之Zookeeper篇</title>
    <link href="https://zspcer.gitee.io/note/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BZookeeper%E7%AF%87/"/>
    <id>https://zspcer.gitee.io/note/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BZookeeper%E7%AF%87/</id>
    <published>2023-05-11T16:37:37.000Z</published>
    <updated>2023-05-11T15:42:17.406Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Zookeeper-是什么？能做什么？"><a href="#1-Zookeeper-是什么？能做什么？" class="headerlink" title="1.Zookeeper 是什么？能做什么？"></a>1.Zookeeper 是什么？能做什么？</h2><p>Zookeeper 是一个<strong>开源的</strong>，是用于维护配置信息，命名，提供<strong>分布式</strong>同步和提供组服务的集中式服务。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BZookeeper%E7%AF%87.assets/1676359277603-b5b69f98-9c1f-448a-b114-1a18f908b8cc.png" alt="img"></p><p>可以基于 Zookeeper 实现诸如<strong>数据发布&#x2F;订阅、负载均衡、命名服务、分布式协调&#x2F;通知、集群管理、Master 选举、分布式锁和分布式队列</strong>等功能。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BZookeeper%E7%AF%87.assets/1676359279793-cea8a2fe-249c-42b2-85e6-b17a243e48ac.png" alt="img"></p><p>Zookeeper 最常用的一个使用场景就是作为<strong>注册中心</strong>，生产者将自己提供的服务注册到 Zookeeper，然后消费者从 Zookeeper 中<strong>拿到生产者的服务列表信息</strong>，然后再去<strong>调用生产者</strong>的内容数据，比如 <strong>Dubbo，Kafka</strong> 都是使用 Zookeeper 作为注册中心的。</p><h2 id="2-说说-Zookeeper-的数据结构吧"><a href="#2-说说-Zookeeper-的数据结构吧" class="headerlink" title="2.说说 Zookeeper 的数据结构吧"></a>2.说说 Zookeeper 的数据结构吧</h2><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BZookeeper%E7%AF%87.assets/1676359282136-57a9f9c0-1ee4-4e30-bc1d-cd1adf5e6a29.png" alt="img"></p><p>ZooKeeper 提供的名称空间与标准文件系统的名称空间非常相似。名称是由斜杠（“ &#x2F;”）分隔的一系列路径元素。ZooKeeper 命名空间中的每个 znode 均由路径标识。<strong>每个 znode 都有一个父对象</strong>，其路径是 znode 的前缀，元素少一个；此规则的例外是 root（“ &#x2F;”），它没有父项。此外，与标准文件系统完全一样，<strong>如果 znode 有子节点，则无法删除它</strong>。</p><p>ZooKeeper 与标准文件系统之间的主要区别在于，<strong>每个 znode 都可以具有与之关联的数据</strong>（每个文件也可以是目录，反之亦然），并且 znode 限于它们可以拥有的数据量。ZooKeeper 旨在存储协调数据：状态信息，配置，位置信息等。这种元信息通常以千字节（如果不是字节）来度量。<strong>ZooKeeper 具有1M的内置完整性检查，以防止将其用作大型数据存储</strong>，但是通常，它用于存储小得多的数据。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BZookeeper%E7%AF%87.assets/1676359284368-e340a44b-ad0f-483b-9f4f-202cc8a4a7d2.png" alt="img"></p><p><strong>Znode的三种类型:</strong></p><ul><li><p><strong>持久节点</strong>（persistent node）节点会被持久</p></li><li><p><strong>临时节点</strong>（ephemeral node），客户端断开连接后，ZooKeeper 会自动删除临时节点</p></li><li><p><strong>顺序节点</strong>（sequential node），每次创建顺序节点时，ZooKeeper 都会在路径后面自动添加上10位的数字，从1开始，最大是2147483647 （2^32-1）</p></li></ul><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BZookeeper%E7%AF%87.assets/1676359286605-0158dce7-a328-4562-b06d-68067f43dcb4.png" alt="img"></p><p><strong>Znode的四种形式:</strong></p><ul><li><p><strong>持久节点</strong>:如 create &#x2F;test&#x2F;a  “hello”，通过 create参数指定为持久节点</p></li><li><p><strong>持久顺序节点</strong>:通过 create -s参数指定为顺序节点</p></li><li><p><strong>临时节点</strong>:通过 create -e参数指定为顺序节点</p></li><li><p><strong>临时顺序节点</strong>:通过 create -s -e参数指定为临时及顺序节点</p></li></ul><h2 id="3-Znode里面都存储了什么？"><a href="#3-Znode里面都存储了什么？" class="headerlink" title="3.Znode里面都存储了什么？"></a>3.Znode里面都存储了什么？</h2><p>Znode包含了<strong>存储数据(data)<strong>、</strong>访问权限(acl)<strong>、</strong>子节点引用(child)<strong>、</strong>节点状态信息(stat)</strong></p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BZookeeper%E7%AF%87.assets/1676359288747-64c0ac73-1089-4a62-9cab-59e5fb43f5f1.png" alt="img"></p><p><strong>data</strong>: znode存储的业务数据信息</p><p><strong>acl</strong>: 记录客户端对znode节点的访问权限，如IP等。</p><p><strong>child</strong>: 当前节点的子节点引用</p><p><strong>stat</strong>: 包含Znode节点的状态信息，比如事务id、版本号、时间戳等等。</p><h2 id="4-Zookeeper-的系统架构又是怎么样的？"><a href="#4-Zookeeper-的系统架构又是怎么样的？" class="headerlink" title="4.Zookeeper 的系统架构又是怎么样的？"></a>4.Zookeeper 的系统架构又是怎么样的？</h2><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BZookeeper%E7%AF%87.assets/1676359291366-9c2e425c-0281-4255-850b-0d80d9511440.png" alt="img"></p><p>ZooKeeper 分为<strong>服务器端</strong>（Server） 和<strong>客户端</strong>（Client），客户端可以连接到整个 ZooKeeper 服务的任意服务器上（除非 leaderServes 参数被显式设置，leader 不允许接受客户端连接），客户端使用并维护一个 <strong>TCP 连接</strong>，通过这个连接发送请求、接受响应、获取观察的事件以及发送信息。</p><p>组成 ZooKeeper 服务的服务器必须彼此了解。它们维护一个内存中的状态图像，以及持久存储中的事务日志和快照，只要<strong>大多数服务器可用，ZooKeeper 服务就可用</strong>；</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BZookeeper%E7%AF%87.assets/1676359293005-e0f9cdba-c3c5-4b6b-91e2-cb53e481ee7c.png" alt="img"></p><p>Zookeeper 集群中<strong>Server有三种角色</strong>，Leader、Follower 和 Observer</p><ul><li><p><strong>Leader</strong>:负责投投票的发起与决议，更新系统状态，写数据</p></li><li><p><strong>Follower</strong>:用于接收客户端请求并用来返回结果，在选主过程中参与投票</p></li><li><p><strong>Observer</strong>:可以接受客户端连接，将<strong>写请求转发给leader</strong>节点，但是不参与投票过程，只<strong>同步leader状态</strong>，主要存在目的就是<strong>为了提高读取效率</strong></p></li></ul><p>将 server 分为三种是为了<strong>避免太多的从节点参与过半写</strong>的过程，导致影响性能，这样 Zookeeper 只要使用一个几台机器的小集群就可以实现高性能了，如果要横向扩展的话，只需要增加 Observer 节点即可。</p><p>Zookeeper 建议集群节点个数为奇数，只要<strong>超过一半的机器</strong>能够正常提供服务，那么整个集群都是可用的状态。</p><p>ZooKeeper 启动时，将从实例中选举一个 leader，<strong>Leader 负责处理数据更新</strong>等操作，一个更新操作成功的标志是当且仅当大多数 Server 在内存中成功修改数据。每个 Server 在内存中存储了一份数据。</p><p>Zookeeper 的数据一致性是依靠<strong>ZAB协议</strong>完成的。</p><h2 id="5-那你继续给我讲讲-ZAB-协议吧"><a href="#5-那你继续给我讲讲-ZAB-协议吧" class="headerlink" title="5.那你继续给我讲讲 ZAB 协议吧"></a>5.那你继续给我讲讲 ZAB 协议吧</h2><p>ZAB（ZooKeeper Atomic Broadcast 原子广播） 协议是为 ZooKeeper 特殊设计的一种<strong>支持崩溃恢复</strong>的原子广播协议。在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。</p><p>ZAB 协议包括有两种模式，分别是 <strong>崩溃恢复和消息广播</strong>。</p><p>1、<strong>崩溃恢复</strong>：当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进人恢复模式并<strong>选举产生新的 Leader</strong> 服务器。当选举产生了新的 Leader 服务器，同时集群中已经有<strong>过半的机器与该 Leader 服务器完成了状态同步</strong>之后，ZAB 协议<strong>就会退出恢复模式</strong>。剩下未同步完成的机器会继续同步，<strong>直到同步完成并加入集群后该节点的服务才可用</strong>。</p><p>2、<strong>消息广播</strong>：当集群中<strong>已经有过半的 Follower 服务器完成了和 Leader 服务器的状态同步</strong>，那么整个服务框架就可以<strong>进人消息广播模式</strong>了。当一台同样遵守 ZAB 协议的服务器启动后加人到集群中时，如果此时集群中<strong>已经存在一个 Leader 服务器在负责进行消息广播</strong>，那么新加人的服务器就会<strong>自觉地进人数据恢复模式</strong>：找到 Leader 所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。ZooKeeper 设计成<strong>只允许唯一的一个 Leader 服务器来进行事务请求</strong>的处理。Leader 服务器在接收到客户端的事务请求后，会生成对应的事务提案并发起一轮广播协议；而如果集群中的<strong>其他机器接收到客户端的事务</strong>请求，那么这些非 Leader 服务器会<strong>首先将这个事务请求转发给 Leader</strong> 服务器。</p><h2 id="6-Zookeeper初始化是如何进行Leader选举的？"><a href="#6-Zookeeper初始化是如何进行Leader选举的？" class="headerlink" title="6.Zookeeper初始化是如何进行Leader选举的？"></a>6.Zookeeper初始化是如何进行Leader选举的？</h2><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BZookeeper%E7%AF%87.assets/1676359295689-6b0c6b6a-6506-4ad6-aa14-d45948010d7f.png" alt="img"></p><p>在集群初始化阶段，只有两台以以上的 ZK 启动才会发生leader选举，过程如下：</p><p>(1) <strong>每个 Server 发出一个投票</strong>。初始选举 ZK1 和 ZK2 都会将自己作为 Leader 服务器来进行投票，每次投票会包含所推举的服务器的(<strong>myid, ZXID</strong>)，此时 ZK1 的投票为(1, 0)，ZK2 的投票为(2, 0)，然后各自<strong>将这个投票发给集群中其他机器</strong>。</p><p>(2) 收到投票。集群的每个服务器收到投票后，首先<strong>判断</strong>该投票的<strong>有效性</strong>，如检查是否是本轮投票、是否来自 LOOKING 状态的服务器。</p><p>(3) 处理投票。每个发起投票的服务器需要<strong>将别人的投票和自己的投票进行比较</strong>，规则如下:</p><ul><li>优先检查 ZXID。<strong>ZXID 比较大的服务器优先作为 Leader</strong>。<strong>如果 ZXID 相同</strong>，那么就比较 myid。<strong>myid 较大的服务器作为Leader服务器</strong>。</li></ul><p>(4) 统计投票。每次投票后，服务器都会统计投票信息，<strong>判断是否已经有过半机器接受到相同的投票信息</strong>，对于 ZK1、ZK2 而言，都统计出集群中已经有两台机器接受了(2, 0)的投票信息，此时便认为已经选出 ZK2 作为Leader。</p><p>(5) 改变服务器状态。<strong>一旦确定了 Leader，每个服务器就会更新自己的状态</strong>，如果是Follower，那么就变更为 FOLLOWING，如果是 Leader，就变更为 LEADING。当新的 Zookeeper 节点 ZK3 启动时，发现已经有 Leader 了，不再选举，直接将直接的状态从 LOOKING 改为 FOLLOWING。</p><h2 id="7-如果Leader挂了，进入崩溃恢复，怎么选举Leader？"><a href="#7-如果Leader挂了，进入崩溃恢复，怎么选举Leader？" class="headerlink" title="7.如果Leader挂了，进入崩溃恢复，怎么选举Leader？"></a>7.如果Leader挂了，进入崩溃恢复，怎么选举Leader？</h2><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BZookeeper%E7%AF%87.assets/1676359298155-2b6da59e-74f1-4e99-9c4a-0b53e717b39a.png" alt="img"></p><p>1、<strong>变更状态</strong>。Leader 挂后，余下的非 Observer 服务器都会讲自己的服务器状态变更为 LOOKING，然后开始进入 Leader 选举过程。</p><p>2、每个<strong>非 Observer</strong> 的 Server 会<strong>发出一个投票</strong>。和启动过程一致。</p><p>3、<strong>接收</strong>来自各个服务器的<strong>投票</strong>。与启动时过程相同。</p><p>4、<strong>处理投票</strong>。与启动时过程相同。</p><p>5、<strong>统计投票</strong>。与启动时过程相同。</p><p>6、<strong>改变服务器的状态</strong>。与启动时过程相同。</p><h2 id="8-说说Wather监听机制和它的原理？"><a href="#8-说说Wather监听机制和它的原理？" class="headerlink" title="8.说说Wather监听机制和它的原理？"></a>8.说说Wather监听机制和它的原理？</h2><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BZookeeper%E7%AF%87.assets/1676359299813-55473a43-0f62-4a08-a1b6-cd157af1c390.png" alt="img"></p><p>具体的步骤如下:</p><p>1、<strong>服务注册</strong>：Provider 启动时，会向 zookeeper 服务端<strong>注册服务信息</strong>，也就是创建一个节点。</p><p>2、<strong>服务发现</strong>：Consumer 启动时，根据自身配置的依赖服务信息，向 zookeeper 服务端获取注册的服务信息并<strong>设置 watch 监听</strong>，获取到注册的服务信息之后，将服务提供者的信息<strong>缓存在本地</strong>，并进行服务的调用。</p><p>3、<strong>服务通知</strong>：一旦服务提供者因某种原因宕机不再提供服务之后，客户端与 zookeeper <strong>服务端断开</strong>连接，zookeeper 服务端上服务提供者对应服务<strong>节点会被删除</strong>，随后 zookeeper 服务端会<strong>异步向所有注册了该服务，且设置了 watch 监听的服务消费者</strong>发出节点被删除的通知，消费者根据<strong>收到的通知拉取最新服务列表</strong>，<strong>更新本地缓存</strong>的服务列表。</p><p>简单的理解就是 client 会对某个 znode 注册一个 watcher 事件，当该 <strong>znode 发生变化</strong>时，这些 client 会<strong>收到 ZooKeeper 的通知</strong>。</p><p><strong>四个特性</strong>：</p><p>1、一次性：一旦一个Wather<strong>触发</strong>之后，Zookeeper<strong>就会</strong>将它从存储中<strong>移除</strong>，<strong>如果还要继续监听</strong>这个节点，就<strong>需要</strong>我们在客户端的监听回调中，<strong>再次</strong>对节点的监听watch事件<strong>设置为True</strong>。否则客户端只能接收到一次该节点的变更通知</p><p>2、客户端串行：客户端的<strong>Wather回调处理是串行同步</strong>的过程，不要因为一个Wather的逻辑阻塞整个客户端</p><p>3、轻量：Wather通知的单位是WathedEvent，<strong>只包含通知状态、事件类型和节点路径，不包含具体的事件内容</strong>，具体的时间内容需要客户端主动去重新获取数据</p><p>4、异步:  Zookeeper服务器<strong>发送watcher的通知事件到客户端是异步</strong>的，不能期望能够监控到节点每次的变化，Zookeeper只能保证最终的一致性，而无法保证强一致性。</p><h2 id="9-Zookeeper有哪些特性呢？"><a href="#9-Zookeeper有哪些特性呢？" class="headerlink" title="9.Zookeeper有哪些特性呢？"></a>9.Zookeeper有哪些特性呢？</h2><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BZookeeper%E7%AF%87.assets/1676359301974-e02fd791-5bb1-4a9d-965d-2b2402c0aeeb.png" alt="img"></p><p><strong>顺序一致性</strong>：leader会根据请求顺序生成 ZXID 来严格保证请求顺序的下发执行。</p><p><strong>原子性</strong>：所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，要么成功，要么就失败。</p><p><strong>单一视图</strong>：无论客户端连到哪一个 ZooKeeper 服务器上，看到的数据都是一致的。</p><p><strong>可靠性</strong>：一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会被一直保留下来。</p><p><strong>实时性</strong>：Zookeeper 仅仅能保证在段时间内客户端最终一定能够从服务端上读取到最新的数据状态。</p><h2 id="10-Zookeeper-如何识别请求的先后顺序？"><a href="#10-Zookeeper-如何识别请求的先后顺序？" class="headerlink" title="10.Zookeeper 如何识别请求的先后顺序？"></a>10.Zookeeper 如何识别请求的先后顺序？</h2><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BZookeeper%E7%AF%87.assets/1676359303980-9fe866e0-f449-4721-b57c-b7939cde3301.png" alt="img"></p><p>Leader 收到请求之后，会将每个请求分配一个全局唯一递增的事务ID：zxid，然后把请求放入到一个 <strong>FIFO 的队列</strong>中，之后就会按照 FIFO 的策略发送给所有的 Follower。</p><h2 id="11-选举-leader-后是怎么进行数据同步的"><a href="#11-选举-leader-后是怎么进行数据同步的" class="headerlink" title="11.选举 leader 后是怎么进行数据同步的"></a>11.选举 leader 后是怎么进行数据同步的</h2><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BZookeeper%E7%AF%87.assets/1676359306037-b25b5d96-f5a4-4ec8-b9b6-57daf6bfa4cc.png" alt="img"></p><p>前面提到写数据是由 leader 负责的，而 leader 会将每个请求分配一个 ZXID，放入一个队列中，依次执行，每次 leader  执行完一个请求后，会记录下执行的这个 ZXID。</p><p>我们将这个队列中最大的 ZXID 称为 <strong>maxZXID</strong>，最小的 ZXID 称为 <strong>minZXID</strong>。</p><p>将 Observer 和 follower 中最新的 ZXID <strong>称为lastSyncZXID</strong></p><p>*<em><strong>proposal : l其实就是将请求中的一些信息如请求头，请求体以及 ZXID 等信息封装到 proposal对象当中*</strong></em></p><p><strong>1、差异化同步</strong></p><ul><li><p>1).leader 向 Observer 和 follower 发送 DIFF 指令，之后就开始差异化同步 </p></li><li><p>2).然后把差异数据 提议 proposal 发送给 Observer 和 follower , Observer 和 follower 返回ACK表示已经完成了同步 </p></li><li><p>3).只要集群中过半的 Observer 和 follower 响应了 ACK 就发送一个 UPTODATE 命令 </p></li><li><p>4).leader 返回 ACK，同步流程结束 </p></li><li><ul><li><strong>触发条件</strong>:minZXID &lt; lastSyncZXID &lt; maxZXID</li></ul></li><li><ul><li><strong>同步过程</strong>:</li></ul></li></ul><p><strong>2、回滚同步</strong></p><ul><li><p>1).直接回滚到 maxZXID </p></li><li><ul><li><strong>触发条件</strong> maxZXID &lt; lastSyncZXID</li></ul></li><li><ul><li><strong>举个例子</strong>：a，b，c三台服务服务器 a是leader，此时队列里面最大的 ZXID 为100，a 收到请求，该 ZXID 为101，还没来得及发送同步数据 a 就挂了，b 变为leader，然后 a 恢复了，此时就需要 a 先将之前 ZXID 为101的数据回滚</li></ul></li></ul><p><strong>3、回滚+差异化同步</strong></p><ul><li><p>1).Observer 和 follower 将数据回滚 </p></li><li><p>2).进行差异化同步 </p></li><li><ul><li><strong>触发条件</strong>:如果Leader刚生成一个proposal，还没有来得及发送出去，此时Leader宕机，重新选举之后作为Follower，但是新的Leader没有这个proposal数据</li></ul></li><li><ul><li><strong>举个例子</strong>：a，b，c三台服务服务器 a是leader，此时队列里面最大的 ZXID 为100，a 收到请求，该 ZXID 为101，还没来得及发送同步数据 a 就挂了，b 变为leader，b 又处理了3个请求，则 b 队列中最大的 ZXID 为103，然后 a 恢复了，此时就需要 a 先将之前 ZXID 为101的数据回滚，再进行同步</li></ul></li></ul><p><strong>4、全量同步</strong></p><ul><li><p>1).lastSyncZXID &lt; minZXID</p></li><li><p>2).Leader服务器上没有缓存队列，并且lastSyncZXID!&#x3D;maxZXID </p></li><li><ul><li><strong>触发条件</strong></li></ul></li><li><ul><li><strong>同步过程</strong>：leader 向 Observer 和 follower 发送SNAP命令，进行数据全量同步</li></ul></li></ul><h2 id="12-Zookeeper-会有数据不一致的情况发生吗？"><a href="#12-Zookeeper-会有数据不一致的情况发生吗？" class="headerlink" title="12.Zookeeper 会有数据不一致的情况发生吗？"></a>12.Zookeeper 会有数据不一致的情况发生吗？</h2><p>还是会有的，因为 Zookeeper 采用的是<strong>过半写</strong>机制，意味着<strong>3台服务器只要有两台写成功就代表整个集群写成功</strong>，如果刚好有请求打在这台还<strong>未写的服务器</strong>上就查询不到该数据，就会有数据不一致的情况产生。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-Zookeeper-是什么？能做什么？&quot;&gt;&lt;a href=&quot;#1-Zookeeper-是什么？能做什么？&quot; class=&quot;headerlink&quot; title=&quot;1.Zookeeper 是什么？能做什么？&quot;&gt;&lt;/a&gt;1.Zookeeper 是什么？能做什么？&lt;/</summary>
      
    
    
    
    <category term="PROJECT" scheme="https://zspcer.gitee.io/categories/PROJECT/"/>
    
    <category term="我要进大厂" scheme="https://zspcer.gitee.io/categories/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/"/>
    
    
    <category term="面试" scheme="https://zspcer.gitee.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="我要进大厂" scheme="https://zspcer.gitee.io/tags/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/"/>
    
    <category term="Zookeeper" scheme="https://zspcer.gitee.io/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>大厂面试之操作系统篇</title>
    <link href="https://zspcer.gitee.io/note/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AF%87/"/>
    <id>https://zspcer.gitee.io/note/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AF%87/</id>
    <published>2023-05-11T16:37:37.000Z</published>
    <updated>2023-05-11T15:42:17.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-操作系统的四个特性？"><a href="#1-操作系统的四个特性？" class="headerlink" title="1.操作系统的四个特性？"></a>1.操作系统的四个特性？</h2><p>并发：同一段时间内多个程序执行（与并行区分，并行指的是同一时刻有多个事件，多处理器系统可以使程序并行执行）</p><p>共享：系统中的资源可以被内存中多个并发执行的进线程共同使用</p><p>虚拟：通过分时复用（如分时系统）以及空分复用（如虚拟内存）技术把一个物理实体虚拟为多个</p><p>异步：系统进程用一种走走停停的方式执行，（并不是一下子走完），进程什么时候以怎样的速度向前推进是不可预知的</p><h2 id="2-进程线程"><a href="#2-进程线程" class="headerlink" title="2.进程线程"></a>2.进程线程</h2><p>进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间。</p><p>线程是比进程更小的执行单位，它是在一个进程中独立的控制流，一个进程可以启动多个线程，每条线程并行执行不同的任务。</p><p><strong>进程和线程的区别如下</strong>：</p><p>1、调度：进程是资源管理的基本单位，线程是程序执行的基本单位。</p><p>2、切换：线程上下文切换比进程上下文切换要快得多。</p><p>3、拥有资源： 进程是拥有资源的一个独立单位，线程不拥有系统资源，但是可以访问隶属于进程的资源。</p><p>4、系统开销： 创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间，I&#x2F;O设备等，OS所付出的开销显著大于在创建或撤销线程时的开销，进程切换的开销也远大于线程切换的开销。</p><h2 id="3-并发和并行"><a href="#3-并发和并行" class="headerlink" title="3.并发和并行"></a>3.并发和并行</h2><p>并发就是在一段时间内，多个任务都会被处理；但在某一时刻，只有一个任务在执行。单核处理器可以做到并发。比如有两个进程<code>A</code>和<code>B</code>，<code>A</code>运行一个时间片之后，切换到<code>B</code>，<code>B</code>运行一个时间片之后又切换到<code>A</code>。因为切换速度足够快，所以宏观上表现为在一段时间内能同时运行多个程序。</p><p>并行就是在同一时刻，有多个任务在执行。这个需要多核处理器才能完成，在微观上就能同时执行多条指令，不同的程序被放到不同的处理器上运行，这个是物理上的多个进程同时进行。</p><h2 id="4-多线程相较单线程的好处"><a href="#4-多线程相较单线程的好处" class="headerlink" title="4.多线程相较单线程的好处"></a>4.多线程相较单线程的好处</h2><p>1、并发提升程序执行效率</p><p>2、提升CPU利用率，访存的时候可以切换线程来执行</p><p>3、更快的响应速度，可以有专门的线程来监听用户请求和专门的线程来处理请求。比如监听线程和工作线程是两个线程，这样监听就负责监听，工作的就负责工作，监听到用户请求马上把请求转到工作线程去处理，监听线程继续监听</p><h2 id="5-什么是协程？"><a href="#5-什么是协程？" class="headerlink" title="5.什么是协程？"></a>5.什么是协程？</h2><p>协程是一种用户态的轻量级线程。</p><p>协程不是由操作系统内核管理，而是完全由用户程序所控制，这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p><p>协程可以理解为可以暂停执行的函数。它拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p><h2 id="6-线程和协程有什么区别呢？"><a href="#6-线程和协程有什么区别呢？" class="headerlink" title="6.线程和协程有什么区别呢？"></a>6.线程和协程有什么区别呢？</h2><p>1、线程是抢占式，而协程是非抢占式的，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。 2、线程是协程的资源。协程通过 可以关联任意线程或线程池的执行器（Interceptor）来间接使用线程的资源的。</p><h2 id="7-进程通信"><a href="#7-进程通信" class="headerlink" title="7.进程通信"></a>7.进程通信</h2><p>进程间通信方式有以下几种：</p><p>1、<strong>管道通信</strong></p><p>匿名管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 有名管道是半双工的通信方式，数据只能单向流动。</p><p>2、<strong>消息队列</strong></p><p>3、<strong>共享内存</strong>。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p><p>4、<strong>信号量</strong>。信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p><h2 id="8-什么是死锁？"><a href="#8-什么是死锁？" class="headerlink" title="8.什么是死锁？"></a>8.什么是死锁？</h2><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象。若无外力作用，它们都将无法推进下去。</p><p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方持有的资源，所以这两个线程就会互相等待而进入死锁状态。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AF%87.assets/1676359011025-9bca64ba-7a48-4a41-befc-137058d82dc2.png" alt="img"></p><p>下面通过例子说明线程死锁，代码来自并发编程之美。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeadLockDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> resource1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//资源 1</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> resource2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//资源 2</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"waiting get resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">"线程 1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"waiting get resource1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">"线程 2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码输出如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Thread</span><span class="token punctuation">[</span>线程 <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span>get resource1<span class="token class-name">Thread</span><span class="token punctuation">[</span>线程 <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span>get resource2<span class="token class-name">Thread</span><span class="token punctuation">[</span>线程 <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span>waiting get resource2<span class="token class-name">Thread</span><span class="token punctuation">[</span>线程 <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span>waiting get resource1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>线程 A 通过 <code>synchronized</code> (resource1) 获得 resource1 的监视器锁，然后通过 <code>Thread.sleep(1000)</code>。让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。</p><h2 id="9-死锁怎么产生？怎么避免？"><a href="#9-死锁怎么产生？怎么避免？" class="headerlink" title="9.死锁怎么产生？怎么避免？"></a>9.死锁怎么产生？怎么避免？</h2><p><strong>死锁产生的四个必要条件</strong>：</p><ul><li><p>互斥：一个资源每次只能被一个进程使用</p></li><li><p>请求与保持：一个进程因请求资源而阻塞时，不释放获得的资源</p></li><li><p>不剥夺：进程已获得的资源，在未使用之前，不能强行剥夺</p></li><li><p>循环等待：进程之间循环等待着资源</p></li></ul><p><strong>避免死锁的方法</strong>：</p><ul><li><p>互斥条件不能破坏，因为加锁就是为了保证互斥</p></li><li><p>一次性申请所有的资源，避免线程占有资源而且在等待其他资源</p></li><li><p>占有部分资源的线程进一步申请其他资源时，如果申请不到，主动释放它占有的资源</p></li><li><p>按序申请资源</p></li></ul><h2 id="10-进程调度策略有哪几种？"><a href="#10-进程调度策略有哪几种？" class="headerlink" title="10.进程调度策略有哪几种？"></a>10.进程调度策略有哪几种？</h2><p>1、<strong>先来先服务</strong>：非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。另外，对<code>I/O</code>密集型进程也不利，因为这种进程每次进行<code>I/O</code>操作之后又得重新排队。</p><p>2、<strong>短作业优先</strong>：非抢占式的调度算法，按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p><p>3、<strong>最短剩余时间优先</strong>：最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p><p>4、<strong>时间片轮转</strong>：将所有就绪进程按 <code>FCFS</code> 的原则排成一个队列，每次调度时，把 <code>CPU</code> 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 <code>CPU</code> 时间分配给队首的进程。</p><p>时间片轮转算法的效率和时间片的大小有很大关系：因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。 而如果时间片过长，那么实时性就不能得到保证。</p><p>5、<strong>优先级调度</strong>：为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p><h2 id="11-进程有哪些状态？"><a href="#11-进程有哪些状态？" class="headerlink" title="11.进程有哪些状态？"></a>11.进程有哪些状态？</h2><p>进程一共有<code>5</code>种状态，分别是创建、就绪、运行（执行）、终止、阻塞。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AF%87.assets/1676359015750-97063aac-4752-45df-80ae-1814b7ca8fc9.png" alt="img"></p><p>运行状态就是进程正在<code>CPU</code>上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态。</p><p>就绪状态就是说进程已处于准备运行的状态，即进程获得了除<code>CPU</code>之外的一切所需资源，一旦得到<code>CPU</code>即可运行。</p><p>阻塞状态就是进程正在等待某一事件而暂停运行，比如等待某资源为可用或等待<code>I/O</code>完成。即使<code>CPU</code>空闲，该进程也不能运行。</p><p><strong>运行态→阻塞态</strong>：往往是由于等待外设，等待主存等资源分配或等待人工干预而引起的。 <strong>阻塞态→就绪态</strong>：则是等待的条件已满足，只需分配到处理器后就能运行。 <strong>运行态→就绪态</strong>：不是由于自身原因，而是由外界原因使运行状态的进程让出处理器，这时候就变成就绪态。例如时间片用完，或有更高优先级的进程来抢占处理器等。 <strong>就绪态→运行态</strong>：系统按某种策略选中就绪队列中的一个进程占用处理器，此时就变成了运行态。</p><h2 id="12-操作系统里的内存碎片怎么理解？"><a href="#12-操作系统里的内存碎片怎么理解？" class="headerlink" title="12.操作系统里的内存碎片怎么理解？"></a>12.操作系统里的内存碎片怎么理解？</h2><p>内存碎片通常分为内部碎片和外部碎片：</p><p>1、内部碎片是由于采用固定大小的内存分区，当一个进程不能完全使用分给它的固定内存区域时就会产生内部碎片。通常内部碎片难以完全避免</p><p>2、外部碎片是由于某些未分配的连续内存区域太小，以至于不能满足任意进程的内存分配请求，从而不能被进程利用的内存区域。</p><p><strong>有什么解决办法</strong>？</p><p>现在普遍采取的内存分配方式是段页式内存分配。将内存分为不同的段，再将每一段分成固定大小的页。通过页表机制，使段内的页可以不必连续处于同一内存区域。</p><h2 id="13-虚拟内存"><a href="#13-虚拟内存" class="headerlink" title="13.虚拟内存"></a>13.虚拟内存</h2><p>虚拟存储器就是具有请求调入功能，能从逻辑上对内存容量加以扩充的一种存储器系统，虚拟内存有多次性，对换性和虚拟性三个特征，它可以将程序分多次调入内存，使得在较小的用户空间可以执行较大的用户程序，所以同时容纳更多的进程并发执行，从而提高系统的吞吐量。发生缺页时可以调入一个段也可以调入一个页，取决于内存的存储管理方式。虚拟性表示虚拟内存和物理内存的映射。</p><p>Linux下，进程不能直接读写内存物理地址，只能访问【虚拟内存地址】。操作系统会把虚拟内存地址–&gt;物理地址。</p><p>虚拟内存解决有限的内存空间加载较大应用程序的问题，根据需要在内存和磁盘之间来回传送数据。</p><p>通过段页表的形式，虚拟内存中取一段连续的内存空间映射到主内存中，主内存空间的程序段可以不连续 。</p><h2 id="14-什么是分页？"><a href="#14-什么是分页？" class="headerlink" title="14.什么是分页？"></a>14.什么是分页？</h2><p>把内存空间划分为<strong>大小相等且固定的块</strong>，作为主存的基本单位。因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，<strong>因此需要一个页表来记录映射关系，以实现从页号到物理块号的映射。</strong></p><p>访问分页系统中内存数据需要<strong>两次的内存访问</strong> (一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址；第二次就是根据第一次得到的物理地址访问内存取出数据)。</p><h2 id="15-什么是分段？"><a href="#15-什么是分段？" class="headerlink" title="15.什么是分段？"></a>15.什么是分段？</h2><p><strong>分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。</strong></p><p>分段内存管理当中，<strong>地址是二维的，一维是段号，二维是段内地址；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的</strong>。由于分段管理中，每个段内部是连续内存分配，但是段和段之间是离散分配的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。</p><h2 id="16-分页和分段有什区别？"><a href="#16-分页和分段有什区别？" class="headerlink" title="16.分页和分段有什区别？"></a>16.分页和分段有什区别？</h2><p>分页对程序员是透明的，但是分段需要程序员显式划分每个段。</p><p>分页的地址空间是一维地址空间，分段是二维的。</p><p>页的大小不可变，段的大小可以动态改变。</p><p>分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</p><h2 id="17-页面置换算法"><a href="#17-页面置换算法" class="headerlink" title="17.页面置换算法"></a>17.页面置换算法</h2><p><strong>为什么要页面置换：</strong></p><p>因为应用程序是分多次装入内存的，所以运行到一定的时间，一定会发生缺页。地址映射的过程中，如果页面中发现要访问的页面不在内存中，会产生缺页中断。此时操作系统必须在内存里选择一个页面把他移出内存，为即将调入的页面让出空间。选择淘汰哪一页的规则就是页面置换算法</p><p><strong>几种页面置换算法：</strong></p><p><strong>最佳置换算法（理想）</strong>：将当前页面中在未来最长时间内不会被访问的页置换出去</p><p><strong>先进先出</strong>：淘汰最早调入的页面</p><p><strong>最近最久未使用 LRU</strong>：每个页面有一个t来记录上次页面被访问直到现在，每次置换时置换t值最大的页面（用寄存器或栈实现）</p><p><strong>时钟算法clock</strong>（也被称为最近未使用算法NRU）：页面设置访问为，将页面链接为一个环形列表，每个页有一个访问位0&#x2F;1, 1表示又一次获救的机会，下次循环指针指向它时可以免除此次置换，但是会把访问位置为0， 代表他下次如果碰到循环指针就该被置换了。页面被访问的时候访问位设为1。页面置换的时候，如果当前指针的访问位为0，置换，否则将这个值置为0，循环直到遇到访问位为0的页面。</p><p><strong>改进型Clock算法</strong>：在clock算法的基础上添加一个修改位，优先替换访问位和修改位都是0的页面，其次替换访问位为0修改位为1的页面。</p><p><strong>最少使用算法LFU</strong>：设置寄存器记录页面被访问次数，每次置换当前访问次数最少的。</p><h2 id="18-用户态和内核态"><a href="#18-用户态和内核态" class="headerlink" title="18.用户态和内核态"></a>18.用户态和内核态</h2><p>内核态：cpu可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu也可以将自己从一个程序切换到另一个程序。</p><p>用户态：只能受限的访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取。</p><p>最大的区别就是权限不同，在运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。</p><h3 id="为什么要有这两种状态？"><a href="#为什么要有这两种状态？" class="headerlink" title="为什么要有这两种状态？"></a>为什么要有这两种状态？</h3><p>内核速度快但是资源有限，能控制的进程数不多，所以需要速度慢一些的用户态协助，但是为了避免用户态被恶意利用，所以限制了用户态程序的权限。</p><p>需要限制不同的程序之间的访问能力，防止他们获取别的程序的内存数据，或者获取外围设备的数据，并发送到网络，CPU划分出<strong>两个权限等级</strong> – 用户态和内核态。</p><h3 id="什么时候转换"><a href="#什么时候转换" class="headerlink" title="什么时候转换"></a>什么时候转换</h3><p><strong>1、系统调用</strong>：</p><p>用户进程主动发起的。用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如fork()就是执行一个创建新进程的系统调用</p><p>用户程序使用系统调用，系统调用会转换为内核态并调用操作系统</p><p><strong>2、发生异常</strong>：</p><p>会从当前运行进程切换到处理次此异常的内核相关程序中</p><p><strong>3、外围设备的中断：</strong></p><p>所有程序都运行在用户态，但在从硬盘读取数据、或从键盘输入时，这些事情只有操作系统能做，程序需要向操作系统请求以程序的名义来执行这些操作。这个时候用户态程序切换到内核态。</p><h2 id="19-什么是缓冲区溢出？有什么危害？"><a href="#19-什么是缓冲区溢出？有什么危害？" class="headerlink" title="19.什么是缓冲区溢出？有什么危害？"></a>19.什么是缓冲区溢出？有什么危害？</h2><p>缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。</p><p>危害有以下两点：</p><ul><li><p>程序崩溃，导致拒绝额服务</p></li><li><p>跳转并且执行一段恶意代码</p></li></ul><p>造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。</p><h2 id="20-IO多路复用"><a href="#20-IO多路复用" class="headerlink" title="20.IO多路复用"></a>20.IO多路复用</h2><p><strong>IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合</strong>：</p><p>1、当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用I&#x2F;O复用。</p><p>2、当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。</p><p>3、如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I&#x2F;O复用。</p><p>4、如果一个服务器即要处理TCP，又要处理UDP，一般要使用I&#x2F;O复用。</p><p>5、如果一个服务器要处理多个服务或多个协议，一般要使用I&#x2F;O复用。</p><p>6、与多进程和多线程技术相比，I&#x2F;O多路复用技术的最大优势是系统开销小，系统不必创建进程&#x2F;线程，也不必维护这些进程&#x2F;线程，从而大大减小了系统的开销。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-操作系统的四个特性？&quot;&gt;&lt;a href=&quot;#1-操作系统的四个特性？&quot; class=&quot;headerlink&quot; title=&quot;1.操作系统的四个特性？&quot;&gt;&lt;/a&gt;1.操作系统的四个特性？&lt;/h2&gt;&lt;p&gt;并发：同一段时间内多个程序执行（与并行区分，并行指的是同一时</summary>
      
    
    
    
    <category term="PROJECT" scheme="https://zspcer.gitee.io/categories/PROJECT/"/>
    
    <category term="我要进大厂" scheme="https://zspcer.gitee.io/categories/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/"/>
    
    
    <category term="面试" scheme="https://zspcer.gitee.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="操作系统" scheme="https://zspcer.gitee.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="我要进大厂" scheme="https://zspcer.gitee.io/tags/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/"/>
    
  </entry>
  
  <entry>
    <title>大厂面试之数据结构篇</title>
    <link href="https://zspcer.gitee.io/note/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/"/>
    <id>https://zspcer.gitee.io/note/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/</id>
    <published>2023-05-11T16:37:37.000Z</published>
    <updated>2023-05-11T15:42:17.421Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-各种数据结构应用场景"><a href="#1-各种数据结构应用场景" class="headerlink" title="1.各种数据结构应用场景"></a>1.各种数据结构应用场景</h2><p>1、栈：逆序输出；语法检查，符号成对判断；方法调用</p><p>2、二叉树：表达式树</p><p>3、B+&#x2F;B-树：文件系统；数据库索引</p><p>4、哈夫曼树：数据压缩算法</p><p>5、哈希表：提高查找性能</p><p>6、红黑树：大致平衡的二叉查找树，相对AVL树，插入删除结点较快，查找性能没有提升</p><h2 id="2-数组"><a href="#2-数组" class="headerlink" title="2.数组"></a>2.数组</h2><p>数组的优点：存取速度快</p><p>数组的缺点:</p><p>1、事先必须知道数组的长度</p><p>2、插入删除元素很慢</p><p>3、空间通常是有限制的</p><p>4、需要大块连续的内存块</p><p>5、插入删除元素的效率很低</p><h2 id="3-链表"><a href="#3-链表" class="headerlink" title="3.链表"></a>3.链表</h2><p>优点：</p><p>1、空间没有限制</p><p>2、插入删除元素很快</p><p>缺点：存取速度很慢</p><p><strong>分类</strong></p><p>1、单向链表 一个节点指向下一个节点。</p><p>2、双向链表 一个节点有两个指针域。</p><p>3、循环链表 能通过任何一个节点找到其他所有的节点，将两种(双向&#x2F;单向)链表的最后一个结点指向第一个结点从而实现循环</p><h2 id="4-哈希表"><a href="#4-哈希表" class="headerlink" title="4.哈希表"></a>4.哈希表</h2><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><h2 id="5-栈"><a href="#5-栈" class="headerlink" title="5.栈"></a>5.栈</h2><p>我们把类似于弹夹那种先进后出的数据结构称为栈，栈是限定<strong>仅在表尾进行插入和删除操作</strong>的线性表，我们把允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈，栈又称后进后出的线性表，简称LIFO结构。</p><p>栈的特殊之处在于限制了这个线性表的<strong>插入和删除位置，它始终只在栈顶进行</strong>。这也就使得：栈底是固定的，最先进栈的只能在栈底。</p><p>栈的插入操作，叫做进栈；栈的删除操作叫做出栈。</p><h2 id="6-队列"><a href="#6-队列" class="headerlink" title="6.队列"></a>6.队列</h2><p>队列是只允许<strong>在一端进行插入操作，而在另一端进行删除操作</strong>的线性表，队列是一种先进先出的线性表，简称FIFO，允许插入的一端称为队尾（Rear），允许删除的一端称为队头(Front)。向队中插入元素称为进队，新元素进队后成为新的队尾元素；向队中删除元素称为出队，元素出队后，其后继元素就成为新的队头元素。</p><h2 id="7-树"><a href="#7-树" class="headerlink" title="7.树"></a>7.树</h2><p>树是一种数据结构，它看上去像一棵 “圣诞树”，它的根在上，叶朝下。</p><p><strong>树有多个节点(node)，用以储存元素。某些节点之间存在一定的关系，用连线表示，连线称为边(edge)。边的上端节点称为父节点，下端称为子节点。树像是一个不断分叉的树根。</strong></p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>最多有两棵子树的树被称为二叉树</p><p>满二叉树: 二叉树中所有非叶子结点的度都是2，且叶子结点都在同一层次上</p><p>完全二叉树: 如果一个二叉树与满二叉树前m个节点的结构相同，这样的二叉树被称为完全二叉树</p><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>指一棵空树或者具有下列性质的二叉树。</p><p>1、若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</p><p>2、若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</p><p>3、任意节点的左、右子树也分别为二叉查找树；</p><p>4、没有键值相等的节点。</p><h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><p><strong>平衡二叉搜索树</strong>，它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87.assets/1676359100005-ad7be6bf-b26b-4dbb-afa1-a5197742ef32.png" alt="img"></p><p>简单了解一下<strong>左旋与右旋</strong>的概念。</p><p>左旋与右旋就是为了解决不平衡问题而产生的，我们构建一颗AVL树的过程会出现结点平衡因子（平衡因子就是二叉排序树中每个结点的左子树和右子树的高度差。）绝对值大于1的情况，这时就可以通过左旋或者右旋操作来达到平衡的目的。</p><p>四种旋转情况</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87.assets/1676359101864-9e17cc6a-b39b-4fed-96ca-0556494dde0f.png" alt="img"></p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树是对AVL树的优化，只要求部分平衡，用非严格的平衡来换取增删节点时候旋转次数的降低，提高了插入和删除的性能。查找性能并没有提高，查找的时间复杂度是O(logn)。红黑树通过左旋、右旋和变色维持平衡。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87.assets/1676359103706-07590fee-692e-4ae5-9d69-a38e01c1470d.png" alt="img"></p><p>对于插入节点，AVL和红黑树都是最多两次旋转来实现平衡。对于删除节点，avl需要维护从被删除节点到根节点root这条路径上所有节点的平衡，旋转的量级为O(logN)，而红黑树最多只需旋转3次。</p><p>红黑树的特性：</p><p>1、每个节点或者是黑色，或者是红色。</p><p>2、根节点和叶子节点是黑色，叶子节点为空。</p><p>3、红色节点的子节点必须是黑色的。</p><p>4、从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点，保证没有一条路径会比其他路径长一倍。</p><p>优点：相比avl树，红黑树插入删除的效率更高。红黑树维持红黑性质所做的红黑变换和旋转的开销，相较于avl树维持平衡的开销要小得多。</p><p><strong>应用场景</strong></p><p>1、Java ConcurrentHashMap &amp; TreeMap</p><p>2、C++ STL: map &amp; set</p><p>3、linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块</p><p>4、epoll在内核中的实现，用红黑树管理事件块</p><p>5、nginx中，用红黑树管理timer等</p><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>也称B-树，属于多叉树又名平衡多路查找树。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87.assets/1676359106204-baf72ae9-e7fd-4748-83bf-116f319ddb8f.png" alt="img"></p><p>规则：</p><p>1、1&lt;子节点数&lt;&#x3D;m，m代表一个树节点最多有多少个查找路径</p><p>2、每个节点最多有m-1个关键字，非根节点至少有m&#x2F;2个关键字，根节点最少可以只有1个关键字</p><p>3、每个节点都有指针指向子节点，指针个数&#x3D;关键字个数+1，叶子节点指针指向null</p><p>B-树的特性：</p><p>1、关键字集合分布在整颗树中；</p><p>2、任何一个关键字只出现在一个节点中；</p><p>3、搜索有可能在非叶子结点结束；</p><p>B+树是B-树的变体，也是一种多路搜索树。B+的搜索与B-树基本相同，区别是B+树只有达到叶子结点才命中，B-树可以在非叶子结点命中。B+树更适合文件索引系统。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87.assets/1676359108970-2d4a2fdc-56b5-42cc-a498-130531990ef8.jpeg" alt="img"></p><p>B-和B+树的区别：</p><p>1、B+树的非叶子结点不包含data，叶子结点使用链表连接，便于区间查找和遍历。B-树需要遍历整棵树，范围查询性能没有B+树好。</p><p>2、B-树的非树节点存放数据和索引，搜索可能在非叶子结点结束，访问更快。</p><h2 id="8-图"><a href="#8-图" class="headerlink" title="8.图"></a>8.图</h2><p>图(Graph)是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为: G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。</p><p>和线性表，树的差异:</p><p>1、线性表中我们把数据元素叫元素，树中将数据元素叫结点，在图中数据元素，我们则称之为顶点(Vertex)。</p><p>2、线性表可以没有元素，称为空表；树中可以没有节点，称为空树；但是，在图中不允许没有顶点(有穷非空性)。</p><p>3、线性表中的各元素是线性关系，树中的各元素是层次关系，而图中各顶点的关系是用边来表示(边集可以为空)。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87.assets/1676359111908-fcd4dda6-91ac-4924-8910-b67bf8720c65.png" alt="img"></p><h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><p><strong>顶点的度</strong></p><p>顶点Vi的度(Degree)是指在图中与Vi相关联的边的条数。对于有向图来说，有入度(In-degree)和出度(Out-degree)之分，有向图顶点的度等于该顶点的入度和出度之和。</p><p><strong>邻接</strong></p><p>若无向图中的两个顶点V1和V2存在一条边(V1,V2)，则称顶点V1和V2邻接(Adjacent)；</p><p>若有向图中存在一条边&lt;V3,V2&gt;，则称顶点V3与顶点V2邻接，且是V3邻接到V2或V2邻接直V3；</p><p><strong>路径</strong></p><p>在无向图中，若从顶点Vi出发有一组边可到达顶点Vj，则称顶点Vi到顶点Vj的顶点序列为从顶点Vi到顶点Vj的路径(Path)。</p><p><strong>连通</strong></p><p>若从Vi到Vj有路径可通，则称顶点Vi和顶点Vj是连通(Connected)的。</p><p><strong>权(Weight)</strong></p><p>有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权(Weight)。</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p><strong>无向图</strong></p><p>如果图中任意两个顶点之间的边都是无向边(简而言之就是没有方向的边)，则称该图为无向图(Undirected graphs)。</p><p>无向图中的边使用小括号“()”表示; 比如 (V1,V2);</p><p><strong>有向图</strong></p><p>如果图中任意两个顶点之间的边都是有向边(简而言之就是有方向的边)，则称该图为有向图(Directed graphs)。</p><p>有向图中的边使用尖括号“&lt;&gt;”表示; 比如&#x2F;&lt;V1,V2&gt;</p><p><strong>完全图</strong></p><p><code>无向完全图</code>: 在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。(含有n个顶点的无向完全图有(n×(n-1))&#x2F;2条边)</p><p>&#96;有向完全图: 在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。(含有n个顶点的有向完全图有n×(n-1)条边</p><h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><p>1、<strong>邻接矩阵</strong></p><p>图的邻接矩阵(Adjacency Matrix)存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87.assets/1676359114523-fdaa7e78-f206-4986-b3b1-ff71a28c0a10.png" alt="img"></p><p>2、<strong>邻接表</strong></p><p>邻接表由表头节点和表节点两部分组成，图中每个顶点均对应一个存储在数组中的表头节点。如果这个表头节点所对应的顶点存在邻接节点，则把邻接节点依次存放于表头节点所指向的单向链表中。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87.assets/1676359116185-7b9178a6-cabe-42ca-8ef7-d7258e4dfc46.png" alt="img"></p><p>下面给出建立图的邻接表中所使用的边结点类的定义</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EdgeNode</span> <span class="token punctuation">&#123;</span>     <span class="token comment">//定义邻接表中的边结点类型</span>    <span class="token keyword">int</span> adjvex<span class="token punctuation">;</span>             <span class="token comment">//邻接点域</span>    <span class="token keyword">int</span> weight<span class="token punctuation">;</span>             <span class="token comment">//边的权值域，假定为整型，对于无权图，边的权值为1</span>    <span class="token class-name">EdgeNode</span> next<span class="token punctuation">;</span>          <span class="token comment">//指向下一个边结点的链接域</span>    <span class="token keyword">public</span> <span class="token class-name">EdgeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> adj<span class="token punctuation">,</span> <span class="token class-name">EdgeNode</span> nt<span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>     <span class="token comment">//对无权图中的边结点进行初始化</span>        adjvex<span class="token operator">=</span>adj<span class="token punctuation">;</span> next<span class="token operator">=</span>nt<span class="token punctuation">;</span> weight<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">EdgeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> adj<span class="token punctuation">,</span> <span class="token keyword">int</span> wgt<span class="token punctuation">,</span> <span class="token class-name">EdgeNode</span> nt<span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>     <span class="token comment">//对有权图中的边结点进行初始化</span>        adjvex<span class="token operator">=</span>adj<span class="token punctuation">;</span> next<span class="token operator">=</span>nt<span class="token punctuation">;</span> weight<span class="token operator">=</span>wgt<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>图的接口类定义如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Graph</span>     <span class="token punctuation">&#123;</span>         <span class="token keyword">boolean</span> <span class="token function">createGraph</span><span class="token punctuation">(</span><span class="token class-name">EdgeElement</span><span class="token punctuation">[</span><span class="token punctuation">]</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//根据边集数组参数d建立一个图</span>         <span class="token keyword">int</span> <span class="token function">graphType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">//返回图的类型</span>         <span class="token keyword">int</span> <span class="token function">vertices</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//返回图中的顶点数</span>         <span class="token keyword">int</span> <span class="token function">edges</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">//返回图中的边数</span>         <span class="token keyword">boolean</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//从图中查找一条边(i,j)是否存在</span>         <span class="token keyword">boolean</span> <span class="token function">putEdge</span><span class="token punctuation">(</span><span class="token class-name">EdgeElement</span> theEdge<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//向图中插入一条边theEdge</span>         <span class="token keyword">boolean</span> <span class="token function">removeEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//从图中删除一条边(i,j)</span>         <span class="token keyword">int</span> <span class="token function">degree</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//返回顶点i的度</span>         <span class="token keyword">int</span> <span class="token function">inDegree</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">//返回顶点i的入度</span>         <span class="token keyword">int</span> <span class="token function">outDegree</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">//返回顶点i的出度</span>         <span class="token keyword">void</span> <span class="token function">output</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">//以图的顶点集和边集的形式输出一个图</span>         <span class="token keyword">void</span> <span class="token function">depthFirstSearch</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//从顶点v开始深度优先搜索遍历图</span>         <span class="token keyword">void</span> <span class="token function">breadthFirstSearch</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//从顶点v开始广度优先搜索遍历图</span>         <span class="token keyword">void</span> <span class="token function">clearGraph</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//清除图中的所有内容</span>     <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p><strong>深度优先遍历</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printl</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token class-name">EdgeNode</span> p <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> p<span class="token punctuation">.</span>adjvex<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>广度优先搜索</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">EdgeNode</span> p <span class="token operator">=</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> p<span class="token punctuation">.</span>adjvex<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                visited<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-各种数据结构应用场景&quot;&gt;&lt;a href=&quot;#1-各种数据结构应用场景&quot; class=&quot;headerlink&quot; title=&quot;1.各种数据结构应用场景&quot;&gt;&lt;/a&gt;1.各种数据结构应用场景&lt;/h2&gt;&lt;p&gt;1、栈：逆序输出；语法检查，符号成对判断；方法调用&lt;/p&gt;
</summary>
      
    
    
    
    <category term="PROJECT" scheme="https://zspcer.gitee.io/categories/PROJECT/"/>
    
    <category term="我要进大厂" scheme="https://zspcer.gitee.io/categories/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/"/>
    
    
    <category term="面试" scheme="https://zspcer.gitee.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="我要进大厂" scheme="https://zspcer.gitee.io/tags/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/"/>
    
    <category term="数据结构" scheme="https://zspcer.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>大厂面试之算法篇</title>
    <link href="https://zspcer.gitee.io/note/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%AE%97%E6%B3%95%E7%AF%87/"/>
    <id>https://zspcer.gitee.io/note/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%AE%97%E6%B3%95%E7%AF%87/</id>
    <published>2023-05-11T16:37:37.000Z</published>
    <updated>2023-05-11T15:42:17.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-二叉树的遍历"><a href="#1-二叉树的遍历" class="headerlink" title="1. 二叉树的遍历"></a>1. 二叉树的遍历</h2><p>二叉树是一种非常重要的数据结构，很多其它数据结构都是基于二叉树的基础演变而来的。</p><p>二叉树的先序、中序和后序属于深度优先遍历DFS，层次遍历属于广度优先遍历BFS。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%AE%97%E6%B3%95%E7%AF%87.assets/1676359029260-ff6c73da-d42f-4d4c-851e-97a48db0bed6.png" alt="img"></p><p>四种主要的遍历思想为：</p><p>前序遍历：根结点 —&gt; 左子树 —&gt; 右子树</p><p>中序遍历：左子树—&gt; 根结点 —&gt; 右子树</p><p>后序遍历：左子树 —&gt; 右子树 —&gt; 根结点</p><p>层次遍历：只需按层次遍历即可</p><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>遍历思路：根结点 —&gt; 左子树 —&gt; 右子树。</p><p>根据前序遍历的顺序，优先访问根结点，然后在访问左子树和右子树。所以，对于任意结点node，第一部分即直接访问之，之后在判断左子树是否为空，不为空时即重复上面的步骤，直到其为空。若为空，则需要访问右子树。注意，在访问过左孩子之后，需要反过来访问其右孩子，可以是栈这种数据结构来支持。对于任意一个结点node，具体步骤如下：</p><ol><li><p>访问结点，并把结点node入栈，当前结点置为左孩子；</p></li><li><p>判断结点node是否为空，若为空，则取出栈顶结点并出栈，将右孩子置为当前结点；否则重复a)步直到当前结点为空或者栈为空（可以发现栈中的结点就是为了访问右孩子才存储的）</p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">preOrderTraverse2</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">TreeNode</span> pNode <span class="token operator">=</span> root<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>pNode <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pNode <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>pNode<span class="token punctuation">.</span>val<span class="token operator">+</span><span class="token string">"  "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>pNode<span class="token punctuation">)</span><span class="token punctuation">;</span>            pNode <span class="token operator">=</span> pNode<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">//pNode == null &amp;&amp; !stack.isEmpty()</span>            <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pNode <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>遍历思路：左子树 —&gt; 根结点 —&gt; 右子树</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> deque <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>deque<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            deque<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>            root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        root <span class="token operator">=</span> deque<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>遍历思路：左子树 —&gt; 右子树 —&gt; 根结点。</p><p>使用 null 作为标志位，访问到 null 说明此次递归调用结束。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            root <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//最后访问</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">//值为null说明此次递归调用结束，将节点值存进结果</span>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>只需要一个队列即可，先在队列中加入根结点。之后对于任意一个结点来说，在其出队列的时候，访问之。同时如果左孩子和右孩子有不为空的，入队列。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">levelTraverse</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">TreeNode</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token operator">+</span><span class="token string">"  "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-排序算法"><a href="#2-排序算法" class="headerlink" title="2. 排序算法"></a>2. 排序算法</h2><p>常见的排序算法主要有：冒泡排序、插入排序、选择排序、快速排序、归并排序、堆排序、基数排序。各种排序算法的时间空间复杂度、稳定性见下图。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%AE%97%E6%B3%95%E7%AF%87.assets/1676359033940-5ecfe770-416b-49e2-a972-9110b28579a3.png" alt="img"></p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><p>思路：</p><ul><li><p>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</p></li><li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</p></li><li><p>针对所有的元素重复以上的步骤，除了最后一个；</p></li><li><p>重复步骤1~3，直到排序完成。</p></li></ul><p>代码实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">boolean</span> flag<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>                flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><p>算法描述：</p><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ul><li><p>从第一个元素开始，该元素可以认为已经被排序；</p></li><li><p>取出下一个元素，在已经排序的元素序列中从后向前扫描；</p></li><li><p>如果该元素（已排序）大于新元素，将该元素移到下一位置；</p></li><li><p>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</p></li><li><p>将新元素插入到该位置后；</p></li><li><p>重复步骤2~5。</p></li></ul><p>代码实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> tmp <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>表现<strong>最稳定的排序算法之一</strong>，因为<strong>无论什么数据进去都是O(n2)的时间复杂度</strong>，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间。</p><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><p>思路：n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li><p>初始状态：无序区为R[1..n]，有序区为空；</p></li><li><p>第i趟排序(i&#x3D;1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</p></li><li><p>n-1趟结束，数组有序化了。</p></li></ul><p>代码实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p><p><strong>希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</strong></p><p>代码实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token class-name">ShellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> temp<span class="token punctuation">,</span> gap <span class="token operator">=</span> len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            temp <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> preIndex <span class="token operator">=</span> i <span class="token operator">-</span> gap<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>preIndex <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                array<span class="token punctuation">[</span>preIndex <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>                preIndex <span class="token operator">-=</span> gap<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            array<span class="token punctuation">[</span>preIndex <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        gap <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> array<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；</p><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p><p>算法描述：</p><ul><li><p>取得数组中的最大数，并取得位数；</p></li><li><p>arr为原始数组，从最低位开始取每个位组成radix数组；</p></li><li><p>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</p></li></ul><p>代码实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token class-name">RadixSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>array <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> array<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> array<span class="token punctuation">;</span>    <span class="token comment">// 1.先算出最大数的位数；</span>    <span class="token keyword">int</span> max <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        max <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> maxDigit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>max <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        max <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>        maxDigit<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> mod <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> div <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ArrayList</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> bucketList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ArrayList</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        bucketList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxDigit<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> mod <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">,</span> div <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">%</span> mod<span class="token punctuation">)</span> <span class="token operator">/</span> div<span class="token punctuation">;</span>            bucketList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> bucketList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> bucketList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>                array<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> bucketList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>            bucketList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> array<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token class-name">CountingSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> array<span class="token punctuation">;</span>    <span class="token keyword">int</span> bias<span class="token punctuation">,</span> min <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> max <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> max<span class="token punctuation">)</span>            max <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min<span class="token punctuation">)</span>            min <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    bias <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">-</span> min<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bucket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>max <span class="token operator">-</span> min <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>bucket<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        bucket<span class="token punctuation">[</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> bias<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            array<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">-</span> bias<span class="token punctuation">;</span>            bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>            index<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> array<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序是由<strong>冒泡排序</strong>改进而得到的，是一种排序执行效率很高的排序算法，它利用<strong>分治法</strong>来对待排序序列进行分治排序，它的思想主要是通过一趟排序将待排记录分隔成独立的两部分，其中的一部分比关键字小，后面一部分比关键字大，然后再对这前后的两部分分别采用这种方式进行排序，通过递归的运算最终达到整个序列有序。</p><p>快速排序的过程如下：</p><p>1、在待排序的N个记录中任取一个元素（通常取第一个记录）作为基准，称为基准记录；</p><p>2、定义两个索引 left 和 right 分别表示首索引和尾索引，key 表示基准值；</p><p>3、首先，尾索引向前扫描，直到找到比基准值小的记录，并替换首索引对应的值；</p><p>4、然后，首索引向后扫描，直到找到比基准值大于的记录，并替换尾索引对应的值；</p><p>5、若在扫描过程中首索引等于尾索引(left &#x3D; right)，则一趟排序结束；将基准值(key)替换首索引所对应的值；</p><p>6、再进行下一趟排序时，待排序列被分成两个区：[0,left-1]和[righ+1,end]</p><p>7、对每一个分区重复以上步骤，直到所有分区中的记录都有序，排序完成</p><p><strong>快排为什么比冒泡效率高？</strong></p><p>快速排序之所以比较快，是因为相比冒泡排序，每次的交换都是跳跃式的，每次设置一个基准值，将小于基准值的都交换到左边，大于基准值的都交换到右边，这样不会像冒泡一样每次都只交换相邻的两个数，因此比较和交换的此数都变少了，速度自然更高。</p><p>快速排序的平均时间复杂度是<code>O(nlgn)</code>，最坏时间复杂度是<code>O(n^2)</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">quickSortHelper</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">quickSortHelper</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">></span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> right<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//j先走，最终循环终止时，j停留的位置就是arr[left]的正确位置</span>        <span class="token comment">//改为i&lt;=j，则会进入死循环，[1,5,5,5,5]->[1] 5 [5,5,5]->[5,5,5]，会死循环</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> tmp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            j<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> tmp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> tmp1 <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp1<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//当循环终止的时候，i=j，因为是j先走的，j所在位置的值小于arr[left]，交换arr[j]和arr[left]</span>    arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token function">quickSortHelper</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">quickSortHelper</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序 (merge sort) 是一类与插入排序、交换排序、选择排序不同的另一种排序方法。归并的含义是将两个或两个以上的有序表合并成一个新的有序表。归并排序有多路归并排序、两路归并排序 ， 可用于内排序，也可以用于外排序。</p><p>两路归并排序算法思路是递归处理。每个递归过程涉及三个步骤</p><ul><li><p>分解： 把待排序的 n 个元素的序列分解成两个子序列， 每个子序列包括 n&#x2F;2 个元素</p></li><li><p>治理： 对每个子序列分别调用归并排序MergeSort， 进行递归操作</p></li><li><p>合并： 合并两个排好序的子序列，生成排序结果</p></li></ul><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%AE%97%E6%B3%95%E7%AF%87.assets/1676359042731-714cfc14-5b58-407d-9988-8d6ce44a7780.png" alt="img"></p><p>时间复杂度：对长度为n的序列，需进行logn次二路归并，每次归并的时间为O(n)，故时间复杂度是O(nlgn)。</p><p>空间复杂度：归并排序需要辅助空间来暂存两个有序子序列归并的结果，故其辅助空间复杂度为O(n)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MergeSort</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//辅助数组</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tmpArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> tmpArr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tmpArr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> tmpArr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> tmpArr<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> tmpArr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tmpArr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> tmpIndex <span class="token operator">=</span> left<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                tmpArr<span class="token punctuation">[</span>tmpIndex<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                tmpArr<span class="token punctuation">[</span>tmpIndex<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            tmpArr<span class="token punctuation">[</span>tmpIndex<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            tmpArr<span class="token punctuation">[</span>tmpIndex<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> m <span class="token operator">=</span> left<span class="token punctuation">;</span> m <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> m<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            arr<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">=</span> tmpArr<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%AE%97%E6%B3%95%E7%AF%87.assets/1676359046118-a0a1686c-c6e2-4041-9b63-c4d6389cd233.png" alt="img"></p><p><strong>Top大问题</strong>解决思路：使用一个固定大小的<strong>最小堆</strong>，当堆满后，每次添加数据的时候与堆顶元素比较，若小于堆顶元素，则舍弃，若大于堆顶元素，则删除堆顶元素，添加新增元素，对堆进行重新排序。</p><p>对于n个数，取Top m个数，时间复杂度为O(nlogm)，这样在n较大情况下，是优于nlogn（其他排序算法）的时间复杂度的。</p><p>PriorityQueue 是一种基于优先级堆的优先级队列。每次从队列中取出的是具有最高优先权的元素。如果不提供Comparator的话，优先队列中元素默认按自然顺序排列，也就是数字默认是小的在队列头。优先级队列用数组实现，但是数组大小可以动态增加，容量无限。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//找出前k个最大数，采用小顶堆实现</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">findKMax</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> pq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//队列默认自然顺序排列，小顶堆，不必重写compare</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pq<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            pq<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pq<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//如果堆顶元素 &lt; 新数，则删除堆顶，加入新数入堆</span>            pq<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pq<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token operator">&amp;&amp;</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-动态规划"><a href="#4-动态规划" class="headerlink" title="4. 动态规划"></a>4. 动态规划</h2><p>动态规划常常适用于有重叠子问题的问题。动态规划的基本思想：若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。</p><p>动态规划法试图仅仅解决每个子问题一次，一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次遇到同一个子问题的时候直接查表得到解。</p><p>动态规划的解题思路：1、状态定义；2、状态转移方程；3、初始状态。</p><h3 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h3><p><a href="https://topjavaer.cn/leetcode/unique-paths.html">不同路径</a></p><h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><p>从给定的字符串 <code>s</code> 中找到最长的回文子串的长度。</p><p>例如 <code>s = &quot;babbad&quot;</code> 的最长回文子串是 <code>&quot;abba&quot;</code> ，长度是 <code>4</code> 。</p><p>解题思路：</p><p>1、定义状态。<code>dp[i][j]</code> 表示子串 <code>s[i..j]</code> 是否为回文子串</p><p>2、状态转移方程：<code>dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]</code></p><p>3、初始化的时候，单个字符一定是回文串，因此把对角线先初始化为 <code>true</code>，即 <code>dp[i][i] = true</code> 。</p><p>4、只要一得到 <code>dp[i][j] = true</code>，就记录子串的长度和起始位置</p><p>注意事项：总是先得到小子串的回文判定，然后大子串才能参考小子串的判断结果，即填表顺序很重要。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%AE%97%E6%B3%95%E7%AF%87.assets/1676359055255-4f750233-b606-4af9-a8ca-e44c1eae699e.png" alt="img"></p><p>时间复杂度O(N2)，空间复杂度O(N2)，因为使用了二维数组。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">longestPalindrome</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 特判</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> s<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> maxLen <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> begin <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// dp[i][j] 表示 s[i, j] 是否是回文串</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> charArray <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>charArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> charArray<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">// 只要 dp[i][j] == true 成立，就表示子串 s[i..j] 是回文，此时记录回文长度和起始位置</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> maxLen<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    maxLen <span class="token operator">=</span> j <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                    begin <span class="token operator">=</span> i<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> begin <span class="token operator">+</span> maxLen<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//substring(i, j)截取i到j(不包含j)的字符串</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h3><p><strong>题目描述</strong>：给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>示例</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入： nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>输出： <span class="token number">6</span>解释： 连续子数组 <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span> 的和最大，为 <span class="token number">6</span> 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>1、首先确定dp数组（dp table）以及下标的含义。</p><p>dp[i]表示以nums[i]结尾的子数组的最大和。</p><p>2、确定递推公式。</p><pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">dp[i] = dp[i - 1] > 0 ? ( dp[i - 1] + nums[i]) : nums[i]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>dp[i+1]取决于dp[i]的值，不需要使用数组保存状态，只需要一个变量sum来保存上一个状态即可。</p><p>3、dp数组如何初始化。</p><p>从递推公式可以看出来dp[i]是依赖于dp[i - 1]的状态，dp[0]就是递推公式的基础。</p><p>dp[0]应该是多少呢？根据dp[i]的定义，很明显dp[0]应为nums[0]即dp[0] &#x3D; nums[0]。</p><p>示例代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                sum <span class="token operator">+=</span> num<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                sum <span class="token operator">=</span> num<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            max <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。 例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。</p><p>动态规划。<code>dp[i][j]</code>表示text1以i-1结尾的子串和text2以j-1结尾的子串的最长公共子序列的长度。dp横坐标或纵坐标为0表示空字符串，<code>dp[0][j] = dp[i][0] = 0</code>，无需额外处理base case。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%AE%97%E6%B3%95%E7%AF%87.assets/1676359058936-a2e9fb51-7087-435d-b9c1-7ebb2d6ab2b5.png" alt="img"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">longestCommonSubsequence</span><span class="token punctuation">(</span><span class="token class-name">String</span> text1<span class="token punctuation">,</span> <span class="token class-name">String</span> text2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1 <span class="token operator">=</span> text1<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr2 <span class="token operator">=</span> text2<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//dp[0][x]和dp[x][0]表示有一个为空字符串</span>        <span class="token comment">//dp[1][1]为text1第一个字符和text2第一个字符的最长公共子序列的长度</span>        <span class="token comment">//dp[i][j]表示text1以i-1结尾的子串和text2以j-1结尾的子串的最长公共子序列的长度</span>        <span class="token keyword">int</span> len1 <span class="token operator">=</span> arr1<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> len2 <span class="token operator">=</span> arr2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>len1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>len2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> arr2<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>len1<span class="token punctuation">]</span><span class="token punctuation">[</span>len2<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>dp[i][j]</code>表示text1以i结尾的子串和text2以j结尾的子串的最长公共子序列的长度。需要处理base case。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">longestCommonSubsequence</span><span class="token punctuation">(</span><span class="token class-name">String</span> text1<span class="token punctuation">,</span> <span class="token class-name">String</span> text2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1 <span class="token operator">=</span> text1<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr2 <span class="token operator">=</span> text2<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len1 <span class="token operator">=</span> arr1<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> len2 <span class="token operator">=</span> arr2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment">//`dp[i][j]`表示text1以i结尾的子串和text2以j结尾的子串的最长公共子序列的长度。</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>len1<span class="token punctuation">]</span><span class="token punctuation">[</span>len2<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> arr2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len1<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> arr2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len2<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> arr2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len1<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len2<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> arr2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>len1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>len2 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h3><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%AE%97%E6%B3%95%E7%AF%87.assets/1676359062838-c6d17f6e-c0dd-48dc-8f5c-df7fc40c7e06.png" alt="img"></p><p>示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：height <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>输出：<span class="token number">6</span>解释：上面是由数组 <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span> 表示的高度图，在这种情况下，可以接 <span class="token number">6</span> 个单位的雨水（蓝色部分表示雨水）。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>动态规划，使用两个数组空间。leftMax[i] 代表第 <code>i</code> 列左边（不包含自身）最高的墙的高度，rightMax[i] 代表第 <code>i</code> 列右边最高的墙的高度。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">trap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> height<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> height<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> leftMax <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rightMax <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            leftMax<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftMax<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> height<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            rightMax<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>rightMax<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> height<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> min <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>leftMax<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> rightMax<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>min <span class="token operator">></span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                res <span class="token operator">+=</span> min <span class="token operator">-</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h3><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%AE%97%E6%B3%95%E7%AF%87.assets/1676359065661-7019af8b-5f43-4de9-9dc9-2b44da037450.png" alt="img"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">wordBreak</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> wordDict<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> maxw <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//dp[i]表示前i个字母组成的字符串是否可以被拆分</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//状态转移方程初始化条件</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">String</span> str <span class="token operator">:</span> wordDict<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>            maxw <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxw<span class="token punctuation">,</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">>=</span> i <span class="token operator">-</span> maxw<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-回溯算法"><a href="#5-回溯算法" class="headerlink" title="5.回溯算法"></a>5.回溯算法</h2><p>回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。</p><h3 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h3><p>题目描述：给定一个<strong>无重复元素</strong>的数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p>示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：candidates <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">,</span>输出：<span class="token punctuation">[</span>  <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用回溯算法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">combinationSum2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> candidates<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>candidates <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> candidates<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> ans<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>candidates<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//排序方便回溯剪枝</span>        <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//作为栈来使用，效率高于Stack；也可以作为队列来使用，效率高于LinkedList；线程不安全</span>        <span class="token function">combinationSum2Helper</span><span class="token punctuation">(</span>candidates<span class="token punctuation">,</span> target<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">combinationSum2Helper</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//剪枝</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> start <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> arr<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//在一个层级，会产生重复</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            path<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">combinationSum2Helper</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> target <span class="token operator">-</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>            path<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p><p>示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>输出<span class="token operator">:</span><span class="token punctuation">[</span>  <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用回溯。注意与组合总和的区别（数字有无顺序）。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">permute</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> flag <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">permuteHelper</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> flag<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">permuteHelper</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> flag<span class="token punctuation">,</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token comment">//继续循环</span>            <span class="token punctuation">&#125;</span>            path<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            flag<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token function">permuteHelper</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> flag<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>            path<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            flag<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="全排列II"><a href="#全排列II" class="headerlink" title="全排列II"></a>全排列II</h3><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。注意与组合总和的区别。</p><p>1、排序；2、同一层级相同元素剪枝。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%AE%97%E6%B3%95%E7%AF%87.assets/1676359070681-75d626db-3dad-44d7-be46-d43dd1bae921.png" alt="img"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">permuteUnique</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> ans<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> used <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//切记</span>        <span class="token function">dps</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> used<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dps</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> used<span class="token punctuation">,</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>used<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>used<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//同一层相同的元素，剪枝</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token comment">//继续循环，不是return退出循环</span>            <span class="token punctuation">&#125;</span>            path<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token function">dps</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> used<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>            path<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-贪心算法"><a href="#6-贪心算法" class="headerlink" title="6.贪心算法"></a>6.贪心算法</h2><p>贪心算法，是寻找<strong>最优解问题</strong>的常用方法，这种方法模式一般将求解过程分成<strong>若干个步骤</strong>，但每个步骤都应用贪心原则，选取当前状态下<strong>最好&#x2F;最优的选择</strong>（局部最有利的选择），并以此希望最后堆叠出的结果也是最好&#x2F;最优的解。</p><p><strong>贪婪法的基本步骤：</strong></p><ol><li><p>从某个初始解出发；</p></li><li><p>采用迭代的过程，当可以向目标前进一步时，就根据局部最优策略，得到一部分解，缩小问题规模；</p></li><li><p>将所有解综合起来。</p></li></ol><h3 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a>买卖股票的最佳时机 II</h3><p><strong>题目描述</strong>：</p><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p><p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</p><p>返回 你能获得的 最大 利润 。</p><p><strong>示例</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：prices <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>输出：<span class="token number">4</span>解释：在第 <span class="token number">1</span> 天（股票价格 <span class="token operator">=</span> <span class="token number">1</span>）的时候买入，在第 <span class="token number">5</span> 天 （股票价格 <span class="token operator">=</span> <span class="token number">5</span>）的时候卖出<span class="token punctuation">,</span> 这笔交易所能获得利润 <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">4</span> 。     总利润为 <span class="token number">4</span> 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>思路：可以尽可能地完成更多的交易，但不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//输入: [7,1,5,3,6,4]</span><span class="token comment">//输出: 7</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prices<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> profit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prices<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> tmp <span class="token operator">=</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                profit <span class="token operator">+=</span> tmp<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> profit<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h3><p><strong>题目描述</strong></p><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><p><strong>示例</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>输出：<span class="token boolean">true</span>解释：可以先跳 <span class="token number">1</span> 步，从下标 <span class="token number">0</span> 到达下标 <span class="token number">1</span><span class="token punctuation">,</span> 然后再从下标 <span class="token number">1</span> 跳 <span class="token number">3</span> 步到达最后一个下标。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>解题思路：</p><p>1、如果某一个作为 起跳点 的格子可以跳跃的距离是 3，那么表示后面 3 个格子都可以作为 起跳点</p><p>2、可以对每一个能作为 起跳点 的格子都尝试跳一次，把 能跳到最远的距离 不断更新</p><p>3、如果可以一直跳到最后，就成功了</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">canJump</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> maxIndex <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>maxIndex <span class="token operator">>=</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                maxIndex <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxIndex<span class="token punctuation">,</span> i <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h3><p><strong>题目描述</strong></p><p>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。</p><p><strong>示例</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入<span class="token operator">:</span> gas <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> cost <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>输出<span class="token operator">:</span> <span class="token number">3</span>解释<span class="token operator">:</span>从 <span class="token number">3</span> 号加油站<span class="token punctuation">(</span>索引为 <span class="token number">3</span> 处<span class="token punctuation">)</span>出发，可获得 <span class="token number">4</span> 升汽油。此时油箱有 <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">+</span> <span class="token number">4</span> <span class="token operator">=</span> <span class="token number">4</span> 升汽油开往 <span class="token number">4</span> 号加油站，此时油箱有 <span class="token number">4</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">5</span> <span class="token operator">=</span> <span class="token number">8</span> 升汽油开往 <span class="token number">0</span> 号加油站，此时油箱有 <span class="token number">8</span> <span class="token operator">-</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">7</span> 升汽油开往 <span class="token number">1</span> 号加油站，此时油箱有 <span class="token number">7</span> <span class="token operator">-</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">6</span> 升汽油开往 <span class="token number">2</span> 号加油站，此时油箱有 <span class="token number">6</span> <span class="token operator">-</span> <span class="token number">4</span> <span class="token operator">+</span> <span class="token number">3</span> <span class="token operator">=</span> <span class="token number">5</span> 升汽油开往 <span class="token number">3</span> 号加油站，你需要消耗 <span class="token number">5</span> 升汽油，正好足够你返回到 <span class="token number">3</span> 号加油站。因此，<span class="token number">3</span> 可为起始索引。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>思路</strong>：</p><p>1、遍历一周，总获得的油量少于要花掉的油量必然没有结果；</p><p>2、先苦后甜，记录遍历时所存的油量最少的站点，由于题目有解只有唯一解，所以从当前站点的下一个站点开始是唯一可能成功开完全程的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">canCompleteCircuit</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> gas<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cost<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> minIdx<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> num<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> gas<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            num<span class="token operator">+=</span>gas<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>cost<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token operator">&lt;</span>sum<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                sum<span class="token operator">=</span>num<span class="token punctuation">;</span>                minIdx<span class="token operator">=</span>i<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> num<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">?</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">:</span><span class="token punctuation">(</span>minIdx<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>gas<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-双指针"><a href="#7-双指针" class="headerlink" title="7.双指针"></a>7.双指针</h2><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p><strong>题目描述</strong></p><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：head <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>输出：<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>思路：</p><p>1、定义两个指针，第一个指针叫 pre，最初是指向 null 的。</p><p>2、第二个指针 cur 指向 head，然后不断遍历 cur。</p><p>3、每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位。</p><p>4、都迭代完了(cur 变成 null 了)，pre 就是最后一个节点了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">reverseList</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">ListNode</span> pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">ListNode</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token class-name">ListNode</span> tmp <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            tmp <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>            pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>            cur <span class="token operator">=</span> tmp<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> pre<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="反转链表II"><a href="#反转链表II" class="headerlink" title="反转链表II"></a>反转链表II</h3><p><strong>题目描述</strong></p><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p><p><strong>示例</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：head <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> left <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">4</span>输出：<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>思路</strong>：双指针+头插法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">reverseBetween</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ListNode</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dummy<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token class-name">ListNode</span> pre <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        head <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> m<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">ListNode</span> cur <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            head<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            pre<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除链表倒数第n个节点"><a href="#删除链表倒数第n个节点" class="headerlink" title="删除链表倒数第n个节点"></a>删除链表倒数第n个节点</h3><p><strong>题目描述</strong></p><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>示例</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：head <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">2</span>输出：<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>思路：使用快慢指针，快指针先走n步。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">removeNthFromEnd</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ListNode</span> tmp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//技巧</span>        tmp<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token class-name">ListNode</span> fast <span class="token operator">=</span> tmp<span class="token punctuation">;</span>        <span class="token class-name">ListNode</span> slow <span class="token operator">=</span> tmp<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        slow<span class="token punctuation">.</span>next <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">return</span> tmp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h3><p><a href="https://leetcode.cn/problems/3sum/">题目链接open in new window</a></p><p><strong>题目描述</strong></p><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p><strong>示例</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">]</span>输出：<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>思路</strong>：</p><ul><li><p>首先对数组进行排序，排序后固定一个数 nums[i]nums[i]，再使用左右指针指向 nums[i]nums[i]后面的两端，数字分别为 nums[L]nums[L] 和</p></li><li><p>nums[R]nums[R]，计算三个数的和 sumsum 判断是否满足为 00，满足则添加进结果集</p></li><li><p>如果 nums[i]nums[i]大于 00，则三数之和必然无法等于 00，结束循环</p></li><li><p>如果 nums[i]nums[i] &#x3D;&#x3D; nums[i-1]nums[i−1]，则说明该数字重复，会导致结果重复，所以应该跳过</p></li><li><p>当 sumsum &#x3D;&#x3D; 00 时，nums[L]nums[L] &#x3D;&#x3D; nums[L+1]nums[L+1] 则会导致结果重复，应该跳过，LL</p></li><li><p>当 sumsum &#x3D;&#x3D; 00 时，nums[R]nums[R] &#x3D;&#x3D; nums[R-1]nums[R−1] 则会导致结果重复，应该跳过，R–R−−</p></li></ul><p><strong>参考代码</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">threeSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//最左边的数字大于0，则sum不会等于0，退出</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//去重复</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">int</span> left <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> sum <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">///array to list</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        left<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>right <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        right<span class="token operator">--</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                    left<span class="token operator">++</span><span class="token punctuation">;</span>                    right<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    right<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    left<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><p><a href="https://leetcode.cn/problems/linked-list-cycle/">题目链接open in new window</a></p><p><strong>题目描述</strong></p><p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p><p><strong>示例</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：head <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> pos <span class="token operator">=</span> <span class="token number">1</span>输出：<span class="token boolean">true</span>解释：链表中有一个环，其尾部连接到第二个节点。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>思路</strong></p><p>快慢指针。快指针每次走两步，慢指针走一步，相当于慢指针不动，快指针每次走一步，如果是环形链表，则一定会相遇。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">ListNode</span> quick <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token class-name">ListNode</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>quick <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> quick<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            quick <span class="token operator">=</span> quick<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>slow <span class="token operator">==</span> quick<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="环形链表II"><a href="#环形链表II" class="headerlink" title="环形链表II"></a>环形链表II</h3><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">题目链接open in new window</a></p><p><strong>题目描述</strong></p><p>给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>不允许修改 链表。</p><p><strong>示例</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：head <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> pos <span class="token operator">=</span> <span class="token number">1</span>输出：返回索引为 <span class="token number">1</span> 的链表节点解释：链表中有一个环，其尾部连接到第二个节点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>解题思路</strong></p><p>方法一：头结点到入环结点的距离为a，入环结点到相遇结点的距离为b，相遇结点到入环结点的距离为c。然后，当fast以slow的两倍速度前进并和slow相遇时，fast走过的距离是s的两倍，即有等式：a+b+c+b &#x3D; 2(a+b) ，可以得出 a &#x3D; c ，所以说，让fast和slow分别从相遇结点和头结点同时同步长出发，他们的相遇结点就是入环结点。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">detectCycle</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ListNode</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token class-name">ListNode</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>fast <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> fast<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>fast <span class="token operator">==</span> slow<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        fast <span class="token operator">=</span> head<span class="token punctuation">;</span>         <span class="token keyword">while</span> <span class="token punctuation">(</span>slow <span class="token operator">!=</span> fast<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> fast<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法二：先算出环的大小n，快指针先走n步，然后快慢指针一起走，相遇的地方即是环的入口。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">detectCycle</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ListNode</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token class-name">ListNode</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token comment">//快慢指针找出环的大小</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>fast <span class="token operator">==</span> slow<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>fast <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> fast<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">int</span> cycleSize <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> slow<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            cycleSize<span class="token operator">++</span><span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//快慢指针重新从链表首部出发，快指针先走sizeOfCycle步</span>        <span class="token comment">//然后两个指针同时一起走，步长为1，相遇节点即是环的入口</span>        fast <span class="token operator">=</span> head<span class="token punctuation">;</span>        slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cycleSize<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span> slow<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> fast<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-二叉树的遍历&quot;&gt;&lt;a href=&quot;#1-二叉树的遍历&quot; class=&quot;headerlink&quot; title=&quot;1. 二叉树的遍历&quot;&gt;&lt;/a&gt;1. 二叉树的遍历&lt;/h2&gt;&lt;p&gt;二叉树是一种非常重要的数据结构，很多其它数据结构都是基于二叉树的基础演变而来的。&lt;/p&gt;</summary>
      
    
    
    
    <category term="PROJECT" scheme="https://zspcer.gitee.io/categories/PROJECT/"/>
    
    <category term="我要进大厂" scheme="https://zspcer.gitee.io/categories/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/"/>
    
    
    <category term="面试" scheme="https://zspcer.gitee.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://zspcer.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="我要进大厂" scheme="https://zspcer.gitee.io/tags/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/"/>
    
  </entry>
  
  <entry>
    <title>大厂面试之计算机网络篇</title>
    <link href="https://zspcer.gitee.io/note/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87/"/>
    <id>https://zspcer.gitee.io/note/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87/</id>
    <published>2023-05-11T16:37:37.000Z</published>
    <updated>2023-05-11T15:42:17.470Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-网络分层结构"><a href="#1-网络分层结构" class="headerlink" title="1.网络分层结构"></a>1.网络分层结构</h2><p>计算机网络体系大致分为三种，OSI七层模型、TCP&#x2F;IP四层模型和五层模型。一般面试的时候考察比较多的是五层模型。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87.assets/1676358848529-41c2f082-ebda-415d-93cc-bd99e5ec482d.png" alt="img"></p><p><strong>五层模型</strong>：应用层、传输层、网络层、数据链路层、物理层。</p><p>1、<strong>应用层</strong>：为应用程序提供交互服务。在互联网中的应用层协议很多，如域名系统DNS、HTTP协议、SMTP协议等。</p><p>2、<strong>传输层</strong>：负责向两台主机进程之间的通信提供数据传输服务。传输层的协议主要有传输控制协议TCP和用户数据协议UDP。</p><p>3、<strong>网络层</strong>：选择合适的路由和交换结点，确保数据及时传送。主要包括IP协议。</p><p>4、<strong>数据链路层</strong>：在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。</p><p>5、<strong>物理层</strong>：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和物理设备的差异。</p><p><strong>ISO七层模型</strong>是国际标准化组织（International Organization for Standardization）制定的一个用于计算机或通信系统间互联的标准体系。</p><p>1、应用层：网络服务与最终用户的一个接口，常见的协议有：<strong>HTTP FTP SMTP SNMP DNS</strong>.</p><p>2、表示层：数据的表示、安全、压缩。，确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。</p><p>3、会话层：建立、管理、终止会话,对应主机进程，指本地主机与远程主机正在进行的会话.</p><p>4、传输层：定义传输数据的协议端口号，以及流控和差错校验,协议有<strong>TCP UDP</strong>.</p><p>5、网络层：进行逻辑地址寻址，实现不同网络之间的路径选择,协议有<strong>ICMP IGMP IP等</strong>.</p><p>6、数据链路层：在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路。</p><p>7、物理层：建立、维护、断开物理连接。</p><p><strong>TCP&#x2F;IP 四层模型</strong></p><p>1、应用层：对应于OSI参考模型的（应用层、表示层、会话层）。</p><p>2传输层: 对应OSI的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。</p><p>3、网际层：对应于OSI参考模型的网络层，主要解决主机到主机的通信问题。</p><p>4、网络接口层：与OSI参考模型的数据链路层、物理层对应。</p><h2 id="2-三次握手"><a href="#2-三次握手" class="headerlink" title="2.三次握手"></a>2.三次握手</h2><p>假设发送端为客户端，接收端为服务端。开始时客户端和服务端的状态都是<code>CLOSED</code>。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87.assets/1676358851894-cb7a8579-821e-4444-b632-8f79cbadc103.png" alt="img"></p><p>1、第一次握手：客户端向服务端发起建立连接请求，客户端会随机生成一个起始序列号x，客户端向服务端发送的字段中包含标志位<code>SYN=1</code>，序列号<code>seq=x</code>。第一次握手前客户端的状态为<code>CLOSE</code>，第一次握手后客户端的状态为<code>SYN-SENT</code>。此时服务端的状态为<code>LISTEN</code>。</p><p>2、第二次握手：服务端在收到客户端发来的报文后，会随机生成一个服务端的起始序列号y，然后给客户端回复一段报文，其中包括标志位<code>SYN=1</code>，<code>ACK=1</code>，序列号<code>seq=y</code>，确认号<code>ack=x+1</code>。第二次握手前服务端的状态为<code>LISTEN</code>，第二次握手后服务端的状态为<code>SYN-RCVD</code>，此时客户端的状态为<code>SYN-SENT</code>。（其中<code>SYN=1</code>表示要和客户端建立一个连接，<code>ACK=1</code>表示确认序号有效）</p><p>3、第三次握手：客户端收到服务端发来的报文后，会再向服务端发送报文，其中包含标志位<code>ACK=1</code>，序列号<code>seq=x+1</code>，确认号<code>ack=y+1</code>。第三次握手前客户端的状态为<code>SYN-SENT</code>，第三次握手后客户端和服务端的状态都为<code>ESTABLISHED</code>。<strong>此时连接建立完成。</strong></p><h2 id="3-两次握手可以吗？"><a href="#3-两次握手可以吗？" class="headerlink" title="3.两次握手可以吗？"></a>3.两次握手可以吗？</h2><p>第三次握手主要为了<strong>防止已失效的连接请求报文段</strong>突然又传输到了服务端，导致产生问题。</p><ul><li><p>比如客户端A发出连接请求，可能因为网络阻塞原因，A没有收到确认报文，于是A再重传一次连接请求。</p></li><li><p>连接成功，等待数据传输完毕后，就释放了连接。</p></li><li><p>然后A发出的第一个连接请求等到连接释放以后的某个时间才到达服务端B，此时B误认为A又发出一次新的连接请求，于是就向A发出确认报文段。</p></li><li><p>如果不采用三次握手，只要B发出确认，就建立新的连接了，<strong>此时A不会响应B的确认且不发送数据，则B一直等待A发送数据，浪费资源。</strong></p></li></ul><h2 id="4-四次挥手"><a href="#4-四次挥手" class="headerlink" title="4.四次挥手"></a>4.四次挥手</h2><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87.assets/1676358854269-3d6a3162-cebf-4e3f-8153-7501913b207f.png" alt="img"></p><p>1、A的应用进程先向其TCP发出连接释放报文段（<code>FIN=1，seq=u</code>），并停止再发送数据，主动关闭TCP连接，进入<code>FIN-WAIT-1</code>（终止等待1）状态，等待B的确认。</p><p>2、B收到连接释放报文段后即发出确认报文段（<code>ACK=1，ack=u+1，seq=v</code>），B进入<code>CLOSE-WAIT</code>（关闭等待）状态，此时的TCP处于半关闭状态，A到B的连接释放。</p><p>3、A收到B的确认后，进入<code>FIN-WAIT-2</code>（终止等待2）状态，等待B发出的连接释放报文段。</p><p>4、B发送完数据，就会发出连接释放报文段（<code>FIN=1，ACK=1，seq=w，ack=u+1</code>），B进入<code>LAST-ACK</code>（最后确认）状态，等待A的确认。</p><p>5、A收到B的连接释放报文段后，对此发出确认报文段（<code>ACK=1，seq=u+1，ack=w+1</code>），A进入<code>TIME-WAIT</code>（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间<code>2MSL</code>（最大报文段生存时间）后，A才进入<code>CLOSED</code>状态。B收到A发出的确认报文段后关闭连接，若没收到A发出的确认报文段，B就会重传连接释放报文段。</p><h2 id="5-第四次挥手为什么要等待2MSL？"><a href="#5-第四次挥手为什么要等待2MSL？" class="headerlink" title="5.第四次挥手为什么要等待2MSL？"></a>5.第四次挥手为什么要等待2MSL？</h2><p><strong>保证A发送的最后一个ACK报文段能够到达B</strong>。这个<code>ACK</code>报文段有可能丢失，B收不到这个确认报文，就会超时重传连接释放报文段，然后A可以在<code>2MSL</code>时间内收到这个重传的连接释放报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到<code>CLOSED</code>状态，若A在<code>TIME-WAIT</code>状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到B重传的连接释放报文段，所以不会再发送一次确认报文段，B就无法正常进入到<code>CLOSED</code>状态。</p><p><strong>防止已失效的连接请求报文段出现在本连接中</strong>。A在发送完最后一个<code>ACK</code>报文段后，再经过2MSL，就可以使这个连接所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现旧的连接请求报文段。</p><h2 id="6-为什么是四次挥手？"><a href="#6-为什么是四次挥手？" class="headerlink" title="6.为什么是四次挥手？"></a>6.为什么是四次挥手？</h2><p>因为当Server端收到Client端的<code>SYN</code>连接请求报文后，可以直接发送<code>SYN+ACK</code>报文。<strong>但是在关闭连接时，当Server端收到Client端发出的连接释放报文时，很可能并不会立即关闭SOCKET</strong>，所以Server端先回复一个<code>ACK</code>报文，告诉Client端我收到你的连接释放报文了。只有等到Server端所有的报文都发送完了，这时Server端才能发送连接释放报文，之后两边才会真正的断开连接。故需要四次挥手。</p><h2 id="7-TCP有哪些特点？"><a href="#7-TCP有哪些特点？" class="headerlink" title="7.TCP有哪些特点？"></a>7.TCP有哪些特点？</h2><p>TCP是<strong>面向连接</strong>的运输层协议。</p><p><strong>点对点</strong>，每一条TCP连接只能有两个端点。</p><p>TCP提供<strong>可靠交付</strong>的服务。</p><p>TCP提供<strong>全双工通信</strong>。</p><p><strong>面向字节流</strong>。</p><h2 id="说说TCP报文首部有哪些字段，其作用又分别是什么？"><a href="#说说TCP报文首部有哪些字段，其作用又分别是什么？" class="headerlink" title="说说TCP报文首部有哪些字段，其作用又分别是什么？"></a>说说TCP报文首部有哪些字段，其作用又分别是什么？</h2><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87.assets/1676358857326-f6eec089-2716-47c9-92f2-be92ea7918cf.png" alt="img"></p><p><strong>16位端口号</strong>：源端口号，主机该报文段是来自哪里；目标端口号，要传给哪个上层协议或应用程序</p><p><strong>32位序号</strong>：一次TCP通信（从TCP连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。</p><p><strong>32位确认号</strong>：用作对另一方发送的tcp报文段的响应。其值是收到的TCP报文段的序号值加1。</p><p><strong>4位头部长度</strong>：表示tcp头部有多少个32bit字（4字节）。因为4位最大能标识15，所以TCP头部最长是60字节。</p><p><strong>6位标志位</strong>：URG(紧急指针是否有效)，ACk（表示确认号是否有效），PSH（缓冲区尚未填满），RST（表示要求对方重新建立连接），SYN（建立连接消息标志接），FIN（表示告知对方本端要关闭连接了）</p><p><strong>16位窗口大小</strong>：是TCP流量控制的一个手段。这里说的窗口，指的是接收通告窗口。它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。</p><p><strong>16位校验和</strong>：由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这个校验不仅包括TCP头部，也包括数据部分。这也是TCP可靠传输的一个重要保障。</p><p><strong>16位紧急指针</strong>：一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP的紧急指针是发送端向接收端发送紧急数据的方法。</p><h2 id="8-TCP和UDP的区别？"><a href="#8-TCP和UDP的区别？" class="headerlink" title="8.TCP和UDP的区别？"></a>8.TCP和UDP的区别？</h2><p>1、TCP<strong>面向连接</strong>；UDP是无连接的，即发送数据之前不需要建立连接。</p><p>2、TCP提供<strong>可靠的服务</strong>；UDP不保证可靠交付。</p><p>3、TCP<strong>面向字节流</strong>，把数据看成一连串无结构的字节流；UDP是面向报文的。</p><p>4、TCP有<strong>拥塞控制</strong>；UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如实时视频会议等）。</p><p>5、每一条TCP连接只能是<strong>点到点</strong>的；UDP支持一对一、一对多、多对一和多对多的通信方式。</p><p>6、TCP首部开销20字节；UDP的首部开销小，只有8个字节。</p><h2 id="9-TCP-和-UDP-分别对应的常见应用层协议有哪些？"><a href="#9-TCP-和-UDP-分别对应的常见应用层协议有哪些？" class="headerlink" title="9.TCP 和 UDP 分别对应的常见应用层协议有哪些？"></a>9.TCP 和 UDP 分别对应的常见应用层协议有哪些？</h2><p><strong>基于TCP的应用层协议有：HTTP、FTP、SMTP、TELNET、SSH</strong></p><ul><li><p><strong>HTTP</strong>：HyperText Transfer Protocol（超文本传输协议），默认端口80</p></li><li><p><strong>FTP</strong>: File Transfer Protocol (文件传输协议), 默认端口(20用于传输数据，21用于传输控制信息)</p></li><li><p><strong>SMTP</strong>: Simple Mail Transfer Protocol (简单邮件传输协议) ,默认端口25</p></li><li><p><strong>TELNET</strong>: Teletype over the Network (网络电传), 默认端口23</p></li><li><p><strong>SSH</strong>：Secure Shell（安全外壳协议），默认端口 22</p></li></ul><p><strong>基于UDP的应用层协议：DNS、TFTP、SNMP</strong></p><ul><li><p><strong>DNS</strong> : Domain Name Service (域名服务),默认端口 53</p></li><li><p><strong>TFTP</strong>: Trivial File Transfer Protocol (简单文件传输协议)，默认端口69</p></li><li><p><strong>SNMP</strong>：Simple Network Management Protocol（简单网络管理协议），通过UDP端口161接收，只有Trap信息采用UDP端口162。</p></li></ul><h2 id="10-TCP的粘包和拆包"><a href="#10-TCP的粘包和拆包" class="headerlink" title="10.TCP的粘包和拆包"></a>10.TCP的粘包和拆包</h2><p>TCP是面向流，没有界限的一串数据。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一<strong>个完整的包可能会被TCP拆分成多个包进行发送</strong>，<strong>也有可能把多个小的包封装成一个大的数据包发送</strong>，这就是所谓的TCP粘包和拆包问题。</p><p><strong>为什么会产生粘包和拆包呢?</strong></p><ul><li><p>要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包；</p></li><li><p>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；</p></li><li><p>要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包；</p></li><li><p>待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。即TCP报文长度-TCP头部长度&gt;MSS。</p></li></ul><p><strong>解决方案：</strong></p><ul><li><p>发送端将每个数据包封装为固定长度</p></li><li><p>在数据尾部增加特殊字符进行分割</p></li><li><p>将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小。</p></li></ul><h2 id="11-说说TCP是如何确保可靠性的呢？"><a href="#11-说说TCP是如何确保可靠性的呢？" class="headerlink" title="11.说说TCP是如何确保可靠性的呢？"></a>11.说说TCP是如何确保可靠性的呢？</h2><p>首先，TCP的连接是基于<strong>三次握手</strong>，而断开则是基于<strong>四次挥手</strong>。确保连接和断开的可靠性。</p><p>其次，TCP的可靠性，还体现在<strong>有状态</strong>;TCP会记录哪些数据发送了，哪些数据被接收了，哪些没有被接受，并且保证数据包按序到达，保证数据传输不出差错。</p><p>再次，TCP的可靠性，还体现在<strong>可控制</strong>。它有数据包校验、ACK应答、**超时重传(发送方)**、失序数据重传（接收方）、丢弃重复数据、流量控制（滑动窗口）和拥塞控制等机制。</p><h2 id="12-说下TCP的滑动窗口机制"><a href="#12-说下TCP的滑动窗口机制" class="headerlink" title="12.说下TCP的滑动窗口机制"></a>12.说下TCP的滑动窗口机制</h2><p>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 TCP会话的双方都各自维护一个发送窗口和一个接收窗口。接收窗口大小取决于应用、系统、硬件的限制。发送窗口则取决于对端通告的接收窗口。接收方发送的确认报文中的window字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将接收方的确认报文window字段设置为 0，则发送方不能发送数据。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87.assets/1676358861135-5010ee50-2705-40ae-8143-1789becbe246.png" alt="img"></p><p>TCP头包含window字段，16bit位，它代表的是窗口的字节容量，最大为65535。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。接收窗口的大小是约等于发送窗口的大小。</p><h2 id="13-详细讲一下拥塞控制？"><a href="#13-详细讲一下拥塞控制？" class="headerlink" title="13.详细讲一下拥塞控制？"></a>13.详细讲一下拥塞控制？</h2><p>防止过多的数据注入到网络中。 几种拥塞控制方法：慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87.assets/1676358863170-b1a0fc7a-2542-47a9-9be4-5a7af3fc11b2.jpeg" alt="img"></p><p><strong>慢开始</strong></p><p>把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。每经过一个传输轮次，拥塞窗口 cwnd 就加倍。 为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。</p><p>当 cwnd &lt; ssthresh 时，使用慢开始算法。</p><p>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</p><p>当 cwnd &#x3D; ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。</p><p><strong>拥塞避免</strong></p><p>让拥塞窗口cwnd缓慢地增大，每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长。</p><p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p><p><strong>快重传</strong></p><p>有时个别报文段会在网络中丢失，但实际上网络并未发生拥塞。如果发送方迟迟收不到确认，就会产生超时，就会误认为网络发生了拥塞。这就导致发送方错误地启动慢开始，把拥塞窗口cwnd又设置为1，因而降低了传输效率。</p><p>快重传算法可以避免这个问题。快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认，使发送方及早知道有报文段没有到达对方。</p><p>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。</p><p><strong>快恢复</strong></p><p>当发送方连续收到三个重复确认，就会把慢开始门限ssthresh减半，接着把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。</p><p>在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用。 采用这样的拥塞控制方法使得TCP的性能有明显的改进。</p><h2 id="14-HTTP协议的特点？"><a href="#14-HTTP协议的特点？" class="headerlink" title="14.HTTP协议的特点？"></a>14.HTTP协议的特点？</h2><p>1、HTTP允许传输<strong>任意类型</strong>的数据。传输的类型由Content-Type加以标记。</p><p>2、<strong>无状态</strong>。对于客户端每次发送的请求，服务器都认为是一个新的请求，上一次会话和下一次会话之间没有联系。</p><p>3、支持<strong>客户端&#x2F;服务器模式</strong>。</p><h2 id="15-HTTP报文格式"><a href="#15-HTTP报文格式" class="headerlink" title="15.HTTP报文格式"></a>15.HTTP报文格式</h2><p>HTTP请求由<strong>请求行、请求头部、空行和请求体</strong>四个部分组成。</p><p><strong>请求行</strong>：包括请求方法，访问的资源URL，使用的HTTP版本。<code>GET</code>和<code>POST</code>是最常见的HTTP方法，除此以外还包括<code>DELETE、HEAD、OPTIONS、PUT、TRACE</code>。</p><p><strong>请求头</strong>：格式为“属性名:属性值”，服务端根据请求头获取客户端的信息，主要有<code>cookie、host、connection、accept-language、accept-encoding、user-agent</code>。</p><p><strong>请求体</strong>：用户的请求数据如用户名，密码等。</p><p><strong>请求报文示例</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token constant">POST</span> <span class="token operator">/</span>xxx <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span> 请求行<span class="token class-name">Accept</span><span class="token operator">:</span>image<span class="token operator">/</span>gif<span class="token punctuation">.</span>image<span class="token operator">/</span>jpeg<span class="token punctuation">,</span> 请求头部<span class="token class-name">Accept</span><span class="token operator">-</span><span class="token class-name">Language</span><span class="token operator">:</span>zh<span class="token operator">-</span>cn<span class="token class-name">Connection</span><span class="token operator">:</span><span class="token class-name">Keep</span><span class="token operator">-</span><span class="token class-name">Alive</span><span class="token class-name">Host</span><span class="token operator">:</span>localhost<span class="token class-name">User</span><span class="token operator">-</span><span class="token class-name">Agent</span><span class="token operator">:</span><span class="token class-name">Mozila</span><span class="token operator">/</span><span class="token number">4.</span><span class="token function">0</span><span class="token punctuation">(</span>compatible<span class="token punctuation">;</span><span class="token constant">MSIE5</span><span class="token punctuation">.</span><span class="token number">01</span><span class="token punctuation">;</span><span class="token class-name">Window</span> <span class="token constant">NT5</span><span class="token punctuation">.</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token class-name">Accept</span><span class="token operator">-</span><span class="token class-name">Encoding</span><span class="token operator">:</span>gzip<span class="token punctuation">,</span>deflateusername<span class="token operator">=</span>dabin 请求体<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HTTP响应也由四个部分组成，分别是：<strong>状态行、响应头、空行和响应体</strong>。</p><p><strong>状态行</strong>：协议版本，状态码及状态描述。</p><p><strong>响应头</strong>：响应头字段主要有<code>connection、content-type、content-encoding、content-length、set-cookie、Last-Modified，、Cache-Control、Expires</code>。</p><p><strong>响应体</strong>：服务器返回给客户端的内容。</p><p><strong>响应报文示例</strong>：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">HTTP/1.1 200 OKServer:Apache Tomcat/5.0.12Date:Mon,6Oct2003 13:23:42 GMTContent-Length:112<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>响应体<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="16-HTTP状态码有哪些？"><a href="#16-HTTP状态码有哪些？" class="headerlink" title="16.HTTP状态码有哪些？"></a>16.HTTP状态码有哪些？</h2><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87.assets/1676358866955-5b5cc131-0432-4ae6-b096-c8fc89e2c3fe.png" alt="img"></p><h2 id="17-HTTP-协议包括哪些请求？"><a href="#17-HTTP-协议包括哪些请求？" class="headerlink" title="17.HTTP 协议包括哪些请求？"></a>17.HTTP 协议包括哪些请求？</h2><p>HTTP协议中共定义了八种方法来表示对Request-URI指定的资源的不同操作方式，具体如下：</p><p>GET：向特定的资源发出请求。</p><p>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和&#x2F;或已有资源的修改。</p><p>OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。</p><p>HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。</p><p>PUT：向指定资源位置上传其最新内容。</p><p>DELETE：请求服务器删除Request-URI所标识的资源。</p><p>TRACE：回显服务器收到的请求，主要用于测试或诊断。</p><p>CONNECT：HTTP&#x2F;1.1协议中预留给能够将连接改为管道方式的代理服务器。</p><h2 id="18-HTTP状态码301和302的区别？"><a href="#18-HTTP状态码301和302的区别？" class="headerlink" title="18.HTTP状态码301和302的区别？"></a>18.HTTP状态码301和302的区别？</h2><p>301：（永久性转移）请求的网页已被永久移动到新位置。服务器返回此响应时，会自动将请求者转到新位置。</p><p>302：（暂时性转移）服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应GET和HEAD请求的301代码类似，会自动将请求者转到不同的位置。</p><p><strong>举个形象的例子</strong>：当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，打个比方说，我有一套房子，但是最近走亲戚去亲戚家住了，过两天我还回来的。而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的，就比如你的那套房子其实是租的，现在租期到了，你又在另一个地方找到了房子，之前租的房子不住了。</p><h2 id="19-URI和URL的区别"><a href="#19-URI和URL的区别" class="headerlink" title="19.URI和URL的区别"></a>19.URI和URL的区别</h2><p>URI，全称是Uniform Resource Identifier)，中文翻译是统一资源标志符，主要作用是唯一标识一个资源。</p><p>URL，全称是Uniform Resource Location)，中文翻译是统一资源定位符，主要作用是提供资源的路径。打个经典比喻吧，URI像是身份证，可以唯一标识一个人，而URL更像一个住址，可以通过URL找到这个人。</p><h2 id="20-POST和GET的区别？"><a href="#20-POST和GET的区别？" class="headerlink" title="20.POST和GET的区别？"></a>20.POST和GET的区别？</h2><p>GET请求参数通过URL传递，POST的参数放在请求体中。</p><p>GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把请求头和请求体一并发送出去；而对于POST，浏览器先发送请求头，服务器响应100 continue，浏览器再发送请求体。</p><p>GET请求会被浏览器主动缓存，而POST不会，除非手动设置。</p><p>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</p><h2 id="21-如何理解HTTP协议是无状态的"><a href="#21-如何理解HTTP协议是无状态的" class="headerlink" title="21.如何理解HTTP协议是无状态的"></a>21.如何理解HTTP协议是无状态的</h2><p>当浏览器第一次发送请求给服务器时，服务器响应了；如果同个浏览器发起第二次请求给服务器时，它还是会响应，但是呢，服务器不知道你就是刚才的那个浏览器。简言之，服务器不会去记住你是谁，所以是无状态协议。</p><h2 id="22-HTTP长连接和短连接？"><a href="#22-HTTP长连接和短连接？" class="headerlink" title="22.HTTP长连接和短连接？"></a>22.HTTP长连接和短连接？</h2><p>HTTP短连接：浏览器和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。<strong>HTTP1.0默认使用的是短连接</strong>。</p><p>HTTP长连接：指的是<strong>复用TCP连接</strong>。多个HTTP请求可以复用同一个TCP连接，这就节省了TCP连接建立和断开的消耗。</p><p><strong>HTTP&#x2F;1.1起，默认使用长连接</strong>。要使用长连接，客户端和服务器的HTTP首部的Connection都要设置为keep-alive，才能支持长连接。</p><h2 id="23-HTTP-如何实现长连接？"><a href="#23-HTTP-如何实现长连接？" class="headerlink" title="23.HTTP 如何实现长连接？"></a>23.HTTP 如何实现长连接？</h2><p>HTTP分为长连接和短连接，<strong>本质上说的是TCP的长短连接</strong>。TCP连接是一个双向的通道，它是可以保持一段时间不关闭的，因此TCP连接才具有真正的长连接和短连接这一说法哈。</p><p>TCP长连接可以复用一个TCP连接，来发起多次的HTTP请求，这样就可以减少资源消耗，比如一次请求HTML，如果是短连接的话，可能还需要请求后续的JS&#x2F;CSS。</p><p><strong>如何设置长连接？</strong></p><p>通过在头部（请求和响应头）设置<strong>Connection</strong>字段指定为<code>keep-alive</code>，HTTP&#x2F;1.0协议支持，但是是默认关闭的，从HTTP&#x2F;1.1以后，连接默认都是长连接。</p><h2 id="24-HTTP长连接在什么时候会超时？"><a href="#24-HTTP长连接在什么时候会超时？" class="headerlink" title="24.HTTP长连接在什么时候会超时？"></a>24.HTTP长连接在什么时候会超时？</h2><p>HTTP一般会有httpd守护进程，里面可以设置<strong>keep-alive timeout</strong>，当tcp连接闲置超过这个时间就会关闭，也可以在HTTP的header里面设置超时时间。</p><p>TCP 的<strong>keep-alive</strong>包含三个参数，支持在系统内核的net.ipv4里面设置；当 TCP 连接之后，闲置了<strong>tcp_keepalive_time</strong>，则会发生侦测包，如果没有收到对方的ACK，那么会每隔 tcp_keepalive_intvl再发一次，直到发送了<strong>tcp_keepalive_probes</strong>，就会丢弃该连接。</p><h2 id="25-HTTP1-1和-HTTP2-0的区别？"><a href="#25-HTTP1-1和-HTTP2-0的区别？" class="headerlink" title="25.HTTP1.1和 HTTP2.0的区别？"></a>25.HTTP1.1和 HTTP2.0的区别？</h2><p>HTTP2.0相比HTTP1.1支持的特性：</p><p><strong>新的二进制格式</strong>：HTTP1.1 基于文本格式传输数据；HTTP2.0采用二进制格式传输数据，解析更高效。</p><p><strong>多路复用</strong>：在一个连接里，允许同时发送多个请求或响应，<strong>并且这些请求或响应能够并行的传输而不被阻塞</strong>，避免 HTTP1.1 出现的”队头堵塞”问题。</p><p><strong>头部压缩</strong>，HTTP1.1的header带有大量信息，而且每次都要重复发送；HTTP2.0 把header从数据中分离，并封装成头帧和数据帧，<strong>使用特定算法压缩头帧</strong>，有效减少头信息大小。并且HTTP2.0**在客户端和服务器端记录了之前发送的键值对，对于相同的数据，不会重复发送。******比如请求a发送了所有的头信息字段，请求b则****<strong>只需要发送差异数据</strong>，这样可以减少冗余数据，降低开销。</p><p><strong>服务端推送</strong>：HTTP2.0允许服务器向客户端推送资源，无需客户端发送请求到服务器获取。</p><h2 id="26-HTTPS与HTTP的区别？"><a href="#26-HTTPS与HTTP的区别？" class="headerlink" title="26.HTTPS与HTTP的区别？"></a>26.HTTPS与HTTP的区别？</h2><p>1、HTTP是超文本传输协议，信息是<strong>明文传输</strong>；HTTPS则是具有<strong>安全性</strong>的ssl加密传输协议。</p><p>2、HTTP和HTTPS用的端口不一样，HTTP端口是80，HTTPS是443。</p><p>3、HTTPS协议<strong>需要到CA机构申请证书</strong>，一般需要一定的费用。</p><p>4、HTTP运行在TCP协议之上；HTTPS运行在SSL协议之上，SSL运行在TCP协议之上。</p><h2 id="27-什么是数字证书？"><a href="#27-什么是数字证书？" class="headerlink" title="27.什么是数字证书？"></a>27.什么是数字证书？</h2><p>服务端可以向证书颁发机构CA申请证书，以避免中间人攻击（防止证书被篡改）。证书包含三部分内容：<strong>证书内容、证书签名算法和签名</strong>，签名是为了验证身份。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87.assets/1676358872192-e43151fd-0414-4313-91c4-793b531d8101.png" alt="img"></p><p>服务端把证书传输给浏览器，浏览器从证书里取公钥。证书可以证明该公钥对应本网站。</p><p><strong>数字签名的制作过程</strong>：</p><p>1、CA使用证书签名算法对证书内容进行<strong>hash运算</strong>。</p><p>2、对hash后的值<strong>用CA的私钥加密</strong>，得到数字签名。</p><p><strong>浏览器验证过程</strong>：</p><p>1、获取证书，得到证书内容、证书签名算法和数字签名。</p><p>2、用CA机构的公钥<strong>对数字签名解密</strong>（由于是浏览器信任的机构，所以浏览器会保存它的公钥）。</p><p>3、用证书里的签名算法<strong>对证书内容进行hash运算</strong>。</p><p>4、比较解密后的数字签名和对证书内容做hash运算后得到的哈希值，相等则表明证书可信。</p><h2 id="28-HTTPS原理"><a href="#28-HTTPS原理" class="headerlink" title="28.HTTPS原理"></a>28.HTTPS原理</h2><p>首先是TCP三次握手，然后客户端发起一个HTTPS连接建立请求，客户端先发一个<code>Client Hello</code>的包，然后服务端响应<code>Server Hello</code>，接着再给客户端发送它的证书，然后双方经过密钥交换，最后使用交换的密钥加解密数据。</p><p>1、<strong>协商加密算法</strong> 。在<code>Client Hello</code>里面客户端会告知服务端自己当前的一些信息，包括客户端要使用的TLS版本，支持的加密算法，要访问的域名，给服务端生成的一个随机数（Nonce）等。需要提前告知服务器想要访问的域名以便服务器发送相应的域名的证书过来。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87.assets/1676358874267-a7c88320-ea0a-4f46-8087-a724021f0137.png" alt="img"></p><p>2、服务端响应<code>Server Hello</code>，告诉客户端服务端<strong>选中的加密算法</strong>。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87.assets/1676358876384-bb1b6d0e-e7ad-491d-8625-5316e5dad58f.png" alt="img"></p><p>3、接着服务端给客户端发来了2个证书。第二个证书是第一个证书的签发机构（CA）的证书。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87.assets/1676358878314-6e92fe9a-0f83-4f0e-adbe-6c3146db59ff.png" alt="img"></p><p>4、客户端使用证书的认证机构CA公开发布的RSA公钥<strong>对该证书进行验证</strong>，下图表明证书认证成功。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87.assets/1676358880141-bf696ba2-dd59-4d67-9ef9-20ce30e61287.png" alt="img"></p><p>5、验证通过之后，浏览器和服务器通过<strong>密钥交换算法</strong>产生共享的<strong>对称密钥</strong>。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87.assets/1676358881698-d39ab7cc-dcd4-476a-96b7-7fce65fe5f78.png" alt="img"></p><p>6、开始传输数据，使用同一个对称密钥来加解密。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87.assets/1676358883511-b90bc9bc-dbe3-4317-9b2d-ec39eda4da99.png" alt="img"></p><h2 id="29-DNS-的解析过程？"><a href="#29-DNS-的解析过程？" class="headerlink" title="29.DNS 的解析过程？"></a>29.DNS 的解析过程？</h2><p>1、浏览器搜索<strong>自己的DNS缓存</strong></p><p>2、若没有，则搜索<strong>操作系统中的DNS缓存和hosts文件</strong></p><p>3、若没有，则操作系统将域名发送至<strong>本地域名服务器</strong>，本地域名服务器查询自己的DNS缓存，查找成功则返回结果，否则依次向<strong>根域名服务器、顶级域名服务器、权限域名服务器</strong>发起查询请求，最终返回IP地址给本地域名服务器</p><p>4、本地域名服务器将得到的IP地址返回给<strong>操作系统</strong>，同时自己也<strong>将IP地址缓存起来</strong></p><p>5、操作系统将 IP 地址返回给浏览器，同时自己也将IP地址缓存起来</p><p>6、浏览器得到域名对应的IP地址</p><h2 id="30-浏览器中输入URL返回页面过程？"><a href="#30-浏览器中输入URL返回页面过程？" class="headerlink" title="30.浏览器中输入URL返回页面过程？"></a>30.浏览器中输入URL返回页面过程？</h2><p>1、<strong>解析域名</strong>，找到主机 IP。</p><p>2、浏览器利用 IP 直接与网站主机通信，<strong>三次握手</strong>，建立 TCP 连接。浏览器会以一个随机端口向服务端的 web 程序 80 端口发起 TCP 的连接。</p><p>3、建立 TCP 连接后，浏览器向主机发起一个HTTP请求。</p><p>4、服务器<strong>响应请求</strong>，返回响应数据。</p><p>5、浏览器<strong>解析响应内容，进行渲染</strong>，呈现给用户。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87.assets/1676358886057-ef3eca4c-4c0f-4963-8303-5892533cfe08.png" alt="img"></p><h2 id="31-什么是cookie和session？"><a href="#31-什么是cookie和session？" class="headerlink" title="31.什么是cookie和session？"></a>31.什么是cookie和session？</h2><p>由于HTTP协议是无状态的协议，需要用某种机制来识具体的用户身份，用来跟踪用户的整个会话。常用的会话跟踪技术是cookie与session。</p><p><strong>cookie</strong>就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。说得更具体一些：当用户使用浏览器访问一个支持cookie的网站的时候，用户会提供包括用户名在内的个人信息并且提交至服务器；接着，服务器在向客户端回传相应的超文本的同时也会发回这些个人信息，当然这些信息并不是存放在HTTP响应体中的，而是存放于HTTP响应头；当客户端浏览器接收到来自服务器的响应之后，浏览器会将这些信息存放在一个统一的位置。 自此，客户端再向服务器发送请求的时候，都会把相应的cookie存放在HTTP请求头再次发回至服务器。服务器在接收到来自客户端浏览器的请求之后，就能够通过分析存放于请求头的cookie得到客户端特有的信息，从而动态生成与该客户端相对应的内容。网站的登录界面中“请记住我”这样的选项，就是通过cookie实现的。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87.assets/1676358888696-5c7d867f-41a7-42b2-94f6-4d3e87848c96.png" alt="img"></p><p><strong>cookie工作流程</strong>：</p><p>1、servlet创建cookie，保存少量数据，发送给浏览器。</p><p>2、浏览器获得服务器发送的cookie数据，将自动的保存到浏览器端。</p><p>3、下次访问时，浏览器将自动携带cookie数据发送给服务器。</p><p><strong>session原理</strong>：首先浏览器请求服务器访问web站点时，服务器首先会检查这个客户端请求是否已经包含了一个session标识、称为SESSIONID，如果已经包含了一个sessionid则说明以前已经为此客户端创建过session，服务器就按照sessionid把这个session检索出来使用，如果客户端请求不包含session id，则服务器为此客户端创建一个session，并且生成一个与此session相关联的独一无二的sessionid存放到cookie中，这个sessionid将在本次响应中返回到客户端保存，这样在交互的过程中，浏览器端每次请求时，都会带着这个sessionid，服务器根据这个sessionid就可以找得到对应的session。以此来达到共享数据的目的。 这里需要注意的是，session不会随着浏览器的关闭而死亡，而是等待超时时间。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87.assets/1676358890845-24db427f-7602-4b8d-a4f9-026d730286d2.png" alt="img"></p><h2 id="32-cookie和session的区别？"><a href="#32-cookie和session的区别？" class="headerlink" title="32.cookie和session的区别？"></a>32.cookie和session的区别？</h2><p><strong>作用范围不同</strong>，Cookie 保存在客户端，Session 保存在服务器端。</p><p><strong>有效期不同</strong>，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</p><p><strong>隐私策略不同</strong>，Cookie 存储在客户端，容易被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</p><p><strong>存储大小不同</strong>， 单个 Cookie 保存的数据不能超过 4K；对于 Session 来说存储没有上限，但出于对服务器的性能考虑，Session 内不要存放过多的数据，并且需要设置 Session 删除机制。</p><h2 id="33-什么是对称加密和非对称加密？"><a href="#33-什么是对称加密和非对称加密？" class="headerlink" title="33.什么是对称加密和非对称加密？"></a>33.什么是对称加密和非对称加密？</h2><p><strong>对称加密</strong>：通信双方使用<strong>相同的密钥</strong>进行加密。特点是加密速度快，但是缺点是密钥泄露会导致密文数据被破解。常见的对称加密有<code>AES</code>和<code>DES</code>算法。</p><p><strong>非对称加密</strong>：它需要生成两个密钥，<strong>公钥和私钥</strong>。公钥是公开的，任何人都可以获得，而私钥是私人保管的。公钥负责加密，私钥负责解密；或者私钥负责加密，公钥负责解密。这种加密算法<strong>安全性更高</strong>，但是<strong>计算量相比对称加密大很多</strong>，加密和解密都很慢。常见的非对称算法有<code>RSA</code>和<code>DSA</code>。</p><h2 id="34-说说-WebSocket与socket的区别"><a href="#34-说说-WebSocket与socket的区别" class="headerlink" title="34.说说 WebSocket与socket的区别"></a>34.说说 WebSocket与socket的区别</h2><p>Socket是一套标准，它完成了对TCP&#x2F;IP的高度封装，屏蔽网络细节，以方便开发者更好地进行网络编程。Socket其实就是等于<strong>IP地址 + 端口 + 协议</strong>。</p><p>WebSocket是一个持久化的协议，它是伴随H5而出的协议，用来解决<strong>http不支持持久化连接</strong>的问题。</p><p>Socket一个是<strong>网编编程的标准接口</strong>，而WebSocket则是应用层通信协议。</p><h2 id="35-ARP协议的工作过程？"><a href="#35-ARP协议的工作过程？" class="headerlink" title="35.ARP协议的工作过程？"></a>35.ARP协议的工作过程？</h2><p>ARP解决了同一个局域网上的主机和路由器IP和MAC地址的解析。</p><p>每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。</p><p>当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP列表中是否存在该 IP地址对应的MAC地址，如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。</p><p>网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址。</p><p>源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。</p><p>如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p><h2 id="36-ICMP协议的功能"><a href="#36-ICMP协议的功能" class="headerlink" title="36.ICMP协议的功能"></a>36.ICMP协议的功能</h2><p>ICMP,Internet Control Message Protocol ,Internet控制消息协议。</p><p>ICMP协议是一种面向无连接的协议，用于传输出错报告控制信息。</p><p>它是一个非常重要的协议，它对于网络安全具有极其重要的意义。它属于网络层协议，主要用于在主机与路由器之间传递控制信息，包括<strong>报告错误、交换受限控制和状态信息</strong>等。</p><p>当遇到IP数据无法访问目标、IP路由器无法按当前的传输速率转发数据包等情况时，会自动发送ICMP消息。</p><p>比如我们日常使用得比较多的<strong>ping</strong>，就是基于ICMP的。</p><h2 id="37-什么是DoS、DDoS、DRDoS攻击？"><a href="#37-什么是DoS、DDoS、DRDoS攻击？" class="headerlink" title="37.什么是DoS、DDoS、DRDoS攻击？"></a>37.什么是DoS、DDoS、DRDoS攻击？</h2><p><strong>DOS</strong>: (Denial of Service),翻译过来就是拒绝服务,一切能引起DOS行为的攻击都被称为DOS攻击。最常见的DoS攻击就有<strong>计算机网络宽带攻击</strong>、<strong>连通性攻击</strong>。</p><p><strong>DDoS</strong>: (Distributed Denial of Service),翻译过来是分布式拒绝服务。是指处于不同位置的多个攻击者同时向一个或几个目标发动攻击，或者一个攻击者控制了位于不同位置的多台机器并利用这些机器对受害者同时实施攻击。常见的DDos有<strong>SYN Flood、Ping of Death、ACK Flood、UDP Flood</strong>等。</p><p><strong>DRDoS</strong>: (Distributed Reflection Denial of Service)，中文是分布式反射拒绝服务，该方式靠的是发送大量带有被害者IP地址的数据包给攻击主机，然后攻击主机对IP地址源做出大量回应，从而形成拒绝服务攻击。</p><h2 id="38-什么是CSRF攻击，如何避免"><a href="#38-什么是CSRF攻击，如何避免" class="headerlink" title="38.什么是CSRF攻击，如何避免"></a>38.什么是CSRF攻击，如何避免</h2><p>CSRF，跨站请求伪造（英文全称是Cross-site request forgery），是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。</p><p><strong>怎么解决CSRF攻击呢？</strong></p><ul><li><p>检查Referer字段。</p></li><li><p>添加校验token。</p></li></ul><h2 id="39-什么是XSS攻击？"><a href="#39-什么是XSS攻击？" class="headerlink" title="39.什么是XSS攻击？"></a>39.什么是XSS攻击？</h2><p>XSS，跨站脚本攻击（Cross-Site Scripting）。它指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意攻击用户的特殊目的。XSS攻击一般分三种类型：<strong>存储型 、反射型 、DOM型XSS</strong></p><h2 id="40-如何解决XSS攻击问题？"><a href="#40-如何解决XSS攻击问题？" class="headerlink" title="40.如何解决XSS攻击问题？"></a>40.如何解决XSS攻击问题？</h2><p>对输入进行过滤，过滤标签等，只允许合法值。</p><p>HTML转义</p><p>对于链接跳转，如<code>&lt;a href=&quot;xxx&quot;</code> 等，要校验内容，禁止以script开头的非法链接。</p><p>限制输入长度</p><h2 id="41-防盗链"><a href="#41-防盗链" class="headerlink" title="41.防盗链"></a>41.防盗链</h2><p><strong>盗链</strong>是指服务提供商自己不提供服务的内容，通过技术手段（可以理解成爬虫）去获取其他网站的资源展示在自己的网站上。常见的盗链有以下几种：图片盗链、音频盗链、视频盗链等。</p><p>网站盗链会大量消耗被盗链网站的带宽，而真正的点击率也许会很小，严重损害了被盗链网站的利益。</p><p>被盗网站就自然会<strong>防盗链</strong>，可以通过经常更换图片名，也可以通过检测referer。因为正常用户访问一张图片一定是从自己的网站点击链接进去的，如果一个请求的referer是其他网站，就说明这是一个爬虫。</p><p><strong>什么是 Referer？</strong></p><p>这里的 Referer 指的是 HTTP 头部的一个字段，也称为 HTTP 来源地址（HTTP Referer），用来表示从哪儿链接到目前的网页，采用的格式是 URL。换句话说，借着 HTTP Referer 头部网页可以检查访客从哪里而来，这也常被用来对付伪造的跨网站请求。</p><p>盗链网站会针对性进行<strong>反盗链</strong>，可以通过在请求的headers中设置referer来绕过<strong>防盗链</strong>，我们现在使用爬虫抓取别人的网站也是这样。</p><p><strong>什么是空 Referer，什么时候会出现空 Referer？</strong></p><p>首先，我们对空 Referer 的定义为，Referer 头部的内容为空，或者，一个 HTTP 请求中根本不包含 Referer 头部。</p><p>那么什么时候 HTTP 请求会不包含 Referer 字段呢？根据 Referer 的定义，它的作用是指示一个请求是从哪里链接过来，那么当一个请求并不是由链接触发产生的，那么自然也就不需要指定这个请求的链接来源。</p><p>比如，直接在浏览器的地址栏中输入一个资源的 URL 地址，那么这种请求是不会包含 Referer 字段的，因为这是一个 “凭空产生” 的 HTTP 请求，并不是从一个地方链接过去的。</p><h2 id="42-说下ping的原理"><a href="#42-说下ping的原理" class="headerlink" title="42.说下ping的原理"></a>42.说下ping的原理</h2><p>ping，<strong>Packet Internet Groper</strong>，是一种因特网包探索器，用于测试网络连接量的程序。Ping是工作在TCP&#x2F;IP网络体系结构中应用层的一个服务命令， 主要是向特定的目的主机发送ICMP（Internet Control Message Protocol 因特网报文控制协议） 请求报文，测试目的站是否可达及了解其有关状态。</p><p>一般来说，ping可以用来检测网络通不通。它是基于<code>ICMP</code>协议工作的。假设<strong>机器A</strong> ping<strong>机器B</strong>，工作过程如下：</p><p>1、ping通知系统，新建一个固定格式的ICMP请求数据包</p><p>2、ICMP协议，将该数据包和目标机器B的IP地址打包，一起转交给IP协议层</p><p>3、IP层协议将本机IP地址为源地址，机器B的IP地址为目标地址，加上一些其他的控制信息，构建一个IP数据包</p><p>4、先获取目标机器B的MAC地址。</p><p>5、数据链路层构建一个数据帧，目的地址是IP层传过来的<strong>MAC地址</strong>，源地址是本机的<strong>MAC地址</strong></p><p>6、机器B收到后，对比目标地址，和自己本机的MAC地址是否一致，符合就处理返回，不符合就丢弃。</p><p>7、根据目的主机返回的ICMP回送回答报文中的时间戳，从而计算出往返时间</p><p>8、最终显示结果有这几项：发送到目的主机的IP地址、发送 &amp; 收到 &amp; 丢失的分组数、往返时间的最小、最大&amp; 平均值</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-网络分层结构&quot;&gt;&lt;a href=&quot;#1-网络分层结构&quot; class=&quot;headerlink&quot; title=&quot;1.网络分层结构&quot;&gt;&lt;/a&gt;1.网络分层结构&lt;/h2&gt;&lt;p&gt;计算机网络体系大致分为三种，OSI七层模型、TCP&amp;#x2F;IP四层模型和五层模型。一般面</summary>
      
    
    
    
    <category term="PROJECT" scheme="https://zspcer.gitee.io/categories/PROJECT/"/>
    
    <category term="我要进大厂" scheme="https://zspcer.gitee.io/categories/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/"/>
    
    
    <category term="面试" scheme="https://zspcer.gitee.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="我要进大厂" scheme="https://zspcer.gitee.io/tags/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/"/>
    
    <category term="计算机网络" scheme="https://zspcer.gitee.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统的IO原理</title>
    <link href="https://zspcer.gitee.io/note/LINUX/SYSTEM/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84IO%E5%8E%9F%E7%90%86/"/>
    <id>https://zspcer.gitee.io/note/LINUX/SYSTEM/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84IO%E5%8E%9F%E7%90%86/</id>
    <published>2023-05-11T11:33:36.000Z</published>
    <updated>2023-05-11T15:42:17.068Z</updated>
    
    <content type="html"><![CDATA[<p>本文来自阅读《操作系统之哲学原理》第六篇：IO原理篇；第19章：输入和输出</p><p>xmind下载：<a href="./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84IO%E5%8E%9F%E7%90%86.assets/IO%E5%8E%9F%E7%90%86.xmind">操作系统的IO原理.xmind</a></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84IO%E5%8E%9F%E7%90%86.assets/image-20230511141325442.png" alt="image-20230511141325442"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文来自阅读《操作系统之哲学原理》第六篇：IO原理篇；第19章：输入和输出&lt;/p&gt;
&lt;p&gt;xmind下载：&lt;a href=&quot;./%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84IO%E5%8E%9F%E7%90%86.assets/</summary>
      
    
    
    
    <category term="LINUX" scheme="https://zspcer.gitee.io/categories/LINUX/"/>
    
    <category term="SYSTEM" scheme="https://zspcer.gitee.io/categories/LINUX/SYSTEM/"/>
    
    
    <category term="操作系统" scheme="https://zspcer.gitee.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="IO原理" scheme="https://zspcer.gitee.io/tags/IO%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>promethues如何添加配置</title>
    <link href="https://zspcer.gitee.io/note/JAVA/%E7%9B%91%E6%8E%A7/promethues%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE/"/>
    <id>https://zspcer.gitee.io/note/JAVA/%E7%9B%91%E6%8E%A7/promethues%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE/</id>
    <published>2023-05-11T02:44:22.303Z</published>
    <updated>2023-05-11T02:44:22.303Z</updated>
    
    <content type="html"><![CDATA[<p>修改promethues.yml文件</p><img src="promethues如何添加配置.assets/image-20220902160951197.png" alt="image-20220902160951197"  /><p>比如我要添加一个kafka的监控，使用kafka-expoter: 进行如下配置：</p><img src="promethues如何添加配置.assets/image-20220902161001220.png" alt="image-20220902161001220" style="zoom:80%;" /><p>首次启动</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nohup</span> ./prometheus <span class="token parameter variable">--config.file</span><span class="token operator">=</span>prometheus.yml <span class="token operator">&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>热部署</p><ul><li>只加载配置文件，不重启promethues的进程</li><li>找到promethues的进程ID： lsof -i:9090</li><li>kill -HUP pid</li><li>观察日志，或者刷新promethus的页面，可以看到新的配置被加载</li></ul><img src="promethues如何添加配置.assets/image-20220902161056730.png" alt="image-20220902161056730" style="zoom:80%;" /><img src="promethues如何添加配置.assets/image-20220902161108613.png" alt="image-20220902161108613" style="zoom:80%;" /><p>使用kafka-expoter指定端口号：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nohup</span> ./kafka_exporter <span class="token parameter variable">--kafka.server</span><span class="token operator">=</span><span class="token number">10.13</span>.70.4:9092 --web.listen-address<span class="token operator">=</span>:9309 <span class="token operator">&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;修改promethues.yml文件&lt;/p&gt;
&lt;img src=&quot;promethues如何添加配置.assets/image-20220902160951197.png&quot; alt=&quot;image-20220902160951197&quot;  /&gt;



&lt;p&gt;比如我要添加一个kaf</summary>
      
    
    
    
    <category term="JAVA" scheme="https://zspcer.gitee.io/categories/JAVA/"/>
    
    <category term="监控" scheme="https://zspcer.gitee.io/categories/JAVA/%E7%9B%91%E6%8E%A7/"/>
    
    
    <category term="promethues" scheme="https://zspcer.gitee.io/tags/promethues/"/>
    
  </entry>
  
  <entry>
    <title>mysql的性能调优从入门到入土</title>
    <link href="https://zspcer.gitee.io/note/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL/mysql%E7%9A%84%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/"/>
    <id>https://zspcer.gitee.io/note/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL/mysql%E7%9A%84%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/</id>
    <published>2023-05-11T02:44:22.246Z</published>
    <updated>2023-05-11T02:44:22.246Z</updated>
    
    <content type="html"><![CDATA[<hr><p>资料：打开</p><h2 id="7-MySQL中-in-和-exists-的区别？"><a href="#7-MySQL中-in-和-exists-的区别？" class="headerlink" title="7.MySQL中 in 和 exists 的区别？"></a>7.MySQL中 in 和 exists 的区别？</h2><p>MySQL中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。我们可能认为exists比in语句的效率要高，这种说法其实是不准确的，要区分情景：</p><p>1、如果查询的两个表大小相当，那么用in和exists差别不大。</p><p>2、如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。</p><p>3、not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。</p><p>mysql的索引优化，联合索引使用的时候，时间+站点+code， 通过时间筛选之后，数据还比较多，此时效率很低。可以把所以改成：站点+时间+code，这样通过站点筛选之后的数据，就剩下很少了，此时效率很高。</p><p>事务中，行锁是在语句执行时才加上的，不是事务开始就加上，但释放是统一在事务结束时才释放。根据这个特性，对于高并发的行记录的操作语句就可以尽可能的安排到最后面，以减少锁等待的时间，提高并发性能</p><p>减少大事务，可以减少主备延迟，可以降低锁的时间，减少死锁的产生，减少死锁检测的性能消耗。</p><p>减少并发量（减少对于同一行更新的并发量），可以减少死锁的产生，可以减少死锁检测的性能消耗</p><p>在删除数据的时候尽量加 limit。这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围。</p><p>在出现IO瓶颈的时候，可以将sync_binglog设置为100-1000内的值，表示累计多少个事务之后才会刷盘，默认是1表示每一个事务都会刷盘写binlog；</p><p>在出现IO瓶颈的时候，可以设置binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count，表示提升binlog的组提交的效果，但是会增加sql的响应时间</p><p>写多读少的场景，由于 change buffer 的优化机制，因此如果业务可以接受，从性能角度出发我建议你优先考虑普通索引。</p><p>mysql要调优，就要知道它为什么慢，哪里慢</p><p>在低版本：show profiles</p><p>在高版本：performance schema</p><p>以上有什么用？</p><ul><li>比如在实际环境中，有一个sql，非常慢</li><li>sql本身没有问题，看执行计划也比较慢，这个时候就可以用到上面的</li><li>可以更加详细的看到，这个sql到底是哪里慢</li></ul><p>process list 可以查看mysql的连接数量，顺丰云上的回话连接是不是？</p><p>不过一般有druid，不用太关注这个。但是呢，druid是什么，要去看看github上面的官网了。了解一下它的优点</p><p>MRR优化，将主键ID回表的随机读，改成主键ID的顺序读，但是默认是关闭的，优化器不倾向于使用MRR，不知道为啥；MRR 能够提升性能的核心在于，这条查询语句在索引 a 上做的是一个范围查询（也就是说，这是一个多值查询），可以得到足够多的主键 id。这样通过排序以后，再去主键索引查数据，才能体现出“顺序性”的优势。</p><p>字符集和字符编码的区别</p><p>大表拆分，将不常用的数据从表里拆出去，表小了之后，每个数据页存的数据就会多，查询的时候，就会减少磁盘IO</p><p>优化：</p><ul><li>不同的数据选择对应的mysql自建数据类型，比如数字就用数字类型，不要用字符串，时间就用时间类型，不要用字符串；用错了数据类型，对业务可能没影响，但是对mysql来说，内部多了一层转换，sql执行会比较慢</li><li>事件类型，建议用date，而不是timestamp，date类型</li></ul><p>大事务不仅会影响到主库，也是造成备库复制延迟的主要原因之一。因此，在平时的开发工作中，我建议你尽量减少大事务操作，把大事务拆成小事务。</p><p>show processlist</p><ul><li><p>看到的只是当前的并发连接数，如果你的系统动不动就成千上百个连接，其实都没关系，只是占用一些内存而已</p></li><li><p>&#96;&#96;&#96;sql<br>mysql&gt; show processlist;<br>+—-+—————–+—————–+——+———+——–+————————+——————+<br>| Id | User            | Host            | db   | Command | Time   | State                  | Info             |<br>+—-+—————–+—————–+——+———+——–+————————+——————+<br>|  5 | event_scheduler | localhost       | NULL | Daemon  | 865562 | Waiting on empty queue | NULL             |<br>| 23 | root            | localhost:60179 | NULL | Query   |      0 | init                   | show processlist |<br>+—-+—————–+—————–+——+———+——–+————————+——————+<br>2 rows in set (0.00 sec)</p><pre class="line-numbers language-none"><code class="language-none">- 真正需要关注的是并发执行数，也就是并发执行的线程，因为连接存在，这个连接不一定在执行。- innodb的并发执行数，通过&#96;innodb_thread_concurrency&#96;这个参数来控制的，默认是0表示不限制。- &#96;innodb_thread_concurrency&#96;的计算规则是：正在执行的线程+1，如果一个线程在执行过程中，遇到了锁，需要等待，线程-1---# IN 查询优化这个名字还真不是我起的，今天要讲的知识点就叫**索引潜水（Index dive）**。先要从一件怪事说起：我先造点数据复现一下问题，创建一张用户表：&#96;&#96;&#96;sqlCREATE TABLE &#96;user&#96; (  &#96;id&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;主键ID&#39;,  &#96;name&#96; varchar(100) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;姓名&#39;,  &#96;age&#96; int(11) NOT NULL DEFAULT 0 COMMENT &#39;年龄&#39;,  PRIMARY KEY (&#96;id&#96;),  KEY &#96;idx_age&#96; (&#96;age&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>通过一批用户年龄，查询该年龄的用户信息，并查看一下SQL执行计划：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> age <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="mysql的性能调优从入门到入土.assets/image-20230209164837331.png" alt="image-20230209164837331" style="zoom:60%;" /><p>where条件中有9个参数，重点关注一下执行计划中的预估扫描行数为279行。</p><p>到这里没什么问题，预估的非常准，实际就是279行。</p><img src="mysql的性能调优从入门到入土.assets/image-20230209164853902.png" alt="image-20230209164853902" /><p>但是，问题来了，当我们在where条件中，再加一个参数，变成了10个参数，预估扫描行数本应该增加，结果却大大减少了。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> age <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="mysql的性能调优从入门到入土.assets/image-20230209164903103.png" alt="image-20230209164903103" /><p>一下子减少到了30行，可是实际行数是多少呢？</p><img src="mysql的性能调优从入门到入土.assets/image-20230209164911034.png" alt="image-20230209164911034" /><p>实际是310行，预估扫描行数是30行，真是错到姥姥家了。</p><p><strong>MySQL咋回事啊，到底还能不能预估？</strong></p><p><strong>不能预估的话，换其他人！</strong></p><p>大家肯定也是满脸疑惑，直到我去官网上看到了一个词语，<strong>索引潜水（Index dive）</strong>。</p><p>跟这个词语相关的，还有一个配置参数 <strong>eq_range_index_dive_limit</strong>。</p><p><strong>MySQL5.7.3</strong>之前的版本，这个值默认是10，之后的版本，这个值默认是200。</p><p>可以使用命令查看一下这个值的大小：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'%eq_range_index_dive_limit%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="mysql的性能调优从入门到入土.assets/image-20230209164922082.png" alt="image-20230209164922082" /><p>当然，我们也可以手动修改这个值的大小：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">set</span> eq_range_index_dive_limit<span class="token operator">=</span><span class="token number">200</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个 <strong>eq_range_index_dive_limit</strong> 配置的作用就是：</p><p>当where语句in条件中参数个数小于这个值的时候，MySQL就采用<strong>索引潜水（Index dive）</strong>的方式预估扫描行数，非常准确。</p><p>当where语句in条件中参数个数大于等于这个值的时候，MySQL就采用另一种方式<strong>索引统计（Index statistics）</strong>预估扫描行数，误差较大。</p><p><strong>MySQL为什么要这么做呢？</strong></p><p>都用<strong>索引潜水（Index dive）</strong>的方式预估扫描行数，不好吗？</p><p>其实这是基于成本的考虑，<strong>索引潜水</strong>估算成本较高，适合小数据量。<strong>索引统计</strong>估算成本较低，适合大数据量。</p><p>一般情况下，我们的where语句的in条件的参数不会太多，适合使用<strong>索引潜水</strong>预估扫描行数。</p><p>建议还在使用<strong>MySQL5.7.3</strong>之前版本的同学们，手动修改一下<strong>索引潜水</strong>的配置参数，改成合适的数值。</p><p>如果你们项目中in条件最多有500个参数，就把配置参数改成501。</p><p>这样MySQL预估扫描行数更准确，可以选择更合适的索引。</p><hr><h2 id="performance-schema详解"><a href="#performance-schema详解" class="headerlink" title="performance schema详解"></a>performance schema详解</h2><h3 id="performance-schema的介绍"><a href="#performance-schema的介绍" class="headerlink" title="performance_schema的介绍"></a>performance_schema的介绍</h3><p>MySQL的performance schema 用于监控MySQL server在一个较低级别的运行过程中的资源消耗、资源等待等情况。</p><p>特点如下：</p><ul><li><p>提供了一种在数据库运行时实时检查server的内部执行情况的方法</p><ul><li><p>performance_schema 数据库中的表使用PERFORMANCE_SCHEMA存储引擎。</p></li><li><p>performance_schema 数据库主要关注数据库运行过程中的性能相关的数据</p></li><li><p>information_schema 数据库主要关注server运行过程中的元数据信息</p></li></ul></li><li><p>performance_schema 通过监视server的事件来实现监视server内部运行情况，</p><ul><li><p>“事件”：就是server内部活动中所做的任何事情以及对应的时间消耗（比如函数调用、操作系统的等待、SQL语句执行的阶段）</p></li><li><p>performance_schema中的事件与binlog中的记录的事件不同</p><ul><li>binlog中的事件是：描述数据修改的events</li><li>performance_schema中的事件是：计划调度程序（这是一种存储程序）的事件</li></ul></li><li><p>performance_schema中的事件记录的是：server执行某些活动对某些资源的消耗、耗时、这些活动执行的次数等情况。</p></li><li><p>performance_schema中的事件只记录在本地server的performance_schema中，不会被写入binlog中，也不会被复制到其他server中。</p></li><li><p>performance_schema的表中的数据不会持久化存储在磁盘中，而是保存在内存中，一旦服务器重启，这些数据会丢失</p></li></ul></li></ul><h3 id="performance-schema入门"><a href="#performance-schema入门" class="headerlink" title="performance schema入门"></a>performance schema入门</h3><p>在mysql的5.7版本中，性能模式是默认开启的，如果想要显式的关闭的话需要修改配置文件，不能直接进行修改，会报错Variable ‘performance_schema’ is a read only variable。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 查看performance_schema的属性</span>mysql<span class="token operator">></span> <span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'performance_schema'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------------------+-------+</span><span class="token operator">|</span> Variable_name      <span class="token operator">|</span> <span class="token keyword">Value</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------------+-------+</span><span class="token operator">|</span> performance_schema <span class="token operator">|</span> <span class="token keyword">ON</span>    <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------------+-------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span><span class="token comment">-- 在配置文件中修改performance_schema的属性值，on表示开启，off表示关闭</span><span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span>performance_schema<span class="token operator">=</span><span class="token keyword">ON</span><span class="token comment">-- 切换数据库</span><span class="token keyword">use</span> performance_schema<span class="token punctuation">;</span><span class="token comment">-- 查看当前数据库下的所有表,会看到有很多表存储着相关的信息</span><span class="token keyword">show</span> <span class="token keyword">tables</span><span class="token punctuation">;</span><span class="token comment">-- 可以通过show create table tablename来查看创建表的时候的表结构</span>mysql<span class="token operator">></span> <span class="token keyword">show</span> <span class="token keyword">create</span> <span class="token keyword">table</span> setup_consumers<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">-----------------+---------------------------------</span><span class="token operator">|</span> <span class="token keyword">Table</span>           <span class="token operator">|</span> <span class="token keyword">Create</span> <span class="token keyword">Table</span>                    <span class="token operator">+</span><span class="token comment">-----------------+---------------------------------</span><span class="token operator">|</span> setup_consumers <span class="token operator">|</span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>setup_consumers<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>NAME<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>                        <span class="token identifier"><span class="token punctuation">`</span>ENABLED<span class="token punctuation">`</span></span> <span class="token keyword">enum</span><span class="token punctuation">(</span><span class="token string">'YES'</span><span class="token punctuation">,</span><span class="token string">'NO'</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>               <span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span>PERFORMANCE_SCHEMA <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8 <span class="token operator">|</span>  <span class="token operator">+</span><span class="token comment">-----------------+---------------------------------</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>                             <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><p>想要搞明白后续的内容，同学们需要理解两个基本概念：</p><ul><li>instruments: 生产者，用于采集mysql中各种各样的操作产生的事件信息，对应配置表中的配置项我们可以称为监控采集配置项。</li><li>consumers: 消费者，对应的消费者表用于存储来自instruments采集的数据，对应配置表中的配置项我们可以称为消费存储配置项。</li></ul><h3 id="performance-schema表的分类"><a href="#performance-schema表的分类" class="headerlink" title="performance_schema表的分类"></a>performance_schema表的分类</h3><p>performance_schema库下的表可以按照监视纬度的不同进行分组。</p><h4 id="语句事件记录表"><a href="#语句事件记录表" class="headerlink" title="语句事件记录表"></a>语句事件记录表</h4><p>语句事件记录表，这些表记录了语句事件信息，当前语句事件表events_statements_current、历史语句事件表events_statements_history和长语句历史事件表events_statements_history_long、以及聚合后的摘要表summary，其中，summary表还可以根据帐号(account)，主机(host)，程序(program)，线程(thread)，用户(user)和全局(global)再进行细分)</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">tables</span> <span class="token operator">like</span> <span class="token string">'%statement%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="等待事件记录表"><a href="#等待事件记录表" class="headerlink" title="等待事件记录表"></a>等待事件记录表</h4><p>等待事件记录表，与语句事件类型的相关记录表类似：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">tables</span> <span class="token operator">like</span> <span class="token string">'%wait%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="阶段事件记录表"><a href="#阶段事件记录表" class="headerlink" title="阶段事件记录表"></a>阶段事件记录表</h4><p>阶段事件记录表，记录语句执行的阶段事件的表</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">tables</span> <span class="token operator">like</span> <span class="token string">'%stage%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="事务事件记录表"><a href="#事务事件记录表" class="headerlink" title="事务事件记录表"></a>事务事件记录表</h4><p>事务事件记录表，记录事务相关的事件的表</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">tables</span> <span class="token operator">like</span> <span class="token string">'%transaction%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="监控文件系统层调用的表"><a href="#监控文件系统层调用的表" class="headerlink" title="监控文件系统层调用的表"></a>监控文件系统层调用的表</h4><p>监控文件系统层调用的表</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">tables</span> <span class="token operator">like</span> <span class="token string">'%file%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="监视内存使用的表"><a href="#监视内存使用的表" class="headerlink" title="监视内存使用的表"></a>监视内存使用的表</h4><p>监视内存使用的表</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">tables</span> <span class="token operator">like</span> <span class="token string">'%memory%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="配置表"><a href="#配置表" class="headerlink" title="配置表"></a>配置表</h4><p>动态对performance_schema进行配置的配置表</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">tables</span> <span class="token operator">like</span> <span class="token string">'%setup%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="performance-schema的简单配置与使用"><a href="#performance-schema的简单配置与使用" class="headerlink" title="performance_schema的简单配置与使用"></a>performance_schema的简单配置与使用</h3><p>数据库刚刚初始化并启动时，并非所有instruments(事件采集项，在采集项的配置表中每一项都有一个开关字段，或为YES，或为NO)和consumers(与采集项类似，也有一个对应的事件类型保存表配置项，为YES就表示对应的表保存性能数据，为NO就表示对应的表不保存性能数据)都启用了，所以默认不会收集所有的事件，可能你需要检测的事件并没有打开，需要进行设置，可以使用如下两个语句打开对应的instruments和consumers（行计数可能会因MySQL版本而异)。</p><h4 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 打开等待事件的采集器配置项开关，需要修改setup_instruments配置表中对应的采集器配置项</span><span class="token keyword">UPDATE</span> setup_instruments <span class="token keyword">SET</span> ENABLED <span class="token operator">=</span> <span class="token string">'YES'</span><span class="token punctuation">,</span> TIMED <span class="token operator">=</span> <span class="token string">'YES'</span><span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">'wait%'</span><span class="token punctuation">;</span><span class="token comment">-- 打开等待事件的保存表配置开关，修改setup_consumers配置表中对应的配置项</span><span class="token keyword">UPDATE</span> setup_consumers <span class="token keyword">SET</span> ENABLED <span class="token operator">=</span> <span class="token string">'YES'</span><span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">'%wait%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查看当前server正在做什么"><a href="#查看当前server正在做什么" class="headerlink" title="查看当前server正在做什么"></a>查看当前server正在做什么</h4><p>当配置完成之后可以查看当前server正在做什么，可以通过查询events_waits_current表来得知，该表中每个线程只包含一行数据，用于显示每个线程的最新监视事件</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> events_waits_current\G<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">1.</span> <span class="token keyword">row</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>            THREAD_ID: <span class="token number">11</span>             EVENT_ID: <span class="token number">570</span>         END_EVENT_ID: <span class="token number">570</span>           EVENT_NAME: wait<span class="token operator">/</span>synch<span class="token operator">/</span>mutex<span class="token operator">/</span><span class="token keyword">innodb</span><span class="token operator">/</span>buf_dblwr_mutex               SOURCE:           TIMER_START: <span class="token number">4508505105239280</span>            TIMER_END: <span class="token number">4508505105270160</span>           TIMER_WAIT: <span class="token number">30880</span>                SPINS: <span class="token boolean">NULL</span>        OBJECT_SCHEMA: <span class="token boolean">NULL</span>          OBJECT_NAME: <span class="token boolean">NULL</span>           INDEX_NAME: <span class="token boolean">NULL</span>          OBJECT_TYPE: <span class="token boolean">NULL</span>OBJECT_INSTANCE_BEGIN: <span class="token number">67918392</span>     NESTING_EVENT_ID: <span class="token boolean">NULL</span>   NESTING_EVENT_TYPE: <span class="token boolean">NULL</span>            OPERATION: <span class="token keyword">lock</span>      NUMBER_OF_BYTES: <span class="token boolean">NULL</span>                FLAGS: <span class="token boolean">NULL</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该信息表示线程id为11的线程正在等待buf_dblwr_mutex锁，等待事件为30880<br>属性说明：</p><ul><li>id:事件来自哪个线程，事件编号是多少</li><li>event_name:表示检测到的具体的内容</li><li>source:表示这个检测代码在哪个源文件中以及行号</li><li>timer_start:表示该事件的开始时间</li><li>timer_end:表示该事件的结束时间</li><li>timer_wait:表示该事件总的花费时间</li></ul><p>注意：_current表中每个线程只保留一条记录，一旦线程完成工作，该表中不会再记录该线程的事件信息</p><h4 id="查看每个线程已经执行完成的事件信息"><a href="#查看每个线程已经执行完成的事件信息" class="headerlink" title="查看每个线程已经执行完成的事件信息"></a>查看每个线程已经执行完成的事件信息</h4><p>_history表中记录每个线程应该执行完成的事件信息，但每个线程的事件信息只会记录10条，再多就会被覆盖，*_history_long表中记录所有线程的事件信息，但总记录数量是10000，超过就会被覆盖掉</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> thread_id<span class="token punctuation">,</span>event_id<span class="token punctuation">,</span>event_name<span class="token punctuation">,</span>timer_wait <span class="token keyword">from</span> events_waits_history <span class="token keyword">order</span> <span class="token keyword">by</span> thread_id <span class="token keyword">limit</span> <span class="token number">21</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="查看事件的汇总信息"><a href="#查看事件的汇总信息" class="headerlink" title="查看事件的汇总信息"></a>查看事件的汇总信息</h4><p>summary表提供所有事件的汇总信息，该组中的表以不同的方式汇总事件数据（如：按用户，按主机，按线程等等）。例如：要查看哪些instruments占用最多的时间，可以通过对events_waits_summary_global_by_event_name表的COUNT_STAR或SUM_TIMER_WAIT列进行查询（这两列是对事件的记录数执行COUNT（*）、事件记录的TIMER_WAIT列执行SUM（TIMER_WAIT）统计而来）</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> EVENT_NAME<span class="token punctuation">,</span>COUNT_STAR <span class="token keyword">FROM</span> events_waits_summary_global_by_event_name  <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> COUNT_STAR <span class="token keyword">DESC</span> <span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="查看被检测的对象"><a href="#查看被检测的对象" class="headerlink" title="查看被检测的对象"></a>查看被检测的对象</h4><p>instance表记录了哪些类型的对象会被检测。这些对象在被server使用时，在该表中将会产生一条事件记录，例如，file_instances表列出了文件I&#x2F;O操作及其关联文件名</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> file_instances <span class="token keyword">limit</span> <span class="token number">20</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="常用配置项的参数说明"><a href="#常用配置项的参数说明" class="headerlink" title="常用配置项的参数说明"></a>常用配置项的参数说明</h3><h4 id="启动选项"><a href="#启动选项" class="headerlink" title="启动选项"></a>启动选项</h4><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>performance_schema_consumer_events_statements_current&#x3D;TRUE</td><td>是否在mysql server启动时就开启events_statements_current表的记录功能(该表记录当前的语句事件信息)，启动之后也可以在setup_consumers表中使用UPDATE语句进行动态更新setup_consumers配置表中的events_statements_current配置项，默认值为TRUE</td></tr><tr><td>performance_schema_consumer_events_statements_history&#x3D;TRUE</td><td>与performance_schema_consumer_events_statements_current选项类似，但该选项是用于配置是否记录语句事件短历史信息，默认为TRUE</td></tr><tr><td>performance_schema_consumer_events_stages_history_long&#x3D;FALSE</td><td>与performance_schema_consumer_events_statements_current选项类似，但该选项是用于配置是否记录语句事件长历史信息，默认为FALSE</td></tr><tr><td>*</td><td>除了statement(语句)事件之外，还支持：wait(等待)事件、state(阶段)事件、transaction(事务)事件，他们与statement事件一样都有三个启动项分别进行配置，但这些等待事件默认未启用，如果需要在MySQL Server启动时一同启动，则通常需要写进my.cnf配置文件中</td></tr><tr><td>performance_schema_consumer_global_instrumentation&#x3D;TRUE</td><td>是否在MySQL Server启动时就开启全局表（如：mutex_instances、rwlock_instances、cond_instances、file_instances、users、hostsaccounts、socket_summary_by_event_name、file_summary_by_instance等大部分的全局对象计数统计和事件汇总统计信息表 ）的记录功能，启动之后也可以在setup_consumers表中使用UPDATE语句进行动态更新全局配置项<br/>默认值为TRUE</td></tr><tr><td>performance_schema_consumer_statements_digest&#x3D;TRUE</td><td>是否在MySQL Server启动时就开启events_statements_summary_by_digest 表的记录功能，启动之后也可以在setup_consumers表中使用UPDATE语句进行动态更新digest配置项<br/>默认值为TRUE</td></tr><tr><td>performance_schema_consumer_thread_instrumentation&#x3D;TRUE</td><td>是否在MySQL Server启动时就开启events_xxx_summary_by_yyy_by_event_name表的记录功能，启动之后也可以在setup_consumers表中使用UPDATE语句进行动态更新线程配置项<br/>默认值为TRUE</td></tr><tr><td>performance_schema_instrument[&#x3D;name]</td><td>是否在MySQL Server启动时就启用某些采集器，由于instruments配置项多达数千个，所以该配置项支持key-value模式，还支持%号进行通配等</td></tr></tbody></table><p>注意，这些启动选项要生效的前提是，需要设置performance_schema&#x3D;ON。另外，这些启动选项虽然无法使用show variables语句查看，但我们可以通过setup_instruments和setup_consumers表查询这些选项指定的值。</p><h4 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'%performance_schema%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重要的属性解释</p><table><thead><tr><th>属性</th><th>解释</th></tr></thead><tbody><tr><td>performance_schema&#x3D;ON</td><td>控制performance_schema功能的开关，要使用MySQL的performance_schema，需要在mysqld启动时启用，以启用事件收集功能<br/>该参数在5.7.x之前支持performance_schema的版本中默认关闭，5.7.x版本开始默认开启<br/>注意：如果mysqld在初始化performance_schema时发现无法分配任何相关的内部缓冲区，则performance_schema将自动禁用，并将performance_schema设置为OFF</td></tr><tr><td>performance_schema_digests_size&#x3D;10000</td><td>控制events_statements_summary_by_digest表中的最大行数。如果产生的语句摘要信息超过此最大值，便无法继续存入该表，此时performance_schema会增加状态变量</td></tr><tr><td>performance_schema_events_statements_history_long_size&#x3D;10000</td><td>控制events_statements_history_long表中的最大行数，该参数控制所有会话在events_statements_history_long表中能够存放的总事件记录数，超过这个限制之后，最早的记录将被覆盖</td></tr><tr><td>performance_schema_events_statements_history_size&#x3D;10</td><td>控制events_statements_history表中单个线程（会话）的最大行数，该参数控制单个会话在events_statements_history表中能够存放的事件记录数，超过这个限制之后，单个会话最早的记录将被覆盖</td></tr><tr><td>performance_schema_max_digest_length&#x3D;1024</td><td>用于控制标准化形式的SQL语句文本在存入performance_schema时的限制长度，该变量与max_digest_length变量相关(max_digest_length变量含义请自行查阅相关资料)<br/>全局变量，只读变量，默认值1024字节，整型值，取值范围0~1048576</td></tr><tr><td>performance_schema_max_sql_text_length&#x3D;1024</td><td>控制存入events_statements_current，events_statements_history和events_statements_history_long语句事件表中的SQL_TEXT列的最大SQL长度字节数。 超出系统变量performance_schema_max_sql_text_length的部分将被丢弃，不会记录，一般情况下不需要调整该参数，除非被截断的部分与其他SQL比起来有很大差异<br/>全局变量，只读变量，整型值，默认值为1024字节，取值范围为0~1048576，5.7.6版本引入<br/>降低系统变量performance_schema_max_sql_text_length值可以减少内存使用，但如果汇总的SQL中，被截断部分有较大差异，会导致没有办法再对这些有较大差异的SQL进行区分。 增加该系统变量值会增加内存使用，但对于汇总SQL来讲可以更精准地区分不同的部分。</td></tr></tbody></table><h3 id="重要配置表的相关说明"><a href="#重要配置表的相关说明" class="headerlink" title="重要配置表的相关说明"></a>重要配置表的相关说明</h3><p>配置表之间存在相互关联关系</p><h4 id="performance-timers表"><a href="#performance-timers表" class="headerlink" title="performance_timers表"></a>performance_timers表</h4><p>performance_timers表中记录了server中有哪些可用的事件计时器</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> performance_timers<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>timer_name</td><td>表示可用计时器名称，CYCLE是基于CPU周期计数器的定时器</td></tr><tr><td>timer_frequency</td><td>表示每秒钟对应的计时器单位的数量,CYCLE计时器的换算值与CPU的频率相关</td></tr><tr><td>timer_resolution</td><td>计时器精度值，表示在每个计时器被调用时额外增加的值</td></tr><tr><td>timer_overhead</td><td>表示在使用定时器获取事件时开销的最小周期值</td></tr></tbody></table><h4 id="setup-timers表"><a href="#setup-timers表" class="headerlink" title="setup_timers表"></a>setup_timers表</h4><p>setup_timers表中记录当前使用的事件计时器信息</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> setup_timers<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>name</td><td>计时器类型，对应某个事件类别</td></tr><tr><td>timer_name</td><td>计时器类型名称</td></tr></tbody></table><h4 id="setup-consumers表"><a href="#setup-consumers表" class="headerlink" title="setup_consumers表"></a>setup_consumers表</h4><p>setup_consumers表中列出了consumers可配置列表项</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> setup_consumers<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>NAME</td><td>consumers配置名称</td></tr><tr><td>ENABLED</td><td>consumers是否启用，有效值为YES或NO，此列可以使用UPDATE语句修改。</td></tr></tbody></table><h4 id="setup-instruments-表"><a href="#setup-instruments-表" class="headerlink" title="setup_instruments 表"></a>setup_instruments 表</h4><p>setup_instruments 表列出了instruments 列表配置项，即代表了哪些事件支持被收集：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> setup_instruments<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>NAME</td><td>instruments名称，instruments名称可能具有多个部分并形成层次结构</td></tr><tr><td>ENABLED</td><td>instrumetns是否启用，有效值为YES或NO，此列可以使用UPDATE语句修改。如果设置为NO，则这个instruments不会被执行，不会产生任何的事件信息</td></tr><tr><td>TIMED</td><td>instruments是否收集时间信息，有效值为YES或NO，此列可以使用UPDATE语句修改，如果设置为NO，则这个instruments不会收集时间信息</td></tr></tbody></table><h4 id="setup-actors表"><a href="#setup-actors表" class="headerlink" title="setup_actors表"></a>setup_actors表</h4><p>setup_actors表的初始内容是匹配任何用户和主机，因此对于所有前台线程，默认情况下启用监视和历史事件收集功能</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> setup_actors<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>HOST</td><td>与grant语句类似的主机名，一个具体的字符串名字，或使用“％”表示“任何主机”</td></tr><tr><td>USER</td><td>一个具体的字符串名称，或使用“％”表示“任何用户”</td></tr><tr><td>ROLE</td><td>当前未使用，MySQL 8.0中才启用角色功能</td></tr><tr><td>ENABLED</td><td>是否启用与HOST，USER，ROLE匹配的前台线程的监控功能，有效值为：YES或NO</td></tr><tr><td>HISTORY</td><td>是否启用与HOST， USER，ROLE匹配的前台线程的历史事件记录功能，有效值为：YES或NO</td></tr></tbody></table><h4 id="setup-objects表"><a href="#setup-objects表" class="headerlink" title="setup_objects表"></a>setup_objects表</h4><p>setup_objects表控制performance_schema是否监视特定对象。默认情况下，此表的最大行数为100行。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> setup_objects<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>OBJECT_TYPE</td><td>instruments类型，有效值为：“EVENT”（事件调度器事件）、“FUNCTION”（存储函数）、“PROCEDURE”（存储过程）、“TABLE”（基表）、“TRIGGER”（触发器），TABLE对象类型的配置会影响表I&#x2F;O事件（wait&#x2F;io&#x2F;table&#x2F;sql&#x2F;handler instrument）和表锁事件（wait&#x2F;lock&#x2F;table&#x2F;sql&#x2F;handler instrument）的收集</td></tr><tr><td>OBJECT_SCHEMA</td><td>某个监视类型对象涵盖的数据库名称，一个字符串名称，或“％”(表示“任何数据库”)</td></tr><tr><td>OBJECT_NAME</td><td>某个监视类型对象涵盖的表名，一个字符串名称，或“％”(表示“任何数据库内的对象”)</td></tr><tr><td>ENABLED</td><td>是否开启对某个类型对象的监视功能，有效值为：YES或NO。此列可以修改</td></tr><tr><td>TIMED</td><td></td></tr></tbody></table><h4 id="threads表"><a href="#threads表" class="headerlink" title="threads表"></a>threads表</h4><p>threads表对于每个server线程生成一行包含线程相关的信息，</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> threads<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>THREAD_ID</td><td>线程的唯一标识符（ID）</td></tr><tr><td>NAME</td><td>与server中的线程检测代码相关联的名称(注意，这里不是instruments名称)</td></tr><tr><td>TYPE</td><td>线程类型，有效值为：FOREGROUND、BACKGROUND。分别表示前台线程和后台线程</td></tr><tr><td>PROCESSLIST_ID</td><td>对应INFORMATION_SCHEMA.PROCESSLIST表中的ID列</td></tr><tr><td>PROCESSLIST_USER</td><td>与前台线程相关联的用户名，对于后台线程为NULL</td></tr><tr><td>PROCESSLIST_HOST</td><td>与前台线程关联的客户端的主机名，对于后台线程为NULL</td></tr><tr><td>PROCESSLIST_DB</td><td>线程的默认数据库，如果没有，则为NULL</td></tr><tr><td>PROCESSLIST_COMMAND</td><td>对于前台线程，该值代表着当前客户端正在执行的command类型，如果是sleep则表示当前会话处于空闲状态</td></tr><tr><td>PROCESSLIST_TIME</td><td>当前线程已处于当前线程状态的持续时间（秒）</td></tr><tr><td>PROCESSLIST_STATE</td><td>表示线程正在做什么事情</td></tr><tr><td>PROCESSLIST_INFO</td><td>线程正在执行的语句，如果没有执行任何语句，则为NULL</td></tr><tr><td>PARENT_THREAD_ID</td><td>如果这个线程是一个子线程（由另一个线程生成），那么该字段显示其父线程ID</td></tr><tr><td>ROLE</td><td>暂未使用</td></tr><tr><td>INSTRUMENTED</td><td>线程执行的事件是否被检测。有效值：YES、NO</td></tr><tr><td>HISTORY</td><td>是否记录线程的历史事件。有效值：YES、NO</td></tr><tr><td>THREAD_OS_ID</td><td>由操作系统层定义的线程或任务标识符（ID）</td></tr></tbody></table><p>注意：在performance_schema库中还包含了很多其他的库和表，能对数据库的性能做完整的监控，大家需要参考官网详细了解。</p><h3 id="performance-schema实践操作"><a href="#performance-schema实践操作" class="headerlink" title="performance_schema实践操作"></a>performance_schema实践操作</h3><p>基本了解了表的相关信息之后，可以通过这些表进行实际的查询操作来进行实际的分析。</p><h4 id="哪类的SQL执行最多？"><a href="#哪类的SQL执行最多？" class="headerlink" title="哪类的SQL执行最多？"></a>哪类的SQL执行最多？</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> DIGEST_TEXT<span class="token punctuation">,</span>COUNT_STAR<span class="token punctuation">,</span>FIRST_SEEN<span class="token punctuation">,</span>LAST_SEEN <span class="token keyword">FROM</span> events_statements_summary_by_digest <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> COUNT_STAR <span class="token keyword">DESC</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="哪类SQL的平均响应时间最多？"><a href="#哪类SQL的平均响应时间最多？" class="headerlink" title="哪类SQL的平均响应时间最多？"></a>哪类SQL的平均响应时间最多？</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> DIGEST_TEXT<span class="token punctuation">,</span>AVG_TIMER_WAIT <span class="token keyword">FROM</span> events_statements_summary_by_digest <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> COUNT_STAR <span class="token keyword">DESC</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="哪类SQL排序记录数最多？"><a href="#哪类SQL排序记录数最多？" class="headerlink" title="哪类SQL排序记录数最多？"></a>哪类SQL排序记录数最多？</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> DIGEST_TEXT<span class="token punctuation">,</span>SUM_SORT_ROWS <span class="token keyword">FROM</span> events_statements_summary_by_digest <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> COUNT_STAR <span class="token keyword">DESC</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="哪类SQL扫描记录数最多？"><a href="#哪类SQL扫描记录数最多？" class="headerlink" title="哪类SQL扫描记录数最多？"></a>哪类SQL扫描记录数最多？</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> DIGEST_TEXT<span class="token punctuation">,</span>SUM_ROWS_EXAMINED <span class="token keyword">FROM</span> events_statements_summary_by_digest <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> COUNT_STAR <span class="token keyword">DESC</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="哪类SQL使用临时表最多？"><a href="#哪类SQL使用临时表最多？" class="headerlink" title="哪类SQL使用临时表最多？"></a>哪类SQL使用临时表最多？</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> DIGEST_TEXT<span class="token punctuation">,</span>SUM_CREATED_TMP_TABLES<span class="token punctuation">,</span>SUM_CREATED_TMP_DISK_TABLES <span class="token keyword">FROM</span> events_statements_summary_by_digest <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> COUNT_STAR <span class="token keyword">DESC</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="哪类SQL返回结果集最多？"><a href="#哪类SQL返回结果集最多？" class="headerlink" title="哪类SQL返回结果集最多？"></a>哪类SQL返回结果集最多？</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> DIGEST_TEXT<span class="token punctuation">,</span>SUM_ROWS_SENT <span class="token keyword">FROM</span> events_statements_summary_by_digest <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> COUNT_STAR <span class="token keyword">DESC</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="哪个表物理IO最多？"><a href="#哪个表物理IO最多？" class="headerlink" title="哪个表物理IO最多？"></a>哪个表物理IO最多？</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> file_name<span class="token punctuation">,</span>event_name<span class="token punctuation">,</span>SUM_NUMBER_OF_BYTES_READ<span class="token punctuation">,</span>SUM_NUMBER_OF_BYTES_WRITE <span class="token keyword">FROM</span> file_summary_by_instance <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> SUM_NUMBER_OF_BYTES_READ <span class="token operator">+</span> SUM_NUMBER_OF_BYTES_WRITE <span class="token keyword">DESC</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="哪个表逻辑IO最多？"><a href="#哪个表逻辑IO最多？" class="headerlink" title="哪个表逻辑IO最多？"></a>哪个表逻辑IO最多？</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> object_name<span class="token punctuation">,</span>COUNT_READ<span class="token punctuation">,</span>COUNT_WRITE<span class="token punctuation">,</span>COUNT_FETCH<span class="token punctuation">,</span>SUM_TIMER_WAIT <span class="token keyword">FROM</span> table_io_waits_summary_by_table <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> sum_timer_wait <span class="token keyword">DESC</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="哪个索引访问最多？"><a href="#哪个索引访问最多？" class="headerlink" title="哪个索引访问最多？"></a>哪个索引访问最多？</h5><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> OBJECT_NAME<span class="token punctuation">,</span>INDEX_NAME<span class="token punctuation">,</span>COUNT_FETCH<span class="token punctuation">,</span>COUNT_INSERT<span class="token punctuation">,</span>COUNT_UPDATE<span class="token punctuation">,</span>COUNT_DELETE <span class="token keyword">FROM</span> table_io_waits_summary_by_index_usage <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> SUM_TIMER_WAIT <span class="token keyword">DESC</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="哪个索引从来没有用过？"><a href="#哪个索引从来没有用过？" class="headerlink" title="哪个索引从来没有用过？"></a>哪个索引从来没有用过？</h5><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> OBJECT_SCHEMA<span class="token punctuation">,</span>OBJECT_NAME<span class="token punctuation">,</span>INDEX_NAME <span class="token keyword">FROM</span> table_io_waits_summary_by_index_usage <span class="token keyword">WHERE</span> INDEX_NAME <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token operator">AND</span> COUNT_STAR <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">AND</span> OBJECT_SCHEMA <span class="token operator">&lt;></span> <span class="token string">'mysql'</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> OBJECT_SCHEMA<span class="token punctuation">,</span>OBJECT_NAME<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="哪个等待事件消耗时间最多？"><a href="#哪个等待事件消耗时间最多？" class="headerlink" title="哪个等待事件消耗时间最多？"></a>哪个等待事件消耗时间最多？</h5><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> EVENT_NAME<span class="token punctuation">,</span>COUNT_STAR<span class="token punctuation">,</span>SUM_TIMER_WAIT<span class="token punctuation">,</span>AVG_TIMER_WAIT <span class="token keyword">FROM</span> events_waits_summary_global_by_event_name <span class="token keyword">WHERE</span> event_name <span class="token operator">!=</span> <span class="token string">'idle'</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> SUM_TIMER_WAIT <span class="token keyword">DESC</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="剖析某条SQL的执行情况，包括statement信息，stege信息，wait信息"><a href="#剖析某条SQL的执行情况，包括statement信息，stege信息，wait信息" class="headerlink" title="剖析某条SQL的执行情况，包括statement信息，stege信息，wait信息"></a>剖析某条SQL的执行情况，包括statement信息，stege信息，wait信息</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> EVENT_ID<span class="token punctuation">,</span>sql_text <span class="token keyword">FROM</span> events_statements_history <span class="token keyword">WHERE</span> sql_text <span class="token operator">LIKE</span> <span class="token string">'%count(*)%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="查看每个阶段的时间消耗"><a href="#查看每个阶段的时间消耗" class="headerlink" title="查看每个阶段的时间消耗"></a>查看每个阶段的时间消耗</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> event_id<span class="token punctuation">,</span>EVENT_NAME<span class="token punctuation">,</span>SOURCE<span class="token punctuation">,</span>TIMER_END <span class="token operator">-</span> TIMER_START <span class="token keyword">FROM</span> events_stages_history_long <span class="token keyword">WHERE</span> NESTING_EVENT_ID <span class="token operator">=</span> <span class="token number">1553</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="查看每个阶段的锁等待情况"><a href="#查看每个阶段的锁等待情况" class="headerlink" title="查看每个阶段的锁等待情况"></a>查看每个阶段的锁等待情况</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> event_id<span class="token punctuation">,</span>event_name<span class="token punctuation">,</span>source<span class="token punctuation">,</span>timer_wait<span class="token punctuation">,</span>object_name<span class="token punctuation">,</span>index_name<span class="token punctuation">,</span>operation<span class="token punctuation">,</span>nesting_event_id <span class="token keyword">FROM</span> events_waits_history_long <span class="token keyword">WHERE</span> nesting_event_id <span class="token operator">=</span> <span class="token number">1553</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="看懂mysql执行计划"><a href="#看懂mysql执行计划" class="headerlink" title="看懂mysql执行计划"></a>看懂mysql执行计划</h2><p>​       在企业的应用场景中，为了知道优化SQL语句的执行，需要查看SQL语句的具体执行过程，以加快SQL语句的执行效率。</p><p>​       可以使用explain+SQL语句来模拟优化器执行SQL查询语句，从而知道mysql是如何处理sql语句的。</p><p>​   官网地址： <a href="https://dev.mysql.com/doc/refman/5.5/en/explain-output.html">https://dev.mysql.com/doc/refman/5.5/en/explain-output.html</a> </p><h3 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">/*Navicat MySQL Data TransferSource Server         : mybatisSource Server Version : 50722Source Host           : localhost:3306Source Database       : dempTarget Server Type    : MYSQLTarget Server Version : 50722File Encoding         : 65001Date: 2020-02-11 20:05:02*/</span><span class="token keyword">SET</span> FOREIGN_KEY_CHECKS<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">-- ----------------------------</span><span class="token comment">-- Table structure for dept</span><span class="token comment">-- ----------------------------</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token identifier"><span class="token punctuation">`</span>dept<span class="token punctuation">`</span></span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>dept<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>DEPTNO<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>DNAME<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>LOC<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>DEPTNO<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span class="token comment">-- ----------------------------</span><span class="token comment">-- Records of dept</span><span class="token comment">-- ----------------------------</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>dept<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'10'</span><span class="token punctuation">,</span> <span class="token string">'ACCOUNTING'</span><span class="token punctuation">,</span> <span class="token string">'NEW YORK'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>dept<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'20'</span><span class="token punctuation">,</span> <span class="token string">'RESEARCH'</span><span class="token punctuation">,</span> <span class="token string">'DALLAS'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>dept<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'30'</span><span class="token punctuation">,</span> <span class="token string">'SALES'</span><span class="token punctuation">,</span> <span class="token string">'CHICAGO'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>dept<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'40'</span><span class="token punctuation">,</span> <span class="token string">'OPERATIONS'</span><span class="token punctuation">,</span> <span class="token string">'BOSTON'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- ----------------------------</span><span class="token comment">-- Table structure for emp</span><span class="token comment">-- ----------------------------</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token identifier"><span class="token punctuation">`</span>emp<span class="token punctuation">`</span></span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>emp<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>EMPNO<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>ENAME<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>JOB<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>MGR<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>HIREDATE<span class="token punctuation">`</span></span> <span class="token keyword">date</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>SAL<span class="token punctuation">`</span></span> <span class="token keyword">double</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>COMM<span class="token punctuation">`</span></span> <span class="token keyword">double</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>DEPTNO<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>EMPNO<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span class="token comment">-- ----------------------------</span><span class="token comment">-- Records of emp</span><span class="token comment">-- ----------------------------</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>emp<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'7369'</span><span class="token punctuation">,</span> <span class="token string">'SMITH'</span><span class="token punctuation">,</span> <span class="token string">'CLERK'</span><span class="token punctuation">,</span> <span class="token string">'7902'</span><span class="token punctuation">,</span> <span class="token string">'1980-12-17'</span><span class="token punctuation">,</span> <span class="token string">'800.00'</span><span class="token punctuation">,</span> <span class="token boolean">null</span><span class="token punctuation">,</span> <span class="token string">'20'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>emp<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'7499'</span><span class="token punctuation">,</span> <span class="token string">'ALLEN'</span><span class="token punctuation">,</span> <span class="token string">'SALESMAN'</span><span class="token punctuation">,</span> <span class="token string">'7698'</span><span class="token punctuation">,</span> <span class="token string">'1981-02-20'</span><span class="token punctuation">,</span> <span class="token string">'1600.00'</span><span class="token punctuation">,</span> <span class="token string">'300.00'</span><span class="token punctuation">,</span> <span class="token string">'30'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>emp<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'7521'</span><span class="token punctuation">,</span> <span class="token string">'WARD'</span><span class="token punctuation">,</span> <span class="token string">'SALESMAN'</span><span class="token punctuation">,</span> <span class="token string">'7698'</span><span class="token punctuation">,</span> <span class="token string">'1981-02-22'</span><span class="token punctuation">,</span> <span class="token string">'1250.00'</span><span class="token punctuation">,</span> <span class="token string">'500.00'</span><span class="token punctuation">,</span> <span class="token string">'30'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>emp<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'7566'</span><span class="token punctuation">,</span> <span class="token string">'JONES'</span><span class="token punctuation">,</span> <span class="token string">'MANAGER'</span><span class="token punctuation">,</span> <span class="token string">'7839'</span><span class="token punctuation">,</span> <span class="token string">'1981-02-02'</span><span class="token punctuation">,</span> <span class="token string">'2975.00'</span><span class="token punctuation">,</span> <span class="token boolean">null</span><span class="token punctuation">,</span> <span class="token string">'20'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>emp<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'7654'</span><span class="token punctuation">,</span> <span class="token string">'MARTIN'</span><span class="token punctuation">,</span> <span class="token string">'SALESMAN'</span><span class="token punctuation">,</span> <span class="token string">'7698'</span><span class="token punctuation">,</span> <span class="token string">'1981-09-28'</span><span class="token punctuation">,</span> <span class="token string">'1250.00'</span><span class="token punctuation">,</span> <span class="token string">'1400.00'</span><span class="token punctuation">,</span> <span class="token string">'30'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>emp<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'7698'</span><span class="token punctuation">,</span> <span class="token string">'BLAKE'</span><span class="token punctuation">,</span> <span class="token string">'MANAGER'</span><span class="token punctuation">,</span> <span class="token string">'7839'</span><span class="token punctuation">,</span> <span class="token string">'1981-01-05'</span><span class="token punctuation">,</span> <span class="token string">'2850.00'</span><span class="token punctuation">,</span> <span class="token boolean">null</span><span class="token punctuation">,</span> <span class="token string">'30'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>emp<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'7782'</span><span class="token punctuation">,</span> <span class="token string">'CLARK'</span><span class="token punctuation">,</span> <span class="token string">'MANAGER'</span><span class="token punctuation">,</span> <span class="token string">'7839'</span><span class="token punctuation">,</span> <span class="token string">'1981-09-06'</span><span class="token punctuation">,</span> <span class="token string">'2450.00'</span><span class="token punctuation">,</span> <span class="token boolean">null</span><span class="token punctuation">,</span> <span class="token string">'10'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>emp<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'7839'</span><span class="token punctuation">,</span> <span class="token string">'KING'</span><span class="token punctuation">,</span> <span class="token string">'PRESIDENT'</span><span class="token punctuation">,</span> <span class="token boolean">null</span><span class="token punctuation">,</span> <span class="token string">'1981-11-17'</span><span class="token punctuation">,</span> <span class="token string">'5000.00'</span><span class="token punctuation">,</span> <span class="token boolean">null</span><span class="token punctuation">,</span> <span class="token string">'10'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>emp<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'7844'</span><span class="token punctuation">,</span> <span class="token string">'TURNER'</span><span class="token punctuation">,</span> <span class="token string">'SALESMAN'</span><span class="token punctuation">,</span> <span class="token string">'7698'</span><span class="token punctuation">,</span> <span class="token string">'1981-09-08'</span><span class="token punctuation">,</span> <span class="token string">'1500.00'</span><span class="token punctuation">,</span> <span class="token string">'0.00'</span><span class="token punctuation">,</span> <span class="token string">'30'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>emp<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'7900'</span><span class="token punctuation">,</span> <span class="token string">'JAMES'</span><span class="token punctuation">,</span> <span class="token string">'CLERK'</span><span class="token punctuation">,</span> <span class="token string">'7698'</span><span class="token punctuation">,</span> <span class="token string">'1981-12-03'</span><span class="token punctuation">,</span> <span class="token string">'950.00'</span><span class="token punctuation">,</span> <span class="token boolean">null</span><span class="token punctuation">,</span> <span class="token string">'30'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>emp<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'7902'</span><span class="token punctuation">,</span> <span class="token string">'FORD'</span><span class="token punctuation">,</span> <span class="token string">'ANALYST'</span><span class="token punctuation">,</span> <span class="token string">'7566'</span><span class="token punctuation">,</span> <span class="token string">'1981-12-03'</span><span class="token punctuation">,</span> <span class="token string">'3000.00'</span><span class="token punctuation">,</span> <span class="token boolean">null</span><span class="token punctuation">,</span> <span class="token string">'20'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>emp<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'7934'</span><span class="token punctuation">,</span> <span class="token string">'MILLER'</span><span class="token punctuation">,</span> <span class="token string">'CLERK'</span><span class="token punctuation">,</span> <span class="token string">'7782'</span><span class="token punctuation">,</span> <span class="token string">'1982-01-23'</span><span class="token punctuation">,</span> <span class="token string">'1300.00'</span><span class="token punctuation">,</span> <span class="token boolean">null</span><span class="token punctuation">,</span> <span class="token string">'10'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- ----------------------------</span><span class="token comment">-- Table structure for salgrade</span><span class="token comment">-- ----------------------------</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token identifier"><span class="token punctuation">`</span>salgrade<span class="token punctuation">`</span></span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>salgrade<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>GRADE<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>LOSAL<span class="token punctuation">`</span></span> <span class="token keyword">double</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>HISAL<span class="token punctuation">`</span></span> <span class="token keyword">double</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>GRADE<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span class="token comment">-- ----------------------------</span><span class="token comment">-- Records of salgrade</span><span class="token comment">-- ----------------------------</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>salgrade<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'700'</span><span class="token punctuation">,</span> <span class="token string">'1200'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>salgrade<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'1201'</span><span class="token punctuation">,</span> <span class="token string">'1400'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>salgrade<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'1401'</span><span class="token punctuation">,</span> <span class="token string">'2000'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>salgrade<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'4'</span><span class="token punctuation">,</span> <span class="token string">'2001'</span><span class="token punctuation">,</span> <span class="token string">'3000'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>salgrade<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'5'</span><span class="token punctuation">,</span> <span class="token string">'3001'</span><span class="token punctuation">,</span> <span class="token string">'9999'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="执行计划中包含的信息"><a href="#执行计划中包含的信息" class="headerlink" title="执行计划中包含的信息"></a>执行计划中包含的信息</h3><table><thead><tr><th align="center">列</th><th>含义</th></tr></thead><tbody><tr><td align="center">id</td><td>select查询的序列号</td></tr><tr><td align="center">select_type</td><td>查询的类型，是普通查询还是联合查询还是子查询</td></tr><tr><td align="center">table</td><td>对应行正在访问哪一个表，表名或者别名，可能是临时表或者union合并结果集</td></tr><tr><td align="center">partitions</td><td>表示当前查询访问的分区，如果是NULL，表示当前不是分区表</td></tr><tr><td align="center">type</td><td>type显示的是访问类型，访问类型表示我是以何种方式去访问我们的数据，最容易想的是全表扫描</td></tr><tr><td align="center">possible_keys</td><td>显示当前查询语句可能会被使用的索引，一个或多个，但不一定被查询实际使用</td></tr><tr><td align="center">key</td><td>实际使用的索引，如果为null，则没有使用索引</td></tr><tr><td align="center">key_len</td><td>表示索引中使用的字节数，可以通过key_len计算查询中使用的索引长度，在不损失精度的情况下长度越短越好</td></tr><tr><td align="center">ref</td><td>显示索引的哪一列被使用了，如果可能的话，是一个常数</td></tr><tr><td align="center">rows</td><td>根据表的统计信息及索引使用情况，大致估算出找出所需记录需要读取的行数</td></tr><tr><td align="center">filtered</td><td>某个表经过搜索条件过滤后剩余记录条数的百分比，rows 乘以 filtered 的结果表示要与下表连接的行数</td></tr><tr><td align="center">extra</td><td>额外的信息</td></tr></tbody></table><h4 id="id"><a href="#id" class="headerlink" title="id"></a><strong>id</strong></h4><p>select查询的序列号，包含一组数字，表示查询中执行select子句或者操作表的顺序</p><p>id号分为三种情况：</p><ul><li>如果id相同，那么执行顺序从上到下</li><li>如果id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li><li>同时存在id相同和不同的：相同的可以认为是一组，从上往下顺序执行，在所有组中，id值越大，优先级越高，越先执行</li></ul><h4 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a><strong>select_type</strong></h4><p>主要用来分辨查询的类型，是普通查询还是联合查询还是子查询</p><ul><li><code>sample</code>：简单的查询，不包含子查询和union</li><li><code>primary</code>：查询中若包含任何复杂的子查询，最外层查询则被标记为Primary</li><li><code>union</code>：若第二个select出现在union之后，则被标记为union</li><li><code>dependent union</code> ： 跟union类似，此处的depentent表示union或union all联合而成的结果会受外部表影响</li><li><code>union result</code>：从union表获取结果的select</li><li><code>subquery</code>：在select或者where列表中包含子查询</li><li><code>dependent subquery</code>：subquery的子查询要受到外部表查询的影响</li><li><code>derived</code>：from子句中出现的子查询</li><li><code>uncacheable subquery</code>：表示使用子查询的结果不能被缓存</li><li><code>uncacheable union</code>：表示union的查询结果不能被缓存：sql语句未验证</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- sample:简单的查询，不包含子查询和union</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp<span class="token punctuation">;</span><span class="token comment">-- primary:查询中若包含任何复杂的子查询，最外层查询则被标记为Primary</span><span class="token keyword">explain</span> <span class="token keyword">select</span> staname<span class="token punctuation">,</span>ename supname <span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">select</span> ename staname<span class="token punctuation">,</span>mgr <span class="token keyword">from</span> emp<span class="token punctuation">)</span> t <span class="token keyword">join</span> emp <span class="token keyword">on</span> t<span class="token punctuation">.</span>mgr<span class="token operator">=</span>emp<span class="token punctuation">.</span>empno <span class="token punctuation">;</span><span class="token comment">-- union:若第二个select出现在union之后，则被标记为union</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> deptno <span class="token operator">=</span> <span class="token number">10</span> <span class="token keyword">union</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> sal <span class="token operator">></span><span class="token number">2000</span><span class="token punctuation">;</span><span class="token comment">-- dependent union : 跟union类似，此处的depentent表示union或union all联合而成的结果会受外部表影响</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp e <span class="token keyword">where</span> e<span class="token punctuation">.</span>empno  <span class="token operator">in</span> <span class="token punctuation">(</span> <span class="token keyword">select</span> empno <span class="token keyword">from</span> emp <span class="token keyword">where</span> deptno <span class="token operator">=</span> <span class="token number">10</span> <span class="token keyword">union</span> <span class="token keyword">select</span> empno <span class="token keyword">from</span> emp <span class="token keyword">where</span> sal <span class="token operator">></span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token comment">-- union result:从union表获取结果的select</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> deptno <span class="token operator">=</span> <span class="token number">10</span> <span class="token keyword">union</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> sal <span class="token operator">></span><span class="token number">2000</span><span class="token punctuation">;</span><span class="token comment">-- subquery:在select或者where列表中包含子查询</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> sal <span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token function">avg</span><span class="token punctuation">(</span>sal<span class="token punctuation">)</span> <span class="token keyword">from</span> emp<span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token comment">-- dependent subquery:subquery的子查询要受到外部表查询的影响</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp e <span class="token keyword">where</span> e<span class="token punctuation">.</span>deptno <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token keyword">distinct</span> deptno <span class="token keyword">from</span> dept<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- DERIVED: from子句中出现的子查询，也叫做派生类，</span><span class="token keyword">explain</span> <span class="token keyword">select</span> staname<span class="token punctuation">,</span>ename supname <span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">select</span> ename staname<span class="token punctuation">,</span>mgr <span class="token keyword">from</span> emp<span class="token punctuation">)</span> t <span class="token keyword">join</span> emp <span class="token keyword">on</span> t<span class="token punctuation">.</span>mgr<span class="token operator">=</span>emp<span class="token punctuation">.</span>empno <span class="token punctuation">;</span><span class="token comment">-- UNCACHEABLE SUBQUERY：表示使用子查询的结果不能被缓存</span> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> empno <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">select</span> empno <span class="token keyword">from</span> emp <span class="token keyword">where</span> deptno<span class="token operator">=</span>@<span class="token variable">@sort_buffer_size</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- uncacheable union:表示union的查询结果不能被缓存：sql语句未验证</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="table"><a href="#table" class="headerlink" title="table"></a><strong>table</strong></h4><p>对应行正在访问哪一个表，表名或者别名，可能是临时表或者union合并结果集</p><ul><li>如果是具体的表名，则表明从实际的物理表中获取数据，当然也可以是表的别名</li><li>表名是derivedN的形式，表示使用了id为N的查询产生的衍生表</li><li>当有union result的时候，表名是union n1,n2等的形式，n1,n2表示参与union的id</li></ul><h4 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a><strong>partitions</strong></h4><p>表示当前查询访问的分区，如果是NULL，表示当前不是分区表</p><h4 id="type"><a href="#type" class="headerlink" title="type"></a><strong>type</strong></h4><p>type显示的是访问类型，访问类型表示我是以何种方式去访问我们的数据，最容易想的是全表扫描，直接暴力的遍历一张表去寻找需要的数据，效率非常低下，访问的类型有很多，效率从最好到最坏依次是：</p><ul><li><code>system</code>：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现</li><li><code>const</code>：这个表至多有一个匹配行，并不是说表里只有一条记录，一般使用主键id查询的时候是这种情况</li><li><code>eq_ref</code>：使用唯一性索引进行数据查找</li><li><code>ref</code>：使用了非唯一性索引进行数据的查找</li><li><code>fulltext</code></li><li><code>ref_or_null</code>：对于某个字段即需要关联条件，也需要null值的情况下，查询优化器会选择这种访问方式</li><li><code>index_merge</code>：在查询过程中需要多个索引组合使用</li><li><code>unique_subquery</code>：该连接类型类似与index_subquery,使用的是唯一索引</li><li><code>index_subquery</code>：利用索引来关联子查询，不再扫描全表</li><li><code>range</code>：表示利用索引查询的时候限制了范围，在指定范围内进行查询，这样避免了index的全索引扫描</li><li><code>index</code>：全索引扫描这个比all的效率要好，主要有两种情况，一种是当前的查询是覆盖索引，或者是使用了索引进行排序，这样就避免数据的重排序</li><li><code>all</code>：全表扫描，一般情况下出现这样的sql语句而且数据量比较大的话那么就需要进行优化。</li></ul><p>一般情况下，得保证查询至少达到range级别，最好能达到ref</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- all:全表扫描，一般情况下出现这样的sql语句而且数据量比较大的话那么就需要进行优化。</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp<span class="token punctuation">;</span><span class="token comment">-- index：全索引扫描这个比all的效率要好，主要有两种情况，一种是当前的查询是覆盖索引，即我们需要的数据在索引中就可以索取，或者是使用了索引进行排序，这样就避免数据的重排序</span><span class="token keyword">explain</span>  <span class="token keyword">select</span> empno <span class="token keyword">from</span> emp<span class="token punctuation">;</span><span class="token comment">-- range：表示利用索引查询的时候限制了范围，在指定范围内进行查询，这样避免了index的全索引扫描，适用的操作符： =, &lt;>, >, >=, &lt;, &lt;=, IS NULL, BETWEEN, LIKE, or IN() </span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> empno <span class="token operator">between</span> <span class="token number">7000</span> <span class="token operator">and</span> <span class="token number">7500</span><span class="token punctuation">;</span><span class="token comment">-- index_subquery：利用索引来关联子查询，不再扫描全表</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> emp<span class="token punctuation">.</span>job <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token keyword">select</span> job <span class="token keyword">from</span> t_job<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- unique_subquery:该连接类型类似与index_subquery,使用的是唯一索引</span> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp e <span class="token keyword">where</span> e<span class="token punctuation">.</span>deptno <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token keyword">distinct</span> deptno <span class="token keyword">from</span> dept<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- index_merge：在查询过程中需要多个索引组合使用，没有模拟出来</span><span class="token comment">-- ref_or_null：对于某个字段即需要关联条件，也需要null值的情况下，查询优化器会选择这种访问方式</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> mgr <span class="token operator">is</span> <span class="token boolean">null</span> <span class="token operator">or</span> mgr<span class="token operator">=</span><span class="token number">7369</span><span class="token punctuation">;</span><span class="token comment">-- ref：使用了非唯一性索引进行数据的查找</span> <span class="token keyword">create</span> <span class="token keyword">index</span> idx_3 <span class="token keyword">on</span> emp<span class="token punctuation">(</span>deptno<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp e<span class="token punctuation">,</span>dept d <span class="token keyword">where</span> e<span class="token punctuation">.</span>deptno <span class="token operator">=</span>d<span class="token punctuation">.</span>deptno<span class="token punctuation">;</span><span class="token comment">-- eq_ref ：使用唯一性索引进行数据查找</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp<span class="token punctuation">,</span>emp2 <span class="token keyword">where</span> emp<span class="token punctuation">.</span>empno <span class="token operator">=</span> emp2<span class="token punctuation">.</span>empno<span class="token punctuation">;</span><span class="token comment">-- const：这个表至多有一个匹配行，并不是说表里只有一条记录，一般使用主键id查询的时候会有这个type</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> empno <span class="token operator">=</span> <span class="token number">7369</span><span class="token punctuation">;</span> <span class="token comment">-- system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a><strong>possible_keys</strong></h4><p>显示当前查询语句可能会被使用的索引，一个或多个，但不一定被查询实际使用</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp<span class="token punctuation">,</span>dept <span class="token keyword">where</span> emp<span class="token punctuation">.</span>deptno <span class="token operator">=</span> dept<span class="token punctuation">.</span>deptno <span class="token operator">and</span> emp<span class="token punctuation">.</span>deptno <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="key"><a href="#key" class="headerlink" title="key"></a><strong>key</strong></h4><p>实际使用的索引，如果为null，则没有使用索引，查询中若使用了覆盖索引，则该索引和查询的select字段重叠。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp<span class="token punctuation">,</span>dept <span class="token keyword">where</span> emp<span class="token punctuation">.</span>deptno <span class="token operator">=</span> dept<span class="token punctuation">.</span>deptno <span class="token operator">and</span> emp<span class="token punctuation">.</span>deptno <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a><strong>key_len</strong></h4><p>表示索引中使用的字节数，可以通过key_len计算查询中使用的索引长度，在不损失精度的情况下长度越短越好。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp<span class="token punctuation">,</span>dept <span class="token keyword">where</span> emp<span class="token punctuation">.</span>deptno <span class="token operator">=</span> dept<span class="token punctuation">.</span>deptno <span class="token operator">and</span> emp<span class="token punctuation">.</span>deptno <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a><strong>ref</strong></h4><p>显示索引的哪一列被使用了，如果可能的话，是一个常数</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp<span class="token punctuation">,</span>dept <span class="token keyword">where</span> emp<span class="token punctuation">.</span>deptno <span class="token operator">=</span> dept<span class="token punctuation">.</span>deptno <span class="token operator">and</span> emp<span class="token punctuation">.</span>deptno <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="rows"><a href="#rows" class="headerlink" title="rows"></a><strong>rows</strong></h4><p>根据表的统计信息及索引使用情况，大致估算出找出所需记录需要读取的行数，此参数很重要，直接反应的sql找了多少数据，在完成目的的情况下越少越好</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a><strong>filtered</strong></h4><p>某个表经过搜索条件<code>过滤后剩余记录条数</code>的百分比，这个<code>过滤后剩余记录条数</code>，是需要用来对下一张表进行连接的行数。什么意思呢？</p><ul><li>对于单表查询来说，这个filtered列的值没什么意义。</li><li>对于多表联合查询，假设表1扫描的rows是10000行，filteres是20%，那么表示要与表2进行连接的行数是：10000 x 20% &#x3D; 2000条记录。</li></ul><h4 id="extra"><a href="#extra" class="headerlink" title="extra"></a><strong>extra</strong></h4><p>包含额外的信息。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- using filesort :说明mysql无法利用索引进行排序，只能利用排序算法进行排序，会消耗额外的位置</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">order</span> <span class="token keyword">by</span> sal<span class="token punctuation">;</span><span class="token comment">-- using temporary:需要使用临时表来保存中间结果，查询完成之后把临时表删除</span><span class="token keyword">explain</span> <span class="token keyword">select</span> ename<span class="token punctuation">,</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> deptno <span class="token operator">=</span> <span class="token number">10</span> <span class="token keyword">group</span> <span class="token keyword">by</span> ename<span class="token punctuation">;</span><span class="token comment">-- using index: 这个表示当前的查询时覆盖索引的，直接从索引中读取数据，而不用访问数据表。如果同时出现using where 表名索引被用来执行索引键值的查找，如果没有，表面索引被用来读取数据，而不是真的查找</span><span class="token keyword">explain</span> <span class="token keyword">select</span> deptno<span class="token punctuation">,</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> emp <span class="token keyword">group</span> <span class="token keyword">by</span> deptno <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">-- using where:使用where进行条件过滤</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_user <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">-- using join buffer :使用连接缓存，情况没有模拟出来</span><span class="token comment">-- impossible where：where语句的结果总是false</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> empno <span class="token operator">=</span> <span class="token number">7469</span><span class="token punctuation">;</span><span class="token comment">-- using MRR：使用了Multi-Range Read 优化 (MRR)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;资料：打开&lt;/p&gt;
&lt;h2 id=&quot;7-MySQL中-in-和-exists-的区别？&quot;&gt;&lt;a href=&quot;#7-MySQL中-in-和-exists-的区别？&quot; class=&quot;headerlink&quot; title=&quot;7.MySQL中 in 和 exists 的区别</summary>
      
    
    
    
    <category term="JAVA" scheme="https://zspcer.gitee.io/categories/JAVA/"/>
    
    <category term="数据库" scheme="https://zspcer.gitee.io/categories/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MYSQL" scheme="https://zspcer.gitee.io/categories/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL/"/>
    
    
    <category term="mysql" scheme="https://zspcer.gitee.io/tags/mysql/"/>
    
    <category term="性能调优" scheme="https://zspcer.gitee.io/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
    <category term="调优" scheme="https://zspcer.gitee.io/tags/%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>mysql的主备从入门到入土</title>
    <link href="https://zspcer.gitee.io/note/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL/mysql%E7%9A%84%E4%B8%BB%E5%A4%87%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/"/>
    <id>https://zspcer.gitee.io/note/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL/mysql%E7%9A%84%E4%B8%BB%E5%A4%87%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/</id>
    <published>2023-05-11T02:44:22.197Z</published>
    <updated>2023-05-11T02:44:22.197Z</updated>
    
    <content type="html"><![CDATA[<p>本文有xmind，配合观看，效果更佳：<a href="mysql%E7%9A%84%E4%B8%BB%E5%A4%87%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F.assets/Mysql%E4%B8%BB%E5%A4%87%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F.xmind">Mysql主备从入门到入土.xmind</a></p><p>binlog 可以用来归档，也可以用来做主备同步，那么具体是怎么做主备同步的呢？为什么备库执行了 binlog 就可以跟主库保持一致了呢？</p><h2 id="什么是主备"><a href="#什么是主备" class="headerlink" title="什么是主备"></a>什么是主备</h2><p>传统的单机架构在目前的应用场景中不足以应对，后来才衍生出高可用，解决单点问题。mysql也不例外</p><h2 id="主备同步（主备一致）的流程"><a href="#主备同步（主备一致）的流程" class="headerlink" title="主备同步（主备一致）的流程"></a>主备同步（主备一致）的流程</h2><pre class="mermaid">flowchart LR开始((开始))-->undologmem[undolog<br/>mem]subgraph masterAundologmem-->datamem[data<br/>mem]datamem-->redologprepare[redolog<br/>prepare]redologprepare-->binlog[binlog]binlog-->redologcommit[redolog<br/>commit]binlog-->dump_thread[<font color='red'>dump_thread</font>]bg_thread[bg_thread]-->undologdisk[undolog<br/>disk]undologdisk-->datadisk[data<br/>disk]endredologcommit-->ack((ack))subgraph masterBdump_thread-->io_thread[<font color='red'>io_thread</font>]io_thread-->relaylog[relaylog]relaylog-->sql_thread[<font color='red'>sql_thread</font>]sql_thread-->data[data]end</pre><p>上图是主备切换的大致流程图，包括undolog，redolog，和binlog的大致流程（复习一下redolog和binlog的二阶段提交）。</p><p>从左到右的流程是：</p><ul><li>masterA主库接收到Client过来的更新请求，先记录undolog，然后写data缓存，记录redolog和binlog。</li><li>当binlog记录成功之后，在masterA主库中有一个线程dump_thread，这个dump_thread线程是用来维护和masterB备库的长链接。</li><li>在masterB备库中，也有一个io_thread线程，负责与主库建立长链接</li><li>masterB备库会向masterA主库请求同步binlog，备库会告诉主库需要同步的位置</li><li>masterA主库会按照masterB备库传过来的位置，读取binlog，发送给masterB备库</li><li>masterB备库，接收到masterA主库传过来的binlog，先暂存到本地文件，称为中转日志 relaylog</li><li>在备库B中有一个线程sql_thread，会负责解析中转日志relaylog，并执行</li></ul><h3 id="两种主备架构"><a href="#两种主备架构" class="headerlink" title="两种主备架构"></a>两种主备架构</h3><p>主备架构有两种，并且两种不同的架构，主备同步的流程有一些区别</p><h3 id="M-S结构的主备同步流程"><a href="#M-S结构的主备同步流程" class="headerlink" title="M-S结构的主备同步流程"></a>M-S结构的主备同步流程</h3><pre class="mermaid">flowchart TDclient-->mysqlAmysqlA-->mysqlB\nreadonly</pre><p>M-S结构如图所示，mysqlB是只读的，作为A的备库。</p><p>在主备切换的时候，会把client的请求转发到B</p><p>同时将mysqlA设置为readonly，设置为mysqlB的备库（修改主备关系）</p><p>当然在主备切换的时候，会有问题，比如把client的请求转发到B，但是此时B是readonly的，写不进去数据怎么办？</p><ul><li>其实这是主备切换必须要面对的问题，后面会介绍到：可用性优先切换，和可靠性优先切换 两个方案。</li><li>点此查看：<a href="#%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BC%98%E5%85%88%E7%AD%96%E7%95%A5">可靠性优先切换策略</a></li><li>点此查看：<a href="#%E5%8F%AF%E7%94%A8%E6%80%A7%E4%BC%98%E5%85%88%E7%AD%96%E7%95%A5">可用性优先切换策略</a></li></ul><h3 id="双M结构的主备同步流程"><a href="#双M结构的主备同步流程" class="headerlink" title="双M结构的主备同步流程"></a>双M结构的主备同步流程</h3><pre class="mermaid">flowchart TDclient-->mysqlAmysqlA-->mysqlB\nreadonlymysqlB\nreadonly-->mysqlA</pre><p>双 M 结构和 M-S 结构，其实区别只是多了一条线，即：mysql A 和 mysql B 之间总是互为主备关系。这样在切换的时候就不用再修改主备关系。</p><h4 id="循环复制问题"><a href="#循环复制问题" class="headerlink" title="循环复制问题"></a>循环复制问题</h4><p>但是双M结构会有一个问题，就是主备同步的时候：</p><ul><li>mysqlA把binlog发给mysqlB，mysqlB执行完binlog之后，又会生成binlog（通过参数log_slave_updates控制执行relaylog执行后是否产生binlog）</li><li>mysqlB再把binlog发给mysqlA，mysqlA又会执行…这就是双M结构的循环复制问题</li></ul><p>解决这个问题，也很简单，思考一下：</p><ul><li>方案一：在mysqlB执行完之后，不生成binlog不就完事了。</li><li>方案二：在mysqlB执行完之后，生成了binlog，但是不发给mysqlA不就完事了。</li><li>方案三：在mysqlB执行完之后，生成了binlog，发给mysqlA，但是mysqlA不执行不就完事了。</li></ul><p>在上面三个方案，其实都可以解决循环复制的问题，</p><ul><li>对于方案一，可以通过<code>log_slave_updates</code>这个参数控制relaylog执行后是否产生binlog，但是呢，我们建议打开备库的binlog。</li><li>对于方案二，mysql没采用这个方法，不知道为什么。</li><li>对于方案三，mysql采用的这个方式，mysql具体是怎么实现的呢？</li></ul><p>方案三的实现：</p><p>在mysql的binlog中，记录了一个叫做server id 的东西，如下是在ROW格式下的binlog（截取了部分）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">C:<span class="token punctuation">\</span>Program Files<span class="token punctuation">\</span>MySQL<span class="token punctuation">\</span>MySQL Server <span class="token number">8.0</span><span class="token punctuation">\</span>bin<span class="token operator">></span>mysqlbinlog.exe  <span class="token parameter variable">-vv</span> <span class="token string">"C:\ProgramData\MySQL\MySQL Server 8.0\Data\xxxxx-bin.000002"</span> --start-position<span class="token operator">=</span><span class="token number">5043</span> --stop-position<span class="token operator">=</span><span class="token number">5300</span><span class="token comment"># at 5043</span><span class="token comment">#221101 15:21:11 server id 1  end_log_pos 5122 CRC32 0x72f668e7         Anonymous_GTID  last_committed=17       sequence_number=18      rbr_only=yes    original_committed_timestamp=1667287271257812   immediate_commit_timestamp=1667287271257812  transaction_length=287</span>SET @@<span class="token environment constant">SESSION</span>.GTID_NEXT<span class="token operator">=</span> <span class="token string">'ANONYMOUS'</span>/*<span class="token operator">!</span>*/<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，是有 <code>server id 1 </code>这个内容的，就表示当前这个binlog是在server&#x3D;1这个库上产生的。</p><p><code>server id</code>在mysql主备中，不同的实例必须是唯一的，如果它们相同，那么它们不能构成主备关系。</p><p>ROW格式的是有serverid的，那么statement格式的有吗？当然也有。也得用mysqlbinlog工具查看才行，都可以看到<code>server id</code>这个字段</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysqlbinlog.exe  -vv &quot;C:\ProgramData\MySQL\MySQL Server 8.0\Data\xxxxx-bin.000002&quot; --start-position&#x3D;7829 --stop-position&#x3D;8126<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>具体的binlog的格式可以参考：<code>mysql的日志从入门到入库-&gt;重要的日志模块(redolog和binlog)-&gt;binlog的结构</code> 这一篇文章</p><ul><li>规定两个库的 server id 必须不同，如果相同，则它们之间不能设定为主备关系；</li><li>一个备库接到 binlog 并在重放的过程中，生成与原 binlog 的 server id 相同的新的 binlog；</li><li>每个库在收到从自己的主库发过来的日志后，先判断 server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志。</li></ul><h3 id="公司生产使用的是M-S结构"><a href="#公司生产使用的是M-S结构" class="headerlink" title="公司生产使用的是M-S结构"></a>公司生产使用的是M-S结构</h3><img src="mysql的主备从入门到入土.assets/image-20221108181935875.png" alt="image-20221108181935875" style="zoom:80%;" /><p>上面两个是生产环境（prod）的主节点和从节点；下面两个是容灾环境（dr）的主节点和从节点。</p><h2 id="主备延迟和产生和避免"><a href="#主备延迟和产生和避免" class="headerlink" title="主备延迟和产生和避免"></a>主备延迟和产生和避免</h2><p>从主备同步可以看出来，备库从主库同步binlog，会有网络的问题，主库和备库机器性能问题等，都会导致备库执行binlog的速度比主库生成的速度慢，这就会导致主备延迟。</p><p>但是呢，只要主库生成的binlog都被备库正常接收了，并且正确执行了，那么主库和备库之间，数据就会保持：最终一致性。</p><p>但是仅仅有最终一致性，是不满足高可用的，因为还有之前说的主备延迟的问题。考虑这么一个场景：主库突然出问题了，要进行主备切换，然后现在备库还没有执行完主库的binlog，强行切换到备库，就会导致数据不一致的问题。</p><h3 id="什么是主备延迟"><a href="#什么是主备延迟" class="headerlink" title="什么是主备延迟"></a>什么是主备延迟</h3><p>备库从主库同步binlog，会有网络的问题，主库和备库机器性能问题等，都会导致备库执行binlog的速度比主库生成的速度慢，这就会导致主备延迟。</p><pre class="mermaid">flowchart LR主库A的binlog生成完成-T1-->备库B接收到binlog-T2-->备库B执行完成binlog-T3</pre><p>上面三个时间点，分别记为：T1，T2，T3，那么T3-T1就是主备延迟的时间。</p><p>在mysql中，可以通过在备库上执行<code>show slave status</code>命令，在执行结果中有一个<code>seconds_behind_master</code>字段，表示备库落后于主库多少秒。</p><h3 id="为什么会产生主备延迟"><a href="#为什么会产生主备延迟" class="headerlink" title="为什么会产生主备延迟"></a>为什么会产生主备延迟</h3><ul><li><p>备库的机器性能比主库差</p></li><li><p>备库压力大</p><ul><li>我们一般把备库设置为readonly，并提供一些只读的查询，这些只读的查询，一般会比较复杂，会对数据库造成压力</li><li>解决：可以采用一主多从的架构，分担读压力；还可以将数据分散到外部系统，比如大数据。</li></ul></li><li><p>大事务</p><ul><li>因为主库上必须等事务执行完成才会写入 binlog，再传给备库。所以，如果一个主库上的语句执行 10 分钟，那这个事务很可能就会导致从库延迟 10 分钟。</li><li>常见的大事务有哪些？<ul><li>大量DML：一次性地用 delete 语句删除太多数据。解决办法就是，少量多次删除。</li><li>大表DDL：使用gh-ost方案。</li></ul></li></ul></li><li><p>主库的事务是并发的，而备库是sql_thread单线程同步的</p><ul><li>备库的并行复制能力</li></ul></li></ul><h3 id="备库的并行复制能力"><a href="#备库的并行复制能力" class="headerlink" title="备库的并行复制能力"></a>备库的并行复制能力</h3><p>通过以上产生主备延迟的原因，基本都有对应的解决办法，都是mysql也为了减少主备延迟的时间，做了很多努力。</p><p>为什么要有多线程复制呢？这是因为单线程复制的能力全面低于多线程复制，对于更新压力较大的主库，备库是可能一直追不上主库的。从现象上看就是，备库上 seconds_behind_master 的值越来越大。</p><p>都做了什么努力呢？我们再来回顾主备同步的步骤。</p><pre class="mermaid">flowchart LR开始((开始))-->undologmem[undolog<br/>mem]subgraph masterAundologmem-->datamem[data<br/>mem]datamem-->redologprepare[redolog<br/>prepare]redologprepare-->binlog[binlog]binlog-->redologcommit[redolog<br/>commit]binlog-->dump_thread[dump_thread]bg_thread[bg_thread]-->undologdisk[undolog<br/>disk]undologdisk-->datadisk[data<br/>disk]endredologcommit-->ack((ack))subgraph masterBdump_thread-->io_thread[io_thread]io_thread-->relaylog[relaylog]relaylog-->sql_thread[sql_thread]sql_thread==>data[data]end</pre><p>这个图，可文章开始的图有一点点细微的差别，这个细微的差别，在于最后一步：sql_thread-&gt;data 这一步的线，比之前的图，粗了一点点。为什么呢？</p><p>因为mysql对这一步骤做了优化，在通过sql_thread执行relaylog的时候，是通过多线程执行的。</p><p>使用了多线程，就可以提高备库的能力。减少主备延迟的时间。</p><h4 id="并行复制的基本原理"><a href="#并行复制的基本原理" class="headerlink" title="并行复制的基本原理"></a>并行复制的基本原理</h4><p>从单线程复制到最新版本的多线程复制，中间的演化经历了好几个版本。接下来，我就跟你说说 MySQL 多线程复制的演进过程。</p><p>其实说到底，所有的多线程复制机制，都是要把上图中只有一个线程的 sql_thread，拆成多个线程：</p><pre class="mermaid">flowchart LRrelaylog-->coordinatorsubgraph sql_threadcoordinator-->worker-1coordinator-->worker-2coordinator-->worker-3coordinator-->点点点[..........]coordinator-->worker-nendworker-1-->dataworker-2-->dataworker-3-->data点点点-->dataworker-n-->data</pre><p>其中的<code>coordinator</code>和<code>worker</code>就是原来的<code>sql_thread</code>;</p><ul><li><code>coordinator</code>复制读取和分发<code>relaylog</code></li><li><code>worker</code>线程是真正来执行<code>relaylog</code>的</li></ul><p>worker线程有多少个？</p><ul><li>是通过<code>slave_parallel_workers</code>参数控制的，一般32C的机器，建议设置为8-16之间，要留一些用于读查询</li><li>对于单机的mysql，默认是0</li><li>公司的生产环境配置的是 16</li></ul><h4 id="并行复制面临的问题"><a href="#并行复制面临的问题" class="headerlink" title="并行复制面临的问题"></a>并行复制面临的问题</h4><p>了解了并行复制的基本原理，接下来思考几个问题？</p><p><strong><code>coordinator</code>是怎么分发<code>relaylog</code>给worker线程的？能不能按照轮训的方式，也就是事务1的日志分为worker1，事务2的日志分给worker2？</strong></p><ul><li>不能</li><li>因为不同的事务可能会操作同一行，由于CPU的调度问题，很有可能导致事务2的日志先执行，事务1的日志后执行，导致数据不一致的问题。</li></ul><p><strong><code>coordinator</code>能不能把一个事务的不同的更新语句的binlog分给多个worker执行？</strong></p><ul><li>不能</li><li>一个事务的binlog是完整的，分开执行，很有可能也会出现数据不一致的情况。</li></ul><p>所以，对<code>coordinator</code>的分发，就提出了两个最基本的要求</p><ul><li>要求更新同一行的不同事务的binlog，必须被分发到同一个 worker 中。</li><li>要求同一个事务的binlog不能被分开，必须被分发到同一个 worker 中。</li></ul><h4 id="MySQL-5-5-版本的并行复制策略（不支持）"><a href="#MySQL-5-5-版本的并行复制策略（不支持）" class="headerlink" title="MySQL 5.5 版本的并行复制策略（不支持）"></a>MySQL 5.5 版本的并行复制策略（不支持）</h4><p>官方 MySQL 5.5 版本是不支持并行复制的。</p><p>但是，在 2012 年的时候，我自己服务的业务出现了严重的主备延迟，原因就是备库只有单线程复制。</p><p>然后，我就先后写了两个版本的并行策略。即按表分发策略和按行分发策略，以帮助你理解 MySQL 官方版本并行复制策略的迭代。</p><h5 id="按表分发策略"><a href="#按表分发策略" class="headerlink" title="按表分发策略"></a>按表分发策略</h5><p><strong>基本原理</strong>：如果两个事务操作的是不同的表，那么这两个事务就可以并行处理；如果一个事务中操作了多张表，那么把这些表当做一张表。</p><p><strong>实现细节</strong>：</p><ul><li>每一个worker线程，维护一个hashmap，key是【库名+表名】，value是待执行的事务日志的个数<ul><li>当<code>coordinator</code>把一个事务分给worker执行的时候，value+1</li><li>当worker把某一个事务执行完成的时候，value-1</li></ul></li><li>当coordinator读取下一个事务的日志之后，先获取到这个事务所操作的【库名+表名】（可能是一张表，也可能是多张表）</li><li>如果是一张表<ul><li>遍历所有的worker</li><li>判断当前worker中的hashmap的key，是不是包含这张表</li><li>如果包含：则把这个事务，交给这个worker执行</li><li>如果不包含，继续遍历下一个worker</li><li>如果所有的worker都不包含，则把这个事务交给负载最低的worker执行，并将当前的【库名+表名】添加到这个worker的hashmap中</li></ul></li><li>如果是多张表<ul><li>遍历所有的worker</li><li>如果这多张表，是由一个worker执行的，则把这个事务，交给这个worker执行</li><li>如果这多张表，目前没有worker执行，则把这个事务，交给负载最低的worker执行</li><li>如果这多张表，是由多个woker执行的，则<code>coordinator</code>进入等待，并且不停的进行遍历worker进行判断</li></ul></li></ul><p><strong>缺点</strong>：这个按表分发的方案，在多个表负载均匀的场景里应用效果很好。但是，如果碰到热点表，比如所有的更新事务都会涉及到某一个表的时候，所有事务都会被分配到同一个 worker 中，就变成单线程复制了。</p><h5 id="按行分发策略"><a href="#按行分发策略" class="headerlink" title="按行分发策略"></a>按行分发策略</h5><p>要解决热点表的并行复制问题，就需要一个按行并行复制的方案。</p><p><strong>基本原理</strong>：如果两个事务没有更新相同的行，它们在备库上可以并行执行。显然，这个模式要求 binlog 格式必须是 row。因为statement记录的是sql语句，无法判断更新了哪一行？</p><p>实现细节：</p><ul><li>每一个worker线程，维护一个hashmap，key是【库名+表名+主键值+唯一索引的值】，value是待执行的事务日志的个数</li><li>剩下的步骤，同<strong>按表分发策略</strong></li></ul><p><strong>缺点</strong>：对比按表分发和按行分发这两个方案的话，按行分发策略的并行度更高。不过，如果是要操作很多行的大事务的话，按行分发的策略有两个问题：</p><ul><li>耗费内存。比如一个语句要删除 100 万行数据，这时候 hash 表就要记录 100 万个项。</li><li>耗费 CPU。解析 binlog，然后计算 hash 值，对于大事务，这个成本还是很高的。</li></ul><p><strong>退化</strong>：因为缺点的存在，所以在实现这个策略的时候会设置一个阈值，单个事务如果超过设置的行数阈值（比如，如果单个事务更新的行数超过 10 万行），就暂时退化为单线程模式，退化过程的逻辑大概是这样的：</p><ul><li>coordinator 暂时先 hold 住这个事务；</li><li>等待所有 worker 都执行完成，变成空队列；</li><li>coordinator 直接执行这个事务；</li><li>恢复并行模式。</li></ul><h4 id="MySQL-5-6-版本的并行复制策略"><a href="#MySQL-5-6-版本的并行复制策略" class="headerlink" title="MySQL 5.6 版本的并行复制策略"></a>MySQL 5.6 版本的并行复制策略</h4><p>官方 MySQL5.6 版本，支持了并行复制，只是支持的粒度是<strong>按库并行</strong>。</p><p>具体的实现方案和按表分发以及按行分拨的是一样的，只不过hashmap中的key是库名了。</p><h4 id="MariaDB-的并行复制策略"><a href="#MariaDB-的并行复制策略" class="headerlink" title="MariaDB 的并行复制策略"></a>MariaDB 的并行复制策略</h4><p><strong>基本原理</strong>：利用了组提交的特性</p><ul><li>能在同一个组中提交的事务，一定不会更新同一行（因为innodb在更新某一行的时候，会先获取行锁，上一个事务还没有commit的时候，行锁是不会释放的）</li><li>主库能并行执行的，备库一定也可以并行执行。</li></ul><p><strong>实现细节</strong>：</p><ul><li>在一组里面提交的事务，有一个共同的commit_id</li><li>coordinator每次从relaylog中获取一批事务（具有相同的commit_id）</li><li>然后把这一批直接分给worker并发执行</li><li>等待worker执行完之后，coordinator在获取下一批事务</li></ul><p><strong>缺点</strong>：虽然是并发了，但是并发度不够，不够在哪里呢？思考一下，在主库上，一组事务的binlog在commit的时候，下一组binlog可能已经开始write了，主库的效率是很高的。而在备库上，coordinator获取一批事务，必须等待这一批执行完，才能执行下一批。效率相比较于主库，就比较慢了。</p><h4 id="MySQL-5-7-的并行复制策略"><a href="#MySQL-5-7-的并行复制策略" class="headerlink" title="MySQL 5.7 的并行复制策略"></a>MySQL 5.7 的并行复制策略</h4><p>在MariaDB 的并行复制策略出现之后，mysql5.7也出了一个类似的，但是呢，也并没有舍弃mysql5.6中的按库分发策略。mysql5.7提供了一个参数</p><ul><li>slave-parallel-type</li><li>配置为 DATABASE，表示使用 MySQL 5.6 版本的按库并行策略；</li><li>配置为 LOGICAL_CLOCK，表示的就是类似 MariaDB 的策略（不过是mysql优化后的）。</li></ul><p><strong>mysql对 MariaDB 的策略进行了优化，优化了什么呢？</strong></p><p>在回顾一下MariaDB的并行复制策略的核心是：所有commit的事务，可以并行执行。因为commit的事务一定是不会有锁冲突的。</p><p>那么在思考一下mysql的更新流程：</p><pre class="mermaid">flowchart LR开始((开始))-->undologmem[undolog<br/>mem]undologmem-->datamem[data<br/>mem]datamem-->redologprepare[redolog<br/>prepare]redologprepare-->binlog[binlog]binlog-->redologcommit[redolog<br/>commit]</pre><p>可以发现，其实在记录redolog（prepare）的时候，就已经通过了锁校验。具体的关于锁，可以看：mysql的锁从入门到入土</p><p>优化点：只要是通过了redolog（prepare）阶段后的一组事务的binlog（组提交），传到备库的时候，这组事务都是可以并行执行的</p><h4 id="MySQL-5-7-22-的并行复制策略"><a href="#MySQL-5-7-22-的并行复制策略" class="headerlink" title="MySQL 5.7.22 的并行复制策略"></a>MySQL 5.7.22 的并行复制策略</h4><p>公司生产用的是mysql版本是5.7.19</p><p>在 2018 年 4 月份发布的 MySQL 5.7.22 版本里，MySQL 增加了一个新的并行复制策略，基于 WRITESET 的并行复制。</p><p>相应地，新增了一个参数 <code>binlog-transaction-dependency-tracking</code>，用来控制是否启用这个新策略。这个参数的可选值有以下三种。</p><ul><li><code>COMMIT_ORDER</code>表示的就是前面介绍的，根据同时进入 prepare 和 commit 来判断是否可以并行的策略。</li><li><code>WRITESET</code>表示的是对于事务涉及更新的每一行，计算出这一行的 hash 值，组成集合 writeset。如果两个事务没有操作相同的行，也就是说它们的 writeset 没有交集，就可以并行。</li><li><code>WRITESET_SESSION</code>是在 WRITESET 的基础上多了一个约束，即在主库上同一个线程先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序。</li></ul><p><strong>实现细节</strong>：</p><ul><li>msyql对于事务涉及更新的每一行，计算出这一行的 hash 值（是通过“库名 + 表名 + 索引名 + 值”计算出来的），组成集合 writeset。</li><li>把这个writeset集合写到binlog中（写在binlog哪里的，不知道，怎么从binlog中获取的，也不知道，这里没扣细节）</li><li>备库执行的时候，直接获取一批事务，获取这一批事务的writeset，和当前正在执行的事务的writeset，判断是否有交集。</li><li>没有交集，就可以并行。</li></ul><p><strong>优点</strong>：</p><ul><li>获取writeset的时候，不需要计算，也不需要解析binlog，就可以直接拿到，省CPU</li><li>不需要把整个事务的 binlog 都扫一遍才能决定分发到哪个 worker，更省内存；</li><li>由于备库的分发策略不依赖于 binlog 内容，所以 binlog 是 statement 格式也是可以的。</li></ul><p><strong>缺点</strong>：</p><ul><li>对于“表上没主键”和“外键约束”的场景，WRITESET 策略也是没法并行的，也会暂时退化为单线程模型。</li></ul><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>如果主库都是单线程压力模式，在从库追主库的过程中，binlog-transaction-dependency-tracking 应该选用什么参数？</p><ul><li><p>首先binlog-transaction-dependency-tracking能选哪些参数？</p><ul><li>ORDER_COMMIT</li><li>WRITE_SET</li><li>WRITE_SET_SESSION</li></ul></li><li><p>其次看这三个参数分别对应了什么？</p><ul><li>ORDER_COMMIT：主要是处于redolog（prepare）状态之后的，组提交的事务，可以并行复制；</li><li>WRITE_SET_SESSION：同一个会话中的事务的writeset，即使没有交集，也要顺序执行</li><li>WRITE_SET：同一个会话中的事务的writeset，只要没有交集，就可以并行</li></ul></li><li><p>在分析题目</p><ul><li>单线程：所以就没有组提交了，因为都是一个一个提交的。</li><li>单线程：所以是一个会话</li></ul></li><li><p>结合来看：</p><ul><li>没有组提交，就不能用ORDER_COMMIT，备库会单线程复制。</li><li>是一个会话，所以就不能用WRITE_SET_SESSION，因为也会顺序执行，顺序执行，就成了单线程复制。</li></ul></li></ul><h2 id="主备切换（高可用）"><a href="#主备切换（高可用）" class="headerlink" title="主备切换（高可用）"></a>主备切换（高可用）</h2><h3 id="为什么要进行主备切换"><a href="#为什么要进行主备切换" class="headerlink" title="为什么要进行主备切换"></a>为什么要进行主备切换</h3><p>主备切换有两种场景，一种是主动切换，一种是被动切换。</p><ul><li>主动切换：人为的发起</li><li>被动切换：一般是因为主库出问题了，由 HA 系统发起的。</li></ul><p>这也就引出了我们今天要讨论的问题：怎么判断一个主库出问题了？</p><h3 id="怎么判断库有问题"><a href="#怎么判断库有问题" class="headerlink" title="怎么判断库有问题"></a>怎么判断库有问题</h3><h4 id="select-1"><a href="#select-1" class="headerlink" title="select 1"></a>select 1</h4><ul><li><p>只能判断mysql的进程是否存在，无法判断数据库是否可用</p></li><li><p>验证</p><ul><li><p>设置<code>innodb_thread_concurrency=3</code>,然后开启4个session，执行下面的语句</p></li><li><table><thead><tr><th>session-1</th><th>session-2</th><th>session-3</th><th>session-4</th></tr></thead><tbody><tr><td>select sleep(1000) from t;</td><td>select sleep(1000) from t;</td><td>select sleep(1000) from t;</td><td></td></tr><tr><td></td><td></td><td></td><td>select 1; (Query OK)<br/>select * from t;(<font color='red'>blocked</font>)</td></tr></tbody></table></li><li><p>可以看到select 1会成功，但是查询表会阻塞；</p></li></ul></li><li><p><code>innodb_thread_concurrency</code>表示限制innoDB的并发执行线程数，是指通知运行的线程有多少个。</p></li><li><p>并发连接数对系统的运行没有多大的影响，有影响的是并发执行数，才会大量占用CPU；具体的可以看：mysql的性能调优从入门到入土</p></li></ul><h4 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h4><p>既然<code>select 1</code>不行，那我用查询语句总可以吧。</p><ul><li>新建一张表，比如叫：health_check；</li><li>定期执行：select * from health_check;</li><li>能执行成功，说明数据库正常</li><li>执行不成功，或者超时没返回结果，数据库不正常</li></ul><p>但是这个方案，也是不行的，因为当<strong>数据库磁盘满了</strong>的时候，此时数据库不能写入，但是可以正常提供读服务；</p><h4 id="更新语句"><a href="#更新语句" class="headerlink" title="更新语句"></a>更新语句</h4><p>既然查询语句，那我用更新语句总可以吧。</p><p>常用的做法是：</p><ul><li>新建一张表，比如叫：health_check</li><li>定期执行：update health_check set check_time&#x3D; now();</li></ul><p>这么一看，似乎问题不大，但是注意：主库定期检测了，备库也需要定期检测呀，但是由于主备同步的存在，会导致数据检测有问题，所以要优化一下</p><ul><li>在health_check表中，加一列，表示当前数据库的server id;</li><li>每次检查的时候，只更新自己的server id，就没问题了(因为主备的server id是不同的)</li><li>update health_check set check_time&#x3D;now() where server_id &#x3D; ‘xxxx’;</li></ul><p>但是呢，这个方案，也是不行的，当数据库的磁盘IO性能瓶颈的时候，比如IO使用率已经100%了，注意IO使用率100%并不是说系统不可用，因为此时IO还在继续工作呢，只不过IO使用率100%了，会导致后续过来的更新操作，排队等待而已，对client来说，就是我的sql执行的好慢呀。</p><p>那么IO使用率100%了，对于我们的检测语句来说，因为检测语句占用的IO资源非常非常小，所以系统可能会安排执行，这样的话，我们的检测语句正常返回了。但是此时数据库已经达到瓶颈了。</p><h4 id="外部判断的弊端"><a href="#外部判断的弊端" class="headerlink" title="外部判断的弊端"></a>外部判断的弊端</h4><p>以上三种判断方法都是外部判断的方式，以上的三种检测方法都有各自的使用场景，但是他们具备同样的一个弊端：</p><ul><li>判断慢</li></ul><p>什么是判断慢，就是系统已经出问题了，但是我们的检测不及时，如果定时检查是10分钟一次，那就要等10分钟之后才能发现问题，而且上面三种方式，还不一定能够覆盖所有的异常场景，所以外部检测的方式，一般只是用来辅助，并不能完全靠它。</p><h4 id="内部判断"><a href="#内部判断" class="headerlink" title="内部判断"></a>内部判断</h4><p>MySQL 5.6 版本以后提供的 performance_schema 库，里面记录了很多数据库运行时候的详细统计信息。</p><p>在mysql性能调优从土门到入土中，也介绍过 performance_schema库</p><p>具体的这里不介绍了，只需要知道这个库中记录的很多超级详细的内容，完全可以实时的检测mysql的运行状态。</p><p>但是还是有需要注意的地方</p><ul><li>如果打开所有的 performance_schema 项，性能大概会下降 10% 左右。所以，我建议你只打开自己需要的项进行统计。</li></ul><h3 id="两种主备架构-1"><a href="#两种主备架构-1" class="headerlink" title="两种主备架构"></a>两种主备架构</h3><pre class="mermaid">flowchart TDsubgraph M-S结构clientms[client]-->mysqlAms[mysqlA]mysqlAms-->mysqlBms[mysqlB<br/>readonly]endsubgraph 双M结构clientmm[client]-->mysqlAmm[mysqlA]mysqlAmm-->mysqlBmm[mysqlB<br/>readonly]mysqlBmm-->mysqlAmmend</pre><p>由于主备延迟的存在，所以在主备切换的时候，就相应的有不同的策略。</p><h3 id="可靠性优先切换策略"><a href="#可靠性优先切换策略" class="headerlink" title="可靠性优先切换策略"></a>可靠性优先切换策略</h3><p>下面的切换流程，是在<code>双M结构</code>的流程下进行的操作，和<code>M-S结构</code>的区别在于：不用修改主备关系了。</p><ul><li>1、判断备库B上的seconds_behind_master，如果小于某个值（比如5秒），继续下一步，否则继续当前步骤</li><li>2、将主库A设置为readonly</li><li>3、判断备库B上的seconds_behind_master，直到它变为0为止</li><li>4、将备库B设置为可读写</li><li>5、将业务请求转发到备库B</li></ul><p>在上面的步骤中，我们看到，系统是有不可用时间的。此时主库A和备库B都处于只读状态。</p><h3 id="可用性优先切换策略"><a href="#可用性优先切换策略" class="headerlink" title="可用性优先切换策略"></a>可用性优先切换策略</h3><p>下面的切换流程，是在<code>双M结构</code>的流程下进行的操作，和<code>M-S结构</code>的区别在于：不用修改主备关系了。</p><ul><li>1、将备库B设置为可读写</li><li>2、将业务请求转发到备库B，此时原来的主库A就不会有业务请求了</li><li>3、判断备库B上的seconds_behind_master，直到它变为0为止</li><li>4、将主库A设置为readonly</li></ul><p>在上面的步骤中，系统可能会出现数据不一致的情况的，就是A产生的binlog，B还没有执行的时候，就接收到了新的请求，然后主库A的binlog此时传到了备库B上，B在执行binlog，就会导致数据不一致的场景。</p><h3 id="公司生产使用的是可靠性优先策略"><a href="#公司生产使用的是可靠性优先策略" class="headerlink" title="公司生产使用的是可靠性优先策略"></a>公司生产使用的是可靠性优先策略</h3><p>公司使用的是M-S结构，并且使用的是可靠性优先切换策略。</p><p>之前进行过主备切换，DBA通知需要停应用才行的。</p><img src="mysql的主备从入门到入土.assets/image-20221110201120695.png" alt="image-20221110201120695" style="zoom:67%;" /><p>而且主备切换，一般是由专门的HA系统操作的，不用人为的介入，以下的公司的ha系统</p><img src="mysql的主备从入门到入土.assets/image-20221110195355203.png" alt="image-20221110195355203" style="zoom: 80%;" /><h2 id="主从切换"><a href="#主从切换" class="headerlink" title="主从切换"></a>主从切换</h2><h3 id="什么是一主多从"><a href="#什么是一主多从" class="headerlink" title="什么是一主多从"></a>什么是一主多从</h3><pre class="mermaid">flowchart TDclient-->|write|mysqlAmysqlA-.->mysqlA1mysqlA1-.->mysqlAclient-->|read|mysqlBclient-->|read|mysqlCclient-->|read|mysqlDmysqlA-.->mysqlBmysqlA-.->mysqlCmysqlA-.->mysqlD</pre><p>mysqlA是主库</p><p>mysqlA1是备库（双M结构）</p><p>mysqlB，C，D是从库，从主库mysqlA进行同步，并且B，C，D提供只读能力</p><p>以上的架构就是一主多从架构。</p><h3 id="一主多从有什么问题"><a href="#一主多从有什么问题" class="headerlink" title="一主多从有什么问题"></a>一主多从有什么问题</h3><p>在系统正常运行的时候，没什么问题，主要考虑异常的情况：</p><ul><li>当主库mysqlA突然宕机了，或者无法提供服务了，怎么办？</li><li>那肯定要进行主备切换了，将主库切换到备库mysqlA1（关于主备切换，上面说过了，这种被动切换的场景，就没法保证数据可靠性了，只能强制切换到备库上）</li><li>但是主备切换完成之后，还有从库呢？怎么办呢？</li><li>之前从库是从<code>主库mysqlA</code>进行同步的，现在从库必须要连接<code>新主库mysqlA1</code>了。（而这一步，就是主从切换的难点）</li></ul><h3 id="一主多从的切换策略"><a href="#一主多从的切换策略" class="headerlink" title="一主多从的切换策略"></a>一主多从的切换策略</h3><p>一起看看一个切换系统会怎么完成一主多从的主备切换过程。</p><p>一主多从一般有两种切换办法</p><ul><li>基于位点的同步</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CHANGE MASTER <span class="token keyword">TO</span> MASTER_HOST<span class="token operator">=</span>$host_name MASTER_PORT<span class="token operator">=</span>$port MASTER_USER<span class="token operator">=</span>$user_name MASTER_PASSWORD<span class="token operator">=</span>$password MASTER_LOG_FILE<span class="token operator">=</span>$master_log_name MASTER_LOG_POS<span class="token operator">=</span>$master_log_pos  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>基于GTID的切换</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CHANGE MASTER <span class="token keyword">TO</span> MASTER_HOST<span class="token operator">=</span>$host_name MASTER_PORT<span class="token operator">=</span>$port MASTER_USER<span class="token operator">=</span>$user_name MASTER_PASSWORD<span class="token operator">=</span>$password master_auto_position<span class="token operator">=</span><span class="token number">1</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>参数解释</li></ul><table><thead><tr><th>字段</th><th>解释</th><th>备注</th></tr></thead><tbody><tr><td>MASTER_HOST</td><td>新主库的ip</td><td></td></tr><tr><td>MASTER_PORT</td><td>新主库的端口</td><td></td></tr><tr><td>MASTER_USER</td><td>新主库的用户名</td><td></td></tr><tr><td>MASTER_PASSWORD</td><td>新主库的密码</td><td></td></tr><tr><td>MASTER_LOG_FILE</td><td>指定从哪个binlog文件进行同步</td><td>基于位点的同步才有</td></tr><tr><td>MASTER_LOG_POS</td><td>指定从这个binlog文件的哪个位置开始同步</td><td>基于位点的同步才有</td></tr><tr><td>master_auto_position</td><td>表示使用GTID协议，使用GTID进行同步</td><td>基于GTID的同步才有，表示使用GTID协议</td></tr></tbody></table><h4 id="基于位点的切换"><a href="#基于位点的切换" class="headerlink" title="基于位点的切换"></a>基于位点的切换</h4><h5 id="什么是位点"><a href="#什么是位点" class="headerlink" title="什么是位点"></a>什么是位点</h5><p>简单地说，就是一条sql语句在binlog中的位置，叫做位点。</p><p>在《mysql日志从入门到入土》一文中，介绍了三种格式的binlog，每一种格式的binlog都会有一个Pos的列，下面以row格式的binlog为例，看一下</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> binlog events <span class="token operator">in</span> <span class="token string">'xxx-bin.000002'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----------------+------+----------------+-----------+-------------+--------------------------------------+</span><span class="token operator">|</span> Log_name       <span class="token operator">|</span> Pos  <span class="token operator">|</span> Event_type     <span class="token operator">|</span> Server_id <span class="token operator">|</span> End_log_pos <span class="token operator">|</span> Info                                 <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----------------+------+----------------+-----------+-------------+--------------------------------------+</span><span class="token operator">|</span> xxx<span class="token operator">-</span>bin<span class="token punctuation">.</span><span class="token number">000002</span> <span class="token operator">|</span> <span class="token number">5043</span> <span class="token operator">|</span> Anonymous_Gtid <span class="token operator">|</span>         <span class="token number">1</span> <span class="token operator">|</span>        <span class="token number">5122</span> <span class="token operator">|</span> <span class="token keyword">SET</span> @<span class="token variable">@SESSION.GTID_NEXT</span><span class="token operator">=</span> <span class="token string">'ANONYMOUS'</span> <span class="token operator">|</span><span class="token operator">|</span> xxx<span class="token operator">-</span>bin<span class="token punctuation">.</span><span class="token number">000002</span> <span class="token operator">|</span> <span class="token number">5122</span> <span class="token operator">|</span> Query          <span class="token operator">|</span>         <span class="token number">1</span> <span class="token operator">|</span>        <span class="token number">5203</span> <span class="token operator">|</span> <span class="token keyword">BEGIN</span>                                <span class="token operator">|</span><span class="token operator">|</span> xxx<span class="token operator">-</span>bin<span class="token punctuation">.</span><span class="token number">000002</span> <span class="token operator">|</span> <span class="token number">5203</span> <span class="token operator">|</span> Table_map      <span class="token operator">|</span>         <span class="token number">1</span> <span class="token operator">|</span>        <span class="token number">5251</span> <span class="token operator">|</span> table_id: <span class="token number">169</span> <span class="token punctuation">(</span>zs<span class="token punctuation">.</span>t<span class="token punctuation">)</span>                 <span class="token operator">|</span><span class="token operator">|</span> xxx<span class="token operator">-</span>bin<span class="token punctuation">.</span><span class="token number">000002</span> <span class="token operator">|</span> <span class="token number">5251</span> <span class="token operator">|</span> Delete_rows    <span class="token operator">|</span>         <span class="token number">1</span> <span class="token operator">|</span>        <span class="token number">5299</span> <span class="token operator">|</span> table_id: <span class="token number">169</span> flags: STMT_END_F      <span class="token operator">|</span><span class="token operator">|</span> xxx<span class="token operator">-</span>bin<span class="token punctuation">.</span><span class="token number">000002</span> <span class="token operator">|</span> <span class="token number">5299</span> <span class="token operator">|</span> Xid            <span class="token operator">|</span>         <span class="token number">1</span> <span class="token operator">|</span>        <span class="token number">5330</span> <span class="token operator">|</span> <span class="token keyword">COMMIT</span> <span class="token comment">/* xid=1924 */</span>                <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----------------+------+----------------+-----------+-------------+--------------------------------------+</span><span class="token number">74</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中Pos就是位点。</p><h5 id="基于位点的同步"><a href="#基于位点的同步" class="headerlink" title="基于位点的同步"></a>基于位点的同步</h5><p>上面已经列出了，使用位点同步的命令，这里在展示一遍</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CHANGE MASTER <span class="token keyword">TO</span> MASTER_HOST<span class="token operator">=</span>$host_name MASTER_PORT<span class="token operator">=</span>$port MASTER_USER<span class="token operator">=</span>$user_name MASTER_PASSWORD<span class="token operator">=</span>$password MASTER_LOG_FILE<span class="token operator">=</span>$master_log_name MASTER_LOG_POS<span class="token operator">=</span>$master_log_pos  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中<code>MASTER_LOG_FILE</code>指定从哪个binlog文件进行同步，<code>MASTER_LOG_POS</code>指定从这个binlog文件的哪个位置开始同步</p><h5 id="怎么获取位点"><a href="#怎么获取位点" class="headerlink" title="怎么获取位点"></a>怎么获取位点</h5><p>那么在主从切换的时候，怎么获取位点呢？</p><p>考虑到切换过程中不能丢数据，所以我们找位点的时候，总是要找一个“<strong>稍微往前</strong>”的，然后再通过判断跳过那些在从库 B 上已经执行过的事务</p><ul><li><p>在新主库A1上：等待新主库A1把系统中的relay log全部执行完，为什么新主库A1还会有relay log?(因为新主库之前只是老主库A的一个备库，所以也有relay log)</p></li><li><p>在新主库A1上：执行 show master status 得到当前 新主库A1上最新的 binlog File 和 binlog Position；</p><ul><li>&#96;&#96;&#96;sql<br>mysql&gt; show master status;<br>+—————–+———-+————–+——————+——————-+<br>| File            | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |<br>+—————–+———-+————–+——————+——————-+<br>| xxxx-bin.000002 |     8156 |              |                  |                   |<br>+—————–+———-+————–+——————+——————-+<br>1 row in set (0.00 sec)<pre class="line-numbers language-none"><code class="language-none">- 取老主库A故障的时刻 T；- 用 mysqlbinlog 工具解析 新主库A1 的 binlog File，得到 T 时刻的位点。  - &#96;&#96;&#96;sql    mysqlbinlog File --start-datetime&#x3D;T --stop-datetime&#x3D;T<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>假设我的崩溃时间是：2022-11-08 17:42:33</p><ul><li>&#96;&#96;&#96;sql<br>C:\Program Files\MySQL\MySQL Server 8.0\bin&gt;mysqlbinlog.exe  -vv “C:\ProgramData\MySQL\MySQL Server 8.0\Data\xxxx-bin.000002” –start-datetime&#x3D;”2022-11-08 17:42:33” –stop-datetime&#x3D;”2022-11-08 17:42:33”<h1 id="The-proper-term-is-pseudo-replica-mode-but-we-use-this-compatibility-alias"><a href="#The-proper-term-is-pseudo-replica-mode-but-we-use-this-compatibility-alias" class="headerlink" title="The proper term is pseudo_replica_mode, but we use this compatibility alias"></a>The proper term is pseudo_replica_mode, but we use this compatibility alias</h1><h1 id="to-make-the-statement-usable-on-server-versions-8-0-24-and-older"><a href="#to-make-the-statement-usable-on-server-versions-8-0-24-and-older" class="headerlink" title="to make the statement usable on server versions 8.0.24 and older."></a>to make the statement usable on server versions 8.0.24 and older.</h1>&#x2F;<em>!50530 SET @@SESSION.PSEUDO_SLAVE_MODE&#x3D;1</em>&#x2F;;<br>&#x2F;<em>!50003 SET @OLD_COMPLETION_TYPE&#x3D;@@COMPLETION_TYPE,COMPLETION_TYPE&#x3D;0</em>&#x2F;;<br>DELIMITER &#x2F;<em>!</em>&#x2F;;<h1 id="at-4"><a href="#at-4" class="headerlink" title="at 4"></a>at 4</h1>#221101 14:12:06 server id 1  end_log_pos 125 CRC32 0xe443eab6  Start: binlog v 4, server v 8.0.26 created 221101 14:12:06 at startup<h1 id="Warning-this-binlog-is-either-in-use-or-was-not-closed-properly"><a href="#Warning-this-binlog-is-either-in-use-or-was-not-closed-properly" class="headerlink" title="Warning: this binlog is either in use or was not closed properly."></a>Warning: this binlog is either in use or was not closed properly.</h1>ROLLBACK&#x2F;<em>!</em>&#x2F;;<br>BINLOG ‘<br>trhgYw8BAAAAeQAAAH0AAAABAAQAOC4wLjI2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA<br>AAAAAAAAAAAAAAAAAAC2uGBjEwANAAgAAAAABAAEAAAAYQAEGggAAAAICAgCAAAACgoKKioAEjQA<br>CigBtupD5A&#x3D;&#x3D;<br>‘&#x2F;<em>!</em>&#x2F;;<br>SET @@SESSION.GTID_NEXT&#x3D; ‘AUTOMATIC’ &#x2F;* added by mysqlbinlog <em>&#x2F; &#x2F;</em>!*&#x2F;;<br>DELIMITER ;<h1 id="End-of-log-file"><a href="#End-of-log-file" class="headerlink" title="End of log file"></a>End of log file</h1>&#x2F;<em>!50003 SET COMPLETION_TYPE&#x3D;@OLD_COMPLETION_TYPE</em>&#x2F;;<br>&#x2F;<em>!50530 SET @@SESSION.PSEUDO_SLAVE_MODE&#x3D;0</em>&#x2F;;<pre class="line-numbers language-none"><code class="language-none">- 其中&#96;end_log_pos 125&#96;这个125就是时刻T崩溃时候的写入的位点。我们使用这个位点就可以了- 那么最终，就可以确定我们从库的同步命令就是下面这样  - &#96;&#96;&#96;sql    CHANGE MASTER TO     MASTER_HOST&#x3D;$host_name     MASTER_PORT&#x3D;$port     MASTER_USER&#x3D;$user_name     MASTER_PASSWORD&#x3D;$password     MASTER_LOG_FILE&#x3D;xxxx-bin.000002    MASTER_LOG_POS&#x3D;125<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h5 id="基于位点同步的问题"><a href="#基于位点同步的问题" class="headerlink" title="基于位点同步的问题"></a>基于位点同步的问题</h5><p>但是我们通过 mysqlbinlog 这个命令获取到的 位点 这个值，并不准确。</p><p>为什么呢？当老主库A在崩溃前，insert了一条语句，并把这个语句的binlog发给了新主库A1和某一个从库C，然后崩溃了，此时从库C上是有这条记录的，但是我们获取新主库A1的同步位点的时候，获取的位点肯定是在这个insert语句之前的。因为其他从库还需要同步这个insert记录呢。</p><p>但是我们的从库C，已经有这条记录的，在同步一次，就会报错：主键冲突。</p><p>所以，基于位点的同步一般需要在从库上跳过错误：</p><ul><li><p>一种做法是：跳过一个事务。跳过命令的写法是：</p><ul><li>&#96;&#96;&#96;sql<br>set global sql_slave_skip_counter&#x3D;1;<br>start slave;<pre class="line-numbers language-none"><code class="language-none">- 另外一种方式是：通过设置 slave_skip_errors 参数，忽略指定的错误。#### 基于 GTID 的切换##### 什么是GTID？GTID 的全称是 Global Transaction Identifier，也就是全局事务 ID，是一个事务在**提交**的时候生成的，是这个事务的唯一标识。它由两部分组成，格式是：&#96;&#96;&#96;sqlGTID&#x3D;server_uuid:gno<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><p>其中：</p><ul><li>server_uuid 是一个实例第一次启动时<strong>自动生成</strong>的，是一个全局唯一的值；不是server_id哦</li><li>gno 是一个整数，初始值是 1，每次提交事务的时候分配给这个事务，并加 1。</li><li>在官网上：GTID&#x3D;source_id:transaction_id；这里只是为了更容易理解，才写成了：server_uuid:gno</li></ul><h5 id="启动GTID模式"><a href="#启动GTID模式" class="headerlink" title="启动GTID模式"></a>启动GTID模式</h5><p>GTID模式默认是关闭的，在公司的环境中，是开启GTID模式的</p><p>在mysql还没有启动的时候</p><ul><li>在启动mysql实例的时候，手动设置：<code>gtid_mode=on</code>和<code>enforce_gtid_consistency=on</code></li></ul><p>在mysql已经启动的时候</p><ul><li>设置：<code>gtid_mode=on</code></li><li>设置：<code>enforce_gtid_consistency=on</code></li><li>下面展示了具体的开启步骤</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'gtid_mode'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">---------------+-------+</span><span class="token operator">|</span> Variable_name <span class="token operator">|</span> <span class="token keyword">Value</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">---------------+-------+</span><span class="token operator">|</span> gtid_mode     <span class="token operator">|</span> <span class="token keyword">OFF</span>   <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">---------------+-------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'enforce_gtid_consistency'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------------------------+-------+</span><span class="token operator">|</span> Variable_name            <span class="token operator">|</span> <span class="token keyword">Value</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------------------+-------+</span><span class="token operator">|</span> enforce_gtid_consistency <span class="token operator">|</span> <span class="token keyword">OFF</span>   <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------------------+-------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">set</span> gtid_mode <span class="token operator">=</span><span class="token string">'ON'</span><span class="token punctuation">;</span>ERROR <span class="token number">1229</span> <span class="token punctuation">(</span>HY000<span class="token punctuation">)</span>: Variable <span class="token string">'gtid_mode'</span> <span class="token operator">is</span> a <span class="token keyword">GLOBAL</span> variable <span class="token operator">and</span> should be <span class="token keyword">set</span> <span class="token keyword">with</span> <span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span>mysql<span class="token operator">></span> <span class="token keyword">set</span> <span class="token keyword">global</span> gtid_mode<span class="token operator">=</span><span class="token string">'ON'</span><span class="token punctuation">;</span>ERROR <span class="token number">1788</span> <span class="token punctuation">(</span>HY000<span class="token punctuation">)</span>: The <span class="token keyword">value</span> <span class="token keyword">of</span> @<span class="token variable">@GLOBAL.GTID_MODE</span> can only be changed one step at a <span class="token keyword">time</span>: <span class="token keyword">OFF</span> <span class="token operator">&lt;</span><span class="token operator">-</span><span class="token operator">></span> OFF_PERMISSIVE <span class="token operator">&lt;</span><span class="token operator">-</span><span class="token operator">></span> ON_PERMISSIVE <span class="token operator">&lt;</span><span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">ON</span><span class="token punctuation">.</span> Also note that this <span class="token keyword">value</span> must be stepped up <span class="token operator">or</span> down simultaneously <span class="token keyword">on</span> <span class="token keyword">all</span> servers<span class="token punctuation">.</span> See the Manual <span class="token keyword">for</span> instructions<span class="token punctuation">.</span>mysql<span class="token operator">></span> <span class="token keyword">set</span> <span class="token keyword">global</span> gtid_mode<span class="token operator">=</span><span class="token string">'OFF_PERMISSIVE'</span><span class="token punctuation">;</span>Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.11</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">set</span> <span class="token keyword">global</span> gtid_mode<span class="token operator">=</span><span class="token string">'ON_PERMISSIVE'</span><span class="token punctuation">;</span>Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.03</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">set</span> <span class="token keyword">global</span> gtid_mode<span class="token operator">=</span><span class="token string">'ON'</span><span class="token punctuation">;</span>ERROR <span class="token number">3111</span> <span class="token punctuation">(</span>HY000<span class="token punctuation">)</span>: <span class="token keyword">SET</span> @<span class="token variable">@GLOBAL.GTID_MODE</span> <span class="token operator">=</span> <span class="token keyword">ON</span> <span class="token operator">is</span> <span class="token operator">not</span> allowed because ENFORCE_GTID_CONSISTENCY <span class="token operator">is</span> <span class="token operator">not</span> <span class="token keyword">ON</span><span class="token punctuation">.</span>mysql<span class="token operator">></span> <span class="token keyword">set</span> <span class="token keyword">global</span> enforce_gtid_consistency<span class="token operator">=</span><span class="token string">'ON'</span><span class="token punctuation">;</span>Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">set</span> <span class="token keyword">global</span> gtid_mode<span class="token operator">=</span><span class="token string">'ON'</span><span class="token punctuation">;</span>Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.03</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'gtid_mode'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">---------------+-------+</span><span class="token operator">|</span> Variable_name <span class="token operator">|</span> <span class="token keyword">Value</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">---------------+-------+</span><span class="token operator">|</span> gtid_mode     <span class="token operator">|</span> <span class="token keyword">ON</span>    <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">---------------+-------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'enforce_gtid_consistency'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">--------------------------+-------+</span><span class="token operator">|</span> Variable_name            <span class="token operator">|</span> <span class="token keyword">Value</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------------------+-------+</span><span class="token operator">|</span> enforce_gtid_consistency <span class="token operator">|</span> <span class="token keyword">ON</span>    <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">--------------------------+-------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="怎么查看GTID"><a href="#怎么查看GTID" class="headerlink" title="怎么查看GTID"></a>怎么查看GTID</h5><p>GTID是存在binlog中的，所以怎么查看binlog的，就怎么查看GTID</p><p>我们知道GTID默认是关闭的，所以下面展示，在关闭GTID模式下，和开启GTID模式下，分别是什么样的</p><p>关闭GTID模式下</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> binlog events <span class="token operator">in</span> <span class="token string">'xxx-bin.000002'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----------------+------+----------------+-----------+-------------+--------------------------------------+</span><span class="token operator">|</span> Log_name       <span class="token operator">|</span> Pos  <span class="token operator">|</span> Event_type     <span class="token operator">|</span> Server_id <span class="token operator">|</span> End_log_pos <span class="token operator">|</span> Info                                 <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----------------+------+----------------+-----------+-------------+--------------------------------------+</span><span class="token operator">|</span> xxx<span class="token operator">-</span>bin<span class="token punctuation">.</span><span class="token number">000002</span> <span class="token operator">|</span> <span class="token number">5043</span> <span class="token operator">|</span> Anonymous_Gtid <span class="token operator">|</span>         <span class="token number">1</span> <span class="token operator">|</span>        <span class="token number">5122</span> <span class="token operator">|</span> <span class="token keyword">SET</span> @<span class="token variable">@SESSION.GTID_NEXT</span><span class="token operator">=</span> <span class="token string">'ANONYMOUS'</span> <span class="token operator">|</span><span class="token operator">|</span> xxx<span class="token operator">-</span>bin<span class="token punctuation">.</span><span class="token number">000002</span> <span class="token operator">|</span> <span class="token number">5122</span> <span class="token operator">|</span> Query          <span class="token operator">|</span>         <span class="token number">1</span> <span class="token operator">|</span>        <span class="token number">5203</span> <span class="token operator">|</span> <span class="token keyword">BEGIN</span>                                <span class="token operator">|</span><span class="token operator">|</span> xxx<span class="token operator">-</span>bin<span class="token punctuation">.</span><span class="token number">000002</span> <span class="token operator">|</span> <span class="token number">5203</span> <span class="token operator">|</span> Table_map      <span class="token operator">|</span>         <span class="token number">1</span> <span class="token operator">|</span>        <span class="token number">5251</span> <span class="token operator">|</span> table_id: <span class="token number">169</span> <span class="token punctuation">(</span>zs<span class="token punctuation">.</span>t<span class="token punctuation">)</span>                 <span class="token operator">|</span><span class="token operator">|</span> xxx<span class="token operator">-</span>bin<span class="token punctuation">.</span><span class="token number">000002</span> <span class="token operator">|</span> <span class="token number">5251</span> <span class="token operator">|</span> Delete_rows    <span class="token operator">|</span>         <span class="token number">1</span> <span class="token operator">|</span>        <span class="token number">5299</span> <span class="token operator">|</span> table_id: <span class="token number">169</span> flags: STMT_END_F      <span class="token operator">|</span><span class="token operator">|</span> xxx<span class="token operator">-</span>bin<span class="token punctuation">.</span><span class="token number">000002</span> <span class="token operator">|</span> <span class="token number">5299</span> <span class="token operator">|</span> Xid            <span class="token operator">|</span>         <span class="token number">1</span> <span class="token operator">|</span>        <span class="token number">5330</span> <span class="token operator">|</span> <span class="token keyword">COMMIT</span> <span class="token comment">/* xid=1924 */</span>                <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----------------+------+----------------+-----------+-------------+--------------------------------------+</span><span class="token number">74</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>开启GTID模式下</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> binlog events <span class="token operator">in</span> <span class="token string">'xxx-bin.000005'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------+</span><span class="token operator">|</span> Log_name       <span class="token operator">|</span> Pos <span class="token operator">|</span> Event_type     <span class="token operator">|</span> Server_id <span class="token operator">|</span> End_log_pos <span class="token operator">|</span> Info                                                              <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------+</span><span class="token operator">|</span> xxx<span class="token operator">-</span>bin<span class="token punctuation">.</span><span class="token number">000005</span> <span class="token operator">|</span>   <span class="token number">4</span> <span class="token operator">|</span> Format_desc    <span class="token operator">|</span>         <span class="token number">1</span> <span class="token operator">|</span>         <span class="token number">125</span> <span class="token operator">|</span> Server ver: <span class="token number">8.0</span><span class="token number">.26</span><span class="token punctuation">,</span> Binlog ver: <span class="token number">4</span>                                 <span class="token operator">|</span><span class="token operator">|</span> xxx<span class="token operator">-</span>bin<span class="token punctuation">.</span><span class="token number">000005</span> <span class="token operator">|</span> <span class="token number">125</span> <span class="token operator">|</span> Previous_gtids <span class="token operator">|</span>         <span class="token number">1</span> <span class="token operator">|</span>         <span class="token number">156</span> <span class="token operator">|</span>                                                                   <span class="token operator">|</span><span class="token operator">|</span> xxx<span class="token operator">-</span>bin<span class="token punctuation">.</span><span class="token number">000005</span> <span class="token operator">|</span> <span class="token number">156</span> <span class="token operator">|</span> Gtid           <span class="token operator">|</span>         <span class="token number">1</span> <span class="token operator">|</span>         <span class="token number">235</span> <span class="token operator">|</span> <span class="token keyword">SET</span> @<span class="token variable">@SESSION.GTID_NEXT</span><span class="token operator">=</span> <span class="token string">'13b96d6b-59ac-11ed-88d6-8c8caa828ba8:1'</span> <span class="token operator">|</span><span class="token operator">|</span> xxx<span class="token operator">-</span>bin<span class="token punctuation">.</span><span class="token number">000005</span> <span class="token operator">|</span> <span class="token number">235</span> <span class="token operator">|</span> Query          <span class="token operator">|</span>         <span class="token number">1</span> <span class="token operator">|</span>         <span class="token number">317</span> <span class="token operator">|</span> <span class="token keyword">BEGIN</span>                                                             <span class="token operator">|</span><span class="token operator">|</span> xxx<span class="token operator">-</span>bin<span class="token punctuation">.</span><span class="token number">000005</span> <span class="token operator">|</span> <span class="token number">317</span> <span class="token operator">|</span> Table_map      <span class="token operator">|</span>         <span class="token number">1</span> <span class="token operator">|</span>         <span class="token number">365</span> <span class="token operator">|</span> table_id: <span class="token number">170</span> <span class="token punctuation">(</span>zs<span class="token punctuation">.</span>t<span class="token punctuation">)</span>                                              <span class="token operator">|</span><span class="token operator">|</span> xxx<span class="token operator">-</span>bin<span class="token punctuation">.</span><span class="token number">000005</span> <span class="token operator">|</span> <span class="token number">365</span> <span class="token operator">|</span> Update_rows    <span class="token operator">|</span>         <span class="token number">1</span> <span class="token operator">|</span>         <span class="token number">427</span> <span class="token operator">|</span> table_id: <span class="token number">170</span> flags: STMT_END_F                                   <span class="token operator">|</span><span class="token operator">|</span> xxx<span class="token operator">-</span>bin<span class="token punctuation">.</span><span class="token number">000005</span> <span class="token operator">|</span> <span class="token number">427</span> <span class="token operator">|</span> Xid            <span class="token operator">|</span>         <span class="token number">1</span> <span class="token operator">|</span>         <span class="token number">458</span> <span class="token operator">|</span> <span class="token keyword">COMMIT</span> <span class="token comment">/* xid=2224 */</span>                                             <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------+</span><span class="token number">7</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中<code>SET @@SESSION.GTID_NEXT=</code>后面跟的值，就是GTID的值，那么为啥这俩不一样呢，GTID是怎么生成的呢？下面介绍</p><h5 id="GTID是如何生成的"><a href="#GTID是如何生成的" class="headerlink" title="GTID是如何生成的"></a>GTID是如何生成的</h5><p>在没有开启GTID模式下，GTID的值，永远都是：<code>ANONYMOUS</code>，这个单词的意思是：匿名的;不知姓名的;名字不公开的;不具名的;没有特色的</p><p>在 开启GTID 模式下，每个事务都会跟一个 GTID 一一对应。这个时候， GTID 有两种生成方式，而使用哪种方式取决于 session 变量 gtid_next 的值。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'gtid_next'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">---------------+-----------+</span><span class="token operator">|</span> Variable_name <span class="token operator">|</span> <span class="token keyword">Value</span>     <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">---------------+-----------+</span><span class="token operator">|</span> gtid_next     <span class="token operator">|</span> AUTOMATIC <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">---------------+-----------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>gtid_next 是session级别的变量，不是全局global的变量，怎么验证呢，可以用下面的命令</p><blockquote><p>show variables like ‘gtid_next’;       &lt;&#x3D;&#x3D;等价于&#x3D;&#x3D;&gt;    select @@gtid_next</p></blockquote><p>使用 select 命令，也可以查看变量的值，并且还可以验证当前变量是否是全局变量</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">select</span> @<span class="token variable">@gtid_next</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">-------------+</span><span class="token operator">|</span> @<span class="token variable">@gtid_next</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-------------+</span><span class="token operator">|</span> AUTOMATIC   <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">select</span> @<span class="token variable">@global.gtid_next</span><span class="token punctuation">;</span>ERROR <span class="token number">1238</span> <span class="token punctuation">(</span>HY000<span class="token punctuation">)</span>: Variable <span class="token string">'gtid_next'</span> <span class="token operator">is</span> a <span class="token keyword">SESSION</span> variable<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么<code>gtid_next</code>都有哪些取值呢？</p><ul><li><code>AUTOMATIC</code>：当设置为AUTOMATIC时(默认值)时，系统会自动分配一个GTID，如果事务回滚或者没有写入到binlog文件时则不会分配</li><li><code>具体的GTID值</code>：可以设置该变量为一个具体的有效的GTID，这时服务器会将该GTID分配给下一个事务，就算该事务没有被写入binlog日志或者为空事务，该GTID也会被分配</li></ul><h5 id="GTID集合"><a href="#GTID集合" class="headerlink" title="GTID集合"></a>GTID集合</h5><p>在每一个mysql的实例上，都有两个关于GTID的集合：</p><ul><li><code>gtid_executed</code>：是在当前服务器上执行成功的事务的GTID集合</li><li><code>gtid_purged</code>：是那些已经在当前服务器上提交的，但已经不存在于binlog文件中了（可能是人工删的，也可能是系统自动删的，这里不展开说了）</li></ul><p>GTID集合的格式：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">select</span> @<span class="token variable">@gtid_executed</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">------------------------------------------+</span><span class="token operator">|</span> @<span class="token variable">@gtid_executed</span>                          <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">------------------------------------------+</span><span class="token operator">|</span> <span class="token number">13</span>b96d6b<span class="token operator">-</span><span class="token number">59</span>ac<span class="token operator">-</span><span class="token number">11</span>ed<span class="token operator">-</span><span class="token number">88</span>d6<span class="token operator">-</span><span class="token number">8</span>c8caa828ba8:<span class="token number">1</span><span class="token operator">-</span><span class="token number">3</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">------------------------------------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="GTID-的基本用法"><a href="#GTID-的基本用法" class="headerlink" title="GTID 的基本用法"></a>GTID 的基本用法</h5><p>用一个例子，来描述GTID的基本用法</p><p>要先开启GTID模式哦，并且设置：<code>gtid_next=AUTOMATIC</code></p><p>在实例 X 中创建一个表 t，并初始化一条数据</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>t<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>c<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行完之后，这条insert语句，就会记录一个binlog，并且有GTID</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> master <span class="token keyword">status</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">------------------+----------+--------------+------------------+--------------------------------------------+</span><span class="token operator">|</span> <span class="token keyword">File</span>             <span class="token operator">|</span> Position <span class="token operator">|</span> Binlog_Do_DB <span class="token operator">|</span> Binlog_Ignore_DB <span class="token operator">|</span> Executed_Gtid_Set                          <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">------------------+----------+--------------+------------------+--------------------------------------------+</span><span class="token operator">|</span> xxxxx<span class="token operator">-</span>bin<span class="token punctuation">.</span><span class="token number">000005</span> <span class="token operator">|</span>     <span class="token number">1349</span> <span class="token operator">|</span>              <span class="token operator">|</span>                  <span class="token operator">|</span> <span class="token number">13</span>b96d6b<span class="token operator">-</span><span class="token number">59</span>ac<span class="token operator">-</span><span class="token number">11</span>ed<span class="token operator">-</span><span class="token number">88</span>d6<span class="token operator">-</span><span class="token number">8</span>c8caa828ba8:<span class="token number">1</span><span class="token operator">-</span><span class="token number">8</span>   <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">------------------+----------+--------------+------------------+--------------------------------------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">show</span> binlog events <span class="token operator">in</span> <span class="token string">'xxxxx-bin.000005'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">------------------+------+----------------+-----------+-------------+-------------------------------------------------------------------+</span><span class="token operator">|</span> Log_name         <span class="token operator">|</span> Pos  <span class="token operator">|</span> Event_type     <span class="token operator">|</span> Server_id <span class="token operator">|</span> End_log_pos <span class="token operator">|</span> Info                                                              <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">------------------+------+----------------+-----------+-------------+-------------------------------------------------------------------+</span><span class="token operator">|</span> xxxxx<span class="token operator">-</span>bin<span class="token punctuation">.</span><span class="token number">000005</span> <span class="token operator">|</span>    <span class="token number">4</span> <span class="token operator">|</span> Format_desc    <span class="token operator">|</span>         <span class="token number">1</span> <span class="token operator">|</span>         <span class="token number">125</span> <span class="token operator">|</span> Server ver: <span class="token number">8.0</span><span class="token number">.26</span><span class="token punctuation">,</span> Binlog ver: <span class="token number">4</span>                                 <span class="token operator">|</span><span class="token operator">|</span> xxxxx<span class="token operator">-</span>bin<span class="token punctuation">.</span><span class="token number">000005</span> <span class="token operator">|</span>  <span class="token number">125</span> <span class="token operator">|</span> Previous_gtids <span class="token operator">|</span>         <span class="token number">1</span> <span class="token operator">|</span>         <span class="token number">156</span> <span class="token operator">|</span>                                                                   <span class="token operator">|</span><span class="token operator">|</span> xxxxx<span class="token operator">-</span>bin<span class="token punctuation">.</span><span class="token number">000005</span> <span class="token operator">|</span>  <span class="token number">156</span> <span class="token operator">|</span> Gtid           <span class="token operator">|</span>         <span class="token number">1</span> <span class="token operator">|</span>         <span class="token number">235</span> <span class="token operator">|</span> <span class="token keyword">SET</span> @<span class="token variable">@SESSION.GTID_NEXT</span><span class="token operator">=</span> <span class="token string">'13b96d6b-59ac-11ed-88d6-8c8caa828ba8:8'</span> <span class="token operator">|</span><span class="token operator">|</span> xxxxx<span class="token operator">-</span>bin<span class="token punctuation">.</span><span class="token number">000005</span> <span class="token operator">|</span>  <span class="token number">235</span> <span class="token operator">|</span> Query          <span class="token operator">|</span>         <span class="token number">1</span> <span class="token operator">|</span>         <span class="token number">317</span> <span class="token operator">|</span> <span class="token keyword">BEGIN</span>                                                             <span class="token operator">|</span><span class="token operator">|</span> xxxxx<span class="token operator">-</span>bin<span class="token punctuation">.</span><span class="token number">000005</span> <span class="token operator">|</span>  <span class="token number">317</span> <span class="token operator">|</span> Table_map      <span class="token operator">|</span>         <span class="token number">1</span> <span class="token operator">|</span>         <span class="token number">365</span> <span class="token operator">|</span> table_id: <span class="token number">170</span> <span class="token punctuation">(</span>zs<span class="token punctuation">.</span>t<span class="token punctuation">)</span>                                              <span class="token operator">|</span><span class="token operator">|</span> xxxxx<span class="token operator">-</span>bin<span class="token punctuation">.</span><span class="token number">000005</span> <span class="token operator">|</span>  <span class="token number">365</span> <span class="token operator">|</span> Update_rows    <span class="token operator">|</span>         <span class="token number">1</span> <span class="token operator">|</span>         <span class="token number">427</span> <span class="token operator">|</span> table_id: <span class="token number">170</span> flags: STMT_END_F                                   <span class="token operator">|</span><span class="token operator">|</span> xxxxx<span class="token operator">-</span>bin<span class="token punctuation">.</span><span class="token number">000005</span> <span class="token operator">|</span>  <span class="token number">427</span> <span class="token operator">|</span> Xid            <span class="token operator">|</span>         <span class="token number">1</span> <span class="token operator">|</span>         <span class="token number">458</span> <span class="token operator">|</span> <span class="token keyword">COMMIT</span> <span class="token comment">/* xid=2224 */</span>                                             <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">------------------+------+----------------+-----------+-------------+-------------------------------------------------------------------+</span><span class="token number">7</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设，现在这个实例 X 是另外一个实例 A 的从库，并且此时在实例 A 上执行了下面这条插入语句：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">insert</span> <span class="token keyword">into</span> t <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>并且，这条语句在实例 A 上的 GTID 是 <code>aaa-bbb-ccc-ddd-eee:10</code></p><p>那么，实例 X 作为 A 的从库，就要同步这个事务过来执行，显然会出现主键冲突，导致实例 X 的同步线程停止。这时，我们应该怎么处理呢？</p><p>处理方法就是，DBA手动执行下面的这个语句序列：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">set</span> gtid_next<span class="token operator">=</span><span class="token string">'aaa-bbb-ccc-ddd-eee:10'</span><span class="token punctuation">;</span><span class="token keyword">begin</span><span class="token punctuation">;</span><span class="token keyword">commit</span><span class="token punctuation">;</span><span class="token keyword">set</span> gtid_next<span class="token operator">=</span>automatic<span class="token punctuation">;</span><span class="token keyword">start</span> slave<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，前三条语句的作用，是通过提交一个空事务，把这个 GTID 加到实例 X 的 GTID 集合中。</p><p>这样，在次在实例 X 上执行<code>start slave</code>开始同步的时候（因为之前主键冲突，实例X上的同步线程停止了），就会跳过这个<code>aaa-bbb-ccc-ddd-eee:10</code>了，避免了主键冲突。</p><p>在上面的这个语句序列中，start slave 命令之前还有一句 set gtid_next&#x3D;automatic。这句话的作用是“恢复 GTID 的默认分配行为”，也就是说如果之后有新的事务再执行，就还是按照原来的分配方式。</p><h5 id="基于GTID的同步"><a href="#基于GTID的同步" class="headerlink" title="基于GTID的同步"></a>基于GTID的同步</h5><p>了解了GTID，再来看一下基于GTID的切换，是什么样的？</p><p>上面已经列出了 基于 GTID同步的语句，这里在展示一下</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CHANGE MASTER <span class="token keyword">TO</span> MASTER_HOST<span class="token operator">=</span>$host_name MASTER_PORT<span class="token operator">=</span>$port MASTER_USER<span class="token operator">=</span>$user_name MASTER_PASSWORD<span class="token operator">=</span>$password master_auto_position<span class="token operator">=</span><span class="token number">1</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用GTID进行同步的话，就比较简单了，只需要指定<code>master_auto_position=1 </code>就可以了。表示这个主备关系使用的是 GTID 协议。</p><p>当主库A挂掉后，此时假设，新主库 A1的 GTID 集合（gtid_executed）记为 set_a1，从库 B 的 GTID 集合（gtid_executed）记为 set_b。接下来，我们就看看现在的主备切换逻辑。</p><ul><li>实例 B 指定主库 A1，基于主备协议建立连接</li><li>实例 B 把 set_b 发给主库 A1</li><li>实例 A1算出 set_a 与 set_b 的差集，也就是所有存在于 set_a，但是不存在于 set_b 的 GTID 的集合</li><li>实例A1判断这个差集需要的所有 binlog 事务在A1中的binlog是否全都存在（可能人为删除了，可能系统自动删除了，这里不展示说）<ul><li>不全都存在：直接返回错误（在基于 GTID 的主备关系里，系统认为只要建立主备关系，就必须保证主库发给备库的日志是完整的。）</li><li>全都存在：A1 从自己的 binlog 文件里面，找出第一个不在 set_b 的事务，发给 B</li></ul></li><li>之后就从这个事务开始，往后读文件，按顺序取 binlog 发给 B 去执行。</li></ul><p>之后这个系统就由新主库 A1写入，主库 A1的自己生成的 binlog 中的 GTID 集合格式是：<code>server_uuid_of_A1:1-M</code></p><p>因为之前从库 B 的主库是A，所以之前B的 GTID 集合格式是 <code>server_uuid_of_A:1-N</code></p><p>那么把主库切换到从库A1之后 GTID 集合的格式就变成了 <code>server_uuid_of_A:1-N, server_uuid_of_A1:1-M</code></p><p>当然，主库 A1之前也是 A 的备库，因此主库 A1和从库 B 的 GTID 集合是一样的。这就达到了我们预期。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">select</span> @<span class="token variable">@gtid_executed</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">---------------------------------------------+</span><span class="token operator">|</span> @<span class="token variable">@gtid_executed</span>                             <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">---------------------------------------------+</span><span class="token operator">|</span> server_uuid_of_A:<span class="token number">1</span><span class="token operator">-</span>N<span class="token punctuation">,</span> server_uuid_of_A1:<span class="token number">1</span><span class="token operator">-</span>M <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">---------------------------------------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="对比位点和GTID同步"><a href="#对比位点和GTID同步" class="headerlink" title="对比位点和GTID同步"></a>对比位点和GTID同步</h4><table><thead><tr><th>基于位点的同步</th><th>基于GTID的同步</th></tr></thead><tbody><tr><td>-</td><td>需要开启GTID模式</td></tr><tr><td>需要从库去主库找位点，而且不准确</td><td>使用GTID集合，由<strong>主库</strong>内部判断，很准确</td></tr><tr><td>操作复杂，change master还需要指定binlog文件和位点</td><td>change master只需要指向新主库即可</td></tr><tr><td>不做日志的完整性判断，基于位点的协议，是由备库决定的，备库指定哪个位点，主库就发哪个位点，不做日志的完整性判断。</td><td>做日志的完整性判断。在基于 GTID 的主备关系里，系统认为只要建立主备关系，就必须保证主库发给备库的日志是完整的。因此，如果实例 B 需要的日志已经不存在，A’就拒绝把日志发给 B。</td></tr></tbody></table><h2 id="读写分离（一主多从的应用场景）"><a href="#读写分离（一主多从的应用场景）" class="headerlink" title="读写分离（一主多从的应用场景）"></a>读写分离（一主多从的应用场景）</h2><h3 id="什么是读写分离"><a href="#什么是读写分离" class="headerlink" title="什么是读写分离"></a>什么是读写分离</h3><p>在写少读多的场景下，写入一般是有主库负责，然后在主库上有很多从库，从库提供只读功能，供业务查询</p><h3 id="读写分离的架构"><a href="#读写分离的架构" class="headerlink" title="读写分离的架构"></a>读写分离的架构</h3><h4 id="直连架构"><a href="#直连架构" class="headerlink" title="直连架构"></a>直连架构</h4><p>客户端（client）主动做负载均衡，这种模式下一般会把数据库的连接信息放在客户端的连接层。也就是说，由客户端来选择后端数据库进行查询。</p><pre class="mermaid">flowchart TDclient-->|write|mysqlAmysqlA-.->mysqlA1mysqlA1-.->mysqlAclient-->|read|mysqlBclient-->|read|mysqlCclient-->|read|mysqlDmysqlA-.->mysqlBmysqlA-.->mysqlCmysqlA-.->mysqlD</pre><h4 id="proxy架构"><a href="#proxy架构" class="headerlink" title="proxy架构"></a>proxy架构</h4><p>在 MySQL 和客户端之间有一个中间代理层 proxy，客户端只连接 proxy， 由 proxy 根据请求类型和上下文决定请求的分发路由。</p><pre class="mermaid">flowchart TDclient-->proxyproxy-->|write|mysqlAmysqlA-.->mysqlA1mysqlA1-.->mysqlAproxy-->|read|mysqlBproxy-->|read|mysqlCproxy-->|read|mysqlDmysqlA-.->mysqlBmysqlA-.->mysqlCmysqlA-.->mysqlD</pre><table><thead><tr><th>直连结构</th><th>proxy结构</th></tr></thead><tbody><tr><td>少了一层 proxy 转发，所以查询性能稍微好一点儿</td><td>对客户端比较友好</td></tr><tr><td>架构简单，排查问题方便</td><td>架构复杂，因为还需要维护proxy的高可用</td></tr><tr><td>高可用查，在出现主备切换、库迁移等操作的时候，客户端都会感知到，并且需要调整数据库连接信息</td><td></td></tr></tbody></table><h3 id="读写分离的缺点（过期读）"><a href="#读写分离的缺点（过期读）" class="headerlink" title="读写分离的缺点（过期读）"></a>读写分离的缺点（过期读）</h3><p>不论使用哪种架构，你都会碰到我们今天要讨论的问题：由于主从可能存在延迟，客户端执行完一个更新事务后马上发起查询，如果查询选择的是从库的话，就有可能读到刚刚的事务更新之前的状态。</p><p>过期读的产生原因是因为：<strong>主备延迟</strong>。</p><ul><li>可以通过上文介绍的方法，来避免主备延迟：<a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E4%BA%A7%E7%94%9F%E4%B8%BB%E5%A4%87%E5%BB%B6%E8%BF%9F">为什么会产生主备延迟</a><ul><li>复习：为什么会产生主备延迟：备库机器差，大事务，备库压力大（有读业务），并行复制能力</li></ul></li><li>但是呢，主备延迟，并不能100%的避免</li></ul><p>主备延迟不能100%的避免，那怎么解决过期读呢？</p><h3 id="过期读的解决方案"><a href="#过期读的解决方案" class="headerlink" title="过期读的解决方案"></a>过期读的解决方案</h3><ul><li>强制走主库方案</li><li>sleep方案</li><li>判断主备无延迟方案（配合semi-sync方案）</li><li>等主库位点方案</li><li>等GTID方案</li></ul><h4 id="强制走主库方案"><a href="#强制走主库方案" class="headerlink" title="强制走主库方案"></a>强制走主库方案</h4><p>将请求分为两类：</p><ul><li>一类是：必须要拿到最新结果的请求</li><li>一类是：可以读到旧数据的请求</li><li>对于第一类，强制将其发到主库上。对于第二类，将其发到从库上。</li></ul><h4 id="sleep方案"><a href="#sleep方案" class="headerlink" title="sleep方案"></a>sleep方案</h4><p>在更新成功，客户端发起查询请求的时候，对这个请求sleep一下，等待主备同步完成，在查询。这样就可以返回最新的结果了。</p><ul><li>存在的问题：sleep多少是一个问题？</li><li>如果sleep短了，去查询，仍然会有过期读；sleep多了，对用户的体验就很不好，感觉接口调用很慢</li></ul><h4 id="判断主备无延迟方案（配合semi-sync）"><a href="#判断主备无延迟方案（配合semi-sync）" class="headerlink" title="判断主备无延迟方案（配合semi-sync）"></a>判断主备无延迟方案（配合semi-sync）</h4><p>解决的思路是：主要主备没有延迟了，说明主备上的数据都是一样的了。</p><p>那么怎么确定主备无延迟了呢？</p><ul><li><p>通过 <code>show slave status</code>命令，以下是截取 <code>show slave status</code> 结果的部分截图。</p></li><li><p>&#96;&#96;&#96;sql</p><blockquote><p>show slave status<br>*************************** 1. row ***************************<br>           Slave_IO_State: Waiting for master to send event<br>              Master_Host: sh-dba-mysql-009<br>              Master_User: repl<br>              Master_Port: 3306<br>            Connect_Retry: 10<br>          Master_Log_File: mysql-bin.000001<br>      Read_Master_Log_Pos: 525<br>           Relay_Log_File: relay.000002<br>            Relay_Log_Pos: 738<br>    Relay_Master_Log_File: mysql-bin.000001<br>    ………………<br>      Exec_Master_Log_Pos: 525<br>    ………………<br>    Seconds_Behind_Master: 0<br>    ………………<br>       Retrieved_Gtid_Set: 456f3e13-6000-11e8-8bda-002272a443bb:1-2<br>        Executed_Gtid_Set: 456f3e13-6000-11e8-8bda-002272a443bb:1-2<br>            Auto_Position: 1<br>    ………………<br>1 row in set (0.00 sec)</p></blockquote><pre class="line-numbers language-none"><code class="language-none">- 有三种方法判断主备无延迟  - 第一种：通过&#96;Seconds_Behind_Master&#96;,但是它的单位是秒，如果你觉得精度不够的话，还有下面两个方案  - 第二种：通过对比位点的方式    - &#96;Master_Log_File&#96;和&#96;Read_Master_Log_Pos&#96;，表示的是读到的主库的最新位点；    - &#96;Relay_Master_Log_File&#96;和&#96;Exec_Master_Log_Pos&#96;，表示的是备库执行的最新位点。    - 如果上面两组值完全相同，说明主备无延迟。  - 第三种：通过对比GTID的方式    - &#96;Auto_Position&#x3D;1&#96; ，表示这对主备关系使用了 GTID 协议。    - &#96;Retrieved_Gtid_Set&#96;，是备库收到的所有日志的 GTID 集合；    - &#96;Executed_Gtid_Set&#96;，是备库所有已经执行完成的 GTID 集合。    - 如果这两个集合相同，说明主备无延迟。存在的问题：复习一下主备同步的流程：主库--&gt;binlog----(网络)---&gt;备库---&gt;relaylog---&gt;备库执行，主库产生的binlog要通过网络传给备库的，如果在传输的过程中，有一个查询过来了，通过这个方案，判断备库是没有延迟的，但是查出来的数据，仍然是过期读。**配合 semi-sync**要解决上面的问题，就要引入半同步复制，也就是 semi-sync replication：- 主库生成binlog，传给从库- 从库收到binlog之后，给主库一个ack- 主库收到ack之后，才给客户端返回“事务完成”的确认也就是说，如果启用了 semi-sync，就表示所有给客户端发送过确认的事务，都确保了备库已经收到了这个日志。这样，&#96;semi-sync&#96; 配合前面&#96;判断主备无延迟方案&#96;,就能够确定在从库上执行的查询请求，可以避免过期读。但是，&#96;semi-sync&#96;+&#96;判断主备无延迟方案&#96;只能适用于一主一备的场景。为什么呢？- 在一主多从的场景，主库只会受到一个从库返回的ack，就会给客户端返回事务提交确认了。- 当然，我们也可以设置为收到所有从库返回ack，但是这样，一个sql执行的代价就太大了。这样**如果查询落在了其他的从库上，还是避免不了过期读**。还有另一个问题，在业务高峰期，更新频率很快，&#96;判断主备无延迟&#96;可能一直不能成功，就会导致落在从库的查询，一直无法响应。还有一个问题，事务A在时刻A提交，事务B在时刻B提交，事务C在时刻C提交，由于事务一直在不停的产生和主备同步，这个时候，如果客户端来查询事务A的结果，此时，事务A早就已经完成了，但是由于&#96;主备无延迟&#96;判断不通过，事务A的结果一直无法返回。**问题：**- 一主多从的时候，在某些从库执行查询请求会存在过期读的现象；- 在更新频繁，持续延迟的情况下，主备延迟判断不通过，可能出现过度等待的问题。#### 等主库位点方案需要使用下面这个sql命令&#96;&#96;&#96;sqlselect master_pos_wait(file, pos, timeout);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>流程</p><ul><li>客户端发起查询请求，落在任意一个从库上，假设是<code>从库-C</code></li><li>在<code>从库-C</code>执行查询请求之前，先执行<code>show master status</code>得到当前主库执行到的 File 和 Position；</li><li>然后在当前<code>从库-C</code>上执行：<code>select master_pos_wait(file, pos, timeout);</code><ul><li>file：是第二步获取到的file</li><li>pos：是第二步获取到的Position</li><li>timeout：超时时间，单位秒，这个命令在超时时间内没返回，就返回-1</li></ul></li><li>在<code>从库-C</code>上的这个命令会返回一个值<ul><li>NULL：表示备库在同步执行期间，备库同步线程发生异常</li><li>-1：超时了，会返回-1</li><li>大于等于0的正整数：表示这个命令执行的时候，<code>从库-C</code>已经把主库上的这个日志同步完成了。</li></ul></li><li>如果返回值是 &gt;&#x3D;0 的正整数，则在这个从库执行查询语句；</li><li>否则，到主库执行查询语句。</li></ul><p>如果所有的从库都延迟超过 1 秒了，那查询压力不就都跑到主库上了吗？确实是这样。所以就需要业务开发同学做好限流策略了。</p><h4 id="等GTID-方案"><a href="#等GTID-方案" class="headerlink" title="等GTID 方案"></a>等GTID 方案</h4><p>需要使用下面这个sql语句</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> wait_for_executed_gtid_set<span class="token punctuation">(</span>gtid_set<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>流程：</p><ul><li>客户端发起查询请求，落在任意一个从库上，假设是<code>从库-C</code></li><li>在<code>从库-C</code>执行查询请求之前，先执行<code>select wait_for_executed_gtid_set(gtid_set, timeout);</code><ul><li>gtid_set：在前面等位点的方案中，是主动去主库执行 show master status。而5.7.6 版本开始，会把这个事务的 GTID 返回给客户端（需要设置<code>session_track_gtids</code>），这样等 GTID 的方案就可以减少一次查询。</li><li>timeout：超时时间，单位秒，这个命令在超时时间内没返回，就返回 1</li></ul></li><li>在<code>从库-C</code>上的这个命令会返回一个值<ul><li>等待，直到这个库执行的事务中包含传入的 gtid_set，返回 0</li><li>超时返回 1</li></ul></li><li>如果返回值是 0，则在这个从库执行查询语句；</li><li>否则，到主库执行查询语句。</li></ul><p>跟等主库位点的方案一样，等待超时后是否直接到主库查询，需要业务开发同学来做限流考虑。</p><h4 id="思考题-1"><a href="#思考题-1" class="headerlink" title="思考题"></a>思考题</h4><p>如果使用 GTID 等位点的方案做读写分离，在对大表做 DDL 的时候会怎么样。</p><ul><li>主库做DDL，典型的大事务，如果持续十分钟，那么从库就是延迟10分钟</li><li>在这10分钟内的所有请求，都会全部打到主库上</li><li>而主库正在做DDL，更加加重了主库的负担。</li></ul><p>解决：</p><ul><li>业务低峰期操作</li><li>使用gh-ots</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文有xmind，配合观看，效果更佳：&lt;a href=&quot;mysql%E7%9A%84%E4%B8%BB%E5%A4%87%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F.assets/Mysql%E4%B8%BB%</summary>
      
    
    
    
    <category term="JAVA" scheme="https://zspcer.gitee.io/categories/JAVA/"/>
    
    <category term="数据库" scheme="https://zspcer.gitee.io/categories/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MYSQL" scheme="https://zspcer.gitee.io/categories/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL/"/>
    
    
    <category term="读写分离" scheme="https://zspcer.gitee.io/tags/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    
    <category term="mysql" scheme="https://zspcer.gitee.io/tags/mysql/"/>
    
    <category term="主备一致" scheme="https://zspcer.gitee.io/tags/%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4/"/>
    
    <category term="高可用" scheme="https://zspcer.gitee.io/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
    <category term="主备切换" scheme="https://zspcer.gitee.io/tags/%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2/"/>
    
    <category term="主备延迟" scheme="https://zspcer.gitee.io/tags/%E4%B8%BB%E5%A4%87%E5%BB%B6%E8%BF%9F/"/>
    
    <category term="GTID" scheme="https://zspcer.gitee.io/tags/GTID/"/>
    
    <category term="binlog" scheme="https://zspcer.gitee.io/tags/binlog/"/>
    
  </entry>
  
  <entry>
    <title>mysql中的交集差集并集</title>
    <link href="https://zspcer.gitee.io/note/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL/mysql%E4%B8%AD%E7%9A%84%E4%BA%A4%E9%9B%86%E5%B7%AE%E9%9B%86%E5%B9%B6%E9%9B%86/"/>
    <id>https://zspcer.gitee.io/note/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL/mysql%E4%B8%AD%E7%9A%84%E4%BA%A4%E9%9B%86%E5%B7%AE%E9%9B%86%E5%B9%B6%E9%9B%86/</id>
    <published>2023-05-11T02:44:22.195Z</published>
    <updated>2023-05-11T02:44:22.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql中的交集差集并集"><a href="#mysql中的交集差集并集" class="headerlink" title="mysql中的交集差集并集"></a>mysql中的交集差集并集</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先要知道，mysql并不直接支持。</p><p>也就是没有什么 INTERSECT，EXCEPT等等等等（oracle中有）。</p><p>那么mysql怎么取交集并集和差集呢？</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>那么mysql怎么取交集并集和差集呢？</p><p>注意： mysql仅仅支持 UNION 和 UNION ALL 这两个操作。</p><p>所以，我们只能通过其他的手段对两个结果进行取交集差集和并集。</p><h3 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h3><p>可以直接使用 UNION 和 UNION ALL 这两个操作。</p><p>UNION 和 UNION ALL 运算：将查询的返回组合成一个结果</p><ul><li>UNION  合并结果并且将重复的内容取唯一</li><li>UNION ALL  合并结果并且没有过滤重复内容，速度更快</li></ul><h3 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h3><p>使用 UNION ALL 配合 GROUP BY 和 HAVING 进行查询</p><ul><li>两个集合的结构要一致,对应的字段数,字段类型</li><li>将两个集合用 UNION ALL 关键字合并,这里的结果是有重复的所有集</li><li>将上面的所有集 GROUP BY id</li><li>最后 HAVING COUNT(id)&#x3D;1,等于1的意思是只出现了一次,所以这个是差集,如果等于2,那么就是交集</li></ul><p>使用方法：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT a.* FROM ((结果集1) UNION ALL (结果集2)) a GROUP BY xxx HAVING COUNT(xxx) &#x3D; 2;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>还有一个方法，就是使用 IN ， 这个方法应该都可以理解。就不过多解释了。</p><p>(结果集1) WHERE xxx IN (结果集2) ;</p><p>注意：使用 IN 当数据量很大的时候，效率比较差</p><p>可以参考： <a href="https://blog.csdn.net/mine_song/article/details/70184072">https://blog.csdn.net/mine_song/article/details/70184072</a></p><h3 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h3><p>使用 UNION ALL 配合 GROUP BY 和 HAVING 进行查询</p><ul><li>两个集合的结构要一致,对应的字段数,字段类型</li><li>将两个集合用 UNION ALL 关键字合并,这里的结果是有重复的所有集</li><li>将上面的所有集 GROUP BY id</li><li>最后 HAVING COUNT(id)&#x3D;1,等于1的意思是只出现了一次,所以这个是差集,如果等于2,那么就是交集</li></ul><p>使用方法：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT a.* FROM ((结果集1) UNION ALL (结果集2)) a GROUP BY xxx HAVING COUNT(xxx) &#x3D; 1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>还有一个方法，就是使用 NOT IN ，</p><p>(结果集1) WHERE xxx NOT IN (结果集2) ;</p><p>注意：使用 NOT IN 当数据量很大的时候，效率比较差</p><p>这个方法应该都可以理解。就不过多解释了。可以参考： <a href="https://blog.csdn.net/mine_song/article/details/70184072">https://blog.csdn.net/mine_song/article/details/70184072</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mysql中的交集差集并集&quot;&gt;&lt;a href=&quot;#mysql中的交集差集并集&quot; class=&quot;headerlink&quot; title=&quot;mysql中的交集差集并集&quot;&gt;&lt;/a&gt;mysql中的交集差集并集&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; cla</summary>
      
    
    
    
    <category term="JAVA" scheme="https://zspcer.gitee.io/categories/JAVA/"/>
    
    <category term="数据库" scheme="https://zspcer.gitee.io/categories/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MYSQL" scheme="https://zspcer.gitee.io/categories/JAVA/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL/"/>
    
    
    <category term="mysql" scheme="https://zspcer.gitee.io/tags/mysql/"/>
    
    <category term="交集" scheme="https://zspcer.gitee.io/tags/%E4%BA%A4%E9%9B%86/"/>
    
    <category term="并集" scheme="https://zspcer.gitee.io/tags/%E5%B9%B6%E9%9B%86/"/>
    
    <category term="差集" scheme="https://zspcer.gitee.io/tags/%E5%B7%AE%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>【mybatis】解决mybatis-plus的分页问题</title>
    <link href="https://zspcer.gitee.io/note/JAVA/SSM/%E3%80%90mybatis%E3%80%91%E8%A7%A3%E5%86%B3mybatis-plus%E7%9A%84%E5%88%86%E9%A1%B5%E9%97%AE%E9%A2%98/"/>
    <id>https://zspcer.gitee.io/note/JAVA/SSM/%E3%80%90mybatis%E3%80%91%E8%A7%A3%E5%86%B3mybatis-plus%E7%9A%84%E5%88%86%E9%A1%B5%E9%97%AE%E9%A2%98/</id>
    <published>2023-05-11T02:44:22.055Z</published>
    <updated>2023-05-11T02:44:22.055Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>mybatis-plus的分页插件：</p><ul><li>默认只支持一页500条；</li><li>但凡是在代码中指定分页大于500的，统一当做500处理；</li></ul><h2 id="怎么解决"><a href="#怎么解决" class="headerlink" title="怎么解决"></a>怎么解决</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MybatisPlusConfig</span> <span class="token keyword">extends</span> <span class="token class-name">MybatisPlusBaseConfig</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">PaginationInterceptor</span> <span class="token function">paginationInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">PaginationInterceptor</span> paginationInterceptor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PaginationInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置最大单页限制数量，默认 500 条，-1 不受限制</span>        paginationInterceptor<span class="token punctuation">.</span><span class="token function">setLimit</span><span class="token punctuation">(</span><span class="token number">50000L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> paginationInterceptor<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在顺丰的框架中（sf-boot）：直接按照上面这样配置，会报错:</p><ul><li>因为<code>com.sf.boot.base.config.MybatisPlusBaseConfig</code>已经把这个分页插件注册进来了，我们自己在注册一遍，就会出现问题；</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Error</span> starting <span class="token class-name">ApplicationContext<span class="token punctuation">.</span> To</span> display the conditions report re<span class="token operator">-</span>run your application <span class="token keyword">with</span> <span class="token char">'debug'</span> enabled<span class="token punctuation">.</span><span class="token number">2022</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">25</span><span class="token constant">T19</span><span class="token operator">:</span><span class="token number">22</span><span class="token operator">:</span><span class="token number">41.054</span><span class="token operator">+</span><span class="token number">0800</span><span class="token operator">|</span><span class="token constant">ERROR</span><span class="token operator">|</span>main<span class="token operator">|</span><span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>diagnostics<span class="token punctuation">.</span></span>LoggingFailureAnalysisReporter</span><span class="token operator">||</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token constant">APPLICATION</span> <span class="token constant">FAILED</span> <span class="token constant">TO</span> <span class="token constant">START</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token class-name">Description</span><span class="token operator">:</span><span class="token class-name">The</span> bean 'performanceInterceptor'<span class="token punctuation">,</span> defined in <span class="token keyword">class</span> path resource <span class="token punctuation">[</span>com<span class="token operator">/</span>sf<span class="token operator">/</span>boot<span class="token operator">/</span>base<span class="token operator">/</span>config<span class="token operator">/</span><span class="token class-name">MybatisPlusBaseConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">]</span><span class="token punctuation">,</span> could not be <span class="token class-name"><span class="token namespace">registered<span class="token punctuation">.</span></span> A</span> bean <span class="token keyword">with</span> <span class="token namespace">that</span> name has already been defined in <span class="token keyword">class</span> path resource <span class="token punctuation">[</span>com<span class="token operator">/</span>sf<span class="token operator">/</span>fns<span class="token operator">/</span>nas<span class="token operator">/</span>amp<span class="token operator">/</span>config<span class="token operator">/</span><span class="token class-name">MybatisPlusConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">]</span> and overriding is <span class="token class-name"><span class="token namespace">disabled<span class="token punctuation">.</span></span>Action</span><span class="token operator">:</span><span class="token class-name">Consider</span> renaming one of the beans or enabling overriding by setting spring<span class="token punctuation">.</span>main<span class="token punctuation">.</span>allow<span class="token operator">-</span>bean<span class="token operator">-</span>definition<span class="token operator">-</span>overriding<span class="token operator">=</span><span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>怎么解决呢？</p><ul><li>方法一：开启spirng的bean重写配置<ul><li>不太靠谱，因为两个地方同时定义了一个bean ，使用bean的覆盖重写其实在某种情况下是很可能出事的。</li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">spring.main.allow-bean-definition-overriding&#x3D;true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>【目前我采用的】方法二：启动类中排除<code>com.sf.boot.base.config.MybatisPlusBaseConfig</code></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableFeignClients</span><span class="token punctuation">(</span>basePackages <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"com.xx.xxx.xxx"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@EnableTransactionManagement</span><span class="token annotation punctuation">@MapperScan</span><span class="token punctuation">(</span><span class="token string">"com.xx.xx.xx.xx.mapper"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token punctuation">(</span>exclude <span class="token operator">=</span> <span class="token class-name">MybatisPlusBaseConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppApplication</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SpringApplication</span><span class="token punctuation">(</span><span class="token class-name">AppApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        app<span class="token punctuation">.</span><span class="token function">setBannerMode</span><span class="token punctuation">(</span><span class="token class-name">Banner<span class="token punctuation">.</span>Mode</span><span class="token punctuation">.</span><span class="token constant">OFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        app<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="源码原因"><a href="#源码原因" class="headerlink" title="源码原因"></a>源码原因</h2><img src="【mybatis】解决mybatis-plus的分页问题.assets/image-20220825111404053.png" alt="image-20220825111404053" style="zoom:80%;" /><img src="【mybatis】解决mybatis-plus的分页问题.assets/image-20220825111444219.png" alt="image-20220825111444219" style="zoom:80%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h2&gt;&lt;p&gt;mybatis-plus的分页插件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认只支持一页500条；&lt;/li&gt;
&lt;li&gt;但凡是在代码中指定分页</summary>
      
    
    
    
    <category term="JAVA" scheme="https://zspcer.gitee.io/categories/JAVA/"/>
    
    <category term="SSM" scheme="https://zspcer.gitee.io/categories/JAVA/SSM/"/>
    
    
    <category term="mybatis-plus" scheme="https://zspcer.gitee.io/tags/mybatis-plus/"/>
    
    <category term="分页" scheme="https://zspcer.gitee.io/tags/%E5%88%86%E9%A1%B5/"/>
    
  </entry>
  
  <entry>
    <title>操作系统的基本原理</title>
    <link href="https://zspcer.gitee.io/note/LINUX/SYSTEM/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>https://zspcer.gitee.io/note/LINUX/SYSTEM/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</id>
    <published>2023-05-10T23:26:40.000Z</published>
    <updated>2023-05-11T02:44:22.308Z</updated>
    
    
    
    
    <category term="LINUX" scheme="https://zspcer.gitee.io/categories/LINUX/"/>
    
    <category term="SYSTEM" scheme="https://zspcer.gitee.io/categories/LINUX/SYSTEM/"/>
    
    
    <category term="操作系统" scheme="https://zspcer.gitee.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>JUC中线程的基础知识</title>
    <link href="https://zspcer.gitee.io/note/JAVA/JUC/JUC%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://zspcer.gitee.io/note/JAVA/JUC/JUC%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2023-05-08T23:23:46.000Z</published>
    <updated>2023-05-11T02:44:21.929Z</updated>
    
    <content type="html"><![CDATA[<p>创建线程的四种方式</p><p>线程的状态</p><ul><li>中断：wait，notify，sleep</li></ul><p>线程的优先级和守护线程</p><p>线程间的通信</p><p>线程池和自定义线程池</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;创建线程的四种方式&lt;/p&gt;
&lt;p&gt;线程的状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中断：wait，notify，sleep&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;线程的优先级和守护线程&lt;/p&gt;
&lt;p&gt;线程间的通信&lt;/p&gt;
&lt;p&gt;线程池和自定义线程池&lt;/p&gt;
</summary>
      
    
    
    
    <category term="JAVA" scheme="https://zspcer.gitee.io/categories/JAVA/"/>
    
    <category term="JUC" scheme="https://zspcer.gitee.io/categories/JAVA/JUC/"/>
    
    
    <category term="线程基础" scheme="https://zspcer.gitee.io/tags/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    <category term="JUC" scheme="https://zspcer.gitee.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC并发之ThreadLocal</title>
    <link href="https://zspcer.gitee.io/note/JAVA/JUC/JUC%E5%B9%B6%E5%8F%91%E4%B9%8BThreadLocal/"/>
    <id>https://zspcer.gitee.io/note/JAVA/JUC/JUC%E5%B9%B6%E5%8F%91%E4%B9%8BThreadLocal/</id>
    <published>2023-05-08T23:23:46.000Z</published>
    <updated>2023-05-11T02:44:21.954Z</updated>
    
    <content type="html"><![CDATA[<p>本文还有xmind，配合xmind食用，味道更佳：<a href="./%5CJUC%E5%B9%B6%E5%8F%91%E4%B9%8BThreadLocal.assets/ThreadLocal.xmind">ThreadLocal.xmind</a></p><img src="JUC并发之ThreadLocal.assets/image-20230509134256706.png" alt="image-20230509134256706" style="zoom: 67%;" /><p><strong>学习目标</strong></p><ul><li><strong>了解ThreadLocal的介绍</strong> </li><li><strong>了解ThreadLocal的内部结构</strong></li><li><strong>了解ThreadLocal的核心方法源码</strong></li><li><strong>了解ThreadLocalMap的源码</strong></li></ul><h2 id="ThreadLocal介绍"><a href="#ThreadLocal介绍" class="headerlink" title="ThreadLocal介绍"></a>ThreadLocal介绍</h2><h3 id="官方介绍"><a href="#官方介绍" class="headerlink" title="官方介绍"></a>官方介绍</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * This class provides thread-local variables.  These variables differ from * their normal counterparts in that each thread that accesses one (via its * &#123;@code get&#125; or &#123;@code set&#125; method) has its own, independently initialized * copy of the variable.  &#123;@code ThreadLocal&#125; instances are typically private * static fields in classes that wish to associate state with a thread (e.g., * a user ID or Transaction ID). * * &lt;p>For example, the class below generates unique identifiers local to each * thread. * A thread's id is assigned the first time it invokes &#123;@code ThreadId.get()&#125; * and remains unchanged on subsequent calls. * &lt;pre> * import java.util.concurrent.atomic.AtomicInteger; * * public class ThreadId &#123; *     // Atomic integer containing the next thread ID to be assigned *     private static final AtomicInteger nextId = new AtomicInteger(0); * *     // Thread local variable containing each thread's ID *     private static final ThreadLocal&amp;lt;Integer&amp;gt; threadId = *         new ThreadLocal&amp;lt;Integer&amp;gt;() &#123; *             &amp;#64;Override protected Integer initialValue() &#123; *                 return nextId.getAndIncrement(); *         &#125; *     &#125;; * *     // Returns the current thread's unique ID, assigning it if necessary *     public static int get() &#123; *         return threadId.get(); *     &#125; * &#125; * &lt;/pre> * &lt;p>Each thread holds an implicit reference to its copy of a thread-local * variable as long as the thread is alive and the &#123;@code ThreadLocal&#125; * instance is accessible; after a thread goes away, all of its copies of * thread-local instances are subject to garbage collection (unless other * references to these copies exist). * * @author  Josh Bloch and Doug Lea * @since   1.2 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​从Java官方文档中的描述：ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问（通过get和set方法访问）时能保证各个线程的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程上下文。</p><p>我们可以得知 ThreadLocal 的作用是：提供线程内的局部变量，不同的线程之间不会相互干扰，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或组件之间一些公共变量传递的复杂度。</p><p>总结:</p><ol><li>线程并发: 在多线程并发的场景下</li><li>传递数据: 我们可以通过ThreadLocal在同一线程，不同组件中传递公共变量</li><li>线程隔离: 每个线程的变量都是独立的，不会互相影响</li></ol><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>​在使用之前,我们先来认识几个ThreadLocal的常用方法</p><table><thead><tr><th>方法声明</th><th>描述</th></tr></thead><tbody><tr><td>ThreadLocal()</td><td>创建ThreadLocal对象</td></tr><tr><td>public void set( T value)</td><td>设置当前线程绑定的局部变量</td></tr><tr><td>public T get()</td><td>获取当前线程绑定的局部变量</td></tr><tr><td>public void remove()</td><td>移除当前线程绑定的局部变量</td></tr></tbody></table><h4 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h4><pre><code> 我们来看下面这个案例, 感受一下ThreadLocal 线程隔离的特点： </code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> content<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">getContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> content<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setContent</span><span class="token punctuation">(</span><span class="token class-name">String</span> content<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>content <span class="token operator">=</span> content<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">MyDemo</span> demo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    demo<span class="token punctuation">.</span><span class="token function">setContent</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"的数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-----------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"--->"</span> <span class="token operator">+</span> demo<span class="token punctuation">.</span><span class="token function">getContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            thread<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"线程"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印结果:</p><p><img src="/JUC%E5%B9%B6%E5%8F%91%E4%B9%8BThreadLocal.assets/002.png" alt="1574149020726"></p><p>​从结果可以看出多个线程在访问同一个变量的时候出现的异常，线程间的数据没有隔离。下面我们来看下采用 ThreadLocal 的方式来解决这个问题的例子。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> tl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> content<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">getContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> tl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setContent</span><span class="token punctuation">(</span><span class="token class-name">String</span> content<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         tl<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">MyDemo</span> demo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    demo<span class="token punctuation">.</span><span class="token function">setContent</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"的数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-----------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"--->"</span> <span class="token operator">+</span> demo<span class="token punctuation">.</span><span class="token function">getContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            thread<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"线程"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印结果: </p><p>​<img src="/JUC%E5%B9%B6%E5%8F%91%E4%B9%8BThreadLocal.assets/003.png" alt="1574149117289"></p><p>从结果来看，这样很好的解决了多线程之间数据隔离的问题，十分方便。</p><h2 id="ThreadLocal的整体流程分析"><a href="#ThreadLocal的整体流程分析" class="headerlink" title="ThreadLocal的整体流程分析"></a>ThreadLocal的整体流程分析</h2><p><img src="/JUC%E5%B9%B6%E5%8F%91%E4%B9%8BThreadLocal.assets/image-20230510225925531.png" alt="image-20230510225925531"></p><p>关键的三点</p><ul><li>ThreadLocal<T> 中有一个静态内部类：ThreadLocalMap</li><li>ThreadLocalMap 中有一个静态内部类 Entry；维护了数组：Entry[] table<ul><li>这个也是ThreadLocal的底层实现，用数组实现了一个map，也有hash冲突的解决，和扩容</li></ul></li><li>在set方法中有两个核心<ul><li>hash冲突是怎么解决的？</li><li>扩容的逻辑是怎么样的？</li></ul></li></ul><h2 id="ThreadLocal的内部结构"><a href="#ThreadLocal的内部结构" class="headerlink" title="ThreadLocal的内部结构"></a>ThreadLocal的内部结构</h2><p>​通过以上的学习，我们对ThreadLocal的作用有了一定的认识。现在我们一起来看一下ThreadLocal的内部结构，探究它能够实现线程数据隔离的原理。</p><h3 id="老版的设计"><a href="#老版的设计" class="headerlink" title="老版的设计"></a>老版的设计</h3><p>​如果我们不去看源代码的话，可能会猜测<code>ThreadLocal</code>是这样子设计的：每个<code>ThreadLocal</code>都创建一个<code>Map</code>，然后用线程作为<code>Map</code>的<code>key</code>，要存储的局部变量作为<code>Map</code>的<code>value</code>，这样就能达到各个线程的局部变量隔离的效果。这是最简单的设计方法，JDK最早期的<code>ThreadLocal</code> 确实是这样设计的，但现在早已不是了。</p><p><img src="/JUC%E5%B9%B6%E5%8F%91%E4%B9%8BThreadLocal.assets/image-20230509105547606.png" alt="image-20230509105547606"></p><h3 id="现在的设计"><a href="#现在的设计" class="headerlink" title="现在的设计"></a>现在的设计</h3><p>​但是，JDK后面优化了设计方案，在JDK8中 <code>ThreadLocal</code>的设计是：每个<code>Thread</code>维护一个<code>ThreadLocalMap</code>，这个Map的<code>key</code>是<code>ThreadLocal</code>实例本身，<code>value</code>才是真正要存储的值<code>Object</code>。</p><p>具体的过程是这样的：</p><p>​（1） 每个Thread线程内部都有一个Map (ThreadLocalMap)<br>​（2） Map里面存储ThreadLocal对象（key）和线程的变量副本（value）<br>​（3）Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。<br>​（4）对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。</p><p><img src="/JUC%E5%B9%B6%E5%8F%91%E4%B9%8BThreadLocal.assets/image-20230509105840948.png" alt="image-20230509105840948"></p><h3 id="这样设计的好处"><a href="#这样设计的好处" class="headerlink" title="这样设计的好处"></a>这样设计的好处</h3><p>​这个设计与我们一开始说的设计刚好相反，这样设计有如下两个优势：</p><p>（1） 这样设计之后每个<code>Map</code>存储的<code>Entry</code>数量就会变少。因为之前的存储数量由<code>Thread</code>的数量决定，现在是由<code>ThreadLocal</code>的数量决定。在实际运用当中，往往ThreadLocal的数量要少于Thread的数量。</p><p>（2） 当<code>Thread</code>销毁之后，对应的<code>ThreadLocalMap</code>也会随之销毁，能减少内存的使用。</p><h2 id="ThreadLocal的核心方法源码"><a href="#ThreadLocal的核心方法源码" class="headerlink" title="ThreadLocal的核心方法源码"></a>ThreadLocal的核心方法源码</h2><p>​基于ThreadLocal的内部结构，我们继续分析它的核心方法源码，更深入的了解其操作原理。</p><p>除了构造方法之外， ThreadLocal对外暴露的方法有以下4个：</p><table><thead><tr><th>方法声明</th><th>描述</th></tr></thead><tbody><tr><td>protected T initialValue()</td><td>返回当前线程局部变量的初始值</td></tr><tr><td>public void set( T value)</td><td>设置当前线程绑定的局部变量</td></tr><tr><td>public T get()</td><td>获取当前线程绑定的局部变量</td></tr><tr><td>public void remove()</td><td>移除当前线程绑定的局部变量</td></tr></tbody></table><p>​以下是这4个方法的详细源码分析(为了保证思路清晰, ThreadLocalMap部分暂时不展开,下一个知识点详解)</p><h3 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h3><p><strong>（1 ) 源码和对应的中文注释</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token comment">/**    * 设置当前线程对应的ThreadLocal的值    *    * @param value 将要保存在当前线程对应的ThreadLocal的值    */</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">T</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token comment">// 获取当前线程对象</span>       <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 获取此线程对象中维护的ThreadLocalMap对象</span>       <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 判断map是否存在</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>           <span class="token comment">// 存在则调用map.set设置此实体entry</span>           map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">else</span>           <span class="token comment">// 1）当前线程Thread 不存在ThreadLocalMap对象</span>           <span class="token comment">// 2）则调用createMap进行ThreadLocalMap对象的初始化</span>           <span class="token comment">// 3）并将 t(当前线程)和value(t对应的值)作为第一个entry存放至ThreadLocalMap中</span>           <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token comment">/**    * 获取当前线程Thread对应维护的ThreadLocalMap     *     * @param  t the current thread 当前线程    * @return the map 对应维护的ThreadLocalMap     */</span>   <span class="token class-name">ThreadLocalMap</span> <span class="token function">getMap</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">return</span> t<span class="token punctuation">.</span>threadLocals<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token comment">/**    *创建当前线程Thread对应维护的ThreadLocalMap     *    * @param t 当前线程    * @param firstValue 存放到map中第一个entry的值    */</span><span class="token keyword">void</span> <span class="token function">createMap</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> t<span class="token punctuation">,</span> <span class="token class-name">T</span> firstValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token comment">//这里的this是调用此方法的threadLocal</span>       t<span class="token punctuation">.</span>threadLocals <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalMap</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> firstValue<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>（2 )  代码执行流程</strong></p><p>​A. 首先获取当前线程，并根据当前线程获取一个Map</p><p>​B. 如果获取的Map不为空，则将参数设置到Map中（当前ThreadLocal的引用作为key）</p><p>​C. 如果Map为空，则给该线程创建 Map，并设置初始值</p><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><p><strong>（1 ) 源码和对应的中文注释</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 返回当前线程中保存ThreadLocal的值 * 如果当前线程没有此ThreadLocal变量， * 则它会通过调用&#123;@link #initialValue&#125; 方法进行初始化值 * * @return 返回当前线程对应此ThreadLocal的值 */</span><span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 获取当前线程对象</span>    <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取此线程对象中维护的ThreadLocalMap对象</span>    <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 如果此map存在</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 以当前的ThreadLocal 为 key，调用getEntry获取对应的存储实体e</span>        <span class="token class-name">ThreadLocalMap<span class="token punctuation">.</span>Entry</span> e <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 对e进行判空 </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>            <span class="token comment">// 获取存储实体 e 对应的 value值</span>            <span class="token comment">// 即为我们想要的当前线程对应此ThreadLocal的值</span>            <span class="token class-name">T</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span>e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/*    初始化 : 有两种情况有执行当前代码    第一种情况: map不存在，表示此线程没有维护的ThreadLocalMap对象    第二种情况: map存在, 但是没有与当前ThreadLocal关联的entry     */</span>    <span class="token keyword">return</span> <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 初始化 * * @return the initial value 初始化后的值 */</span><span class="token keyword">private</span> <span class="token class-name">T</span> <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 调用initialValue获取初始化的值</span>    <span class="token comment">// 此方法可以被子类重写, 如果不重写默认返回null</span>    <span class="token class-name">T</span> value <span class="token operator">=</span> <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取当前线程对象</span>    <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取此线程对象中维护的ThreadLocalMap对象</span>    <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 判断map是否存在</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token comment">// 存在则调用map.set设置此实体entry</span>        map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token comment">// 1）当前线程Thread 不存在ThreadLocalMap对象</span>        <span class="token comment">// 2）则调用createMap进行ThreadLocalMap对象的初始化</span>        <span class="token comment">// 3）并将 t(当前线程)和value(t对应的值)作为第一个entry存放至ThreadLocalMap中</span>        <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回设置的值value</span>    <span class="token keyword">return</span> value<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>（2 )  代码执行流程</strong> </p><p>​A. 首先获取当前线程, 根据当前线程获取一个Map</p><p>​B. 如果获取的Map不为空，则在Map中以ThreadLocal的引用作为key来在Map中获取对应的Entry e，否则转到D</p><p>​C. 如果e不为null，则返回e.value，否则转到D</p><p>​D. Map为空或者e为空，则通过initialValue函数获取初始值value，然后用ThreadLocal的引用和value作为firstKey和firstValue创建一个新的Map</p><p>总结:  <strong>先获取当前线程的 ThreadLocalMap 变量，如果存在则返回值，不存在则创建并返回初始值。</strong></p><h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><p><strong>（1 ) 源码和对应的中文注释</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**    * 删除当前线程中保存的ThreadLocal对应的实体entry    */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token comment">// 获取当前线程对象中维护的ThreadLocalMap对象</span>        <span class="token class-name">ThreadLocalMap</span> m <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 如果此map存在</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>           <span class="token comment">// 存在则调用map.remove</span>           <span class="token comment">// 以当前ThreadLocal为key删除对应的实体entry</span>            m<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>（2 )  代码执行流程</strong></p><p>​A. 首先获取当前线程，并根据当前线程获取一个Map</p><p>​B. 如果获取的Map不为空，则移除当前ThreadLocal对象对应的entry</p><h3 id="initialValue方法"><a href="#initialValue方法" class="headerlink" title="initialValue方法"></a><strong>initialValue方法</strong></h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**  * 返回当前线程对应的ThreadLocal的初始值    * 此方法的第一次调用发生在，当线程通过get方法访问此线程的ThreadLocal值时  * 除非线程先调用了set方法，在这种情况下，initialValue 才不会被这个线程调用。  * 通常情况下，每个线程最多调用一次这个方法。  *  * &lt;p>这个方法仅仅简单的返回null &#123;@code null&#125;;  * 如果程序员想ThreadLocal线程局部变量有一个除null以外的初始值，  * 必须通过子类继承&#123;@code ThreadLocal&#125; 的方式去重写此方法  * 通常, 可以通过匿名内部类的方式实现  *  * @return 当前ThreadLocal的初始值  */</span><span class="token keyword">protected</span> <span class="token class-name">T</span> <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​此方法的作用是 返回该线程局部变量的初始值。</p><p>（1） 这个方法是一个延迟调用方法，从上面的代码我们得知，在set方法还未调用而先调用了get方法时才执行，并且仅执行1次。</p><p>（2）这个方法缺省实现直接返回一个<code>null</code>。</p><p>（3）如果想要一个除null之外的初始值，可以重写此方法。（备注： 该方法是一个<code>protected</code>的方法，显然是为了让子类覆盖而设计的）</p><h2 id="ThreadLocalMap源码分析"><a href="#ThreadLocalMap源码分析" class="headerlink" title="ThreadLocalMap源码分析"></a>ThreadLocalMap源码分析</h2><p>​在分析ThreadLocal方法的时候，我们了解到ThreadLocal的操作实际上是围绕ThreadLocalMap展开的。ThreadLocalMap的源码相对比较复杂, 我们从以下三个方面进行讨论。</p><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>​ThreadLocalMap是ThreadLocal的内部类，没有实现Map接口，用独立的方式实现了Map的功能，其内部的Entry也是独立实现。</p><p><img src="/JUC%E5%B9%B6%E5%8F%91%E4%B9%8BThreadLocal.assets/image-20230509110912228.png" alt="image-20230509110912228"></p><p><strong>（1） 成员变量</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 初始容量 —— 必须是2的整次幂 */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">INITIAL_CAPACITY</span> <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span><span class="token comment">/** * 存放数据的table，Entry类的定义在下面分析 * 同样，数组长度必须是2的整次幂。 */</span><span class="token keyword">private</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span><span class="token comment">/** * 数组里面entrys的个数，可以用于判断table当前使用量是否超过阈值。 */</span><span class="token keyword">private</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">/** * 进行扩容的阈值，表使用量大于它的时候进行扩容。 */</span><span class="token keyword">private</span> <span class="token keyword">int</span> threshold<span class="token punctuation">;</span> <span class="token comment">// Default to 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​跟HashMap类似，INITIAL_CAPACITY代表这个Map的初始容量；table 是一个Entry 类型的数组，用于存储数据；size 代表表中的存储数目； threshold 代表需要扩容时对应 size 的阈值。</p><p>链接：<a href="https://www.jianshu.com/p/acfd2239c9f4">https://www.jianshu.com/p/acfd2239c9f4</a></p><p>来源：简书</p><p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p><strong>（2） 存储结构 - Entry</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/* * Entry继承WeakReference，并且用ThreadLocal作为key. * 如果key为null(entry.get() == null)，意味着key不再被引用， * 因此这时候entry也可以从table中清除。 */</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ThreadLocal</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">/** The value associated with this ThreadLocal. */</span>    <span class="token class-name">Object</span> value<span class="token punctuation">;</span>    <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> k<span class="token punctuation">,</span> <span class="token class-name">Object</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        value <span class="token operator">=</span> v<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​ 在ThreadLocalMap中，也是用Entry来保存K-V结构数据的。不过Entry中的key只能是ThreadLocal对象，这点在构造方法中已经限定死了。</p><p>​另外，Entry继承WeakReference，也就是key（ThreadLocal）是弱引用，其目的是将ThreadLocal对象的生命周期和线程生命周期解绑。</p><h3 id="弱引用和内存泄漏"><a href="#弱引用和内存泄漏" class="headerlink" title="弱引用和内存泄漏"></a>弱引用和内存泄漏</h3><p>​有些程序员在使用ThreadLocal的过程中会发现有内存泄漏的情况发生，就猜测这个内存泄漏跟Entry中使用了弱引用的key有关系。这个理解其实是不对的。</p><p>​我们先来回顾这个问题中涉及的几个名词概念，再来分析问题。</p><p>   <strong>（1） 内存泄漏相关概念</strong></p><ul><li>Memory overflow:内存溢出，没有足够的内存提供申请者使用。</li><li>Memory leak: 内存泄漏是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。内存泄漏的堆积终将导致内存溢出。</li></ul><p></p><p><strong>（2）  弱引用相关概念</strong></p><p>​Java中的引用有4种类型： 强、软、弱、虚。当前这个问题主要涉及到强引用和弱引用：</p><p>​<strong>强引用（“Strong” Reference）</strong>，就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾回收器就不会回收这种对象。</p><p>​<strong>弱引用（WeakReference）</strong>，垃圾回收器一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p><p><strong>（3） 如果key使用强引用</strong></p><p>​假设ThreadLocalMap中的key使用了强引用，那么会出现内存泄漏吗？</p><p>​此时ThreadLocal的内存图（实线表示强引用）如下： </p><p><img src="/JUC%E5%B9%B6%E5%8F%91%E4%B9%8BThreadLocal.assets/image-20230509111712240.png" alt="image-20230509111712240"></p><p>​假设在业务代码中使用完ThreadLocal ，threadLocal Ref被回收了。</p><p>​但是因为threadLocalMap的Entry强引用了threadLocal，造成threadLocal无法被回收。</p><p>​在没有手动删除这个Entry以及CurrentThread依然运行的前提下，始终有强引用链 threadRef-&gt;currentThread-&gt;threadLocalMap-&gt;entry，Entry就不会被回收（Entry中包括了ThreadLocal实例和value），导致Entry内存泄漏。</p><p>​也就是说，ThreadLocalMap中的key使用了强引用， 是无法完全避免内存泄漏的。</p><p><strong>（5）如果key使用弱引用</strong></p><p>​那么ThreadLocalMap中的key使用了弱引用，会出现内存泄漏吗？</p><p>​此时ThreadLocal的内存图（实线表示强引用，虚线表示弱引用）如下： </p><p><img src="/JUC%E5%B9%B6%E5%8F%91%E4%B9%8BThreadLocal.assets/image-20230509112052764.png" alt="image-20230509112052764"></p><p>​</p><p>​同样假设在业务代码中使用完ThreadLocal ，threadLocal Ref被回收了。</p><p>​由于ThreadLocalMap只持有ThreadLocal的弱引用，没有任何强引用指向threadlocal实例, 所以threadlocal就可以顺利被gc回收，此时Entry中的key&#x3D;null。</p><p>​但是在没有手动删除这个Entry以及CurrentThread依然运行的前提下，也存在有强引用链 threadRef-&gt;currentThread-&gt;threadLocalMap-&gt;entry -&gt; value ，value不会被回收， 而这块value永远不会被访问到了，导致value内存泄漏。</p><p>​也就是说，ThreadLocalMap中的key使用了弱引用， 也有可能内存泄漏。</p><p><strong>（6）出现内存泄漏的真实原因</strong></p><p>​比较以上两种情况，我们就会发现，内存泄漏的发生跟ThreadLocalMap中的key是否使用弱引用是没有关系的。那么内存泄漏的的真正原因是什么呢？</p><p>​细心的同学会发现，在以上两种内存泄漏的情况中，都有两个前提：</p><pre><code> 1. 没有手动删除这个Entry 2. CurrentThread依然运行</code></pre><p>   第一点很好理解，只要在使用完ThreadLocal，调用其remove方法删除对应的Entry，就能避免内存泄漏。</p><p>​第二点稍微复杂一点， 由于ThreadLocalMap是Thread的一个属性，被当前线程所引用，所以它的生命周期跟Thread一样长。那么在使用完ThreadLocal的使用，如果当前Thread也随之执行结束，ThreadLocalMap自然也会被gc回收，从根源上避免了内存泄漏。</p><p>​综上，<strong>ThreadLocal内存泄漏的根源是</strong>：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏。</p><p>扩展：内存泄漏分为两部分：</p><ul><li>指向 Entry 的指针（也就是 ThreadLocal 对象）的内存泄漏</li><li>Entry 中Value 发生内存泄漏； </li><li>针对第一种内存泄漏，使用弱引用就可以解决了。</li><li>针对第二种内存泄漏，需要手动 remove 或者线程终结；</li></ul><p><strong>（7） 为什么使用弱引用</strong></p><p>​根据刚才的分析, 我们知道了： 无论ThreadLocalMap中的key使用哪种类型引用都无法完全避免内存泄漏，跟使用弱引用没有关系。</p><p>​要避免内存泄漏有两种方式：</p><ol><li><p>使用完ThreadLocal，调用其remove方法删除对应的Entry</p></li><li><p>使用完ThreadLocal，当前Thread也随之运行结束</p></li></ol><p>相对第一种方式，第二种方式显然更不好控制，特别是使用线程池的时候，线程结束是不会销毁的。</p><p>也就是说，只要记得在使用完ThreadLocal及时的调用remove，无论key是强引用还是弱引用都不会有问题。那么为什么key要用弱引用呢？</p><p>事实上，在ThreadLocalMap中的set&#x2F;getEntry方法中，会对key为null（也即是ThreadLocal为null）进行判断，如果为null的话，那么是会对value置为null的。</p><p>这就意味着使用完ThreadLocal，CurrentThread依然运行的前提下，就算忘记调用remove方法，<strong>弱引用比强引用可以多一层保障</strong>：弱引用的ThreadLocal会被回收，对应的value在下一次ThreadLocalMap调用set,get,remove中的任一方法的时候会被清除，从而避免内存泄漏。</p><h3 id="hash冲突的解决"><a href="#hash冲突的解决" class="headerlink" title="hash冲突的解决"></a>hash冲突的解决</h3><p>​hash冲突的解决是Map中的一个重要内容。我们以hash冲突的解决为线索，来研究一下ThreadLocalMap的核心源码。</p><p><strong>（1） 首先从ThreadLocal的set() 方法入手</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">T</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>          <span class="token comment">//调用了ThreadLocalMap的set方法</span>          map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">else</span>          <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span> <span class="token function">getMap</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> t<span class="token punctuation">.</span>threadLocals<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">void</span> <span class="token function">createMap</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> t<span class="token punctuation">,</span> <span class="token class-name">T</span> firstValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">//调用了ThreadLocalMap的构造方法</span>      t<span class="token punctuation">.</span>threadLocals <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> firstValue<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法我们刚才分析过, 其作用是设置当前线程绑定的局部变量 : </p><p>​A. 首先获取当前线程，并根据当前线程获取一个Map</p><p>​B. 如果获取的Map不为空，则将参数设置到Map中（当前ThreadLocal的引用作为key）</p><p>​<strong>(这里调用了ThreadLocalMap的set方法)</strong></p><p>​C. 如果Map为空，则给该线程创建 Map，并设置初始值</p><p>​<strong>(这里调用了ThreadLocalMap的构造方法)</strong></p><p>这段代码有两个地方分别涉及到ThreadLocalMap的两个方法, 我们接着分析这两个方法。</p><p>**（2）构造方法<code>ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue)**</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token comment">/*  * firstKey : 本ThreadLocal实例(this)  * firstValue ： 要保存的线程本地变量  */</span><span class="token class-name">ThreadLocalMap</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> firstKey<span class="token punctuation">,</span> <span class="token class-name">Object</span> firstValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//初始化table</span>        table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap<span class="token punctuation">.</span>Entry</span><span class="token punctuation">[</span><span class="token constant">INITIAL_CAPACITY</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//计算索引(重点代码）</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> firstKey<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token constant">INITIAL_CAPACITY</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置值</span>        table<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap<span class="token punctuation">.</span>Entry</span><span class="token punctuation">(</span>firstKey<span class="token punctuation">,</span> firstValue<span class="token punctuation">)</span><span class="token punctuation">;</span>        size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">//设置阈值</span>        <span class="token function">setThreshold</span><span class="token punctuation">(</span><span class="token constant">INITIAL_CAPACITY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​构造函数首先创建一个长度为16的Entry数组，然后计算出firstKey对应的索引，然后存储到table中，并设置size和threshold。</p><p>​<strong>重点分析</strong>： <code>int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1)</code>。</p><p>a. 关于<code>firstKey.threadLocalHashCode</code>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> threadLocalHashCode <span class="token operator">=</span> <span class="token function">nextHashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextHashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> nextHashCode<span class="token punctuation">.</span><span class="token function">getAndAdd</span><span class="token punctuation">(</span><span class="token constant">HASH_INCREMENT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">//AtomicInteger是一个提供原子操作的Integer类，通过线程安全的方式操作加减,适合高并发情况下的使用</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">AtomicInteger</span> nextHashCode <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//特殊的hash值</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">HASH_INCREMENT</span> <span class="token operator">=</span> <span class="token number">0x61c88647</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​这里定义了一个AtomicInteger类型，每次获取当前值并加上HASH_INCREMENT，<code>HASH_INCREMENT = 0x61c88647</code>,这个值跟斐波那契数列（黄金分割数）有关，其主要目的就是为了让哈希码能均匀的分布在2的n次方的数组里, 也就是Entry[] table中，这样做可以尽量避免hash冲突。</p><p>b. 关于<code>&amp; (INITIAL_CAPACITY - 1)</code></p><p>​计算hash的时候里面采用了hashCode &amp; (size - 1)的算法，这相当于取模运算hashCode % size的一个更高效的实现。正是因为这种算法，我们要求size必须是2的整次幂，这也能保证在索引不越界的前提下，使得hash发生冲突的次数减小。</p><p><strong>（3） ThreadLocalMap中的set方法</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap<span class="token punctuation">.</span>Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment">//计算索引(重点代码，刚才分析过了）</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> key<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/**         * 使用线性探测法查找元素（重点代码）         */</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap<span class="token punctuation">.</span>Entry</span> e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>             e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>             e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> k <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//ThreadLocal 对应的 key 存在，直接覆盖之前的值</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// key为 null，但是值不为 null，说明之前的 ThreadLocal 对象已经被回收了，</span>           <span class="token comment">// 当前数组中的 Entry 是一个陈旧（stale）的元素</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//用新元素替换陈旧的元素，这个方法进行了不少的垃圾清理动作，防止内存泄漏</span>                <span class="token function">replaceStaleEntry</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//ThreadLocal对应的key不存在并且没有找到陈旧的元素，则在空元素的位置创建一个新的Entry。</span>            tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> sz <span class="token operator">=</span> <span class="token operator">++</span>size<span class="token punctuation">;</span>            <span class="token comment">/**             * cleanSomeSlots用于清除那些e.get()==null的元素，             * 这种数据key关联的对象已经被回收，所以这个Entry(table[index])可以被置null。             * 如果没有清除任何entry,并且当前使用量达到了负载因子所定义(长度的2/3)，那么进行              * rehash（执行一次全表的扫描清理工作）             */</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">cleanSomeSlots</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> sz<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> sz <span class="token operator">>=</span> threshold<span class="token punctuation">)</span>                <span class="token function">rehash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token comment">/**     * 获取环形数组的下一个索引     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token operator">?</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​代码执行流程：</p><p>A. 首先还是根据key计算出索引 i，然后查找i位置上的Entry，</p><p>B. 若是Entry已经存在并且key等于传入的key，那么这时候直接给这个Entry赋新的value值,</p><p>C. 若是Entry存在，但是key为null，则调用replaceStaleEntry来更换这个key为空的Entry,</p><p>D. 不断循环检测，直到遇到为null的地方，这时候要是还没在循环过程中return，那么就在这个null的位置新建一个Entry，并且插入，同时size增加1。</p><p>​    最后调用cleanSomeSlots，清理key为null的Entry，最后返回是否清理了Entry，接下来再判断sz 是否&gt;&#x3D; thresgold达到了rehash的条件，达到的话就会调用rehash函数执行一次全表的扫描清理。</p><p><strong>重点分析</strong> ： ThreadLocalMap使用<code>线性探测法</code>来解决哈希冲突的。</p><p>​该方法一次探测下一个地址，直到有空的地址后插入，若整个空间都找不到空余的地址，则产生溢出。</p><p>​举个例子，假设当前table长度为16，也就是说如果计算出来key的hash值为14，如果table[14]上已经有值，并且其key与当前key不一致，那么就发生了hash冲突，这个时候将14加1得到15，取table[15]进行判断，这个时候如果还是冲突会回到0，取table[0],以此类推，直到可以插入。</p><p>​按照上面的描述，可以把Entry[]  table看成一个环形数组。</p><h3 id="线性探测法也叫开放定址法"><a href="#线性探测法也叫开放定址法" class="headerlink" title="线性探测法也叫开放定址法"></a>线性探测法也叫开放定址法</h3><h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>在 ThreadLocalMap set 方法最后两行</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * cleanSomeSlots用于清除那些e.get()==null的元素， * 这种数据key关联的对象已经被回收，所以这个Entry(table[index])可以被置null。 * 如果没有清除任何entry,并且当前使用量达到了负载因子所定义(长度的2/3)，那么进行  * rehash（执行一次全表的扫描清理工作） */</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">cleanSomeSlots</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> sz<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> sz <span class="token operator">>=</span> threshold<span class="token punctuation">)</span>    <span class="token function">rehash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>会尝试清理 slot 槽位（启发式清理），如果清理完之后的 slot 槽位，还是大于 threshold 定义长度</p><p>就会进行 rehash()</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rehash</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//清理过期Entry</span>    <span class="token function">expungeStaleEntries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">>=</span> threshold <span class="token operator">-</span> threshold <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//清理过期Entry</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">expungeStaleEntries</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Entry</span> e <span class="token operator">=</span> tab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token function">expungeStaleEntry</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>rehash() 包含两个操作</p><ul><li>全表清理（和启发式清理不一样）</li><li>扩容 resize()</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Double the capacity of the table. */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldLen <span class="token operator">=</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> newLen <span class="token operator">=</span> oldLen <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>newLen<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldLen<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Entry</span> e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> k <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// Help the GC</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> h <span class="token operator">=</span> k<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newLen <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>newTab<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                    h <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> newLen<span class="token punctuation">)</span><span class="token punctuation">;</span>                newTab<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">setThreshold</span><span class="token punctuation">(</span>newLen<span class="token punctuation">)</span><span class="token punctuation">;</span>    size <span class="token operator">=</span> count<span class="token punctuation">;</span>    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>扩容后的<code>newTab</code>的大小为老数组的两倍</p><p>然后遍历老的table数组，散列方法重新计算位置，开放地址解决冲突，然后放到新的<code>newTab</code></p><p>遍历完成之后，<code>oldTab</code>中所有的<code>entry</code>数据都已经放入到<code>newTab</code>中了，然后table引用指向<code>newTab</code></p><p><img src="/JUC%E5%B9%B6%E5%8F%91%E4%B9%8BThreadLocal.assets/image-20230509115153827.png" alt="image-20230509115153827"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文还有xmind，配合xmind食用，味道更佳：&lt;a href=&quot;./%5CJUC%E5%B9%B6%E5%8F%91%E4%B9%8BThreadLocal.assets/ThreadLocal.xmind&quot;&gt;ThreadLocal.xmind&lt;/a&gt;&lt;/p&gt;
&lt;img</summary>
      
    
    
    
    <category term="JAVA" scheme="https://zspcer.gitee.io/categories/JAVA/"/>
    
    <category term="JUC" scheme="https://zspcer.gitee.io/categories/JAVA/JUC/"/>
    
    
    <category term="JUC" scheme="https://zspcer.gitee.io/tags/JUC/"/>
    
    <category term="ThreadLocal" scheme="https://zspcer.gitee.io/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>大厂面试之Redis篇</title>
    <link href="https://zspcer.gitee.io/note/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87/"/>
    <id>https://zspcer.gitee.io/note/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87/</id>
    <published>2023-05-08T16:30:17.000Z</published>
    <updated>2023-05-11T15:42:17.148Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-说说什么是Redis"><a href="#1-说说什么是Redis" class="headerlink" title="1.说说什么是Redis?"></a>1.说说什么是Redis?</h2><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676357909974-1cc2caa7-27fa-42ec-969f-9b580585b13e.png" alt="img"></p><p>Redis是一种基于键值对（key-value）的NoSQL数据库。</p><p>比一般键值对数据库强大的地方，Redis中的value支持string（字符串）、hash（哈希）、 list（列表）、set（集合）、zset（有序集合）、Bitmaps（位图）、 HyperLogLog、GEO（地理信息定位）等多种数据结构，因此 Redis可以满足很多的应用场景。</p><p>而且因为Redis会将所有数据都存放在内存中，所以它的读写性能非常出色。</p><p>不仅如此，Redis还可以将内存的数据利用快照和日志的形式保存到硬盘上，这样在发生类似断电或者机器故障的时候，内存中的数据不会“丢失”。</p><p>除了上述功能以外，Redis还提供了键过期、发布订阅、事务、流水线、Lua脚本等附加功能。</p><p>总之，Redis是一款强大的性能利器。</p><h2 id="2-Redis可以用来干什么？"><a href="#2-Redis可以用来干什么？" class="headerlink" title="2.Redis可以用来干什么？"></a>2.Redis可以用来干什么？</h2><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676357911812-954d8bf0-b8c1-43a8-87a0-1ae82d3071c3.png" alt="img"></p><p>1、缓存</p><p>这是Redis应用最广泛地方，基本所有的Web应用都会使用Redis作为缓存，来降低数据源压力，提高响应速度。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676357931667-08a734be-cbc5-42c2-8e8b-509a7fbe409b.png" alt="img"></p><p>2、计数器 Redis天然支持计数功能，而且计数性能非常好，可以用来记录浏览量、点赞量等等。</p><p>3、排行榜 Redis提供了列表和有序集合数据结构，合理地使用这些数据结构可以很方便地构建各种排行榜系统。</p><p>4、社交网络 赞&#x2F;踩、粉丝、共同好友&#x2F;喜好、推送、下拉刷新。</p><p>5、消息队列 Redis提供了发布订阅功能和阻塞队列的功能，可以满足一般消息队列功能。</p><p>6、分布式锁 分布式环境下，利用Redis实现分布式锁，也是Redis常见的应用。</p><p>Redis的应用一般会结合项目去问，以一个电商项目的用户服务为例：</p><ul><li><p>Token存储：用户登录成功之后，使用Redis存储Token</p></li><li><p>登录失败次数计数：使用Redis计数，登录失败超过一定次数，锁定账号</p></li><li><p>地址缓存：对省市区数据的缓存</p></li><li><p>分布式锁：分布式环境下登录、注册等操作加分布式锁</p></li><li><p>……</p></li></ul><h2 id="3-Redis-有哪些数据结构？"><a href="#3-Redis-有哪些数据结构？" class="headerlink" title="3.Redis 有哪些数据结构？"></a>3.Redis 有哪些数据结构？</h2><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676357936063-9e0cca5d-9b35-4b53-b0c7-cc4393da2a69.png" alt="img"></p><h3 id="string"><a href="#string" class="headerlink" title="string"></a><strong>string</strong></h3><p>字符串最基础的数据结构。字符串类型的值实际可以是字符串（简单的字符串、复杂的字符串（例如JSON、XML））、数字 （整数、浮点数），甚至是二进制（图片、音频、视频），但是值最大不能超过512MB。</p><p>字符串主要有以下几个典型使用场景：</p><ul><li><p>缓存功能</p></li><li><p>计数</p></li><li><p>共享Session</p></li><li><p>限速</p></li></ul><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a><strong>hash</strong></h3><p>哈希类型是指键值本身又是一个键值对结构。</p><p>哈希主要有以下典型应用场景：</p><ul><li><p>缓存用户信息</p></li><li><p>缓存对象</p></li></ul><h3 id="list"><a href="#list" class="headerlink" title="list"></a><strong>list</strong></h3><p>列表（list）类型是用来存储多个有序的字符串。列表是一种比较灵活的数据结构，它可以充当栈和队列的角色</p><p>列表主要有以下几种使用场景：</p><ul><li><p>消息队列</p></li><li><p>文章列表</p></li></ul><h3 id="set"><a href="#set" class="headerlink" title="set"></a><strong>set</strong></h3><p>集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一 样的是，集合中不允许有重复元素，并且集合中的元素是无序的。</p><p>集合主要有如下使用场景：</p><ul><li><p>标签（tag）</p></li><li><p>共同关注</p></li></ul><h3 id="sorted-set"><a href="#sorted-set" class="headerlink" title="sorted set"></a><strong>sorted set</strong></h3><p>有序集合中的元素可以排序。但是它和列表使用索引下标作为排序依据不同的是，它给每个元素设置一个权重（score）作为排序的依据。</p><p>有序集合主要应用场景：</p><ul><li><p>用户点赞统计</p></li><li><p>用户排序</p></li></ul><h2 id="4-Redis为什么快呢？"><a href="#4-Redis为什么快呢？" class="headerlink" title="4.Redis为什么快呢？"></a>4.Redis为什么快呢？</h2><p>Redis的速度⾮常的快，单机的Redis就可以⽀撑每秒十几万的并发，相对于MySQL来说，性能是MySQL的⼏⼗倍。速度快的原因主要有⼏点：</p><p>1、<strong>完全基于内存操作</strong></p><p>2、使⽤单线程，避免了线程切换和竞态产生的消耗</p><p>3、基于⾮阻塞的IO多路复⽤机制</p><p>4、C语⾔实现，优化过的数据结构，基于⼏种基础的数据结构，redis做了⼤量的优化，性能极⾼<img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676357940292-701c0890-0f17-44ce-9fbb-63932812a159.png" alt="img"></p><h2 id="5-能说一下I-x2F-O多路复用吗？"><a href="#5-能说一下I-x2F-O多路复用吗？" class="headerlink" title="5.能说一下I&#x2F;O多路复用吗？"></a>5.能说一下I&#x2F;O多路复用吗？</h2><p>引用知乎上一个高赞的回答来解释什么是I&#x2F;O多路复用。假设你是一个老师，让30个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择：</p><ul><li><p>第一种选择：按顺序逐个检查，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生卡住，全班都会被耽误。这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。</p></li><li><p>第二种选择：你创建30个分身，每个分身检查一个学生的答案是否正确。这种类似于为每一个用户创建一个进程或者- 线程处理连接。</p></li><li><p>第三种选择，你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。</p></li></ul><p>第一种就是阻塞IO模型，第三种就是I&#x2F;O复用模型。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676357941942-e03bdd4d-c27c-4e5b-8371-32132b56a499.png" alt="img"></p><p>Linux系统有三种方式实现IO多路复用：select、poll和epoll。</p><p>例如epoll方式是将用户socket对应的fd注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。此时的socket应该采用非阻塞模式。</p><p>这样，整个过程只在进行select、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的reactor模式。</p><h2 id="6-Redis为什么早期选择单线程？"><a href="#6-Redis为什么早期选择单线程？" class="headerlink" title="6. Redis为什么早期选择单线程？"></a>6. Redis为什么早期选择单线程？</h2><p>官方解释：<a href="https://redis.io/topics/faq">https://redis.io/topics/faq</a></p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/image-20230511173147070.png" alt="image-20230511173147070"></p><p>官方FAQ表示，因为Redis是基于内存的操作，CPU成为Redis的瓶颈的情况很少见，Redis的瓶颈最有可能是内存的大小或者网络限制。</p><p>如果想要最大程度利用CPU，可以在一台机器上启动多个Redis实例。</p><p>PS：网上有这样的回答，吐槽官方的解释有些敷衍，其实就是历史原因，开发者嫌多线程麻烦，后来这个CPU的利用问题就被抛给了使用者。</p><p>同时FAQ里还提到了， Redis 4.0 之后开始变成多线程，除了主线程外，它也有后台线程在处理一些较为缓慢的操作，例如清理脏数据、无用连接的释放、大 Key 的删除等等。</p><h2 id="7-Redis6-0使用多线程是怎么回事"><a href="#7-Redis6-0使用多线程是怎么回事" class="headerlink" title="7.Redis6.0使用多线程是怎么回事?"></a>7.Redis6.0使用多线程是怎么回事?</h2><p>Redis不是说用单线程的吗？怎么6.0成了多线程的？</p><p>Redis6.0的多线程是用多线程来处理数据的<strong>读写和协议解析</strong>，但是Redis<strong>执行命令</strong>还是单线程的。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676357944805-f384a2c3-e145-47ec-bb25-0dc10b3f3b30.png" alt="img"></p><p>这样做的⽬的是因为Redis的性能瓶颈在于⽹络IO⽽⾮CPU，使⽤多线程能提升IO读写的效率，从⽽整体提⾼Redis的性能。</p><h2 id="8-Redis持久化⽅式有哪些？有什么区别？"><a href="#8-Redis持久化⽅式有哪些？有什么区别？" class="headerlink" title="8.Redis持久化⽅式有哪些？有什么区别？"></a>8.Redis持久化⽅式有哪些？有什么区别？</h2><p>Redis持久化⽅案分为RDB和AOF两种。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676357948424-bc727cff-089c-41d9-8ea9-4af8fa2c7128.png" alt="img"></p><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a><strong>RDB</strong></h3><p>RDB持久化是把当前进程数据生成<strong>快照</strong>保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发。</p><p>RDB⽂件是⼀个压缩的⼆进制⽂件，通过它可以还原某个时刻数据库的状态。由于RDB⽂件是保存在硬盘上的，所以即使Redis崩溃或者退出，只要RDB⽂件存在，就可以⽤它来恢复还原数据库的状态。</p><p>手动触发分别对应save和bgsave命令:</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676357949860-bc150df0-92da-4d3d-a2ca-7a6ae31869c8.png" alt="img"></p><ul><li><p>save命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。</p></li><li><p>bgsave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。</p></li></ul><p>以下场景会自动触发RDB持久化：</p><ul><li><p>使用save相关配置，如“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave。</p></li><li><p>如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点</p></li><li><p>执行debug reload命令重新加载Redis时，也会自动触发save操作</p></li><li><p>默认情况下执行shutdown命令时，如果没有开启AOF持久化功能则自动执行bgsave。</p></li></ul><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a><strong>AOF</strong></h3><p>AOF（append only file）持久化：以独立日志的方式记录每次写命令， 重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式。</p><p>AOF的工作流程操作：命令写入 （append）、文件同步（sync）、文件重写（rewrite）、重启加载 （load）</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676357951841-274eacc3-f01b-4e24-afaf-70504186398a.png" alt="img"></p><p>流程如下：</p><p>1）所有的写入命令会追加到aof_buf（缓冲区）中。</p><p>2）AOF缓冲区根据对应的策略向硬盘做同步操作。</p><p>3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩 的目的。</p><p>4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。</p><h2 id="9-RDB-和-AOF-各自有什么优缺点？"><a href="#9-RDB-和-AOF-各自有什么优缺点？" class="headerlink" title="9.RDB 和 AOF 各自有什么优缺点？"></a>9.RDB 和 AOF 各自有什么优缺点？</h2><h3 id="RDB-优点"><a href="#RDB-优点" class="headerlink" title="RDB | 优点"></a><strong>RDB | 优点</strong></h3><p>1、只有一个紧凑的二进制文件 <code>dump.rdb</code>，非常适合备份、全量复制的场景。</p><p>2、<strong>容灾性好</strong>，可以把RDB文件拷贝道远程机器或者文件系统张，用于容灾恢复。</p><p>3、<strong>恢复速度快</strong>，RDB恢复数据的速度远远快于AOF的方式</p><h3 id="RDB-缺点"><a href="#RDB-缺点" class="headerlink" title="RDB | 缺点"></a><strong>RDB | 缺点</strong></h3><p>1、<strong>实时性低</strong>，RDB 是间隔一段时间进行持久化，没法做到实时持久化&#x2F;秒级持久化。如果在这一间隔事件发生故障，数据会丢失。</p><p>2、<strong>存在兼容问题</strong>，Redis演进过程存在多个格式的RDB版本，存在老版本Redis无法兼容新版本RDB的问题。</p><h3 id="AOF-优点"><a href="#AOF-优点" class="headerlink" title="AOF | 优点"></a><strong>AOF | 优点</strong></h3><p>1、<strong>实时性好</strong>，aof 持久化可以配置 <code>appendfsync</code> 属性，有 <code>always</code>，每进行一次命令操作就记录到 aof 文件中一次。</p><p>2、通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</p><h3 id="AOF-缺点"><a href="#AOF-缺点" class="headerlink" title="AOF | 缺点"></a><strong>AOF | 缺点</strong></h3><p>1、AOF 文件比 RDB <strong>文件大</strong>，且 <strong>恢复速度慢</strong>。</p><p>2、<strong>数据集大</strong> 的时候，比 RDB <strong>启动效率低</strong>。</p><h2 id="10-RDB和AOF如何选择？"><a href="#10-RDB和AOF如何选择？" class="headerlink" title="10.RDB和AOF如何选择？"></a>10.RDB和AOF如何选择？</h2><ul><li><p>一般来说， 如果想达到足以媲美数据库的 <strong>数据安全性</strong>，应该 <strong>同时使用两种持久化功能</strong>。在这种情况下，当 Redis 重启的时候会优先载入 AOF 文件来恢复原始的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整。</p></li><li><p>如果 <strong>可以接受数分钟以内的数据丢失</strong>，那么可以 <strong>只使用 RDB 持久化</strong>。</p></li><li><p>有很多用户都只使用 AOF 持久化，但并不推荐这种方式，因为定时生成 RDB 快照（snapshot）非常便于进行数据备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快，除此之外，使用 RDB 还可以避免 AOF 程序的 bug。</p></li><li><p>如果只需要数据在服务器运行的时候存在，也可以不使用任何持久化方式。</p></li></ul><h2 id="11-Redis的数据恢复？"><a href="#11-Redis的数据恢复？" class="headerlink" title="11.Redis的数据恢复？"></a>11.Redis的数据恢复？</h2><p>当Redis发生了故障，可以从RDB或者AOF中恢复数据。</p><p>恢复的过程也很简单，把RDB或者AOF文件拷贝到Redis的数据目录下，如果使用AOF恢复，配置文件开启AOF，然后启动redis-server即可。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676357955586-2676e80b-708e-451c-a7f5-5dfd9a42ce9f.png" alt="img"></p><p><strong>Redis</strong> 启动时加载数据的流程：</p><p>1、AOF持久化开启且存在AOF文件时，优先加载AOF文件。</p><p>2、AOF关闭或者AOF文件不存在时，加载RDB文件。</p><p>3、加载AOF&#x2F;RDB文件成功后，Redis启动成功。</p><p>4、AOF&#x2F;RDB文件存在错误时，Redis启动失败并打印错误信息。</p><h2 id="12-Redis-4-0-的混合持久化了解吗？"><a href="#12-Redis-4-0-的混合持久化了解吗？" class="headerlink" title="12.Redis 4.0 的混合持久化了解吗？"></a>12.Redis 4.0 的混合持久化了解吗？</h2><p>重启 Redis 时，我们很少使用 <code>RDB</code> 来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 <code>RDB</code> 来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。</p><p><strong>Redis 4.0</strong> 为了解决这个问题，带来了一个新的持久化选项——<strong>混合持久化</strong>。将 <code>rdb</code> 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是 <strong>自持久化开始到持久化结束</strong> 的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676357958629-b7735226-e18e-4cc9-9c7d-456752a8fa24.png" alt="img"></p><p>于是在 Redis 重启的时候，可以先加载 <code>rdb</code> 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。</p><p>Redis保证高可用主要有三种方式：主从、哨兵、集群。</p><h2 id="13-主从复制了解吗？"><a href="#13-主从复制了解吗？" class="headerlink" title="13.主从复制了解吗？"></a>13.主从复制了解吗？</h2><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676357960513-496ebbe4-28b1-46cc-a749-ca0faf861a99.png" alt="img"></p><p><strong>主从复制</strong>，是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为 **主节点(master)**，后者称为 **从节点(slave)**。且数据的复制是 <strong>单向</strong> 的，只能由主节点到从节点。Redis 主从复制支持 <strong>主从同步</strong> 和 <strong>从从同步</strong> 两种，后者是 Redis 后续版本新增的功能，以减轻主节点的同步负担。</p><p>主从复制主要的作用?</p><ul><li><p><strong>数据冗余：</strong> 主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</p></li><li><p><strong>故障恢复：</strong> 当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复 *(实际上是一种服务的冗余)*。</p></li><li><p><strong>负载均衡：</strong> 在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务 <em>（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点）</em>，分担服务器负载。尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。</p></li><li><p><strong>高可用基石：</strong> 除了上述作用以外，主从复制还是哨兵和集群能够实施的 <strong>基础</strong>，因此说主从复制是 Redis 高可用的基础。</p></li></ul><h2 id="14-Redis主从有几种常见的拓扑结构？"><a href="#14-Redis主从有几种常见的拓扑结构？" class="headerlink" title="14.Redis主从有几种常见的拓扑结构？"></a>14.Redis主从有几种常见的拓扑结构？</h2><p>Redis的复制拓扑结构可以支持单层或多层复制关系，根据拓扑复杂性可以分为以下三种：一主一从、一主多从、树状主从结构。</p><p>1、一主一从结构</p><p>一主一从结构是最简单的复制拓扑结构，用于主节点出现宕机时从节点提供故障转移支持。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676357962771-414cab0c-c3b9-4f05-8d7d-2b20aaffc83d.png" alt="img"></p><p>2、一主多从结构</p><p>一主多从结构（又称为星形拓扑结构）使得应用端可以利用多个从节点实现读写分离（见图6-5）。对于读占比较大的场景，可以把读命令发送到从节点来分担主节点压力。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676357964539-1c6ac3ae-12f1-4f15-8d5f-faf6db7f5bde.png" alt="img"></p><p>3、树状主从结构</p><p>树状主从结构（又称为树状拓扑结构）使得从节点不但可以复制主节点数据，同时可以作为其他从节点的主节点继续向下层复制。通过引入复制中间层，可以有效降低主节点负载和需要传送给从节点的数据量。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676357966450-81f8fc28-09a5-43a8-af1d-a9a37c4335e3.png" alt="img"></p><h2 id="15-Redis的主从复制原理了解吗？"><a href="#15-Redis的主从复制原理了解吗？" class="headerlink" title="15.Redis的主从复制原理了解吗？"></a>15.Redis的主从复制原理了解吗？</h2><p>Redis主从复制的工作流程大概可以分为如下几步：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676357968253-f8ec31da-f2dc-484e-9585-c6b626c1e3b4.png" alt="img"></p><p>1、保存主节点（master）信息 这一步只是保存主节点信息，保存主节点的ip和port。</p><p>2、主从建立连接 从节点（slave）发现新的主节点后，会尝试和主节点建立网络连接。</p><p>3、发送ping命令 连接建立成功后从节点发送ping请求进行首次通信，主要是检测主从之间网络套接字是否可用、主节点当前是否可接受处理命令。</p><p>4、权限验证 如果主节点要求密码验证，从节点必须正确的密码才能通过验证。</p><p>5、同步数据集 主从复制连接正常通信后，主节点会把持有的数据全部发送给从节点。</p><p>6、命令持续复制 接下来主节点会持续地把写命令发送给从节点，保证主从数据一致性。</p><h2 id="16-说说主从数据同步的方式？"><a href="#16-说说主从数据同步的方式？" class="headerlink" title="16.说说主从数据同步的方式？"></a>16.说说主从数据同步的方式？</h2><p>Redis在2.8及以上版本使用psync命令完成主从数据同步，同步过程分为：全量复制和部分复制。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676357971220-fc34f191-5435-4576-b8f7-1ff4c704c955.png" alt="img"></p><p><strong>全量复制</strong>一般用于初次复制场景，Redis早期支持的复制功能只有全量复制，它会把主节点全部数据一次性发送给从节点，当数据量较大时，会对主从节点和网络造成很大的开销。</p><p>全量复制的完整运行流程如下：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676357972661-4a8d31c3-e8df-4503-bd6c-058f0f7d31b7.png" alt="img"></p><p>1、发送psync命令进行数据同步，由于是第一次进行复制，从节点没有复制偏移量和主节点的运行ID，所以发送psync-1。</p><p>2、主节点根据psync-1解析出当前为全量复制，回复+FULLRESYNC响应。</p><p>3、从节点接收主节点的响应数据保存运行ID和偏移量offset</p><p>4、主节点执行bgsave保存RDB文件到本地</p><p>5、主节点发送RDB文件给从节点，从节点把接收的RDB文件保存在本地并直接作为从节点的数据文件</p><p>6、对于从节点开始接收RDB快照到接收完成期间，主节点仍然响应读写命令，因此主节点会把这期间写命令数据保存在复制客户端缓冲区内，当从节点加载完RDB文件后，主节点再把缓冲区内的数据发送给从节点，保证主从之间数据一致性。</p><p>7、从节点接收完主节点传送来的全部数据后会清空自身旧数据</p><p>8、从节点清空数据后开始加载RDB文件</p><p>9、从节点成功加载完RDB后，如果当前节点开启了AOF持久化功能， 它会立刻做bgrewriteaof操作，为了保证全量复制后AOF持久化文件立刻可用。</p><p><strong>部分复制</strong>部分复制主要是Redis针对全量复制的过高开销做出的一种优化措施， 使用psync{runId}{offset}命令实现。当从节点（slave）正在复制主节点 （master）时，如果出现网络闪断或者命令丢失等异常情况时，从节点会向 主节点要求补发丢失的命令数据，如果主节点的复制积压缓冲区内存在这部分数据则直接发送给从节点，这样就可以保持主从节点复制的一致性。<img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676357975681-bdbfcc81-39dd-4eaf-820d-2ce13d9f11b8.png" alt="img"></p><p>1、当主从节点之间网络出现中断时，如果超过repl-timeout时间，主节点会认为从节点故障并中断复制连接</p><p>2、主从连接中断期间主节点依然响应命令，但因复制连接中断命令无法发送给从节点，不过主节点内部存在的复制积压缓冲区，依然可以保存最近一段时间的写命令数据，默认最大缓存1MB。</p><p>3、当主从节点网络恢复后，从节点会再次连上主节点</p><p>4、当主从连接恢复后，由于从节点之前保存了自身已复制的偏移量和主节点的运行ID。因此会把它们当作psync参数发送给主节点，要求进行部分复制操作。</p><p>5、主节点接到psync命令后首先核对参数runId是否与自身一致，如果一 致，说明之前复制的是当前主节点；之后根据参数offset在自身复制积压缓冲区查找，如果偏移量之后的数据存在缓冲区中，则对从节点发送+CONTINUE响应，表示可以进行部分复制。</p><p>6、主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。</p><h2 id="17-主从复制存在哪些问题呢？"><a href="#17-主从复制存在哪些问题呢？" class="headerlink" title="17.主从复制存在哪些问题呢？"></a>17.主从复制存在哪些问题呢？</h2><p>主从复制虽好，但也存在一些问题：</p><ul><li><p>一旦主节点出现故障，需要手动将一个从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令其他从节点去复制新的主节点，整个过程都需要人工干预。</p></li><li><p>主节点的写能力受到单机的限制。</p></li><li><p>主节点的存储能力受到单机的限制。</p></li></ul><p>第一个问题是Redis的高可用问题，第二、三个问题属于Redis的分布式问题。</p><h2 id="18-Redis-Sentinel（哨兵）了解吗？"><a href="#18-Redis-Sentinel（哨兵）了解吗？" class="headerlink" title="18.Redis Sentinel（哨兵）了解吗？"></a>18.Redis Sentinel（哨兵）了解吗？</h2><p>主从复制存在一个问题，没法完成自动故障转移。所以我们需要一个方案来完成自动故障转移，它就是Redis Sentinel（哨兵）。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676357978322-fbe309c9-b325-4c21-8440-13787e428748.png" alt="img"></p><p>Redis Sentinel ，它由两部分组成，哨兵节点和数据节点：</p><ul><li><p><strong>哨兵节点：</strong> 哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的 Redis 节点，不存储数据，对数据节点进行监控。</p></li><li><p><strong>数据节点：</strong> 主节点和从节点都是数据节点；</p></li></ul><p>在复制的基础上，哨兵实现了 <strong>自动化的故障恢复</strong> 功能，下面是官方对于哨兵功能的描述：</p><ul><li><p><strong>监控（Monitoring）：</strong> 哨兵会不断地检查主节点和从节点是否运作正常。</p></li><li><p><strong>自动故障转移（Automatic failover）：</strong> 当 <strong>主节点</strong> 不能正常工作时，哨兵会开始 <strong>自动故障转移操作</strong>，它会将失效主节点的其中一个 <strong>从节点升级为新的主节点</strong>，并让其他从节点改为复制新的主节点。</p></li><li><p><strong>配置提供者（Configuration provider）：</strong> 客户端在初始化时，通过连接哨兵来获得当前 Redis 服务的主节点地址。</p></li><li><p><strong>通知（Notification）：</strong> 哨兵可以将故障转移的结果发送给客户端。</p></li></ul><p>其中，监控和自动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移。而配置提供者和通知功能，则需要在与客户端的交互中才能体现。</p><h2 id="19-Redis-Sentinel（哨兵）实现原理知道吗？"><a href="#19-Redis-Sentinel（哨兵）实现原理知道吗？" class="headerlink" title="19.Redis Sentinel（哨兵）实现原理知道吗？"></a>19.Redis Sentinel（哨兵）实现原理知道吗？</h2><p>哨兵模式是通过哨兵节点完成对数据节点的监控、下线、故障转移。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676357981748-e1e8d25b-a8f8-4aad-b7bd-ff9017c26cf2.png" alt="img"></p><ul><li><p><strong>定时监控</strong><br>  <img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676357980307-219952de-1d96-43a8-b56d-14971a12ad0a.png" alt="img"> </p></li><li><p>Redis Sentinel通过三个定时监控任务完成对各个节点发现和监控： </p></li><li><ul><li>每隔10秒，每个Sentinel节点会向主节点和从节点发送info命令获取最新的拓扑结构</li></ul></li><li><ul><li>每隔2秒，每个Sentinel节点会向Redis数据节点的<strong>sentinel</strong>：hello 频道上发送该Sentinel节点对于主节点的判断以及当前Sentinel节点的信息</li></ul></li><li><ul><li>每隔1秒，每个Sentinel节点会向主节点、从节点、其余Sentinel节点发送一条ping命令做一次心跳检测，来确认这些节点当前是否可达</li></ul></li><li><p><strong>主观下线和客观下线</strong>主观下线就是哨兵节点认为某个节点有问题，客观下线就是超过一定数量的哨兵节点认为主节点有问题。<img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676357983904-e701faec-a65f-4976-a71f-684f7f5b65ce.png" alt="img"></p></li></ul><p>1、主观下线 每个Sentinel节点会每隔1秒对主节点、从节点、其他Sentinel节点发送ping命令做心跳检测，当这些节点超过 down-after-milliseconds没有进行有效回复，Sentinel节点就会对该节点做失败判定，这个行为叫做主观下线。</p><p>2、客观下线 当Sentinel主观下线的节点是主节点时，该Sentinel节点会通过sentinel is- master-down-by-addr命令向其他Sentinel节点询问对主节点的判断，当超过 个数，Sentinel节点认为主节点确实有问题，这时该Sentinel节点会做出客观下线的决定</p><ul><li><p><strong>领导者Sentinel节点选举</strong>Sentinel节点之间会做一个领导者选举的工作，选出一个Sentinel节点作为领导者进行故障转移的工作。Redis使用了Raft算法实现领导者选举。 </p></li><li><p><strong>故障转移</strong><br>  领导者选举出的Sentinel节点负责故障转移，过程如下：<br>  <img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676357986607-890712e2-3614-41d8-8c12-8dfe92bbd31b.png" alt="img"><br>  1、在从节点列表中选出一个节点作为新的主节点，这一步是相对复杂一些的一步<br>  2、Sentinel领导者节点会对第一步选出来的从节点执行slaveof no one命令让其成为主节点<br>  3、Sentinel领导者节点会向剩余的从节点发送命令，让它们成为新主节点的从节点<br>  4、Sentinel节点集合会将原来的主节点更新为从节点，并保持着对其关注，当其恢复后命令它去复制新的主节点</p></li></ul><h2 id="20-领导者Sentinel节点选举了解吗？"><a href="#20-领导者Sentinel节点选举了解吗？" class="headerlink" title="20.领导者Sentinel节点选举了解吗？"></a>20.领导者Sentinel节点选举了解吗？</h2><p>Redis使用了Raft算法实 现领导者选举，大致流程如下：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676357988308-dd177d4c-d634-4645-8cc7-13f9351c6da9.png" alt="img"></p><p>1、每个在线的Sentinel节点都有资格成为领导者，当它确认主节点主观 下线时候，会向其他Sentinel节点发送sentinel is-master-down-by-addr命令， 要求将自己设置为领导者。</p><p>2、收到命令的Sentinel节点，如果没有同意过其他Sentinel节点的sentinel is-master-down-by-addr命令，将同意该请求，否则拒绝。</p><p>3、如果该Sentinel节点发现自己的票数已经大于等于max（quorum， num（sentinels）&#x2F;2+1），那么它将成为领导者。</p><p>4、如果此过程没有选举出领导者，将进入下一次选举。</p><h2 id="21-新的主节点是怎样被挑选出来的？"><a href="#21-新的主节点是怎样被挑选出来的？" class="headerlink" title="21.新的主节点是怎样被挑选出来的？"></a>21.新的主节点是怎样被挑选出来的？</h2><p>选出新的主节点，大概分为这么几步：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676357991178-6de54651-8979-403c-9b6d-4dbd30d180e2.png" alt="img"></p><p>1、过滤：“不健康”（主观下线、断线）、5秒内没有回复过Sentinel节 点ping响应、与主节点失联超过down-after-milliseconds*10秒。</p><p>2、选择slave-priority（从节点优先级）最高的从节点列表，如果存在则返回，不存在则继续。</p><p>3、选择复制偏移量最大的从节点（复制的最完整），如果存在则返 回，不存在则继续。</p><p>4、选择runid最小的从节点。</p><h2 id="22-Redis-集群了解吗？"><a href="#22-Redis-集群了解吗？" class="headerlink" title="22.Redis 集群了解吗？"></a>22.Redis 集群了解吗？</h2><p>前面说到了主从存在高可用和分布式的问题，哨兵解决了高可用的问题，而集群就是终极方案，一举解决高可用和分布式问题。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676357993275-87209457-3152-4670-b118-ea136969688b.png" alt="img"></p><p>1、<strong>数据分区：</strong> 数据分区 <em>(或称数据分片)</em> 是集群最核心的功能。集群将数据分散到多个节点，一方面 突破了 Redis 单机内存大小的限制，<strong>存储容量大大增加</strong>；<strong>另一方面</strong> 每个主节点都可以对外提供读服务和写服务，<strong>大大提高了集群的响应能力</strong>。</p><p>2、<strong>高可用：</strong> 集群支持主从复制和主节点的 <strong>自动故障转移</strong> <em>（与哨兵类似）</em>，当任一节点发生故障时，集群仍然可以对外提供服务。</p><h2 id="23-集群中数据如何分区？"><a href="#23-集群中数据如何分区？" class="headerlink" title="23.集群中数据如何分区？"></a>23.集群中数据如何分区？</h2><p>分布式的存储中，要把数据集按照分区规则映射到多个节点，常见的数据分区规则三种：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676357995086-e5f00bd4-ace4-4ddc-86f4-4f1a4b33e451.png" alt="img"></p><h3 id="方案一：节点取余分区"><a href="#方案一：节点取余分区" class="headerlink" title="方案一：节点取余分区"></a>方案一：节点取余分区</h3><p>节点取余分区，非常好理解，使用特定的数据，比如Redis的键，或者用户ID之类，对响应的hash值取余：hash（key）%N，来确定数据映射到哪一个节点上。</p><p>不过该方案最大的问题是，当节点数量变化时，如扩容或收缩节点，数据节点映射关 系需要重新计算，会导致数据的重新迁移。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676357997219-aa27007d-dabc-4a2e-a8a7-e464fb73eb32.png" alt="img"></p><h3 id="方案二：一致性哈希分区"><a href="#方案二：一致性哈希分区" class="headerlink" title="方案二：一致性哈希分区"></a>方案二：一致性哈希分区</h3><p>将整个 Hash 值空间组织成一个虚拟的圆环，然后将缓存节点的 IP 地址或者主机名做 Hash 取值后，放置在这个圆环上。当我们需要确定某一个 Key 需 要存取到哪个节点上的时候，先对这个 Key 做同样的 Hash 取值，确定在环上的位置，然后按照顺时针方向在环上“行走”，遇到的第一个缓存节点就是要访问的节点。</p><p>比如说下面 这张图里面，Key 1 和 Key 2 会落入到 Node 1 中，Key 3、Key 4 会落入到 Node 2 中，Key 5 落入到 Node 3 中，Key 6 落入到 Node 4 中。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676357998826-145db0ac-cd63-4931-8bf1-fc1167f01b02.png" alt="img"></p><p>这种方式相比节点取余最大的好处在于加入和删除节点只影响哈希环中 相邻的节点，对其他节点无影响。</p><p>但它还是存在问题：</p><ul><li><p>缓存节点在圆环上分布不平均，会造成部分缓存节点的压力较大</p></li><li><p>当某个节点故障时，这个节点所要承担的所有访问都会被顺移到另一个节点上，会对后面这个节点造成力。</p></li></ul><h3 id="方案三：虚拟槽分区"><a href="#方案三：虚拟槽分区" class="headerlink" title="方案三：虚拟槽分区"></a>方案三：虚拟槽分区</h3><p>这个方案 一致性哈希分区的基础上，引入了 <strong>虚拟节点</strong> 的概念。Redis 集群使用的便是该方案，其中的虚拟节点称为 <strong>槽（slot）</strong>。槽是介于数据和实际节点之间的虚拟概念，每个实际节点包含一定数量的槽，每个槽包含哈希值在一定范围内的数据。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358000877-4a37bfdd-1b56-4023-82fd-d8890a4f4a65.png" alt="img"></p><p>在使用了槽的一致性哈希分区中，槽是数据管理和迁移的基本单位。槽解耦了数据和实际节点 之间的关系，增加或删除节点对系统的影响很小。仍以上图为例，系统中有 <code>4</code> 个实际节点，假设为其分配 <code>16</code> 个槽(0-15)；</p><ul><li>槽 0-3 位于 node1；4-7 位于 node2；以此类推….</li></ul><p>如果此时删除 <code>node2</code>，只需要将槽 4-7 重新分配即可，例如槽 4-5 分配给 <code>node1</code>，槽 6 分配给 <code>node3</code>，槽 7 分配给 <code>node4</code>，数据在其他节点的分布仍然较为均衡。</p><h2 id="24-能说说Redis集群的原理吗？"><a href="#24-能说说Redis集群的原理吗？" class="headerlink" title="24.能说说Redis集群的原理吗？"></a>24.能说说Redis集群的原理吗？</h2><p>Redis集群通过数据分区来实现数据的分布式存储，通过自动故障转移实现高可用。</p><h3 id="集群创建"><a href="#集群创建" class="headerlink" title="集群创建"></a>集群创建</h3><p>数据分区是在集群创建的时候完成的。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358003277-20e4896c-0852-46e2-b4d6-d3b84166fb5b.png" alt="img"></p><p><strong>设置节点</strong>Redis集群一般由多个节点组成，节点数量至少为6个才能保证组成完整高可用的集群。每个节点需要开启配置cluster-enabled yes，让Redis运行在集群模式下。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358007186-79bac799-da1e-41a5-ac23-e40bc2d95a27.png" alt="img"></p><p><strong>节点握手</strong>节点握手是指一批运行在集群模式下的节点通过Gossip协议彼此通信， 达到感知对方的过程。节点握手是集群彼此通信的第一步，由客户端发起命 令：cluster meet{ip}{port}。完成节点握手之后，一个个的Redis节点就组成了一个多节点的集群。</p><p><strong>分配槽（slot）</strong>Redis集群把所有的数据映射到16384个槽中。每个节点对应若干个槽，只有当节点分配了槽，才能响应和这些槽关联的键命令。通过 cluster addslots命令为节点分配槽。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358007221-c41a5dbf-2f6a-4cb9-892b-e815c3d35ac1.png" alt="img"></p><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>Redis集群的故障转移和哨兵的故障转移类似，但是Redis集群中所有的节点都要承担状态维护的任务。</p><p><strong>故障发现</strong>Redis集群内节点通过ping&#x2F;pong消息实现节点通信，集群中每个节点都会定期向其他节点发送ping消息，接收节点回复pong 消息作为响应。如果在cluster-node-timeout时间内通信一直失败，则发送节 点会认为接收节点存在故障，把接收节点标记为主观下线（pfail）状态。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358009360-b4011f7d-39f0-45f9-9a79-8189f7f61411.png" alt="img"></p><p>当某个节点判断另一个节点主观下线后，相应的节点状态会跟随消息在集群内传播。通过Gossip消息传播，集群内节点不断收集到故障节点的下线报告。当 半数以上持有槽的主节点都标记某个节点是主观下线时。触发客观下线流程。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358011041-cbab41ad-32fe-4e92-8c57-30463e207541.png" alt="img"></p><p><strong>故障恢复</strong></p><p>故障节点变为客观下线后，如果下线节点是持有槽的主节点则需要在它 的从节点中选出一个替换它，从而保证集群的高可用。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358013040-de71286d-bfb6-4210-bbe9-e90505f57142.png" alt="img"></p><p>1、资格检查 每个从节点都要检查最后与主节点断线时间，判断是否有资格替换故障 的主节点。</p><p>2、准备选举时间 当从节点符合故障转移资格后，更新触发故障选举的时间，只有到达该 时间后才能执行后续流程。</p><p>3、发起选举 当从节点定时任务检测到达故障选举时间（failover_auth_time）到达后，发起选举流程。</p><p>4、选举投票 持有槽的主节点处理故障选举消息。投票过程其实是一个领导者选举的过程，如集群内有N个持有槽的主节 点代表有N张选票。由于在每个配置纪元内持有槽的主节点只能投票给一个 从节点，因此只能有一个从节点获得N&#x2F;2+1的选票，保证能够找出唯一的从节点。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358015026-424352e4-ec39-4d94-9b47-e6d61513f8f5.png" alt="img"></p><p>5、替换主节点 当从节点收集到足够的选票之后，触发替换主节点操作。</p><p><strong>部署Redis集群至少需要几个物理节点？</strong></p><p>在投票选举的环节，故障主节点也算在投票数内，假设集群内节点规模是3主3从，其中有2 个主节点部署在一台机器上，当这台机器宕机时，由于从节点无法收集到 3&#x2F;2+1个主节点选票将导致故障转移失败。这个问题也适用于故障发现环节。因此部署集群时所有主节点最少需要部署在3台物理机上才能避免单点问题。</p><h2 id="25-说说集群的伸缩？"><a href="#25-说说集群的伸缩？" class="headerlink" title="25.说说集群的伸缩？"></a>25.说说集群的伸缩？</h2><p>Redis集群提供了灵活的节点扩容和收缩方案，可以在不影响集群对外服务的情况下，为集群添加节点进行扩容也可以下线部分节点进行缩容。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358017202-93f54195-2406-4364-a213-c5381c6c69a7.png" alt="img"></p><p>其实，集群扩容和缩容的关键点，就在于槽和节点的对应关系，扩容和缩容就是将一部分<code>槽</code>和<code>数据</code>迁移给新节点。</p><p>例如下面一个集群，每个节点对应若干个槽，每个槽对应一定的数据，如果希望加入1个节点希望实现集群扩容时，需要通过相关命令把一部分槽和内容迁移给新节点。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358018974-a654f3c7-7dd0-48cb-b5e4-1098cc401a3e.png" alt="img"></p><p>缩容也是类似，先把槽和数据迁移到其它节点，再把对应的节点下线。</p><h2 id="26-什么是缓存击穿、缓存穿透、缓存雪崩？"><a href="#26-什么是缓存击穿、缓存穿透、缓存雪崩？" class="headerlink" title="26.什么是缓存击穿、缓存穿透、缓存雪崩？"></a>26.什么是缓存击穿、缓存穿透、缓存雪崩？</h2><p>PS:这是多年黄历的老八股了，一定要理解清楚。</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>一个并发访问量比较大的key在某个时间过期，导致所有的请求直接打在DB上。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358022256-fac5bf65-df2e-4b00-950e-32802c669f99.png" alt="img"></p><p>解决⽅案：</p><p>1、加锁更新，⽐如请求查询A，发现缓存中没有，对A这个key加锁，同时去数据库查询数据，写⼊缓存，再返回给⽤户，这样后⾯的请求就可以从缓存中拿到数据了。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358023646-e1604997-aefe-4766-ad7f-37fcea643d85.png" alt="img"></p><p>2、将过期时间组合写在value中，通过异步的⽅式不断的刷新过期时间，防⽌此类现象。</p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透指的查询缓存和数据库中都不存在的数据，这样每次请求直接打到数据库，就好像缓存不存在一样。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358025914-91cb6f85-f76e-4a00-bedd-e21097f3aff6.png" alt="img"></p><p>缓存穿透将导致不存在的数据每次请求都要到存储层去查询，失去了缓存保护后端存储的意义。</p><p>缓存穿透可能会使后端存储负载加大，如果发现大量存储层空命中，可能就是出现了缓存穿透问题。</p><p>缓存穿透可能有两种原因：</p><p>1、自身业务代码问题</p><p>2、恶意攻击，爬虫造成空命中</p><p>它主要有两种解决办法：</p><p><strong>缓存空值&#x2F;默认值</strong></p><p>一种方式是在数据库不命中之后，把一个空对象或者默认值保存到缓存，之后再访问这个数据，就会从缓存中获取，这样就保护了数据库。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358051741-940ee42f-b150-46be-a375-e86356695809.png" alt="img"></p><p>缓存空值有两大问题：</p><p>1、空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间（如果是攻击，问题更严重），比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。</p><p>2、缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。例如过期时间设置为5分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致。这时候可以利用消息队列或者其它异步方式清理缓存中的空对象。</p><p><strong>布隆过滤器</strong></p><p>除了缓存空对象，我们还可以在存储和缓存之前，加一个布隆过滤器，做一层过滤。</p><p>布隆过滤器里会保存数据是否存在，如果判断数据不不能再，就不会访问存储。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358053666-c05a6f01-ee7d-4969-8842-90f9a3ab40c5.png" alt="img"></p><p>两种解决方案的对比：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358055414-43b3405a-b2f7-4c11-850a-8fe99d54f7da.png" alt="img"></p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>某⼀时刻发⽣⼤规模的缓存失效的情况，例如缓存服务宕机、大量key在同一时间过期，这样的后果就是⼤量的请求进来直接打到DB上，可能导致整个系统的崩溃，称为雪崩。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358057194-0e56aa6f-008c-4f90-a5bd-10cb5c3224fe.png" alt="img"></p><p>缓存雪崩是三大缓存问题里最严重的一种，我们来看看怎么预防和处理。</p><ul><li><strong>提高缓存可用性</strong></li></ul><p>1、集群部署：通过集群来提升缓存的可用性，可以利用Redis本身的Redis Cluster或者第三方集群方案如Codis等。</p><p>2、多级缓存：设置多级缓存，第一级缓存失效的基础上，访问二级缓存，每一级缓存的失效时间都不同。</p><ul><li><strong>过期时间</strong></li></ul><p>1、均匀过期：为了避免大量的缓存在同一时间过期，可以把不同的 key 过期时间随机生成，避免过期时间太过集中。</p><p>2、热点数据永不过期。</p><ul><li><strong>熔断降级</strong></li></ul><p>1、服务熔断：当缓存服务器宕机或超时响应时，为了防止整个系统出现雪崩，暂时停止业务服务访问缓存系统。</p><p>2、服务降级：当出现大量缓存失效，而且处在高并发高负荷的情况下，在业务系统内部暂时舍弃对一些非核心的接口和数据的请求，而直接返回一个提前准备好的 fallback（退路）错误处理信息。</p><h2 id="27-能说说布隆过滤器吗？"><a href="#27-能说说布隆过滤器吗？" class="headerlink" title="27.能说说布隆过滤器吗？"></a>27.能说说布隆过滤器吗？</h2><p>布隆过滤器，它是一个连续的数据结构，每个存储位存储都是一个<code>bit</code>，即<code>0</code>或者<code>1</code>, 来标识数据是否存在。</p><p>存储数据的时时候，使用K个不同的哈希函数将这个变量映射为bit列表的的K个点，把它们置为1。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358059389-9eca7a20-a059-40a4-a458-2dc9776ca7d7.png" alt="img">我们判断缓存key是否存在，同样，K个哈希函数，映射到bit列表上的K个点，判断是不是1：</p><ul><li><p>如果全不是1，那么key不存在；</p></li><li><p>如果都是1，也只是表示key可能存在。</p></li></ul><p>布隆过滤器也有一些缺点：</p><p>1、它在判断元素是否在集合中时是有一定错误几率，因为哈希算法有一定的碰撞的概率。</p><p>2、不支持删除元素。</p><h2 id="28-如何保证缓存和数据库数据的⼀致性？"><a href="#28-如何保证缓存和数据库数据的⼀致性？" class="headerlink" title="28.如何保证缓存和数据库数据的⼀致性？"></a>28.如何保证缓存和数据库数据的⼀致性？</h2><p>根据CAP理论，在保证可用性和分区容错性的前提下，无法保证一致性，所以缓存和数据库的绝对一致是不可能实现的，只能尽可能保存缓存和数据库的最终一致性。</p><h3 id="选择合适的缓存更新策略"><a href="#选择合适的缓存更新策略" class="headerlink" title="选择合适的缓存更新策略"></a>选择合适的缓存更新策略</h3><p><strong>1、删除缓存而不是更新缓存</strong></p><p>当一个线程对缓存的key进行写操作的时候，如果其它线程进来读数据库的时候，读到的就是脏数据，产生了数据不一致问题。</p><p>相比较而言，删除缓存的速度比更新缓存的速度快很多，所用时间相对也少很多，读脏数据的概率也小很多。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358062268-a8c6e24a-90dd-4ec1-bb53-d4518984bf07.png" alt="img"></p><p><strong>2、先更数据，后删缓存</strong></p><p>先更数据库还是先删缓存？这是一个问题。</p><p>更新数据，耗时可能在删除缓存的百倍以上。在缓存中不存在对应的key，数据库又没有完成更新的时候，如果有线程进来读取数据，并写入到缓存，那么在更新成功之后，这个key就是一个脏数据。</p><p>毫无疑问，先删缓存，再更数据库，缓存中key不存在的时间的时间更长，有更大的概率会产生脏数据。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358063739-061b60d7-e79c-4033-baca-6f9e88b93419.png" alt="img">目前最流行的缓存读写策略cache-aside-pattern就是采用先更数据库，再删缓存的方式。</p><h3 id="缓存不一致处理"><a href="#缓存不一致处理" class="headerlink" title="缓存不一致处理"></a>缓存不一致处理</h3><p>如果不是并发特别高，对缓存依赖性很强，其实一定程序的不一致是可以接受的。</p><p>但是如果对一致性要求比较高，那就得想办法保证缓存和数据库中数据一致。</p><p>缓存和数据库数据不一致常见的两种原因：</p><ul><li><p>缓存key删除失败</p></li><li><p>并发导致写入了脏数据</p></li></ul><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358065302-a0c3c047-4cae-4b7d-80de-d724af90f74a.png" alt="img"></p><p><strong>消息队列保证key被删除</strong>可以引入消息队列，把要删除的key或者删除失败的key丢尽消息队列，利用消息队列的重试机制，重试删除对应的key。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358066991-a4d69dcc-15c0-4dff-a6bf-450bc926e2ee.png" alt="img"></p><p>这种方案看起来不错，缺点是对业务代码有一定的侵入性。</p><p><strong>数据库订阅+消息队列保证key被删除</strong>可以用一个服务（比如阿里的 canal）去监听数据库的binlog，获取需要操作的数据。</p><p>然后用一个公共的服务获取订阅程序传来的信息，进行缓存删除操作。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358068763-ba0591db-0b60-4d15-9e46-054bc843e478.png" alt="img"></p><p>这种方式降低了对业务的侵入，但其实整个系统的复杂度是提升的，适合基建完善的大厂。</p><p><strong>延时双删防止脏数据</strong>还有一种情况，是在缓存不存在的时候，写入了脏数据，这种情况在先删缓存，再更数据库的缓存更新策略下发生的比较多，解决方案是延时双删。</p><p>简单说，就是在第一次删除缓存之后，过了一段时间之后，再次删除缓存。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358070316-422f2470-9aa6-4623-9cfd-dfb996e66ab6.png" alt="img"></p><p>这种方式的延时时间设置需要仔细考量和测试。</p><p><strong>设置缓存过期时间兜底</strong></p><p>这是一个朴素但是有用的办法，给缓存设置一个合理的过期时间，即使发生了缓存数据不一致的问题，它也不会永远不一致下去，缓存过期的时候，自然又会恢复一致。</p><h2 id="29-如何保证本地缓存和分布式缓存的一致？"><a href="#29-如何保证本地缓存和分布式缓存的一致？" class="headerlink" title="29.如何保证本地缓存和分布式缓存的一致？"></a>29.如何保证本地缓存和分布式缓存的一致？</h2><p>PS:这道题面试很少问，但实际工作中很常见。</p><p>在日常的开发中，我们常常采用两级缓存：本地缓存+分布式缓存。</p><p>所谓本地缓存，就是对应服务器的内存缓存，比如Caffeine，分布式缓存基本就是采用Redis。</p><p>那么问题来了，本地缓存和分布式缓存怎么保持数据一致？</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358073717-299c0290-8921-4083-a79c-9b91d395ed91.png" alt="img"></p><p>Redis缓存，数据库发生更新，直接删除缓存的key即可，因为对于应用系统而言，它是一种中心化的缓存。</p><p>但是本地缓存，它是非中心化的，散落在分布式服务的各个节点上，没法通过客户端的请求删除本地缓存的key，所以得想办法通知集群所有节点，删除对应的本地缓存key。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358075657-da6e3496-a2b0-4bcc-b448-901b6fc154ce.png" alt="img"></p><p>可以采用消息队列的方式：</p><p>1、采用Redis本身的Pub&#x2F;Sub机制，分布式集群的所有节点订阅删除本地缓存频道，删除Redis缓存的节点，同事发布删除本地缓存消息，订阅者们订阅到消息后，删除对应的本地key。但是Redis的发布订阅不是可靠的，不能保证一定删除成功。</p><p>2、引入专业的消息队列，比如RocketMQ，保证消息的可靠性，但是增加了系统的复杂度。</p><p>3、设置适当的过期时间兜底，本地缓存可以设置相对短一些的过期时间。</p><h2 id="30-怎么处理热key？"><a href="#30-怎么处理热key？" class="headerlink" title="30.怎么处理热key？"></a>30.怎么处理热key？</h2><p><strong>什么是热Key？</strong>所谓的热key，就是访问频率比较的key。</p><p>比如，热门新闻事件或商品，这类key通常有大流量的访问，对存储这类信息的 Redis来说，是不小的压力。</p><p>假如Redis集群部署，热key可能会造成整体流量的不均衡，个别节点出现OPS过大的情况，极端情况下热点key甚至会超过 Redis本身能够承受的OPS。</p><p><strong>怎么处理热key？</strong></p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358077809-ef759e84-8d0b-4d53-903f-4a9c95aa96b3.png" alt="img"></p><p>对热key的处理，最关键的是对热点key的监控，可以从这些端来监控热点key:</p><p>1、客户端 客户端其实是距离key“最近”的地方，因为Redis命令就是从客户端发出的，例如在客户端设置全局字典（key和调用次数），每次调用Redis命令时，使用这个字典进行记录。</p><p>2、代理端 像Twemproxy、Codis这些基于代理的Redis分布式架构，所有客户端的请求都是通过代理端完成的，可以在代理端进行收集统计。</p><p>3、Redis服务端 使用monitor命令统计热点key是很多开发和运维人员首先想到，monitor命令可以监控到Redis执行的所有命令。</p><p>只要监控到了热key，对热key的处理就简单了：</p><p>1、把热key打散到不同的服务器，降低压⼒</p><p>2、加⼊⼆级缓存，提前加载热key数据到内存中，如果redis宕机，⾛内存查询</p><h2 id="31-缓存预热怎么做呢？"><a href="#31-缓存预热怎么做呢？" class="headerlink" title="31.缓存预热怎么做呢？"></a>31.缓存预热怎么做呢？</h2><p>所谓缓存预热，就是提前把数据库里的数据刷到缓存里，通常有这些方法：</p><p>1、直接写个缓存刷新页面或者接口，上线时手动操作</p><p>2、数据量不大，可以在项目启动的时候自动进行加载</p><p>3、定时任务刷新缓存.</p><h2 id="32-热点key重建？问题？解决？"><a href="#32-热点key重建？问题？解决？" class="headerlink" title="32.热点key重建？问题？解决？"></a>32.热点key重建？问题？解决？</h2><p>开发的时候一般使用“缓存+过期时间”的策略，既可以加速数据读写，又保证数据的定期更新，这种模式基本能够满足绝大部分需求。</p><p>但是有两个问题如果同时出现，可能就会出现比较大的问题：</p><ul><li><p>当前key是一个热点key（例如一个热门的娱乐新闻），并发量非常大。</p></li><li><p>重建缓存不能在短时间完成，可能是一个复杂计算，例如复杂的 SQL、多次IO、多个依赖等。在缓存失效的瞬间，有大量线程来重建缓存，造成后端负载加大，甚至可能会让应用崩溃。</p></li></ul><p><strong>怎么处理呢？</strong></p><p>要解决这个问题也不是很复杂，解决问题的要点在于：</p><ul><li><p>减少重建缓存的次数。</p></li><li><p>数据尽可能一致。</p></li><li><p>较少的潜在危险。</p></li></ul><p>所以一般采用如下方式：</p><p>1、互斥锁（mutex key） 这种方法只允许一个线程重建缓存，其他线程等待重建缓存的线程执行完，重新从缓存获取数据即可。</p><p>2、永远不过期 “永远不过期”包含两层意思：</p><p>从缓存层面来看，确实没有设置过期时间，所以不会出现热点key过期后产生的问题，也就是“物理”不过期。</p><p>从功能层面来看，为每个value设置一个逻辑过期时间，当发现超过逻辑过期时间后，会使用单独的线程去构建缓存。</p><h2 id="33-无底洞问题吗？如何解决？"><a href="#33-无底洞问题吗？如何解决？" class="headerlink" title="33.无底洞问题吗？如何解决？"></a>33.无底洞问题吗？如何解决？</h2><p><strong>什么是无底洞问题？</strong></p><p>2010年，Facebook的Memcache节点已经达到了3000个，承载着TB级别的缓存数据。但开发和运维人员发现了一个问题，为了满足业务要求添加了大量新Memcache节点，但是发现性能不但没有好转反而下降了，当时将这 种现象称为缓存的“<strong>无底洞</strong>”现象。</p><p>那么为什么会产生这种现象呢?</p><p>通常来说添加节点使得Memcache集群 性能应该更强了，但事实并非如此。键值数据库由于通常采用哈希函数将 key映射到各个节点上，造成key的分布与业务无关，但是由于数据量和访问量的持续增长，造成需要添加大量节点做水平扩容，导致键值分布到更多的 节点上，所以无论是Memcache还是Redis的分布式，批量操作通常需要从不同节点上获取，相比于单机批量操作只涉及一次网络操作，分布式批量操作会涉及多次网络时间。</p><p><strong>无底洞问题如何优化呢？</strong></p><p>先分析一下无底洞问题：</p><ul><li><p>客户端一次批量操作会涉及多次网络操作，也就意味着批量操作会随着节点的增多，耗时会不断增大。</p></li><li><p>网络连接数变多，对节点的性能也有一定影响。</p></li></ul><p>常见的优化思路如下：</p><ul><li><p>命令本身的优化，例如优化操作语句等。</p></li><li><p>减少网络通信次数。</p></li><li><p>降低接入成本，例如客户端使用长连&#x2F;连接池、NIO等。</p></li></ul><h2 id="34-Redis报内存不足怎么处理？"><a href="#34-Redis报内存不足怎么处理？" class="headerlink" title="34.Redis报内存不足怎么处理？"></a>34.Redis报内存不足怎么处理？</h2><p>Redis 内存不足有这么几种处理方式：</p><ul><li><p>修改配置文件 redis.conf 的 maxmemory 参数，增加 Redis 可用内存</p></li><li><p>也可以通过命令set maxmemory动态设置内存上限</p></li><li><p>修改内存淘汰策略，及时释放内存空间</p></li><li><p>使用 Redis 集群模式，进行横向扩容。</p></li></ul><h2 id="35-Redis的过期数据回收策略有哪些？"><a href="#35-Redis的过期数据回收策略有哪些？" class="headerlink" title="35.Redis的过期数据回收策略有哪些？"></a>35.Redis的过期数据回收策略有哪些？</h2><p>Redis主要有2种过期数据回收策略：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358082004-332ebb99-fd8b-4450-a436-b3ca3652564e.png" alt="img"></p><p><strong>惰性删除</strong></p><p>惰性删除指的是当我们查询key的时候才对key进⾏检测，如果已经达到过期时间，则删除。显然，他有⼀个缺点就是如果这些过期的key没有被访问，那么他就⼀直⽆法被删除，⽽且⼀直占⽤内存。</p><p><strong>定期删除</strong></p><p>定期删除指的是Redis每隔⼀段时间对数据库做⼀次检查，删除⾥⾯的过期key。由于不可能对所有key去做轮询来删除，所以Redis会每次随机取⼀些key去做检查和删除。</p><h2 id="36-Redis有哪些内存溢出控制-x2F-内存淘汰策略？"><a href="#36-Redis有哪些内存溢出控制-x2F-内存淘汰策略？" class="headerlink" title="36.Redis有哪些内存溢出控制&#x2F;内存淘汰策略？"></a>36.Redis有哪些内存溢出控制&#x2F;内存淘汰策略？</h2><p>Redis所用内存达到maxmemory上限时会触发相应的溢出控制策略，Redis支持六种策略：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358083740-4191418b-dbd8-4ba6-97d5-252e3567c23d.png" alt="img"></p><p>1、<code>noeviction</code>：默认策略，不会删除任何数据，拒绝所有写入操作并返 回客户端错误信息，此 时Redis只响应读操作。</p><p>2、<code>volatile-lru</code>：根据LRU算法删除设置了超时属性（expire）的键，直 到腾出足够空间为止。如果没有可删除的键对象，回退到noeviction策略。</p><p>3、<code>allkeys-lru</code>：根据LRU算法删除键，不管数据有没有设置超时属性， 直到腾出足够空间为止。</p><p>4、<code>allkeys-random</code>：随机删除所有键，直到腾出足够空间为止。</p><p>5、<code>volatile-random</code>：随机删除过期键，直到腾出足够空间为止。</p><p>6、<code>volatile-ttl</code>：根据键值对象的ttl属性，删除最近将要过期数据。如果 没有，回退到noeviction策略。</p><h2 id="37-Redis阻塞？怎么解决？"><a href="#37-Redis阻塞？怎么解决？" class="headerlink" title="37.Redis阻塞？怎么解决？"></a>37.Redis阻塞？怎么解决？</h2><p>Redis发生阻塞，可以从以下几个方面排查：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358085937-8e75deb6-993a-4627-b2e2-763553e949b4.png" alt="img"></p><p><strong>API或数据结构使用不合理</strong></p><p>通常Redis执行命令速度非常快，但是不合理地使用命令，可能会导致执行速度很慢，导致阻塞，对于高并发的场景，应该尽量避免在大对象上执行算法复杂 度超过O（n）的命令。</p><p>对慢查询的处理分为两步：</p><p>1、发现慢查询：slowlog get{n}命令可以获取最近 的n条慢查询命令；</p><p>2、发现慢查询后，可以从两个方向去优化慢查询：1）修改为低算法复杂度的命令，如hgetall改为hmget等，禁用keys、sort等命 令 2）调整大对象：缩减大对象数据或把大对象拆分为多个小对象，防止一次命令操作过多的数据。</p><p><strong>CPU饱和的问题</strong></p><p>单线程的Redis处理命令时只能使用一个CPU。而CPU饱和是指Redis单核CPU使用率跑到接近100%。</p><p>针对这种情况，处理步骤一般如下：</p><p>1、判断当前Redis并发量是否已经达到极限，可以使用统计命令redis-cli-h{ip}-p{port}–stat获取当前 Redis使用情况</p><p>2、如果Redis的请求几万+，那么大概就是Redis的OPS已经到了极限，应该做集群化水品扩展来分摊OPS压力</p><p>3、如果只有几百几千，那么就得排查命令和内存的使用</p><p><strong>持久化相关的阻塞</strong></p><p>对于开启了持久化功能的Redis节点，需要排查是否是持久化导致的阻塞。</p><p>1、fork阻塞 fork操作发生在RDB和AOF重写时，Redis主线程调用fork操作产生共享 内存的子进程，由子进程完成持久化文件重写工作。如果fork操作本身耗时过长，必然会导致主线程的阻塞。</p><p>2、AOF刷盘阻塞 当我们开启AOF持久化功能时，文件刷盘的方式一般采用每秒一次，后台线程每秒对AOF文件做fsync操作。当硬盘压力过大时，fsync操作需要等 待，直到写入完成。如果主线程发现距离上一次的fsync成功超过2秒，为了 数据安全性它会阻塞直到后台线程执行fsync操作完成。</p><p>3、HugePage写操作阻塞 对于开启Transparent HugePages的 操作系统，每次写命令引起的复制内存页单位由4K变为2MB，放大了512 倍，会拖慢写操作的执行时间，导致大量写操作慢查询。</p><h2 id="38-大key问题了解吗？"><a href="#38-大key问题了解吗？" class="headerlink" title="38.大key问题了解吗？"></a>38.大key问题了解吗？</h2><p>Redis使用过程中，有时候会出现大key的情况， 比如：</p><ul><li><p>单个简单的key存储的value很大，size超过10KB</p></li><li><p>hash， set，zset，list 中存储过多的元素（以万为单位）</p></li></ul><p><strong>大key会造成什么问题呢？</strong></p><ul><li><p>客户端耗时增加，甚至超时</p></li><li><p>对大key进行IO操作时，会严重占用带宽和CPU</p></li><li><p>造成Redis集群中数据倾斜</p></li><li><p>主动删除、被动删等，可能会导致阻塞</p></li></ul><p><strong>如何找到大key?</strong></p><ul><li><p>bigkeys命令：使用bigkeys命令以遍历的方式分析Redis实例中的所有Key，并返回整体统计信息与每个数据类型中Top1的大Key</p></li><li><p>redis-rdb-tools：redis-rdb-tools是由Python写的用来分析Redis的rdb快照文件用的工具，它可以把rdb快照文件生成json文件或者生成报表用来分析Redis的使用详情。</p></li></ul><p><strong>如何处理大key?</strong></p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358088950-07608c5b-a11e-4db3-ad0b-bfb9b3721912.png" alt="img"></p><ul><li><strong>删除大key</strong></li></ul><p>当Redis版本大于4.0时，可使用UNLINK命令安全地删除大Key，该命令能够以非阻塞的方式，逐步地清理传入的Key。</p><p>当Redis版本小于4.0时，避免使用阻塞式命令KEYS，而是建议通过SCAN命令执行增量迭代扫描key，然后判断进行删除。</p><p><strong>压缩和拆分key</strong></p><p>当vaule是string时，比较难拆分，则使用序列化、压缩算法将key的大小控制在合理范围内，但是序列化和反序列化都会带来更多时间上的消耗。</p><p>当value是string，压缩之后仍然是大key，则需要进行拆分，一个大key分为不同的部分，记录每个部分的key，使用multiget等操作实现事务读取。</p><p>当value是list&#x2F;set等集合类型时，根据预估的数据规模来进行分片，不同的元素计算后分到不同的片。</p><h2 id="39-Redis常见性能问题和解决方案？"><a href="#39-Redis常见性能问题和解决方案？" class="headerlink" title="39.Redis常见性能问题和解决方案？"></a>39.Redis常见性能问题和解决方案？</h2><p>1、Master 最好不要做任何持久化工作，包括内存快照和 AOF 日志文件，特别是不要启用内存快照做持久化。</p><p>2、如果数据比较关键，某个 Slave 开启 AOF 备份数据，策略为每秒同步一次。</p><p>3、为了主从复制的速度和连接的稳定性，Slave 和 Master 最好在同一个局域网内。</p><p>4、尽量避免在压力较大的主库上增加从库。</p><p>5、Master 调用 BGREWRITEAOF 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象。</p><p>6、为了 Master 的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…，这样的结构也方便解决单点故障问题，实现 Slave 对 Master 的替换，也即，如果 Master 挂了，可以立马启用 Slave1 做 Master，其他不变。</p><h2 id="40-使用Redis-如何实现异步队列？"><a href="#40-使用Redis-如何实现异步队列？" class="headerlink" title="40.使用Redis 如何实现异步队列？"></a>40.使用Redis 如何实现异步队列？</h2><p>我们知道redis支持很多种结构的数据，那么如何使用redis作为异步队列使用呢？一般有以下几种方式：</p><p><strong>使用list作为队列，lpush生产消息，rpop消费消息</strong></p><p>这种方式，消费者死循环rpop从队列中消费消息。但是这样，即使队列里没有消息，也会进行rpop，会导致Redis CPU的消耗。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358091817-5087270c-ed2b-4079-b058-e22260145247.png" alt="img"></p><p>可以通过让消费者休眠的方式的方式来处理，但是这样又会又消息的延迟问题。</p><p><strong>使用list作为队列，lpush生产消息，brpop消费消息</strong></p><p>brpop是rpop的阻塞版本，list为空的时候，它会一直阻塞，直到list中有值或者超时。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358093630-67ec8c34-0d24-47aa-b3eb-5d4433494cb7.png" alt="img"></p><p>这种方式只能实现一对一的消息队列。</p><p><strong>使用Redis的pub&#x2F;sub来进行消息的发布&#x2F;订阅</strong></p><p>发布&#x2F;订阅模式可以1：N的消息发布&#x2F;订阅。发布者将消息发布到指定的频道频道（channel），订阅相应频道的客户端都能收到消息。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358095448-7a18f5df-a836-465a-8d9d-998beb53dbf0.png" alt="img"></p><p>但是这种方式不是可靠的，它不保证订阅者一定能收到消息，也不进行消息的存储。</p><p>所以，一般的异步队列的实现还是交给专业的消息队列。</p><h2 id="41-Redis-如何实现延时队列"><a href="#41-Redis-如何实现延时队列" class="headerlink" title="41.Redis 如何实现延时队列?"></a>41.Redis 如何实现延时队列?</h2><p><strong>使用zset，利用排序实现</strong></p><p>可以使用 zset这个结构，用设置好的时间戳作为score进行排序，使用 zadd score1 value1 ….命令就可以一直往内存中生产消息。再利用 zrangebysocre 查询符合条件的所有待处理的任务，通过循环执行队列任务即可。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358097840-90b19855-085c-419e-8dca-5ca8182d5e15.png" alt="img"></p><h2 id="42-Redis-支持事务吗？"><a href="#42-Redis-支持事务吗？" class="headerlink" title="42.Redis 支持事务吗？"></a>42.Redis 支持事务吗？</h2><p>Redis提供了简单的事务，但它对事务ACID的支持并不完备。</p><p>multi命令代表事务开始，exec命令代表事务结束，它们之间的命令是原子顺序执行的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> multi OK<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> sadd user:a:follow user:b QUEUED <span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> sadd user:b:fans user:a QUEUED<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> sismember user:a:follow user:b <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> <span class="token builtin class-name">exec</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Redis事务的原理，是所有的指令在 exec 之前不执行，而是缓存在 服务器的一个事务队列中，服务器一旦收到 exec 指令，才开执行整个事务队列，执行完毕后一次性返回所有指令的运行结果。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358100402-afb0809b-36a1-45c0-a325-1cbd62a43dd3.png" alt="img"></p><p>因为Redis执行命令是单线程的，所以这组命令顺序执行，而且不会被其它线程打断。</p><p><strong>Redis事务的注意点有哪些？</strong></p><p>需要注意的点有：</p><ul><li><p>Redis 事务是不支持回滚的，不像 MySQL 的事务一样，要么都执行要么都不执行；</p></li><li><p>Redis 服务端在执行事务的过程中，不会被其他客户端发送来的命令请求打断。直到事务命令全部执行完毕才会执行其他客户端的命令。</p></li></ul><p><strong>Redis 事务为什么不支持回滚？</strong></p><p>Redis 的事务不支持回滚。</p><p>如果执行的命令有语法错误，Redis 会执行失败，这些问题可以从程序层面捕获并解决。但是如果出现其他问题，则依然会继续执行余下的命令。</p><p>这样做的原因是因为回滚需要增加很多工作，而不支持回滚则可以<strong>保持简单、快速的特性</strong>。</p><h2 id="43-Redis和Lua脚本的使用了解吗？"><a href="#43-Redis和Lua脚本的使用了解吗？" class="headerlink" title="43.Redis和Lua脚本的使用了解吗？"></a>43.Redis和Lua脚本的使用了解吗？</h2><p>Redis的事务功能比较简单，平时的开发中，可以利用Lua脚本来增强Redis的命令。</p><p>Lua脚本能给开发人员带来这些好处：</p><ul><li><p>Lua脚本在Redis中是原子执行的，执行过程中间不会插入其他命令。</p></li><li><p>Lua脚本可以帮助开发和运维人员创造出自己定制的命令，并可以将这 些命令常驻在Redis内存中，实现复用的效果。</p></li><li><p>Lua脚本可以将多条命令一次性打包，有效地减少网络开销。</p></li></ul><p>比如这一段很（烂）经（大）典（街）的秒杀系统利用lua扣减Redis库存的脚本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-- 库存未预热<span class="token keyword">if</span> <span class="token punctuation">(</span>redis.call<span class="token punctuation">(</span><span class="token string">'exists'</span>, KEYS<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">then</span>     <span class="token builtin class-name">return</span> -9<span class="token punctuation">;</span> end<span class="token punctuation">;</span> -- 秒杀商品库存存在 <span class="token keyword">if</span> <span class="token punctuation">(</span>redis.call<span class="token punctuation">(</span><span class="token string">'exists'</span>, KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">then</span>     <span class="token builtin class-name">local</span> stock <span class="token operator">=</span> tonumber<span class="token punctuation">(</span>redis.call<span class="token punctuation">(</span><span class="token string">'get'</span>, KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">))</span><span class="token punctuation">;</span>     <span class="token builtin class-name">local</span> num <span class="token operator">=</span> tonumber<span class="token punctuation">(</span>ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     -- 剩余库存少于请求数量     <span class="token keyword">if</span> <span class="token punctuation">(</span>stock <span class="token operator">&lt;</span> num<span class="token punctuation">)</span> <span class="token keyword">then</span>         <span class="token builtin class-name">return</span> <span class="token parameter variable">-3</span>     end<span class="token punctuation">;</span>     -- 扣减库存     <span class="token keyword">if</span> <span class="token punctuation">(</span>stock <span class="token operator">>=</span> num<span class="token punctuation">)</span> <span class="token keyword">then</span>         redis.call<span class="token punctuation">(</span><span class="token string">'incrby'</span>, KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>, <span class="token number">0</span> - num<span class="token punctuation">)</span><span class="token punctuation">;</span>         -- 扣减成功         <span class="token builtin class-name">return</span> <span class="token number">1</span>     end<span class="token punctuation">;</span>     <span class="token builtin class-name">return</span> -2<span class="token punctuation">;</span> end<span class="token punctuation">;</span> -- 秒杀商品库存不存在 <span class="token builtin class-name">return</span> -1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="44-Redis的管道了解吗？"><a href="#44-Redis的管道了解吗？" class="headerlink" title="44.Redis的管道了解吗？"></a>44.Redis的管道了解吗？</h2><p>Redis 提供三种将客户端多条命令打包发送给服务端执行的方式：</p><p>Pipelining(管道) 、 Transactions(事务) 和 Lua Scripts(Lua 脚本) 。</p><p><strong>Pipelining</strong>（管道）</p><p>Redis 管道是三者之中最简单的，当客户端需要执行多条 redis 命令时，可以通过管道一次性将要执行的多条命令发送给服务端，其作用是为了降低 RTT(Round Trip Time) 对性能的影响，比如我们使用 nc 命令将两条指令发送给 redis 服务端。</p><p>Redis 服务端接收到管道发送过来的多条命令后，会一直执命令，并将命令的执行结果进行缓存，直到最后一条命令执行完成，再所有命令的执行结果一次性返回给客户端 。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358103585-41bb3f1d-c6ff-4b97-ba0f-2fb9a38da921.png" alt="img"></p><p><strong>Pipelining的优势</strong></p><p>在性能方面， Pipelining 有下面两个优势：</p><ul><li><p><strong>节省了RTT</strong>：将多条命令打包一次性发送给服务端，减少了客户端与服务端之间的网络调用次数</p></li><li><p><strong>减少了上下文切换</strong>：当客户端&#x2F;服务端需要从网络中读写数据时，都会产生一次系统调用，系统调用是非常耗时的操作，其中设计到程序由用户态切换到内核态，再从内核态切换回用户态的过程。当我们执行 10 条 redis 命令的时候，就会发生 10 次用户态到内核态的上下文切换，但如果我们使用 Pipeining 将多条命令打包成一条一次性发送给服务端，就只会产生一次上下文切换。</p></li></ul><h2 id="45-Redis实现分布式锁了解吗？"><a href="#45-Redis实现分布式锁了解吗？" class="headerlink" title="45.Redis实现分布式锁了解吗？"></a>45.Redis实现分布式锁了解吗？</h2><p>Redis是分布式锁本质上要实现的目标就是在 Redis 里面占一个“茅坑”，当别的进程也要来占时，发现已经有人蹲在那里了，就只好放弃或者稍后再试。</p><p><strong>V1：setnx命令</strong></p><p>占坑一般是使用 setnx(set if not exists) 指令，只允许被一个客户端占坑。先来先占， 用完了，再调用 del 指令释放茅坑。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358106130-57562585-b16a-42c2-a546-1c398de58fc0.png" alt="img"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">></span> setnx lock:fighter <span class="token boolean">true</span>OK<span class="token punctuation">..</span>. <span class="token keyword">do</span> something critical <span class="token punctuation">..</span>.<span class="token operator">></span> del lock:fighter<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是有个问题，如果逻辑执行到中间出现异常了，可能会导致 del 指令没有被调用，这样就会陷入死锁，锁永远得不到释放。</p><p><strong>V2:锁超时释放</strong></p><p>所以在拿到锁之后，再给锁加上一个过期时间，比如 5s，这样即使中间出现异常也可以保证 5 秒之后锁会自动释放。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358108436-036d711b-b2a6-45b5-8a48-683883edb297.png" alt="img"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">></span> setnx lock:fighter <span class="token boolean">true</span>OK<span class="token operator">></span> expire lock:fighter <span class="token number">5</span><span class="token punctuation">..</span>. <span class="token keyword">do</span> something critical <span class="token punctuation">..</span>.<span class="token operator">></span> del lock:fighter<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是以上逻辑还有问题。如果在 setnx 和 expire 之间服务器进程突然挂掉了，可能是因为机器掉电或者是被人为杀掉的，就会导致 expire 得不到执行，也会造成死锁。</p><p>这种问题的根源就在于 setnx 和 expire 是两条指令而不是原子指令。如果这两条指令可以一起执行就不会出现问题。</p><p><strong>V3:set指令</strong></p><p>这个问题在Redis 2.8 版本中得到了解决，这个版本加入了 set 指令的扩展参数，使得 setnx 和expire 指令可以一起执行。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358110372-3cbd3f1b-46b2-4ce8-941c-2176e06c7ee1.png" alt="img"></p><pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">set lock:fighter3 true ex 5 nx OK ... do something critical ... > del lock:codehole<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面这个指令就是 setnx 和 expire 组合在一起的原子指令，这个就算是比较完善的分布式锁了。</p><p>当然实际的开发，没人会去自己写分布式锁的命令，因为有专业的轮子——<strong>Redisson</strong>。</p><p>这一部分就比较深了，如果不是简历上写了精通Redis，应该不会怎么问。</p><h2 id="46-说说Redis底层数据结构？"><a href="#46-说说Redis底层数据结构？" class="headerlink" title="46.说说Redis底层数据结构？"></a>46.说说Redis底层数据结构？</h2><p>Redis有**动态字符串(sds)******、******链表(list)******、******字典(ht)******、******跳跃表(skiplist)******、******整数集合(intset)******、****<strong>压缩列表(ziplist)</strong> 等底层数据结构。</p><p>Redis并没有使用这些数据结构来直接实现键值对数据库，而是基于这些数据结构创建了一个对象系统，来表示所有的key-value。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358112532-0a74b190-8a2c-4bfc-8d5b-d4b8565c518b.png" alt="img">我们常用的数据类型和编码对应的映射关系：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358115912-1b8a1b56-8e3b-4e95-ac34-53f32f6f3a54.png" alt="img"></p><p>简单看一下底层数据结构，如果对数据结构掌握不错的话，理解这些结构应该不是特别难：</p><p>1、<strong>字符串</strong>：redis没有直接使⽤C语⾔传统的字符串表示，⽽是⾃⼰实现的叫做简单动态字符串SDS的抽象类型。</p><p>C语⾔的字符串不记录⾃身的⻓度信息，⽽SDS则保存了⻓度信息，这样将获取字符串⻓度的时间由O(N)降低到了O(1)，同时可以避免缓冲区溢出和减少修改字符串⻓度时所需的内存重分配次数。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358118068-33757fc3-a2a8-4be8-a05d-0aedef27fd97.png" alt="img"></p><p>2、<strong>链表linkedlist</strong>：redis链表是⼀个双向⽆环链表结构，很多发布订阅、慢查询、监视器功能都是使⽤到了链表来实现，每个链表的节点由⼀个listNode结构来表示，每个节点都有指向前置节点和后置节点的指针，同时表头节点的前置和后置节点都指向NULL。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358121139-4f9c9af8-0668-43e8-9bef-d8d2aeeb7c69.png" alt="img"></p><p>3、<strong>字典dict</strong>：⽤于保存键值对的抽象数据结构。Redis使⽤hash表作为底层实现，一个哈希表里可以有多个哈希表节点，而每个哈希表节点就保存了字典里中的一个键值对。每个字典带有两个hash表，供平时使⽤和rehash时使⽤，hash表使⽤链地址法来解决键冲突，被分配到同⼀个索引位置的多个键值对会形成⼀个单向链表，在对hash表进⾏扩容或者缩容的时候，为了服务的可⽤性，rehash的过程不是⼀次性完成的，⽽是渐进式的。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358123009-73bfc368-2b41-4287-bbe1-bfac15219730.png" alt="img"></p><p>4、<strong>跳跃表skiplist</strong>：跳跃表是有序集合的底层实现之⼀，Redis中在实现有序集合键和集群节点的内部结构中都是⽤到了跳跃表。Redis跳跃表由zskiplist和zskiplistNode组成，zskiplist⽤于保存跳跃表信息（表头、表尾节点、⻓度等），zskiplistNode⽤于表示表跳跃节点，每个跳跃表节点的层⾼都是1-32的随机数，在同⼀个跳跃表中，多个节点可以包含相同的分值，但是每个节点的成员对象必须是唯⼀的，节点按照分值⼤⼩排序，如果分值相同，则按照成员对象的⼤⼩排序。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358125309-7d11f6af-01b5-4313-b57f-ddf542f11041.png" alt="img"></p><p>5、<strong>整数集合intset</strong>：⽤于保存整数值的集合抽象数据结构，不会出现重复元素，底层实现为数组。</p><img src="大厂面试之Redis篇.assets/1676358127915-4c94b16e-5970-414d-8710-50daaefbebac.png" alt="img" /><p>6、<strong>压缩列表ziplist</strong>：压缩列表是为节约内存⽽开发的顺序性数据结构，它可以包含任意多个节点，每个节点可以保存⼀个字节数组或者整数值。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358131121-1e84051e-c137-4ebb-aaa8-16e424c6b2ee.png" alt="img"></p><h2 id="47-Redis-的-SDS-和-C-中字符串相比有什么优势？"><a href="#47-Redis-的-SDS-和-C-中字符串相比有什么优势？" class="headerlink" title="47.Redis 的 SDS 和 C 中字符串相比有什么优势？"></a>47.Redis 的 SDS 和 C 中字符串相比有什么优势？</h2><p>C 语言使用了一个长度为 <code>N+1</code> 的字符数组来表示长度为 <code>N</code> 的字符串，并且字符数组最后一个元素总是 <code>\0</code>，这种简单的字符串表示方式 不符合 Redis 对字符串在安全性、效率以及功能方面的要求。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358133476-3c3b180d-75c7-4635-b9cb-d6aedb4c9c88.png" alt="img"></p><p><strong>C语言的字符串可能有什么问题？</strong></p><p>这样简单的数据结构可能会造成以下一些问题：</p><ul><li><p><strong>获取字符串长度复杂度高</strong> ：因为 C 不保存数组的长度，每次都需要遍历一遍整个数组，时间复杂度为O(n)；</p></li><li><p>不能杜绝 <strong>缓冲区溢出&#x2F;内存泄漏</strong> 的问题 : C字符串不记录自身长度带来的另外一个问题是容易造成缓存区溢出（buffer overflow），例如在字符串拼接的时候，新的</p></li><li><p>C 字符串 <strong>只能保存文本数据</strong> → 因为 C 语言中的字符串必须符合某种编码（比如 ASCII），例如中间出现的 <code>&#39;\0&#39;</code> 可能会被判定为提前结束的字符串而识别不了；</p></li></ul><p><strong>Redis如何解决？优势？</strong></p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358136548-9b405bd4-127a-4210-a700-e370c65e00ab.png" alt="img"></p><p>简单来说一下 Redis 如何解决的：</p><p>1、<strong>多增加 len 表示当前字符串的长度</strong>：这样就可以直接获取长度了，复杂度 O(1)；</p><p>2、<strong>自动扩展空间</strong>：当 SDS 需要对字符串进行修改时，首先借助于 <code>len</code> 和 <code>alloc</code> 检查空间是否满足修改所需的要求，如果空间不够的话，SDS 会自动扩展空间，避免了像 C 字符串操作中的溢出情况；</p><p>3、<strong>有效降低内存分配次数</strong>：C 字符串在涉及增加或者清除操作时会改变底层数组的大小造成重新分配，SDS 使用了 <strong>空间预分配</strong> 和 <strong>惰性空间释放</strong> 机制，简单理解就是每次在扩展时是成倍的多分配的，在缩容是也是先留着并不正式归还给 OS；</p><p>4、<strong>二进制安全</strong>：C 语言字符串只能保存 <code>ascii</code> 码，对于图片、音频等信息无法保存，SDS 是二进制安全的，写入什么读取就是什么，不做任何过滤和限制；</p><h2 id="48-字典是如何实现的？Rehash-了解吗？"><a href="#48-字典是如何实现的？Rehash-了解吗？" class="headerlink" title="48.字典是如何实现的？Rehash 了解吗？"></a>48.字典是如何实现的？Rehash 了解吗？</h2><p>字典是 Redis 服务器中出现最为频繁的复合型数据结构。除了 <strong>hash</strong> 结构的数据会用到字典外，整个 Redis 数据库的所有 <code>key</code> 和 <code>value</code> 也组成了一个 <strong>全局字典</strong>，还有带过期时间的 <code>key</code> 也是一个字典。*(存储在 RedisDb 数据结构中)*</p><p><strong>字典结构是什么样的呢？</strong></p><p><strong>Redis</strong> 中的字典相当于 Java 中的 <strong>HashMap</strong>，内部实现也差不多类似，采用哈希与运算计算下标位置；通过 **”数组 + 链表” ******的****<strong>链地址法</strong> 来解决哈希冲突，同时这样的结构也吸收了两种不同数据结构的优点。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358139010-bb0ea1ae-63b3-4629-b001-11a3ad4ac8e0.png" alt="img"></p><p><strong>字典是怎么扩容的？</strong></p><p>字典结构内部包含 <strong>两个 hashtable</strong>，通常情况下只有一个哈希表 ht[0] 有值，在扩容的时候，把ht[0]里的值rehash到ht[1]，然后进行 <strong>渐进式rehash</strong> ——所谓渐进式rehash，指的是这个rehash的动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成的。</p><p>待搬迁结束后，h[1]就取代h[0]存储字典的元素。</p><h2 id="49-跳跃表是如何实现的？原理？"><a href="#49-跳跃表是如何实现的？原理？" class="headerlink" title="49.跳跃表是如何实现的？原理？"></a>49.跳跃表是如何实现的？原理？</h2><p>PS:跳跃表是比较常问的一种结构。</p><p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其它节点的指针，从而达到快速访问节点的目的。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358140847-86793c13-bd50-48f4-a652-128a77684a43.png" alt="img"></p><p><strong>为什么使用跳跃表?</strong></p><p>首先，因为 zset 要支持随机的插入和删除，所以它 <strong>不宜使用数组来实现</strong>，关于排序问题，我们也很容易就想到 <strong>红黑树&#x2F; 平衡树</strong> 这样的树形结构，为什么 Redis 不使用这样一些结构呢？</p><p>1、<strong>性能考虑：</strong> 在高并发的情况下，树形结构需要执行一些类似于 rebalance 这样的可能涉及整棵树的操作，相对来说跳跃表的变化只涉及局部；</p><p>2、<strong>实现考虑：</strong> 在复杂度与红黑树相同的情况下，跳跃表实现起来更简单，看起来也更加直观；</p><p>基于以上的一些考虑，Redis 基于 <strong>William Pugh</strong> 的论文做出一些改进后采用了 <strong>跳跃表</strong> 这样的结构。</p><p>本质是解决查找问题。</p><p><strong>跳跃表是怎么实现的？</strong></p><p>跳跃表的节点里有这些元素：</p><p>1、<strong>层</strong>跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其它节点的指针，程序可以通过这些层来加快访问其它节点的速度，一般来说，层的数量月多，访问其它节点的速度就越快。</p><p>每次创建一个新的跳跃表节点的时候，程序都根据幂次定律，随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”</p><p>2、<strong>前进指针</strong>每个层都有一个指向表尾的前进指针（level[i].forward属性），用于从表头向表尾方向访问节点。</p><p>我们看一下跳跃表从表头到表尾，遍历所有节点的路径：</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358143181-8c5eda64-27da-4c10-847e-4bd3b977a9e7.png" alt="img"></p><p>3、<strong>跨度</strong>层的跨度用于记录两个节点之间的距离。跨度是用来计算排位（rank)的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。</p><p>例如查找，分值为3.0、成员对象为o3的节点时，沿途经历的层：查找的过程只经过了一个层，并且层的跨度为3，所以目标节点在跳跃表中的排位为3。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358146495-7d0d8659-0348-46fa-a75c-feb424fc0954.png" alt="img"></p><p>4、<strong>分值和成员</strong>节点的分值（score属性)是一个double类型的浮点数，跳跃表中所有的节点都按分值从小到大来排序。</p><p>节点的成员对象（obj属性）是一个指针，它指向一个字符串对象，而字符串对象则保存这一个SDS值。</p><h2 id="50-压缩列表了解吗？"><a href="#50-压缩列表了解吗？" class="headerlink" title="50.压缩列表了解吗？"></a>50.压缩列表了解吗？</h2><p>压缩列表是 Redis <strong>为了节约内存</strong> 而使用的一种数据结构，是由一系列特殊编码的连续内存快组成的顺序型数据结构。</p><p>一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358149451-cf638c12-f860-4f4d-acb7-fe88d5dc2e68.png" alt="img"></p><p>压缩列表由这么几部分组成：</p><ul><li><p><strong>zlbyttes</strong>:记录整个压缩列表占用的内存字节数</p></li><li><p><strong>zltail</strong>:记录压缩列表表尾节点距离压缩列表的起始地址有多少字节</p></li><li><p><strong>zllen</strong>:记录压缩列表包含的节点数量</p></li><li><p><strong>entryX</strong>:列表节点</p></li><li><p><strong>zlend</strong>:用于标记压缩列表的末端</p></li></ul><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358151402-828cdd8b-182d-4408-bab0-a1087b68106c.png" alt="img"></p><h2 id="51-快速列表-quicklist-了解吗？"><a href="#51-快速列表-quicklist-了解吗？" class="headerlink" title="51.快速列表 quicklist 了解吗？"></a>51.快速列表 quicklist 了解吗？</h2><p>Redis 早期版本存储 list 列表数据结构使用的是压缩列表 ziplist 和普通的双向链表 linkedlist，也就是说当元素少时使用 ziplist，当元素多时用 linkedlist。</p><p>但考虑到链表的附加空间相对较高，<code>prev</code> 和 <code>next</code> 指针就要占去 <code>16</code> 个字节（64 位操作系统占用 <code>8</code> 个字节），另外每个节点的内存都是单独分配，会家具内存的碎片化，影响内存管理效率。</p><p>后来 Redis 新版本（3.2）对列表数据结构进行了改造，使用 <code>quicklist</code> 代替了 <code>ziplist</code> 和 <code>linkedlist</code>，quicklist是综合考虑了时间效率与空间效率引入的新型数据结构。</p><p>quicklist由list和ziplist结合而成，它是一个由ziplist充当节点的双向链表。</p><p><img src="/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E4%B9%8BRedis%E7%AF%87.assets/1676358153179-5e3150ab-60d6-4e69-9e10-b6239d7eb519.png" alt="img"></p><h2 id="52-假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？"><a href="#52-假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？" class="headerlink" title="52.假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？"></a>52.假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？</h2><p>使用 <code>keys</code> 指令可以扫出指定模式的 key 列表。但是要注意 keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 <code>scan</code> 指令，<code>scan</code> 指令可以无阻塞的提取出指定模式的 <code>key</code> 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 <code>keys</code> 指令长。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-说说什么是Redis&quot;&gt;&lt;a href=&quot;#1-说说什么是Redis&quot; class=&quot;headerlink&quot; title=&quot;1.说说什么是Redis?&quot;&gt;&lt;/a&gt;1.说说什么是Redis?&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/%E5%A4%A7%E5%8E%8</summary>
      
    
    
    
    <category term="PROJECT" scheme="https://zspcer.gitee.io/categories/PROJECT/"/>
    
    <category term="我要进大厂" scheme="https://zspcer.gitee.io/categories/PROJECT/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/"/>
    
    
    <category term="面试" scheme="https://zspcer.gitee.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="我要进大厂" scheme="https://zspcer.gitee.io/tags/%E6%88%91%E8%A6%81%E8%BF%9B%E5%A4%A7%E5%8E%82/"/>
    
    <category term="Redis" scheme="https://zspcer.gitee.io/tags/Redis/"/>
    
  </entry>
  
</feed>
